# @omlish-generated
# type: ignore
# ruff: noqa
# flake8: noqa
import dataclasses
import reprlib
import types


##


REGISTRY = {}


def _register(**kwargs):
    def inner(fn):
        REGISTRY[kwargs['plan_repr']] = (kwargs, fn)
        return fn
    return inner


##


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('group_ids', 'group_names', 'next_token', 'max_results', 'dry_run', 'filters')), E"
        "qPlan(fields=('group_ids', 'group_names', 'next_token', 'max_results', 'dry_run', 'filters')), FrozenPlan(fiel"
        "ds=('__shape__', 'group_ids', 'group_names', 'next_token', 'max_results', 'dry_run', 'filters'), allow_dynamic"
        "_dunder_attrs=False), HashPlan(action='add', fields=('group_ids', 'group_names', 'next_token', 'max_results', "
        "'dry_run', 'filters'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='"
        "init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_ids', annotation=OpRef(n"
        "ame='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='group_names', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.3.annotation'), defa"
        "ult=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_results', annotation=OpRef(n"
        "ame='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='dry_run', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None), InitPlan.Field(name='filters', annotation=OpRef(name='init.fields.6.annotation'), default=OpR"
        "ef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('group_id"
        "s', 'group_names', 'next_token', 'max_results', 'dry_run', 'filters'), frozen=True, slots=False, post_init_par"
        "ams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='group_ids', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='group_names', kw_only=True, fn=None), ReprPlan.Field(name='next_token', kw_only=True"
        ", fn=None), ReprPlan.Field(name='max_results', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only="
        "True, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn=None)), id=False, terse=False, default_fn=None"
        ")))"
    ),
    plan_repr_sha1='00d5a06f8a67111c73bc3b7f92f2c26b2c8935c7',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeSecurityGroupsRequest'),
    ),
)
def _process_dataclass__00d5a06f8a67111c73bc3b7f92f2c26b2c8935c7():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                group_ids=self.group_ids,
                group_names=self.group_names,
                next_token=self.next_token,
                max_results=self.max_results,
                dry_run=self.dry_run,
                filters=self.filters,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.group_ids == other.group_ids and
                self.group_names == other.group_names and
                self.next_token == other.next_token and
                self.max_results == other.max_results and
                self.dry_run == other.dry_run and
                self.filters == other.filters
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'group_ids',
            'group_names',
            'next_token',
            'max_results',
            'dry_run',
            'filters',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'group_ids',
            'group_names',
            'next_token',
            'max_results',
            'dry_run',
            'filters',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.group_ids,
                self.group_names,
                self.next_token,
                self.max_results,
                self.dry_run,
                self.filters,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            group_ids: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            group_names: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            next_token: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            max_results: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            dry_run: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            filters: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'group_ids', group_ids)
            __dataclass__object_setattr(self, 'group_names', group_names)
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'max_results', max_results)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'filters', filters)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"group_ids={self.group_ids!r}")
            parts.append(f"group_names={self.group_names!r}")
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"max_results={self.max_results!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"filters={self.filters!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('retention_period_in_days', 'execution_timeout')), EqPlan(fields=('retention_perio"
        "d_in_days', 'execution_timeout')), FrozenPlan(fields=('__shape__', 'retention_period_in_days', 'execution_time"
        "out'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('retention_period_in_days', 'executio"
        "n_timeout'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.field"
        "s.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VA"
        "R, coerce=None, validate=None, check_type=None), InitPlan.Field(name='retention_period_in_days', annotation=Op"
        "Ref(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init="
        "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
        "eld(name='execution_timeout', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fiel"
        "ds.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('retention_period_in_days',"
        " 'execution_timeout'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPla"
        "n(fields=(ReprPlan.Field(name='retention_period_in_days', kw_only=True, fn=None), ReprPlan.Field(name='executi"
        "on_timeout', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='017f0ccfabf58bb95e85ed87d1549bbb2e98094f',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'DurableConfig'),
    ),
)
def _process_dataclass__017f0ccfabf58bb95e85ed87d1549bbb2e98094f():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                retention_period_in_days=self.retention_period_in_days,
                execution_timeout=self.execution_timeout,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.retention_period_in_days == other.retention_period_in_days and
                self.execution_timeout == other.execution_timeout
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'retention_period_in_days',
            'execution_timeout',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'retention_period_in_days',
            'execution_timeout',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.retention_period_in_days,
                self.execution_timeout,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            retention_period_in_days: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            execution_timeout: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'retention_period_in_days', retention_period_in_days)
            __dataclass__object_setattr(self, 'execution_timeout', execution_timeout)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"retention_period_in_days={self.retention_period_in_days!r}")
            parts.append(f"execution_timeout={self.execution_timeout!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('apply_on', 'optimization_status')), EqPlan(fields=('apply_on', 'optimization_stat"
        "us')), FrozenPlan(fields=('__shape__', 'apply_on', 'optimization_status'), allow_dynamic_dunder_attrs=False), "
        "HashPlan(action='add', fields=('apply_on', 'optimization_status'), cache=False), InitPlan(fields=(InitPlan.Fie"
        "ld(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, in"
        "it=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='apply_on', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='optimization_status', annotation=OpRef(name='init.fields.2.ann"
        "otation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_"
        "only_params=('apply_on', 'optimization_status'), frozen=True, slots=False, post_init_params=None, init_fns=(),"
        " validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='apply_on', kw_only=True, fn=None), ReprPlan.Field(nam"
        "e='optimization_status', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='019cda7bb51f31d049f4fa706f3c46d80940f395',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'SnapStartResponse'),
    ),
)
def _process_dataclass__019cda7bb51f31d049f4fa706f3c46d80940f395():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                apply_on=self.apply_on,
                optimization_status=self.optimization_status,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.apply_on == other.apply_on and
                self.optimization_status == other.optimization_status
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'apply_on',
            'optimization_status',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'apply_on',
            'optimization_status',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.apply_on,
                self.optimization_status,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            apply_on: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            optimization_status: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'apply_on', apply_on)
            __dataclass__object_setattr(self, 'optimization_status', optimization_status)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"apply_on={self.apply_on!r}")
            parts.append(f"optimization_status={self.optimization_status!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('capacity_provider_arn', 'per_execution_environment_max_concurrency', 'execution_e"
        "nvironment_memory_gi_b_per_v_cpu')), EqPlan(fields=('capacity_provider_arn', 'per_execution_environment_max_co"
        "ncurrency', 'execution_environment_memory_gi_b_per_v_cpu')), FrozenPlan(fields=('__shape__', 'capacity_provide"
        "r_arn', 'per_execution_environment_max_concurrency', 'execution_environment_memory_gi_b_per_v_cpu'), allow_dyn"
        "amic_dunder_attrs=False), HashPlan(action='add', fields=('capacity_provider_arn', 'per_execution_environment_m"
        "ax_concurrency', 'execution_environment_memory_gi_b_per_v_cpu'), cache=False), InitPlan(fields=(InitPlan.Field"
        "(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init"
        "=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='capacity_provider_arn', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None), InitPlan.Field(name='per_execution_environment_max_concurrency', annotation=OpRef(name='init.fields.2.a"
        "nnotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='execution_envir"
        "onment_memory_gi_b_per_v_cpu', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fie"
        "lds.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('capacity_provider_arn', '"
        "per_execution_environment_max_concurrency', 'execution_environment_memory_gi_b_per_v_cpu'), frozen=True, slots"
        "=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='capacity_p"
        "rovider_arn', kw_only=True, fn=None), ReprPlan.Field(name='per_execution_environment_max_concurrency', kw_only"
        "=True, fn=None), ReprPlan.Field(name='execution_environment_memory_gi_b_per_v_cpu', kw_only=True, fn=None)), i"
        "d=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='02fae62a0f61feae0ec5fbd59f6801f513d2c3e6',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'LambdaManagedInstancesCapacityProviderConfig'),
    ),
)
def _process_dataclass__02fae62a0f61feae0ec5fbd59f6801f513d2c3e6():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                capacity_provider_arn=self.capacity_provider_arn,
                per_execution_environment_max_concurrency=self.per_execution_environment_max_concurrency,
                execution_environment_memory_gi_b_per_v_cpu=self.execution_environment_memory_gi_b_per_v_cpu,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.capacity_provider_arn == other.capacity_provider_arn and
                self.per_execution_environment_max_concurrency == other.per_execution_environment_max_concurrency and
                self.execution_environment_memory_gi_b_per_v_cpu == other.execution_environment_memory_gi_b_per_v_cpu
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'capacity_provider_arn',
            'per_execution_environment_max_concurrency',
            'execution_environment_memory_gi_b_per_v_cpu',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'capacity_provider_arn',
            'per_execution_environment_max_concurrency',
            'execution_environment_memory_gi_b_per_v_cpu',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.capacity_provider_arn,
                self.per_execution_environment_max_concurrency,
                self.execution_environment_memory_gi_b_per_v_cpu,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            capacity_provider_arn: __dataclass__init__fields__1__annotation,
            per_execution_environment_max_concurrency: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            execution_environment_memory_gi_b_per_v_cpu: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'capacity_provider_arn', capacity_provider_arn)
            __dataclass__object_setattr(self, 'per_execution_environment_max_concurrency', per_execution_environment_max_concurrency)
            __dataclass__object_setattr(self, 'execution_environment_memory_gi_b_per_v_cpu', execution_environment_memory_gi_b_per_v_cpu)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"capacity_provider_arn={self.capacity_provider_arn!r}")
            parts.append(f"per_execution_environment_max_concurrency={self.per_execution_environment_max_concurrency!r}")
            parts.append(f"execution_environment_memory_gi_b_per_v_cpu={self.execution_environment_memory_gi_b_per_v_cpu!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('association_id', 'cidr_block', 'cidr_block_state')), EqPlan(fields=('association_"
        "id', 'cidr_block', 'cidr_block_state')), FrozenPlan(fields=('__shape__', 'association_id', 'cidr_block', 'cidr"
        "_block_state'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('association_id', 'cidr_bloc"
        "k', 'cidr_block_state'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name"
        "='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='association_id', annotation="
        "OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='cidr_block', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='cidr_block_state', annotation=OpRef(name='init.fields.3.annota"
        "tion'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_onl"
        "y_params=('association_id', 'cidr_block', 'cidr_block_state'), frozen=True, slots=False, post_init_params=None"
        ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='association_id', kw_only=True, fn=None)"
        ", ReprPlan.Field(name='cidr_block', kw_only=True, fn=None), ReprPlan.Field(name='cidr_block_state', kw_only=Tr"
        "ue, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='040de49b0cfab72b376b5f24d0bbcccbb8d8612b',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'VpcCidrBlockAssociation'),
    ),
)
def _process_dataclass__040de49b0cfab72b376b5f24d0bbcccbb8d8612b():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                association_id=self.association_id,
                cidr_block=self.cidr_block,
                cidr_block_state=self.cidr_block_state,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.association_id == other.association_id and
                self.cidr_block == other.cidr_block and
                self.cidr_block_state == other.cidr_block_state
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'association_id',
            'cidr_block',
            'cidr_block_state',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'association_id',
            'cidr_block',
            'cidr_block_state',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.association_id,
                self.cidr_block,
                self.cidr_block_state,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            association_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            cidr_block: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            cidr_block_state: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'association_id', association_id)
            __dataclass__object_setattr(self, 'cidr_block', cidr_block)
            __dataclass__object_setattr(self, 'cidr_block_state', cidr_block_state)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"association_id={self.association_id!r}")
            parts.append(f"cidr_block={self.cidr_block!r}")
            parts.append(f"cidr_block_state={self.cidr_block_state!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('capacity_reservation_id', 'capacity_reservation_resource_group_arn')), EqPlan(fie"
        "lds=('capacity_reservation_id', 'capacity_reservation_resource_group_arn')), FrozenPlan(fields=('__shape__', '"
        "capacity_reservation_id', 'capacity_reservation_resource_group_arn'), allow_dynamic_dunder_attrs=False), HashP"
        "lan(action='add', fields=('capacity_reservation_id', 'capacity_reservation_resource_group_arn'), cache=False),"
        " InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default="
        "None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=N"
        "one, check_type=None), InitPlan.Field(name='capacity_reservation_id', annotation=OpRef(name='init.fields.1.ann"
        "otation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='capacity_reservat"
        "ion_resource_group_arn', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('capacity_reservation_id', 'capa"
        "city_reservation_resource_group_arn'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_"
        "fns=()), ReprPlan(fields=(ReprPlan.Field(name='capacity_reservation_id', kw_only=True, fn=None), ReprPlan.Fiel"
        "d(name='capacity_reservation_resource_group_arn', kw_only=True, fn=None)), id=False, terse=False, default_fn=N"
        "one)))"
    ),
    plan_repr_sha1='045209aeb87ab83d8d5340fd2caacf0f856dd39d',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CapacityReservationTarget'),
        ('ominfra.clouds.aws.models.services.ec2', 'CapacityReservationTargetResponse'),
    ),
)
def _process_dataclass__045209aeb87ab83d8d5340fd2caacf0f856dd39d():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                capacity_reservation_id=self.capacity_reservation_id,
                capacity_reservation_resource_group_arn=self.capacity_reservation_resource_group_arn,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.capacity_reservation_id == other.capacity_reservation_id and
                self.capacity_reservation_resource_group_arn == other.capacity_reservation_resource_group_arn
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'capacity_reservation_id',
            'capacity_reservation_resource_group_arn',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'capacity_reservation_id',
            'capacity_reservation_resource_group_arn',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.capacity_reservation_id,
                self.capacity_reservation_resource_group_arn,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            capacity_reservation_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            capacity_reservation_resource_group_arn: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'capacity_reservation_id', capacity_reservation_id)
            __dataclass__object_setattr(self, 'capacity_reservation_resource_group_arn', capacity_reservation_resource_group_arn)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"capacity_reservation_id={self.capacity_reservation_id!r}")
            parts.append(f"capacity_reservation_resource_group_arn={self.capacity_reservation_resource_group_arn!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('db_instance_identifier', 'db_instance_class', 'engine', 'db_instance_status', 'ma"
        "ster_username', 'db_name', 'endpoint', 'allocated_storage', 'instance_create_time', 'preferred_backup_window',"
        " 'backup_retention_period', 'db_security_groups', 'vpc_security_groups', 'db_parameter_groups', 'availability_"
        "zone', 'db_subnet_group', 'preferred_maintenance_window', 'upgrade_rollout_order', 'pending_modified_values', "
        "'latest_restorable_time', 'multi_az', 'engine_version', 'auto_minor_version_upgrade', 'read_replica_source_db_"
        "instance_identifier', 'read_replica_db_instance_identifiers', 'read_replica_db_cluster_identifiers', 'replica_"
        "mode', 'license_model', 'iops', 'storage_throughput', 'option_group_memberships', 'character_set_name', 'nchar"
        "_character_set_name', 'secondary_availability_zone', 'publicly_accessible', 'status_infos', 'storage_type', 't"
        "de_credential_arn', 'db_instance_port', 'db_cluster_identifier', 'storage_encrypted', 'kms_key_id', 'dbi_resou"
        "rce_id', 'ca_certificate_identifier', 'domain_memberships', 'copy_tags_to_snapshot', 'monitoring_interval', 'e"
        "nhanced_monitoring_resource_arn', 'monitoring_role_arn', 'promotion_tier', 'db_instance_arn', 'timezone', 'iam"
        "_database_authentication_enabled', 'database_insights_mode', 'performance_insights_enabled', 'performance_insi"
        "ghts_kms_key_id', 'performance_insights_retention_period', 'enabled_cloudwatch_logs_exports', 'processor_featu"
        "res', 'deletion_protection', 'associated_roles', 'listener_endpoint', 'max_allocated_storage', 'tag_list', 'au"
        "tomation_mode', 'resume_full_automation_mode_time', 'customer_owned_ip_enabled', 'network_type', 'activity_str"
        "eam_status', 'activity_stream_kms_key_id', 'activity_stream_kinesis_stream_name', 'activity_stream_mode', 'act"
        "ivity_stream_engine_native_audit_fields_included', 'aws_backup_recovery_point_arn', 'db_instance_automated_bac"
        "kups_replications', 'backup_target', 'automatic_restart_time', 'custom_iam_instance_profile', 'activity_stream"
        "_policy_status', 'certificate_details', 'db_system_id', 'master_user_secret', 'read_replica_source_db_cluster_"
        "identifier', 'percent_progress', 'multi_tenant', 'dedicated_log_volume', 'is_storage_config_upgrade_available'"
        ", 'engine_lifecycle_support', 'additional_storage_volumes', 'storage_volume_status')), EqPlan(fields=('db_inst"
        "ance_identifier', 'db_instance_class', 'engine', 'db_instance_status', 'master_username', 'db_name', 'endpoint"
        "', 'allocated_storage', 'instance_create_time', 'preferred_backup_window', 'backup_retention_period', 'db_secu"
        "rity_groups', 'vpc_security_groups', 'db_parameter_groups', 'availability_zone', 'db_subnet_group', 'preferred"
        "_maintenance_window', 'upgrade_rollout_order', 'pending_modified_values', 'latest_restorable_time', 'multi_az'"
        ", 'engine_version', 'auto_minor_version_upgrade', 'read_replica_source_db_instance_identifier', 'read_replica_"
        "db_instance_identifiers', 'read_replica_db_cluster_identifiers', 'replica_mode', 'license_model', 'iops', 'sto"
        "rage_throughput', 'option_group_memberships', 'character_set_name', 'nchar_character_set_name', 'secondary_ava"
        "ilability_zone', 'publicly_accessible', 'status_infos', 'storage_type', 'tde_credential_arn', 'db_instance_por"
        "t', 'db_cluster_identifier', 'storage_encrypted', 'kms_key_id', 'dbi_resource_id', 'ca_certificate_identifier'"
        ", 'domain_memberships', 'copy_tags_to_snapshot', 'monitoring_interval', 'enhanced_monitoring_resource_arn', 'm"
        "onitoring_role_arn', 'promotion_tier', 'db_instance_arn', 'timezone', 'iam_database_authentication_enabled', '"
        "database_insights_mode', 'performance_insights_enabled', 'performance_insights_kms_key_id', 'performance_insig"
        "hts_retention_period', 'enabled_cloudwatch_logs_exports', 'processor_features', 'deletion_protection', 'associ"
        "ated_roles', 'listener_endpoint', 'max_allocated_storage', 'tag_list', 'automation_mode', 'resume_full_automat"
        "ion_mode_time', 'customer_owned_ip_enabled', 'network_type', 'activity_stream_status', 'activity_stream_kms_ke"
        "y_id', 'activity_stream_kinesis_stream_name', 'activity_stream_mode', 'activity_stream_engine_native_audit_fie"
        "lds_included', 'aws_backup_recovery_point_arn', 'db_instance_automated_backups_replications', 'backup_target',"
        " 'automatic_restart_time', 'custom_iam_instance_profile', 'activity_stream_policy_status', 'certificate_detail"
        "s', 'db_system_id', 'master_user_secret', 'read_replica_source_db_cluster_identifier', 'percent_progress', 'mu"
        "lti_tenant', 'dedicated_log_volume', 'is_storage_config_upgrade_available', 'engine_lifecycle_support', 'addit"
        "ional_storage_volumes', 'storage_volume_status')), FrozenPlan(fields=('__shape__', 'db_instance_identifier', '"
        "db_instance_class', 'engine', 'db_instance_status', 'master_username', 'db_name', 'endpoint', 'allocated_stora"
        "ge', 'instance_create_time', 'preferred_backup_window', 'backup_retention_period', 'db_security_groups', 'vpc_"
        "security_groups', 'db_parameter_groups', 'availability_zone', 'db_subnet_group', 'preferred_maintenance_window"
        "', 'upgrade_rollout_order', 'pending_modified_values', 'latest_restorable_time', 'multi_az', 'engine_version',"
        " 'auto_minor_version_upgrade', 'read_replica_source_db_instance_identifier', 'read_replica_db_instance_identif"
        "iers', 'read_replica_db_cluster_identifiers', 'replica_mode', 'license_model', 'iops', 'storage_throughput', '"
        "option_group_memberships', 'character_set_name', 'nchar_character_set_name', 'secondary_availability_zone', 'p"
        "ublicly_accessible', 'status_infos', 'storage_type', 'tde_credential_arn', 'db_instance_port', 'db_cluster_ide"
        "ntifier', 'storage_encrypted', 'kms_key_id', 'dbi_resource_id', 'ca_certificate_identifier', 'domain_membershi"
        "ps', 'copy_tags_to_snapshot', 'monitoring_interval', 'enhanced_monitoring_resource_arn', 'monitoring_role_arn'"
        ", 'promotion_tier', 'db_instance_arn', 'timezone', 'iam_database_authentication_enabled', 'database_insights_m"
        "ode', 'performance_insights_enabled', 'performance_insights_kms_key_id', 'performance_insights_retention_perio"
        "d', 'enabled_cloudwatch_logs_exports', 'processor_features', 'deletion_protection', 'associated_roles', 'liste"
        "ner_endpoint', 'max_allocated_storage', 'tag_list', 'automation_mode', 'resume_full_automation_mode_time', 'cu"
        "stomer_owned_ip_enabled', 'network_type', 'activity_stream_status', 'activity_stream_kms_key_id', 'activity_st"
        "ream_kinesis_stream_name', 'activity_stream_mode', 'activity_stream_engine_native_audit_fields_included', 'aws"
        "_backup_recovery_point_arn', 'db_instance_automated_backups_replications', 'backup_target', 'automatic_restart"
        "_time', 'custom_iam_instance_profile', 'activity_stream_policy_status', 'certificate_details', 'db_system_id',"
        " 'master_user_secret', 'read_replica_source_db_cluster_identifier', 'percent_progress', 'multi_tenant', 'dedic"
        "ated_log_volume', 'is_storage_config_upgrade_available', 'engine_lifecycle_support', 'additional_storage_volum"
        "es', 'storage_volume_status'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('db_instance_"
        "identifier', 'db_instance_class', 'engine', 'db_instance_status', 'master_username', 'db_name', 'endpoint', 'a"
        "llocated_storage', 'instance_create_time', 'preferred_backup_window', 'backup_retention_period', 'db_security_"
        "groups', 'vpc_security_groups', 'db_parameter_groups', 'availability_zone', 'db_subnet_group', 'preferred_main"
        "tenance_window', 'upgrade_rollout_order', 'pending_modified_values', 'latest_restorable_time', 'multi_az', 'en"
        "gine_version', 'auto_minor_version_upgrade', 'read_replica_source_db_instance_identifier', 'read_replica_db_in"
        "stance_identifiers', 'read_replica_db_cluster_identifiers', 'replica_mode', 'license_model', 'iops', 'storage_"
        "throughput', 'option_group_memberships', 'character_set_name', 'nchar_character_set_name', 'secondary_availabi"
        "lity_zone', 'publicly_accessible', 'status_infos', 'storage_type', 'tde_credential_arn', 'db_instance_port', '"
        "db_cluster_identifier', 'storage_encrypted', 'kms_key_id', 'dbi_resource_id', 'ca_certificate_identifier', 'do"
        "main_memberships', 'copy_tags_to_snapshot', 'monitoring_interval', 'enhanced_monitoring_resource_arn', 'monito"
        "ring_role_arn', 'promotion_tier', 'db_instance_arn', 'timezone', 'iam_database_authentication_enabled', 'datab"
        "ase_insights_mode', 'performance_insights_enabled', 'performance_insights_kms_key_id', 'performance_insights_r"
        "etention_period', 'enabled_cloudwatch_logs_exports', 'processor_features', 'deletion_protection', 'associated_"
        "roles', 'listener_endpoint', 'max_allocated_storage', 'tag_list', 'automation_mode', 'resume_full_automation_m"
        "ode_time', 'customer_owned_ip_enabled', 'network_type', 'activity_stream_status', 'activity_stream_kms_key_id'"
        ", 'activity_stream_kinesis_stream_name', 'activity_stream_mode', 'activity_stream_engine_native_audit_fields_i"
        "ncluded', 'aws_backup_recovery_point_arn', 'db_instance_automated_backups_replications', 'backup_target', 'aut"
        "omatic_restart_time', 'custom_iam_instance_profile', 'activity_stream_policy_status', 'certificate_details', '"
        "db_system_id', 'master_user_secret', 'read_replica_source_db_cluster_identifier', 'percent_progress', 'multi_t"
        "enant', 'dedicated_log_volume', 'is_storage_config_upgrade_available', 'engine_lifecycle_support', 'additional"
        "_storage_volumes', 'storage_volume_status'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', a"
        "nnotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_insta"
        "nce_identifier', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='db_instance_class', annotation=OpRef(name='init.fields.2.annotation'),"
        " default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='engine', annotation=OpRef(n"
        "ame='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='db_instance_status', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None), InitPlan.Field(name='master_username', annotation=OpRef(name='init.fields.5.annota"
        "tion'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_name', annotation"
        "=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
        ".Field(name='endpoint', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='allocated_storage', annotation=OpRef(name='init.fields.8.annota"
        "tion'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_create_time"
        "', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='preferred_backup_window', annotation=OpRef(name='init.fields.10.annotation'), defaul"
        "t=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_type=FieldType."
        "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='backup_retention_period', annotat"
        "ion=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='db_security_groups', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name="
        "'init.fields.12.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_security_groups', annotation=OpRef(name='i"
        "nit.fields.13.annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
        "'db_parameter_groups', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='availability_zone', annotation=OpRef(name='init.fields.15.anno"
        "tation'), default=OpRef(name='init.fields.15.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_subnet_group',"
        " annotation=OpRef(name='init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='preferred_maintenance_window', annotation=OpRef(name='init.fields.17.annotation'), d"
        "efault=OpRef(name='init.fields.17.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='upgrade_rollout_order', anno"
        "tation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.18.default'), default_factory="
        "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
        "InitPlan.Field(name='pending_modified_values', annotation=OpRef(name='init.fields.19.annotation'), default=OpR"
        "ef(name='init.fields.19.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
        "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='latest_restorable_time', annotation=Op"
        "Ref(name='init.fields.20.annotation'), default=OpRef(name='init.fields.20.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='multi_az', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='init.fields.21."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='engine_version', annotation=OpRef(name='init.fields.22.annotat"
        "ion'), default=OpRef(name='init.fields.22.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='auto_minor_version_u"
        "pgrade', annotation=OpRef(name='init.fields.23.annotation'), default=OpRef(name='init.fields.23.default'), def"
        "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
        "_type=None), InitPlan.Field(name='read_replica_source_db_instance_identifier', annotation=OpRef(name='init.fie"
        "lds.24.annotation'), default=OpRef(name='init.fields.24.default'), default_factory=None, init=True, override=F"
        "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='read_r"
        "eplica_db_instance_identifiers', annotation=OpRef(name='init.fields.25.annotation'), default=OpRef(name='init."
        "fields.25.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='read_replica_db_cluster_identifiers', annotation=OpR"
        "ef(name='init.fields.26.annotation'), default=OpRef(name='init.fields.26.default'), default_factory=None, init"
        "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
        "ield(name='replica_mode', annotation=OpRef(name='init.fields.27.annotation'), default=OpRef(name='init.fields."
        "27.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='license_model', annotation=OpRef(name='init.fields.28.annot"
        "ation'), default=OpRef(name='init.fields.28.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='iops', annotation="
        "OpRef(name='init.fields.29.annotation'), default=OpRef(name='init.fields.29.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='storage_throughput', annotation=OpRef(name='init.fields.30.annotation'), default=OpRef(name='ini"
        "t.fields.30.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='option_group_memberships', annotation=OpRef(name='"
        "init.fields.31.annotation'), default=OpRef(name='init.fields.31.default'), default_factory=None, init=True, ov"
        "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='character_set_name', annotation=OpRef(name='init.fields.32.annotation'), default=OpRef(name='init.fields.32."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='nchar_character_set_name', annotation=OpRef(name='init.fields."
        "33.annotation'), default=OpRef(name='init.fields.33.default'), default_factory=None, init=True, override=False"
        ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='secondary_"
        "availability_zone', annotation=OpRef(name='init.fields.34.annotation'), default=OpRef(name='init.fields.34.def"
        "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
        "None, check_type=None), InitPlan.Field(name='publicly_accessible', annotation=OpRef(name='init.fields.35.annot"
        "ation'), default=OpRef(name='init.fields.35.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='status_infos', ann"
        "otation=OpRef(name='init.fields.36.annotation'), default=OpRef(name='init.fields.36.default'), default_factory"
        "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
        " InitPlan.Field(name='storage_type', annotation=OpRef(name='init.fields.37.annotation'), default=OpRef(name='i"
        "nit.fields.37.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
        "e=None, validate=None, check_type=None), InitPlan.Field(name='tde_credential_arn', annotation=OpRef(name='init"
        ".fields.38.annotation'), default=OpRef(name='init.fields.38.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db"
        "_instance_port', annotation=OpRef(name='init.fields.39.annotation'), default=OpRef(name='init.fields.39.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='db_cluster_identifier', annotation=OpRef(name='init.fields.40.annota"
        "tion'), default=OpRef(name='init.fields.40.default'), default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='storage_encrypted',"
        " annotation=OpRef(name='init.fields.41.annotation'), default=OpRef(name='init.fields.41.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='kms_key_id', annotation=OpRef(name='init.fields.42.annotation'), default=OpRef(name="
        "'init.fields.42.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='dbi_resource_id', annotation=OpRef(name='init."
        "fields.43.annotation'), default=OpRef(name='init.fields.43.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ca_"
        "certificate_identifier', annotation=OpRef(name='init.fields.44.annotation'), default=OpRef(name='init.fields.4"
        "4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='domain_memberships', annotation=OpRef(name='init.fields.45.a"
        "nnotation'), default=OpRef(name='init.fields.45.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='copy_tags_to_s"
        "napshot', annotation=OpRef(name='init.fields.46.annotation'), default=OpRef(name='init.fields.46.default'), de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
        "k_type=None), InitPlan.Field(name='monitoring_interval', annotation=OpRef(name='init.fields.47.annotation'), d"
        "efault=OpRef(name='init.fields.47.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='enhanced_monitoring_resource"
        "_arn', annotation=OpRef(name='init.fields.48.annotation'), default=OpRef(name='init.fields.48.default'), defau"
        "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
        "ype=None), InitPlan.Field(name='monitoring_role_arn', annotation=OpRef(name='init.fields.49.annotation'), defa"
        "ult=OpRef(name='init.fields.49.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='promotion_tier', annotation=OpR"
        "ef(name='init.fields.50.annotation'), default=OpRef(name='init.fields.50.default'), default_factory=None, init"
        "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
        "ield(name='db_instance_arn', annotation=OpRef(name='init.fields.51.annotation'), default=OpRef(name='init.fiel"
        "ds.51.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='timezone', annotation=OpRef(name='init.fields.52.annotat"
        "ion'), default=OpRef(name='init.fields.52.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='iam_database_authent"
        "ication_enabled', annotation=OpRef(name='init.fields.53.annotation'), default=OpRef(name='init.fields.53.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='database_insights_mode', annotation=OpRef(name='init.fields.54.anno"
        "tation'), default=OpRef(name='init.fields.54.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='performance_insig"
        "hts_enabled', annotation=OpRef(name='init.fields.55.annotation'), default=OpRef(name='init.fields.55.default')"
        ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='performance_insights_kms_key_id', annotation=OpRef(name='init.fields.56"
        ".annotation'), default=OpRef(name='init.fields.56.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='performance_"
        "insights_retention_period', annotation=OpRef(name='init.fields.57.annotation'), default=OpRef(name='init.field"
        "s.57.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None), InitPlan.Field(name='enabled_cloudwatch_logs_exports', annotation=OpRef(name='"
        "init.fields.58.annotation'), default=OpRef(name='init.fields.58.default'), default_factory=None, init=True, ov"
        "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='processor_features', annotation=OpRef(name='init.fields.59.annotation'), default=OpRef(name='init.fields.59."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='deletion_protection', annotation=OpRef(name='init.fields.60.an"
        "notation'), default=OpRef(name='init.fields.60.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='associated_role"
        "s', annotation=OpRef(name='init.fields.61.annotation'), default=OpRef(name='init.fields.61.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='listener_endpoint', annotation=OpRef(name='init.fields.62.annotation'), default=O"
        "pRef(name='init.fields.62.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_allocated_storage', annotation=O"
        "pRef(name='init.fields.63.annotation'), default=OpRef(name='init.fields.63.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
        ".Field(name='tag_list', annotation=OpRef(name='init.fields.64.annotation'), default=OpRef(name='init.fields.64"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None), InitPlan.Field(name='automation_mode', annotation=OpRef(name='init.fields.65.annot"
        "ation'), default=OpRef(name='init.fields.65.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='resume_full_automa"
        "tion_mode_time', annotation=OpRef(name='init.fields.66.annotation'), default=OpRef(name='init.fields.66.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='customer_owned_ip_enabled', annotation=OpRef(name='init.fields.67.an"
        "notation'), default=OpRef(name='init.fields.67.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_type', "
        "annotation=OpRef(name='init.fields.68.annotation'), default=OpRef(name='init.fields.68.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='activity_stream_status', annotation=OpRef(name='init.fields.69.annotation'), default="
        "OpRef(name='init.fields.69.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
        "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='activity_stream_kms_key_id', annota"
        "tion=OpRef(name='init.fields.70.annotation'), default=OpRef(name='init.fields.70.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='activity_stream_kinesis_stream_name', annotation=OpRef(name='init.fields.71.annotation'), d"
        "efault=OpRef(name='init.fields.71.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='activity_stream_mode', annot"
        "ation=OpRef(name='init.fields.72.annotation'), default=OpRef(name='init.fields.72.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='activity_stream_engine_native_audit_fields_included', annotation=OpRef(name='init.fields.7"
        "3.annotation'), default=OpRef(name='init.fields.73.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='aws_backup_"
        "recovery_point_arn', annotation=OpRef(name='init.fields.74.annotation'), default=OpRef(name='init.fields.74.de"
        "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
        "=None, check_type=None), InitPlan.Field(name='db_instance_automated_backups_replications', annotation=OpRef(na"
        "me='init.fields.75.annotation'), default=OpRef(name='init.fields.75.default'), default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='backup_target', annotation=OpRef(name='init.fields.76.annotation'), default=OpRef(name='init.fields.76.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='automatic_restart_time', annotation=OpRef(name='init.fields.77."
        "annotation'), default=OpRef(name='init.fields.77.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='custom_iam_in"
        "stance_profile', annotation=OpRef(name='init.fields.78.annotation'), default=OpRef(name='init.fields.78.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='activity_stream_policy_status', annotation=OpRef(name='init.fields.7"
        "9.annotation'), default=OpRef(name='init.fields.79.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='certificate"
        "_details', annotation=OpRef(name='init.fields.80.annotation'), default=OpRef(name='init.fields.80.default'), d"
        "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='db_system_id', annotation=OpRef(name='init.fields.81.annotation'), default"
        "=OpRef(name='init.fields.81.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
        "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='master_user_secret', annotation=Op"
        "Ref(name='init.fields.82.annotation'), default=OpRef(name='init.fields.82.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='read_replica_source_db_cluster_identifier', annotation=OpRef(name='init.fields.83.annotation'), de"
        "fault=OpRef(name='init.fields.83.default'), default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='percent_progress', annotation"
        "=OpRef(name='init.fields.84.annotation'), default=OpRef(name='init.fields.84.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='multi_tenant', annotation=OpRef(name='init.fields.85.annotation'), default=OpRef(name='init.fie"
        "lds.85.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='dedicated_log_volume', annotation=OpRef(name='init.fiel"
        "ds.86.annotation'), default=OpRef(name='init.fields.86.default'), default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='is_stor"
        "age_config_upgrade_available', annotation=OpRef(name='init.fields.87.annotation'), default=OpRef(name='init.fi"
        "elds.87.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='engine_lifecycle_support', annotation=OpRef(name='init"
        ".fields.88.annotation'), default=OpRef(name='init.fields.88.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ad"
        "ditional_storage_volumes', annotation=OpRef(name='init.fields.89.annotation'), default=OpRef(name='init.fields"
        ".89.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='storage_volume_status', annotation=OpRef(name='init.fields"
        ".90.annotation'), default=OpRef(name='init.fields.90.default'), default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params"
        "=(), kw_only_params=('db_instance_identifier', 'db_instance_class', 'engine', 'db_instance_status', 'master_us"
        "ername', 'db_name', 'endpoint', 'allocated_storage', 'instance_create_time', 'preferred_backup_window', 'backu"
        "p_retention_period', 'db_security_groups', 'vpc_security_groups', 'db_parameter_groups', 'availability_zone', "
        "'db_subnet_group', 'preferred_maintenance_window', 'upgrade_rollout_order', 'pending_modified_values', 'latest"
        "_restorable_time', 'multi_az', 'engine_version', 'auto_minor_version_upgrade', 'read_replica_source_db_instanc"
        "e_identifier', 'read_replica_db_instance_identifiers', 'read_replica_db_cluster_identifiers', 'replica_mode', "
        "'license_model', 'iops', 'storage_throughput', 'option_group_memberships', 'character_set_name', 'nchar_charac"
        "ter_set_name', 'secondary_availability_zone', 'publicly_accessible', 'status_infos', 'storage_type', 'tde_cred"
        "ential_arn', 'db_instance_port', 'db_cluster_identifier', 'storage_encrypted', 'kms_key_id', 'dbi_resource_id'"
        ", 'ca_certificate_identifier', 'domain_memberships', 'copy_tags_to_snapshot', 'monitoring_interval', 'enhanced"
        "_monitoring_resource_arn', 'monitoring_role_arn', 'promotion_tier', 'db_instance_arn', 'timezone', 'iam_databa"
        "se_authentication_enabled', 'database_insights_mode', 'performance_insights_enabled', 'performance_insights_km"
        "s_key_id', 'performance_insights_retention_period', 'enabled_cloudwatch_logs_exports', 'processor_features', '"
        "deletion_protection', 'associated_roles', 'listener_endpoint', 'max_allocated_storage', 'tag_list', 'automatio"
        "n_mode', 'resume_full_automation_mode_time', 'customer_owned_ip_enabled', 'network_type', 'activity_stream_sta"
        "tus', 'activity_stream_kms_key_id', 'activity_stream_kinesis_stream_name', 'activity_stream_mode', 'activity_s"
        "tream_engine_native_audit_fields_included', 'aws_backup_recovery_point_arn', 'db_instance_automated_backups_re"
        "plications', 'backup_target', 'automatic_restart_time', 'custom_iam_instance_profile', 'activity_stream_policy"
        "_status', 'certificate_details', 'db_system_id', 'master_user_secret', 'read_replica_source_db_cluster_identif"
        "ier', 'percent_progress', 'multi_tenant', 'dedicated_log_volume', 'is_storage_config_upgrade_available', 'engi"
        "ne_lifecycle_support', 'additional_storage_volumes', 'storage_volume_status'), frozen=True, slots=False, post_"
        "init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db_instance_identifier'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='db_instance_class', kw_only=True, fn=None), ReprPlan.Field(name"
        "='engine', kw_only=True, fn=None), ReprPlan.Field(name='db_instance_status', kw_only=True, fn=None), ReprPlan."
        "Field(name='master_username', kw_only=True, fn=None), ReprPlan.Field(name='db_name', kw_only=True, fn=None), R"
        "eprPlan.Field(name='endpoint', kw_only=True, fn=None), ReprPlan.Field(name='allocated_storage', kw_only=True, "
        "fn=None), ReprPlan.Field(name='instance_create_time', kw_only=True, fn=None), ReprPlan.Field(name='preferred_b"
        "ackup_window', kw_only=True, fn=None), ReprPlan.Field(name='backup_retention_period', kw_only=True, fn=None), "
        "ReprPlan.Field(name='db_security_groups', kw_only=True, fn=None), ReprPlan.Field(name='vpc_security_groups', k"
        "w_only=True, fn=None), ReprPlan.Field(name='db_parameter_groups', kw_only=True, fn=None), ReprPlan.Field(name="
        "'availability_zone', kw_only=True, fn=None), ReprPlan.Field(name='db_subnet_group', kw_only=True, fn=None), Re"
        "prPlan.Field(name='preferred_maintenance_window', kw_only=True, fn=None), ReprPlan.Field(name='upgrade_rollout"
        "_order', kw_only=True, fn=None), ReprPlan.Field(name='pending_modified_values', kw_only=True, fn=None), ReprPl"
        "an.Field(name='latest_restorable_time', kw_only=True, fn=None), ReprPlan.Field(name='multi_az', kw_only=True, "
        "fn=None), ReprPlan.Field(name='engine_version', kw_only=True, fn=None), ReprPlan.Field(name='auto_minor_versio"
        "n_upgrade', kw_only=True, fn=None), ReprPlan.Field(name='read_replica_source_db_instance_identifier', kw_only="
        "True, fn=None), ReprPlan.Field(name='read_replica_db_instance_identifiers', kw_only=True, fn=None), ReprPlan.F"
        "ield(name='read_replica_db_cluster_identifiers', kw_only=True, fn=None), ReprPlan.Field(name='replica_mode', k"
        "w_only=True, fn=None), ReprPlan.Field(name='license_model', kw_only=True, fn=None), ReprPlan.Field(name='iops'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='storage_throughput', kw_only=True, fn=None), ReprPlan.Field(nam"
        "e='option_group_memberships', kw_only=True, fn=None), ReprPlan.Field(name='character_set_name', kw_only=True, "
        "fn=None), ReprPlan.Field(name='nchar_character_set_name', kw_only=True, fn=None), ReprPlan.Field(name='seconda"
        "ry_availability_zone', kw_only=True, fn=None), ReprPlan.Field(name='publicly_accessible', kw_only=True, fn=Non"
        "e), ReprPlan.Field(name='status_infos', kw_only=True, fn=None), ReprPlan.Field(name='storage_type', kw_only=Tr"
        "ue, fn=None), ReprPlan.Field(name='tde_credential_arn', kw_only=True, fn=None), ReprPlan.Field(name='db_instan"
        "ce_port', kw_only=True, fn=None), ReprPlan.Field(name='db_cluster_identifier', kw_only=True, fn=None), ReprPla"
        "n.Field(name='storage_encrypted', kw_only=True, fn=None), ReprPlan.Field(name='kms_key_id', kw_only=True, fn=N"
        "one), ReprPlan.Field(name='dbi_resource_id', kw_only=True, fn=None), ReprPlan.Field(name='ca_certificate_ident"
        "ifier', kw_only=True, fn=None), ReprPlan.Field(name='domain_memberships', kw_only=True, fn=None), ReprPlan.Fie"
        "ld(name='copy_tags_to_snapshot', kw_only=True, fn=None), ReprPlan.Field(name='monitoring_interval', kw_only=Tr"
        "ue, fn=None), ReprPlan.Field(name='enhanced_monitoring_resource_arn', kw_only=True, fn=None), ReprPlan.Field(n"
        "ame='monitoring_role_arn', kw_only=True, fn=None), ReprPlan.Field(name='promotion_tier', kw_only=True, fn=None"
        "), ReprPlan.Field(name='db_instance_arn', kw_only=True, fn=None), ReprPlan.Field(name='timezone', kw_only=True"
        ", fn=None), ReprPlan.Field(name='iam_database_authentication_enabled', kw_only=True, fn=None), ReprPlan.Field("
        "name='database_insights_mode', kw_only=True, fn=None), ReprPlan.Field(name='performance_insights_enabled', kw_"
        "only=True, fn=None), ReprPlan.Field(name='performance_insights_kms_key_id', kw_only=True, fn=None), ReprPlan.F"
        "ield(name='performance_insights_retention_period', kw_only=True, fn=None), ReprPlan.Field(name='enabled_cloudw"
        "atch_logs_exports', kw_only=True, fn=None), ReprPlan.Field(name='processor_features', kw_only=True, fn=None), "
        "ReprPlan.Field(name='deletion_protection', kw_only=True, fn=None), ReprPlan.Field(name='associated_roles', kw_"
        "only=True, fn=None), ReprPlan.Field(name='listener_endpoint', kw_only=True, fn=None), ReprPlan.Field(name='max"
        "_allocated_storage', kw_only=True, fn=None), ReprPlan.Field(name='tag_list', kw_only=True, fn=None), ReprPlan."
        "Field(name='automation_mode', kw_only=True, fn=None), ReprPlan.Field(name='resume_full_automation_mode_time', "
        "kw_only=True, fn=None), ReprPlan.Field(name='customer_owned_ip_enabled', kw_only=True, fn=None), ReprPlan.Fiel"
        "d(name='network_type', kw_only=True, fn=None), ReprPlan.Field(name='activity_stream_status', kw_only=True, fn="
        "None), ReprPlan.Field(name='activity_stream_kms_key_id', kw_only=True, fn=None), ReprPlan.Field(name='activity"
        "_stream_kinesis_stream_name', kw_only=True, fn=None), ReprPlan.Field(name='activity_stream_mode', kw_only=True"
        ", fn=None), ReprPlan.Field(name='activity_stream_engine_native_audit_fields_included', kw_only=True, fn=None),"
        " ReprPlan.Field(name='aws_backup_recovery_point_arn', kw_only=True, fn=None), ReprPlan.Field(name='db_instance"
        "_automated_backups_replications', kw_only=True, fn=None), ReprPlan.Field(name='backup_target', kw_only=True, f"
        "n=None), ReprPlan.Field(name='automatic_restart_time', kw_only=True, fn=None), ReprPlan.Field(name='custom_iam"
        "_instance_profile', kw_only=True, fn=None), ReprPlan.Field(name='activity_stream_policy_status', kw_only=True,"
        " fn=None), ReprPlan.Field(name='certificate_details', kw_only=True, fn=None), ReprPlan.Field(name='db_system_i"
        "d', kw_only=True, fn=None), ReprPlan.Field(name='master_user_secret', kw_only=True, fn=None), ReprPlan.Field(n"
        "ame='read_replica_source_db_cluster_identifier', kw_only=True, fn=None), ReprPlan.Field(name='percent_progress"
        "', kw_only=True, fn=None), ReprPlan.Field(name='multi_tenant', kw_only=True, fn=None), ReprPlan.Field(name='de"
        "dicated_log_volume', kw_only=True, fn=None), ReprPlan.Field(name='is_storage_config_upgrade_available', kw_onl"
        "y=True, fn=None), ReprPlan.Field(name='engine_lifecycle_support', kw_only=True, fn=None), ReprPlan.Field(name="
        "'additional_storage_volumes', kw_only=True, fn=None), ReprPlan.Field(name='storage_volume_status', kw_only=Tru"
        "e, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='06d1d03f4b9d0ffc072cef69b6538b583c4a3931',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__24__annotation',
        '__dataclass__init__fields__24__default',
        '__dataclass__init__fields__25__annotation',
        '__dataclass__init__fields__25__default',
        '__dataclass__init__fields__26__annotation',
        '__dataclass__init__fields__26__default',
        '__dataclass__init__fields__27__annotation',
        '__dataclass__init__fields__27__default',
        '__dataclass__init__fields__28__annotation',
        '__dataclass__init__fields__28__default',
        '__dataclass__init__fields__29__annotation',
        '__dataclass__init__fields__29__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__30__annotation',
        '__dataclass__init__fields__30__default',
        '__dataclass__init__fields__31__annotation',
        '__dataclass__init__fields__31__default',
        '__dataclass__init__fields__32__annotation',
        '__dataclass__init__fields__32__default',
        '__dataclass__init__fields__33__annotation',
        '__dataclass__init__fields__33__default',
        '__dataclass__init__fields__34__annotation',
        '__dataclass__init__fields__34__default',
        '__dataclass__init__fields__35__annotation',
        '__dataclass__init__fields__35__default',
        '__dataclass__init__fields__36__annotation',
        '__dataclass__init__fields__36__default',
        '__dataclass__init__fields__37__annotation',
        '__dataclass__init__fields__37__default',
        '__dataclass__init__fields__38__annotation',
        '__dataclass__init__fields__38__default',
        '__dataclass__init__fields__39__annotation',
        '__dataclass__init__fields__39__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__40__annotation',
        '__dataclass__init__fields__40__default',
        '__dataclass__init__fields__41__annotation',
        '__dataclass__init__fields__41__default',
        '__dataclass__init__fields__42__annotation',
        '__dataclass__init__fields__42__default',
        '__dataclass__init__fields__43__annotation',
        '__dataclass__init__fields__43__default',
        '__dataclass__init__fields__44__annotation',
        '__dataclass__init__fields__44__default',
        '__dataclass__init__fields__45__annotation',
        '__dataclass__init__fields__45__default',
        '__dataclass__init__fields__46__annotation',
        '__dataclass__init__fields__46__default',
        '__dataclass__init__fields__47__annotation',
        '__dataclass__init__fields__47__default',
        '__dataclass__init__fields__48__annotation',
        '__dataclass__init__fields__48__default',
        '__dataclass__init__fields__49__annotation',
        '__dataclass__init__fields__49__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__50__annotation',
        '__dataclass__init__fields__50__default',
        '__dataclass__init__fields__51__annotation',
        '__dataclass__init__fields__51__default',
        '__dataclass__init__fields__52__annotation',
        '__dataclass__init__fields__52__default',
        '__dataclass__init__fields__53__annotation',
        '__dataclass__init__fields__53__default',
        '__dataclass__init__fields__54__annotation',
        '__dataclass__init__fields__54__default',
        '__dataclass__init__fields__55__annotation',
        '__dataclass__init__fields__55__default',
        '__dataclass__init__fields__56__annotation',
        '__dataclass__init__fields__56__default',
        '__dataclass__init__fields__57__annotation',
        '__dataclass__init__fields__57__default',
        '__dataclass__init__fields__58__annotation',
        '__dataclass__init__fields__58__default',
        '__dataclass__init__fields__59__annotation',
        '__dataclass__init__fields__59__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__60__annotation',
        '__dataclass__init__fields__60__default',
        '__dataclass__init__fields__61__annotation',
        '__dataclass__init__fields__61__default',
        '__dataclass__init__fields__62__annotation',
        '__dataclass__init__fields__62__default',
        '__dataclass__init__fields__63__annotation',
        '__dataclass__init__fields__63__default',
        '__dataclass__init__fields__64__annotation',
        '__dataclass__init__fields__64__default',
        '__dataclass__init__fields__65__annotation',
        '__dataclass__init__fields__65__default',
        '__dataclass__init__fields__66__annotation',
        '__dataclass__init__fields__66__default',
        '__dataclass__init__fields__67__annotation',
        '__dataclass__init__fields__67__default',
        '__dataclass__init__fields__68__annotation',
        '__dataclass__init__fields__68__default',
        '__dataclass__init__fields__69__annotation',
        '__dataclass__init__fields__69__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__70__annotation',
        '__dataclass__init__fields__70__default',
        '__dataclass__init__fields__71__annotation',
        '__dataclass__init__fields__71__default',
        '__dataclass__init__fields__72__annotation',
        '__dataclass__init__fields__72__default',
        '__dataclass__init__fields__73__annotation',
        '__dataclass__init__fields__73__default',
        '__dataclass__init__fields__74__annotation',
        '__dataclass__init__fields__74__default',
        '__dataclass__init__fields__75__annotation',
        '__dataclass__init__fields__75__default',
        '__dataclass__init__fields__76__annotation',
        '__dataclass__init__fields__76__default',
        '__dataclass__init__fields__77__annotation',
        '__dataclass__init__fields__77__default',
        '__dataclass__init__fields__78__annotation',
        '__dataclass__init__fields__78__default',
        '__dataclass__init__fields__79__annotation',
        '__dataclass__init__fields__79__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__80__annotation',
        '__dataclass__init__fields__80__default',
        '__dataclass__init__fields__81__annotation',
        '__dataclass__init__fields__81__default',
        '__dataclass__init__fields__82__annotation',
        '__dataclass__init__fields__82__default',
        '__dataclass__init__fields__83__annotation',
        '__dataclass__init__fields__83__default',
        '__dataclass__init__fields__84__annotation',
        '__dataclass__init__fields__84__default',
        '__dataclass__init__fields__85__annotation',
        '__dataclass__init__fields__85__default',
        '__dataclass__init__fields__86__annotation',
        '__dataclass__init__fields__86__default',
        '__dataclass__init__fields__87__annotation',
        '__dataclass__init__fields__87__default',
        '__dataclass__init__fields__88__annotation',
        '__dataclass__init__fields__88__default',
        '__dataclass__init__fields__89__annotation',
        '__dataclass__init__fields__89__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__90__annotation',
        '__dataclass__init__fields__90__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'DBInstance'),
    ),
)
def _process_dataclass__06d1d03f4b9d0ffc072cef69b6538b583c4a3931():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__24__annotation,
        __dataclass__init__fields__24__default,
        __dataclass__init__fields__25__annotation,
        __dataclass__init__fields__25__default,
        __dataclass__init__fields__26__annotation,
        __dataclass__init__fields__26__default,
        __dataclass__init__fields__27__annotation,
        __dataclass__init__fields__27__default,
        __dataclass__init__fields__28__annotation,
        __dataclass__init__fields__28__default,
        __dataclass__init__fields__29__annotation,
        __dataclass__init__fields__29__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__30__annotation,
        __dataclass__init__fields__30__default,
        __dataclass__init__fields__31__annotation,
        __dataclass__init__fields__31__default,
        __dataclass__init__fields__32__annotation,
        __dataclass__init__fields__32__default,
        __dataclass__init__fields__33__annotation,
        __dataclass__init__fields__33__default,
        __dataclass__init__fields__34__annotation,
        __dataclass__init__fields__34__default,
        __dataclass__init__fields__35__annotation,
        __dataclass__init__fields__35__default,
        __dataclass__init__fields__36__annotation,
        __dataclass__init__fields__36__default,
        __dataclass__init__fields__37__annotation,
        __dataclass__init__fields__37__default,
        __dataclass__init__fields__38__annotation,
        __dataclass__init__fields__38__default,
        __dataclass__init__fields__39__annotation,
        __dataclass__init__fields__39__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__40__annotation,
        __dataclass__init__fields__40__default,
        __dataclass__init__fields__41__annotation,
        __dataclass__init__fields__41__default,
        __dataclass__init__fields__42__annotation,
        __dataclass__init__fields__42__default,
        __dataclass__init__fields__43__annotation,
        __dataclass__init__fields__43__default,
        __dataclass__init__fields__44__annotation,
        __dataclass__init__fields__44__default,
        __dataclass__init__fields__45__annotation,
        __dataclass__init__fields__45__default,
        __dataclass__init__fields__46__annotation,
        __dataclass__init__fields__46__default,
        __dataclass__init__fields__47__annotation,
        __dataclass__init__fields__47__default,
        __dataclass__init__fields__48__annotation,
        __dataclass__init__fields__48__default,
        __dataclass__init__fields__49__annotation,
        __dataclass__init__fields__49__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__50__annotation,
        __dataclass__init__fields__50__default,
        __dataclass__init__fields__51__annotation,
        __dataclass__init__fields__51__default,
        __dataclass__init__fields__52__annotation,
        __dataclass__init__fields__52__default,
        __dataclass__init__fields__53__annotation,
        __dataclass__init__fields__53__default,
        __dataclass__init__fields__54__annotation,
        __dataclass__init__fields__54__default,
        __dataclass__init__fields__55__annotation,
        __dataclass__init__fields__55__default,
        __dataclass__init__fields__56__annotation,
        __dataclass__init__fields__56__default,
        __dataclass__init__fields__57__annotation,
        __dataclass__init__fields__57__default,
        __dataclass__init__fields__58__annotation,
        __dataclass__init__fields__58__default,
        __dataclass__init__fields__59__annotation,
        __dataclass__init__fields__59__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__60__annotation,
        __dataclass__init__fields__60__default,
        __dataclass__init__fields__61__annotation,
        __dataclass__init__fields__61__default,
        __dataclass__init__fields__62__annotation,
        __dataclass__init__fields__62__default,
        __dataclass__init__fields__63__annotation,
        __dataclass__init__fields__63__default,
        __dataclass__init__fields__64__annotation,
        __dataclass__init__fields__64__default,
        __dataclass__init__fields__65__annotation,
        __dataclass__init__fields__65__default,
        __dataclass__init__fields__66__annotation,
        __dataclass__init__fields__66__default,
        __dataclass__init__fields__67__annotation,
        __dataclass__init__fields__67__default,
        __dataclass__init__fields__68__annotation,
        __dataclass__init__fields__68__default,
        __dataclass__init__fields__69__annotation,
        __dataclass__init__fields__69__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__70__annotation,
        __dataclass__init__fields__70__default,
        __dataclass__init__fields__71__annotation,
        __dataclass__init__fields__71__default,
        __dataclass__init__fields__72__annotation,
        __dataclass__init__fields__72__default,
        __dataclass__init__fields__73__annotation,
        __dataclass__init__fields__73__default,
        __dataclass__init__fields__74__annotation,
        __dataclass__init__fields__74__default,
        __dataclass__init__fields__75__annotation,
        __dataclass__init__fields__75__default,
        __dataclass__init__fields__76__annotation,
        __dataclass__init__fields__76__default,
        __dataclass__init__fields__77__annotation,
        __dataclass__init__fields__77__default,
        __dataclass__init__fields__78__annotation,
        __dataclass__init__fields__78__default,
        __dataclass__init__fields__79__annotation,
        __dataclass__init__fields__79__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__80__annotation,
        __dataclass__init__fields__80__default,
        __dataclass__init__fields__81__annotation,
        __dataclass__init__fields__81__default,
        __dataclass__init__fields__82__annotation,
        __dataclass__init__fields__82__default,
        __dataclass__init__fields__83__annotation,
        __dataclass__init__fields__83__default,
        __dataclass__init__fields__84__annotation,
        __dataclass__init__fields__84__default,
        __dataclass__init__fields__85__annotation,
        __dataclass__init__fields__85__default,
        __dataclass__init__fields__86__annotation,
        __dataclass__init__fields__86__default,
        __dataclass__init__fields__87__annotation,
        __dataclass__init__fields__87__default,
        __dataclass__init__fields__88__annotation,
        __dataclass__init__fields__88__default,
        __dataclass__init__fields__89__annotation,
        __dataclass__init__fields__89__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__90__annotation,
        __dataclass__init__fields__90__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                db_instance_identifier=self.db_instance_identifier,
                db_instance_class=self.db_instance_class,
                engine=self.engine,
                db_instance_status=self.db_instance_status,
                master_username=self.master_username,
                db_name=self.db_name,
                endpoint=self.endpoint,
                allocated_storage=self.allocated_storage,
                instance_create_time=self.instance_create_time,
                preferred_backup_window=self.preferred_backup_window,
                backup_retention_period=self.backup_retention_period,
                db_security_groups=self.db_security_groups,
                vpc_security_groups=self.vpc_security_groups,
                db_parameter_groups=self.db_parameter_groups,
                availability_zone=self.availability_zone,
                db_subnet_group=self.db_subnet_group,
                preferred_maintenance_window=self.preferred_maintenance_window,
                upgrade_rollout_order=self.upgrade_rollout_order,
                pending_modified_values=self.pending_modified_values,
                latest_restorable_time=self.latest_restorable_time,
                multi_az=self.multi_az,
                engine_version=self.engine_version,
                auto_minor_version_upgrade=self.auto_minor_version_upgrade,
                read_replica_source_db_instance_identifier=self.read_replica_source_db_instance_identifier,
                read_replica_db_instance_identifiers=self.read_replica_db_instance_identifiers,
                read_replica_db_cluster_identifiers=self.read_replica_db_cluster_identifiers,
                replica_mode=self.replica_mode,
                license_model=self.license_model,
                iops=self.iops,
                storage_throughput=self.storage_throughput,
                option_group_memberships=self.option_group_memberships,
                character_set_name=self.character_set_name,
                nchar_character_set_name=self.nchar_character_set_name,
                secondary_availability_zone=self.secondary_availability_zone,
                publicly_accessible=self.publicly_accessible,
                status_infos=self.status_infos,
                storage_type=self.storage_type,
                tde_credential_arn=self.tde_credential_arn,
                db_instance_port=self.db_instance_port,
                db_cluster_identifier=self.db_cluster_identifier,
                storage_encrypted=self.storage_encrypted,
                kms_key_id=self.kms_key_id,
                dbi_resource_id=self.dbi_resource_id,
                ca_certificate_identifier=self.ca_certificate_identifier,
                domain_memberships=self.domain_memberships,
                copy_tags_to_snapshot=self.copy_tags_to_snapshot,
                monitoring_interval=self.monitoring_interval,
                enhanced_monitoring_resource_arn=self.enhanced_monitoring_resource_arn,
                monitoring_role_arn=self.monitoring_role_arn,
                promotion_tier=self.promotion_tier,
                db_instance_arn=self.db_instance_arn,
                timezone=self.timezone,
                iam_database_authentication_enabled=self.iam_database_authentication_enabled,
                database_insights_mode=self.database_insights_mode,
                performance_insights_enabled=self.performance_insights_enabled,
                performance_insights_kms_key_id=self.performance_insights_kms_key_id,
                performance_insights_retention_period=self.performance_insights_retention_period,
                enabled_cloudwatch_logs_exports=self.enabled_cloudwatch_logs_exports,
                processor_features=self.processor_features,
                deletion_protection=self.deletion_protection,
                associated_roles=self.associated_roles,
                listener_endpoint=self.listener_endpoint,
                max_allocated_storage=self.max_allocated_storage,
                tag_list=self.tag_list,
                automation_mode=self.automation_mode,
                resume_full_automation_mode_time=self.resume_full_automation_mode_time,
                customer_owned_ip_enabled=self.customer_owned_ip_enabled,
                network_type=self.network_type,
                activity_stream_status=self.activity_stream_status,
                activity_stream_kms_key_id=self.activity_stream_kms_key_id,
                activity_stream_kinesis_stream_name=self.activity_stream_kinesis_stream_name,
                activity_stream_mode=self.activity_stream_mode,
                activity_stream_engine_native_audit_fields_included=self.activity_stream_engine_native_audit_fields_included,
                aws_backup_recovery_point_arn=self.aws_backup_recovery_point_arn,
                db_instance_automated_backups_replications=self.db_instance_automated_backups_replications,
                backup_target=self.backup_target,
                automatic_restart_time=self.automatic_restart_time,
                custom_iam_instance_profile=self.custom_iam_instance_profile,
                activity_stream_policy_status=self.activity_stream_policy_status,
                certificate_details=self.certificate_details,
                db_system_id=self.db_system_id,
                master_user_secret=self.master_user_secret,
                read_replica_source_db_cluster_identifier=self.read_replica_source_db_cluster_identifier,
                percent_progress=self.percent_progress,
                multi_tenant=self.multi_tenant,
                dedicated_log_volume=self.dedicated_log_volume,
                is_storage_config_upgrade_available=self.is_storage_config_upgrade_available,
                engine_lifecycle_support=self.engine_lifecycle_support,
                additional_storage_volumes=self.additional_storage_volumes,
                storage_volume_status=self.storage_volume_status,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.db_instance_identifier == other.db_instance_identifier and
                self.db_instance_class == other.db_instance_class and
                self.engine == other.engine and
                self.db_instance_status == other.db_instance_status and
                self.master_username == other.master_username and
                self.db_name == other.db_name and
                self.endpoint == other.endpoint and
                self.allocated_storage == other.allocated_storage and
                self.instance_create_time == other.instance_create_time and
                self.preferred_backup_window == other.preferred_backup_window and
                self.backup_retention_period == other.backup_retention_period and
                self.db_security_groups == other.db_security_groups and
                self.vpc_security_groups == other.vpc_security_groups and
                self.db_parameter_groups == other.db_parameter_groups and
                self.availability_zone == other.availability_zone and
                self.db_subnet_group == other.db_subnet_group and
                self.preferred_maintenance_window == other.preferred_maintenance_window and
                self.upgrade_rollout_order == other.upgrade_rollout_order and
                self.pending_modified_values == other.pending_modified_values and
                self.latest_restorable_time == other.latest_restorable_time and
                self.multi_az == other.multi_az and
                self.engine_version == other.engine_version and
                self.auto_minor_version_upgrade == other.auto_minor_version_upgrade and
                self.read_replica_source_db_instance_identifier == other.read_replica_source_db_instance_identifier and
                self.read_replica_db_instance_identifiers == other.read_replica_db_instance_identifiers and
                self.read_replica_db_cluster_identifiers == other.read_replica_db_cluster_identifiers and
                self.replica_mode == other.replica_mode and
                self.license_model == other.license_model and
                self.iops == other.iops and
                self.storage_throughput == other.storage_throughput and
                self.option_group_memberships == other.option_group_memberships and
                self.character_set_name == other.character_set_name and
                self.nchar_character_set_name == other.nchar_character_set_name and
                self.secondary_availability_zone == other.secondary_availability_zone and
                self.publicly_accessible == other.publicly_accessible and
                self.status_infos == other.status_infos and
                self.storage_type == other.storage_type and
                self.tde_credential_arn == other.tde_credential_arn and
                self.db_instance_port == other.db_instance_port and
                self.db_cluster_identifier == other.db_cluster_identifier and
                self.storage_encrypted == other.storage_encrypted and
                self.kms_key_id == other.kms_key_id and
                self.dbi_resource_id == other.dbi_resource_id and
                self.ca_certificate_identifier == other.ca_certificate_identifier and
                self.domain_memberships == other.domain_memberships and
                self.copy_tags_to_snapshot == other.copy_tags_to_snapshot and
                self.monitoring_interval == other.monitoring_interval and
                self.enhanced_monitoring_resource_arn == other.enhanced_monitoring_resource_arn and
                self.monitoring_role_arn == other.monitoring_role_arn and
                self.promotion_tier == other.promotion_tier and
                self.db_instance_arn == other.db_instance_arn and
                self.timezone == other.timezone and
                self.iam_database_authentication_enabled == other.iam_database_authentication_enabled and
                self.database_insights_mode == other.database_insights_mode and
                self.performance_insights_enabled == other.performance_insights_enabled and
                self.performance_insights_kms_key_id == other.performance_insights_kms_key_id and
                self.performance_insights_retention_period == other.performance_insights_retention_period and
                self.enabled_cloudwatch_logs_exports == other.enabled_cloudwatch_logs_exports and
                self.processor_features == other.processor_features and
                self.deletion_protection == other.deletion_protection and
                self.associated_roles == other.associated_roles and
                self.listener_endpoint == other.listener_endpoint and
                self.max_allocated_storage == other.max_allocated_storage and
                self.tag_list == other.tag_list and
                self.automation_mode == other.automation_mode and
                self.resume_full_automation_mode_time == other.resume_full_automation_mode_time and
                self.customer_owned_ip_enabled == other.customer_owned_ip_enabled and
                self.network_type == other.network_type and
                self.activity_stream_status == other.activity_stream_status and
                self.activity_stream_kms_key_id == other.activity_stream_kms_key_id and
                self.activity_stream_kinesis_stream_name == other.activity_stream_kinesis_stream_name and
                self.activity_stream_mode == other.activity_stream_mode and
                self.activity_stream_engine_native_audit_fields_included == other.activity_stream_engine_native_audit_fields_included and
                self.aws_backup_recovery_point_arn == other.aws_backup_recovery_point_arn and
                self.db_instance_automated_backups_replications == other.db_instance_automated_backups_replications and
                self.backup_target == other.backup_target and
                self.automatic_restart_time == other.automatic_restart_time and
                self.custom_iam_instance_profile == other.custom_iam_instance_profile and
                self.activity_stream_policy_status == other.activity_stream_policy_status and
                self.certificate_details == other.certificate_details and
                self.db_system_id == other.db_system_id and
                self.master_user_secret == other.master_user_secret and
                self.read_replica_source_db_cluster_identifier == other.read_replica_source_db_cluster_identifier and
                self.percent_progress == other.percent_progress and
                self.multi_tenant == other.multi_tenant and
                self.dedicated_log_volume == other.dedicated_log_volume and
                self.is_storage_config_upgrade_available == other.is_storage_config_upgrade_available and
                self.engine_lifecycle_support == other.engine_lifecycle_support and
                self.additional_storage_volumes == other.additional_storage_volumes and
                self.storage_volume_status == other.storage_volume_status
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'db_instance_identifier',
            'db_instance_class',
            'engine',
            'db_instance_status',
            'master_username',
            'db_name',
            'endpoint',
            'allocated_storage',
            'instance_create_time',
            'preferred_backup_window',
            'backup_retention_period',
            'db_security_groups',
            'vpc_security_groups',
            'db_parameter_groups',
            'availability_zone',
            'db_subnet_group',
            'preferred_maintenance_window',
            'upgrade_rollout_order',
            'pending_modified_values',
            'latest_restorable_time',
            'multi_az',
            'engine_version',
            'auto_minor_version_upgrade',
            'read_replica_source_db_instance_identifier',
            'read_replica_db_instance_identifiers',
            'read_replica_db_cluster_identifiers',
            'replica_mode',
            'license_model',
            'iops',
            'storage_throughput',
            'option_group_memberships',
            'character_set_name',
            'nchar_character_set_name',
            'secondary_availability_zone',
            'publicly_accessible',
            'status_infos',
            'storage_type',
            'tde_credential_arn',
            'db_instance_port',
            'db_cluster_identifier',
            'storage_encrypted',
            'kms_key_id',
            'dbi_resource_id',
            'ca_certificate_identifier',
            'domain_memberships',
            'copy_tags_to_snapshot',
            'monitoring_interval',
            'enhanced_monitoring_resource_arn',
            'monitoring_role_arn',
            'promotion_tier',
            'db_instance_arn',
            'timezone',
            'iam_database_authentication_enabled',
            'database_insights_mode',
            'performance_insights_enabled',
            'performance_insights_kms_key_id',
            'performance_insights_retention_period',
            'enabled_cloudwatch_logs_exports',
            'processor_features',
            'deletion_protection',
            'associated_roles',
            'listener_endpoint',
            'max_allocated_storage',
            'tag_list',
            'automation_mode',
            'resume_full_automation_mode_time',
            'customer_owned_ip_enabled',
            'network_type',
            'activity_stream_status',
            'activity_stream_kms_key_id',
            'activity_stream_kinesis_stream_name',
            'activity_stream_mode',
            'activity_stream_engine_native_audit_fields_included',
            'aws_backup_recovery_point_arn',
            'db_instance_automated_backups_replications',
            'backup_target',
            'automatic_restart_time',
            'custom_iam_instance_profile',
            'activity_stream_policy_status',
            'certificate_details',
            'db_system_id',
            'master_user_secret',
            'read_replica_source_db_cluster_identifier',
            'percent_progress',
            'multi_tenant',
            'dedicated_log_volume',
            'is_storage_config_upgrade_available',
            'engine_lifecycle_support',
            'additional_storage_volumes',
            'storage_volume_status',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'db_instance_identifier',
            'db_instance_class',
            'engine',
            'db_instance_status',
            'master_username',
            'db_name',
            'endpoint',
            'allocated_storage',
            'instance_create_time',
            'preferred_backup_window',
            'backup_retention_period',
            'db_security_groups',
            'vpc_security_groups',
            'db_parameter_groups',
            'availability_zone',
            'db_subnet_group',
            'preferred_maintenance_window',
            'upgrade_rollout_order',
            'pending_modified_values',
            'latest_restorable_time',
            'multi_az',
            'engine_version',
            'auto_minor_version_upgrade',
            'read_replica_source_db_instance_identifier',
            'read_replica_db_instance_identifiers',
            'read_replica_db_cluster_identifiers',
            'replica_mode',
            'license_model',
            'iops',
            'storage_throughput',
            'option_group_memberships',
            'character_set_name',
            'nchar_character_set_name',
            'secondary_availability_zone',
            'publicly_accessible',
            'status_infos',
            'storage_type',
            'tde_credential_arn',
            'db_instance_port',
            'db_cluster_identifier',
            'storage_encrypted',
            'kms_key_id',
            'dbi_resource_id',
            'ca_certificate_identifier',
            'domain_memberships',
            'copy_tags_to_snapshot',
            'monitoring_interval',
            'enhanced_monitoring_resource_arn',
            'monitoring_role_arn',
            'promotion_tier',
            'db_instance_arn',
            'timezone',
            'iam_database_authentication_enabled',
            'database_insights_mode',
            'performance_insights_enabled',
            'performance_insights_kms_key_id',
            'performance_insights_retention_period',
            'enabled_cloudwatch_logs_exports',
            'processor_features',
            'deletion_protection',
            'associated_roles',
            'listener_endpoint',
            'max_allocated_storage',
            'tag_list',
            'automation_mode',
            'resume_full_automation_mode_time',
            'customer_owned_ip_enabled',
            'network_type',
            'activity_stream_status',
            'activity_stream_kms_key_id',
            'activity_stream_kinesis_stream_name',
            'activity_stream_mode',
            'activity_stream_engine_native_audit_fields_included',
            'aws_backup_recovery_point_arn',
            'db_instance_automated_backups_replications',
            'backup_target',
            'automatic_restart_time',
            'custom_iam_instance_profile',
            'activity_stream_policy_status',
            'certificate_details',
            'db_system_id',
            'master_user_secret',
            'read_replica_source_db_cluster_identifier',
            'percent_progress',
            'multi_tenant',
            'dedicated_log_volume',
            'is_storage_config_upgrade_available',
            'engine_lifecycle_support',
            'additional_storage_volumes',
            'storage_volume_status',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.db_instance_identifier,
                self.db_instance_class,
                self.engine,
                self.db_instance_status,
                self.master_username,
                self.db_name,
                self.endpoint,
                self.allocated_storage,
                self.instance_create_time,
                self.preferred_backup_window,
                self.backup_retention_period,
                self.db_security_groups,
                self.vpc_security_groups,
                self.db_parameter_groups,
                self.availability_zone,
                self.db_subnet_group,
                self.preferred_maintenance_window,
                self.upgrade_rollout_order,
                self.pending_modified_values,
                self.latest_restorable_time,
                self.multi_az,
                self.engine_version,
                self.auto_minor_version_upgrade,
                self.read_replica_source_db_instance_identifier,
                self.read_replica_db_instance_identifiers,
                self.read_replica_db_cluster_identifiers,
                self.replica_mode,
                self.license_model,
                self.iops,
                self.storage_throughput,
                self.option_group_memberships,
                self.character_set_name,
                self.nchar_character_set_name,
                self.secondary_availability_zone,
                self.publicly_accessible,
                self.status_infos,
                self.storage_type,
                self.tde_credential_arn,
                self.db_instance_port,
                self.db_cluster_identifier,
                self.storage_encrypted,
                self.kms_key_id,
                self.dbi_resource_id,
                self.ca_certificate_identifier,
                self.domain_memberships,
                self.copy_tags_to_snapshot,
                self.monitoring_interval,
                self.enhanced_monitoring_resource_arn,
                self.monitoring_role_arn,
                self.promotion_tier,
                self.db_instance_arn,
                self.timezone,
                self.iam_database_authentication_enabled,
                self.database_insights_mode,
                self.performance_insights_enabled,
                self.performance_insights_kms_key_id,
                self.performance_insights_retention_period,
                self.enabled_cloudwatch_logs_exports,
                self.processor_features,
                self.deletion_protection,
                self.associated_roles,
                self.listener_endpoint,
                self.max_allocated_storage,
                self.tag_list,
                self.automation_mode,
                self.resume_full_automation_mode_time,
                self.customer_owned_ip_enabled,
                self.network_type,
                self.activity_stream_status,
                self.activity_stream_kms_key_id,
                self.activity_stream_kinesis_stream_name,
                self.activity_stream_mode,
                self.activity_stream_engine_native_audit_fields_included,
                self.aws_backup_recovery_point_arn,
                self.db_instance_automated_backups_replications,
                self.backup_target,
                self.automatic_restart_time,
                self.custom_iam_instance_profile,
                self.activity_stream_policy_status,
                self.certificate_details,
                self.db_system_id,
                self.master_user_secret,
                self.read_replica_source_db_cluster_identifier,
                self.percent_progress,
                self.multi_tenant,
                self.dedicated_log_volume,
                self.is_storage_config_upgrade_available,
                self.engine_lifecycle_support,
                self.additional_storage_volumes,
                self.storage_volume_status,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            db_instance_identifier: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            db_instance_class: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            engine: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            db_instance_status: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            master_username: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            db_name: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            endpoint: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            allocated_storage: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            instance_create_time: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            preferred_backup_window: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            backup_retention_period: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            db_security_groups: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            vpc_security_groups: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            db_parameter_groups: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            availability_zone: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            db_subnet_group: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            preferred_maintenance_window: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            upgrade_rollout_order: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            pending_modified_values: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            latest_restorable_time: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            multi_az: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            engine_version: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            auto_minor_version_upgrade: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
            read_replica_source_db_instance_identifier: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
            read_replica_db_instance_identifiers: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
            read_replica_db_cluster_identifiers: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
            replica_mode: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
            license_model: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
            iops: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
            storage_throughput: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
            option_group_memberships: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
            character_set_name: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
            nchar_character_set_name: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
            secondary_availability_zone: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
            publicly_accessible: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
            status_infos: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
            storage_type: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
            tde_credential_arn: __dataclass__init__fields__38__annotation = __dataclass__init__fields__38__default,
            db_instance_port: __dataclass__init__fields__39__annotation = __dataclass__init__fields__39__default,
            db_cluster_identifier: __dataclass__init__fields__40__annotation = __dataclass__init__fields__40__default,
            storage_encrypted: __dataclass__init__fields__41__annotation = __dataclass__init__fields__41__default,
            kms_key_id: __dataclass__init__fields__42__annotation = __dataclass__init__fields__42__default,
            dbi_resource_id: __dataclass__init__fields__43__annotation = __dataclass__init__fields__43__default,
            ca_certificate_identifier: __dataclass__init__fields__44__annotation = __dataclass__init__fields__44__default,
            domain_memberships: __dataclass__init__fields__45__annotation = __dataclass__init__fields__45__default,
            copy_tags_to_snapshot: __dataclass__init__fields__46__annotation = __dataclass__init__fields__46__default,
            monitoring_interval: __dataclass__init__fields__47__annotation = __dataclass__init__fields__47__default,
            enhanced_monitoring_resource_arn: __dataclass__init__fields__48__annotation = __dataclass__init__fields__48__default,
            monitoring_role_arn: __dataclass__init__fields__49__annotation = __dataclass__init__fields__49__default,
            promotion_tier: __dataclass__init__fields__50__annotation = __dataclass__init__fields__50__default,
            db_instance_arn: __dataclass__init__fields__51__annotation = __dataclass__init__fields__51__default,
            timezone: __dataclass__init__fields__52__annotation = __dataclass__init__fields__52__default,
            iam_database_authentication_enabled: __dataclass__init__fields__53__annotation = __dataclass__init__fields__53__default,
            database_insights_mode: __dataclass__init__fields__54__annotation = __dataclass__init__fields__54__default,
            performance_insights_enabled: __dataclass__init__fields__55__annotation = __dataclass__init__fields__55__default,
            performance_insights_kms_key_id: __dataclass__init__fields__56__annotation = __dataclass__init__fields__56__default,
            performance_insights_retention_period: __dataclass__init__fields__57__annotation = __dataclass__init__fields__57__default,
            enabled_cloudwatch_logs_exports: __dataclass__init__fields__58__annotation = __dataclass__init__fields__58__default,
            processor_features: __dataclass__init__fields__59__annotation = __dataclass__init__fields__59__default,
            deletion_protection: __dataclass__init__fields__60__annotation = __dataclass__init__fields__60__default,
            associated_roles: __dataclass__init__fields__61__annotation = __dataclass__init__fields__61__default,
            listener_endpoint: __dataclass__init__fields__62__annotation = __dataclass__init__fields__62__default,
            max_allocated_storage: __dataclass__init__fields__63__annotation = __dataclass__init__fields__63__default,
            tag_list: __dataclass__init__fields__64__annotation = __dataclass__init__fields__64__default,
            automation_mode: __dataclass__init__fields__65__annotation = __dataclass__init__fields__65__default,
            resume_full_automation_mode_time: __dataclass__init__fields__66__annotation = __dataclass__init__fields__66__default,
            customer_owned_ip_enabled: __dataclass__init__fields__67__annotation = __dataclass__init__fields__67__default,
            network_type: __dataclass__init__fields__68__annotation = __dataclass__init__fields__68__default,
            activity_stream_status: __dataclass__init__fields__69__annotation = __dataclass__init__fields__69__default,
            activity_stream_kms_key_id: __dataclass__init__fields__70__annotation = __dataclass__init__fields__70__default,
            activity_stream_kinesis_stream_name: __dataclass__init__fields__71__annotation = __dataclass__init__fields__71__default,
            activity_stream_mode: __dataclass__init__fields__72__annotation = __dataclass__init__fields__72__default,
            activity_stream_engine_native_audit_fields_included: __dataclass__init__fields__73__annotation = __dataclass__init__fields__73__default,
            aws_backup_recovery_point_arn: __dataclass__init__fields__74__annotation = __dataclass__init__fields__74__default,
            db_instance_automated_backups_replications: __dataclass__init__fields__75__annotation = __dataclass__init__fields__75__default,
            backup_target: __dataclass__init__fields__76__annotation = __dataclass__init__fields__76__default,
            automatic_restart_time: __dataclass__init__fields__77__annotation = __dataclass__init__fields__77__default,
            custom_iam_instance_profile: __dataclass__init__fields__78__annotation = __dataclass__init__fields__78__default,
            activity_stream_policy_status: __dataclass__init__fields__79__annotation = __dataclass__init__fields__79__default,
            certificate_details: __dataclass__init__fields__80__annotation = __dataclass__init__fields__80__default,
            db_system_id: __dataclass__init__fields__81__annotation = __dataclass__init__fields__81__default,
            master_user_secret: __dataclass__init__fields__82__annotation = __dataclass__init__fields__82__default,
            read_replica_source_db_cluster_identifier: __dataclass__init__fields__83__annotation = __dataclass__init__fields__83__default,
            percent_progress: __dataclass__init__fields__84__annotation = __dataclass__init__fields__84__default,
            multi_tenant: __dataclass__init__fields__85__annotation = __dataclass__init__fields__85__default,
            dedicated_log_volume: __dataclass__init__fields__86__annotation = __dataclass__init__fields__86__default,
            is_storage_config_upgrade_available: __dataclass__init__fields__87__annotation = __dataclass__init__fields__87__default,
            engine_lifecycle_support: __dataclass__init__fields__88__annotation = __dataclass__init__fields__88__default,
            additional_storage_volumes: __dataclass__init__fields__89__annotation = __dataclass__init__fields__89__default,
            storage_volume_status: __dataclass__init__fields__90__annotation = __dataclass__init__fields__90__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'db_instance_identifier', db_instance_identifier)
            __dataclass__object_setattr(self, 'db_instance_class', db_instance_class)
            __dataclass__object_setattr(self, 'engine', engine)
            __dataclass__object_setattr(self, 'db_instance_status', db_instance_status)
            __dataclass__object_setattr(self, 'master_username', master_username)
            __dataclass__object_setattr(self, 'db_name', db_name)
            __dataclass__object_setattr(self, 'endpoint', endpoint)
            __dataclass__object_setattr(self, 'allocated_storage', allocated_storage)
            __dataclass__object_setattr(self, 'instance_create_time', instance_create_time)
            __dataclass__object_setattr(self, 'preferred_backup_window', preferred_backup_window)
            __dataclass__object_setattr(self, 'backup_retention_period', backup_retention_period)
            __dataclass__object_setattr(self, 'db_security_groups', db_security_groups)
            __dataclass__object_setattr(self, 'vpc_security_groups', vpc_security_groups)
            __dataclass__object_setattr(self, 'db_parameter_groups', db_parameter_groups)
            __dataclass__object_setattr(self, 'availability_zone', availability_zone)
            __dataclass__object_setattr(self, 'db_subnet_group', db_subnet_group)
            __dataclass__object_setattr(self, 'preferred_maintenance_window', preferred_maintenance_window)
            __dataclass__object_setattr(self, 'upgrade_rollout_order', upgrade_rollout_order)
            __dataclass__object_setattr(self, 'pending_modified_values', pending_modified_values)
            __dataclass__object_setattr(self, 'latest_restorable_time', latest_restorable_time)
            __dataclass__object_setattr(self, 'multi_az', multi_az)
            __dataclass__object_setattr(self, 'engine_version', engine_version)
            __dataclass__object_setattr(self, 'auto_minor_version_upgrade', auto_minor_version_upgrade)
            __dataclass__object_setattr(self, 'read_replica_source_db_instance_identifier', read_replica_source_db_instance_identifier)
            __dataclass__object_setattr(self, 'read_replica_db_instance_identifiers', read_replica_db_instance_identifiers)
            __dataclass__object_setattr(self, 'read_replica_db_cluster_identifiers', read_replica_db_cluster_identifiers)
            __dataclass__object_setattr(self, 'replica_mode', replica_mode)
            __dataclass__object_setattr(self, 'license_model', license_model)
            __dataclass__object_setattr(self, 'iops', iops)
            __dataclass__object_setattr(self, 'storage_throughput', storage_throughput)
            __dataclass__object_setattr(self, 'option_group_memberships', option_group_memberships)
            __dataclass__object_setattr(self, 'character_set_name', character_set_name)
            __dataclass__object_setattr(self, 'nchar_character_set_name', nchar_character_set_name)
            __dataclass__object_setattr(self, 'secondary_availability_zone', secondary_availability_zone)
            __dataclass__object_setattr(self, 'publicly_accessible', publicly_accessible)
            __dataclass__object_setattr(self, 'status_infos', status_infos)
            __dataclass__object_setattr(self, 'storage_type', storage_type)
            __dataclass__object_setattr(self, 'tde_credential_arn', tde_credential_arn)
            __dataclass__object_setattr(self, 'db_instance_port', db_instance_port)
            __dataclass__object_setattr(self, 'db_cluster_identifier', db_cluster_identifier)
            __dataclass__object_setattr(self, 'storage_encrypted', storage_encrypted)
            __dataclass__object_setattr(self, 'kms_key_id', kms_key_id)
            __dataclass__object_setattr(self, 'dbi_resource_id', dbi_resource_id)
            __dataclass__object_setattr(self, 'ca_certificate_identifier', ca_certificate_identifier)
            __dataclass__object_setattr(self, 'domain_memberships', domain_memberships)
            __dataclass__object_setattr(self, 'copy_tags_to_snapshot', copy_tags_to_snapshot)
            __dataclass__object_setattr(self, 'monitoring_interval', monitoring_interval)
            __dataclass__object_setattr(self, 'enhanced_monitoring_resource_arn', enhanced_monitoring_resource_arn)
            __dataclass__object_setattr(self, 'monitoring_role_arn', monitoring_role_arn)
            __dataclass__object_setattr(self, 'promotion_tier', promotion_tier)
            __dataclass__object_setattr(self, 'db_instance_arn', db_instance_arn)
            __dataclass__object_setattr(self, 'timezone', timezone)
            __dataclass__object_setattr(self, 'iam_database_authentication_enabled', iam_database_authentication_enabled)
            __dataclass__object_setattr(self, 'database_insights_mode', database_insights_mode)
            __dataclass__object_setattr(self, 'performance_insights_enabled', performance_insights_enabled)
            __dataclass__object_setattr(self, 'performance_insights_kms_key_id', performance_insights_kms_key_id)
            __dataclass__object_setattr(self, 'performance_insights_retention_period', performance_insights_retention_period)
            __dataclass__object_setattr(self, 'enabled_cloudwatch_logs_exports', enabled_cloudwatch_logs_exports)
            __dataclass__object_setattr(self, 'processor_features', processor_features)
            __dataclass__object_setattr(self, 'deletion_protection', deletion_protection)
            __dataclass__object_setattr(self, 'associated_roles', associated_roles)
            __dataclass__object_setattr(self, 'listener_endpoint', listener_endpoint)
            __dataclass__object_setattr(self, 'max_allocated_storage', max_allocated_storage)
            __dataclass__object_setattr(self, 'tag_list', tag_list)
            __dataclass__object_setattr(self, 'automation_mode', automation_mode)
            __dataclass__object_setattr(self, 'resume_full_automation_mode_time', resume_full_automation_mode_time)
            __dataclass__object_setattr(self, 'customer_owned_ip_enabled', customer_owned_ip_enabled)
            __dataclass__object_setattr(self, 'network_type', network_type)
            __dataclass__object_setattr(self, 'activity_stream_status', activity_stream_status)
            __dataclass__object_setattr(self, 'activity_stream_kms_key_id', activity_stream_kms_key_id)
            __dataclass__object_setattr(self, 'activity_stream_kinesis_stream_name', activity_stream_kinesis_stream_name)
            __dataclass__object_setattr(self, 'activity_stream_mode', activity_stream_mode)
            __dataclass__object_setattr(self, 'activity_stream_engine_native_audit_fields_included', activity_stream_engine_native_audit_fields_included)
            __dataclass__object_setattr(self, 'aws_backup_recovery_point_arn', aws_backup_recovery_point_arn)
            __dataclass__object_setattr(self, 'db_instance_automated_backups_replications', db_instance_automated_backups_replications)
            __dataclass__object_setattr(self, 'backup_target', backup_target)
            __dataclass__object_setattr(self, 'automatic_restart_time', automatic_restart_time)
            __dataclass__object_setattr(self, 'custom_iam_instance_profile', custom_iam_instance_profile)
            __dataclass__object_setattr(self, 'activity_stream_policy_status', activity_stream_policy_status)
            __dataclass__object_setattr(self, 'certificate_details', certificate_details)
            __dataclass__object_setattr(self, 'db_system_id', db_system_id)
            __dataclass__object_setattr(self, 'master_user_secret', master_user_secret)
            __dataclass__object_setattr(self, 'read_replica_source_db_cluster_identifier', read_replica_source_db_cluster_identifier)
            __dataclass__object_setattr(self, 'percent_progress', percent_progress)
            __dataclass__object_setattr(self, 'multi_tenant', multi_tenant)
            __dataclass__object_setattr(self, 'dedicated_log_volume', dedicated_log_volume)
            __dataclass__object_setattr(self, 'is_storage_config_upgrade_available', is_storage_config_upgrade_available)
            __dataclass__object_setattr(self, 'engine_lifecycle_support', engine_lifecycle_support)
            __dataclass__object_setattr(self, 'additional_storage_volumes', additional_storage_volumes)
            __dataclass__object_setattr(self, 'storage_volume_status', storage_volume_status)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"db_instance_identifier={self.db_instance_identifier!r}")
            parts.append(f"db_instance_class={self.db_instance_class!r}")
            parts.append(f"engine={self.engine!r}")
            parts.append(f"db_instance_status={self.db_instance_status!r}")
            parts.append(f"master_username={self.master_username!r}")
            parts.append(f"db_name={self.db_name!r}")
            parts.append(f"endpoint={self.endpoint!r}")
            parts.append(f"allocated_storage={self.allocated_storage!r}")
            parts.append(f"instance_create_time={self.instance_create_time!r}")
            parts.append(f"preferred_backup_window={self.preferred_backup_window!r}")
            parts.append(f"backup_retention_period={self.backup_retention_period!r}")
            parts.append(f"db_security_groups={self.db_security_groups!r}")
            parts.append(f"vpc_security_groups={self.vpc_security_groups!r}")
            parts.append(f"db_parameter_groups={self.db_parameter_groups!r}")
            parts.append(f"availability_zone={self.availability_zone!r}")
            parts.append(f"db_subnet_group={self.db_subnet_group!r}")
            parts.append(f"preferred_maintenance_window={self.preferred_maintenance_window!r}")
            parts.append(f"upgrade_rollout_order={self.upgrade_rollout_order!r}")
            parts.append(f"pending_modified_values={self.pending_modified_values!r}")
            parts.append(f"latest_restorable_time={self.latest_restorable_time!r}")
            parts.append(f"multi_az={self.multi_az!r}")
            parts.append(f"engine_version={self.engine_version!r}")
            parts.append(f"auto_minor_version_upgrade={self.auto_minor_version_upgrade!r}")
            parts.append(f"read_replica_source_db_instance_identifier={self.read_replica_source_db_instance_identifier!r}")
            parts.append(f"read_replica_db_instance_identifiers={self.read_replica_db_instance_identifiers!r}")
            parts.append(f"read_replica_db_cluster_identifiers={self.read_replica_db_cluster_identifiers!r}")
            parts.append(f"replica_mode={self.replica_mode!r}")
            parts.append(f"license_model={self.license_model!r}")
            parts.append(f"iops={self.iops!r}")
            parts.append(f"storage_throughput={self.storage_throughput!r}")
            parts.append(f"option_group_memberships={self.option_group_memberships!r}")
            parts.append(f"character_set_name={self.character_set_name!r}")
            parts.append(f"nchar_character_set_name={self.nchar_character_set_name!r}")
            parts.append(f"secondary_availability_zone={self.secondary_availability_zone!r}")
            parts.append(f"publicly_accessible={self.publicly_accessible!r}")
            parts.append(f"status_infos={self.status_infos!r}")
            parts.append(f"storage_type={self.storage_type!r}")
            parts.append(f"tde_credential_arn={self.tde_credential_arn!r}")
            parts.append(f"db_instance_port={self.db_instance_port!r}")
            parts.append(f"db_cluster_identifier={self.db_cluster_identifier!r}")
            parts.append(f"storage_encrypted={self.storage_encrypted!r}")
            parts.append(f"kms_key_id={self.kms_key_id!r}")
            parts.append(f"dbi_resource_id={self.dbi_resource_id!r}")
            parts.append(f"ca_certificate_identifier={self.ca_certificate_identifier!r}")
            parts.append(f"domain_memberships={self.domain_memberships!r}")
            parts.append(f"copy_tags_to_snapshot={self.copy_tags_to_snapshot!r}")
            parts.append(f"monitoring_interval={self.monitoring_interval!r}")
            parts.append(f"enhanced_monitoring_resource_arn={self.enhanced_monitoring_resource_arn!r}")
            parts.append(f"monitoring_role_arn={self.monitoring_role_arn!r}")
            parts.append(f"promotion_tier={self.promotion_tier!r}")
            parts.append(f"db_instance_arn={self.db_instance_arn!r}")
            parts.append(f"timezone={self.timezone!r}")
            parts.append(f"iam_database_authentication_enabled={self.iam_database_authentication_enabled!r}")
            parts.append(f"database_insights_mode={self.database_insights_mode!r}")
            parts.append(f"performance_insights_enabled={self.performance_insights_enabled!r}")
            parts.append(f"performance_insights_kms_key_id={self.performance_insights_kms_key_id!r}")
            parts.append(f"performance_insights_retention_period={self.performance_insights_retention_period!r}")
            parts.append(f"enabled_cloudwatch_logs_exports={self.enabled_cloudwatch_logs_exports!r}")
            parts.append(f"processor_features={self.processor_features!r}")
            parts.append(f"deletion_protection={self.deletion_protection!r}")
            parts.append(f"associated_roles={self.associated_roles!r}")
            parts.append(f"listener_endpoint={self.listener_endpoint!r}")
            parts.append(f"max_allocated_storage={self.max_allocated_storage!r}")
            parts.append(f"tag_list={self.tag_list!r}")
            parts.append(f"automation_mode={self.automation_mode!r}")
            parts.append(f"resume_full_automation_mode_time={self.resume_full_automation_mode_time!r}")
            parts.append(f"customer_owned_ip_enabled={self.customer_owned_ip_enabled!r}")
            parts.append(f"network_type={self.network_type!r}")
            parts.append(f"activity_stream_status={self.activity_stream_status!r}")
            parts.append(f"activity_stream_kms_key_id={self.activity_stream_kms_key_id!r}")
            parts.append(f"activity_stream_kinesis_stream_name={self.activity_stream_kinesis_stream_name!r}")
            parts.append(f"activity_stream_mode={self.activity_stream_mode!r}")
            parts.append(f"activity_stream_engine_native_audit_fields_included={self.activity_stream_engine_native_audit_fields_included!r}")
            parts.append(f"aws_backup_recovery_point_arn={self.aws_backup_recovery_point_arn!r}")
            parts.append(f"db_instance_automated_backups_replications={self.db_instance_automated_backups_replications!r}")
            parts.append(f"backup_target={self.backup_target!r}")
            parts.append(f"automatic_restart_time={self.automatic_restart_time!r}")
            parts.append(f"custom_iam_instance_profile={self.custom_iam_instance_profile!r}")
            parts.append(f"activity_stream_policy_status={self.activity_stream_policy_status!r}")
            parts.append(f"certificate_details={self.certificate_details!r}")
            parts.append(f"db_system_id={self.db_system_id!r}")
            parts.append(f"master_user_secret={self.master_user_secret!r}")
            parts.append(f"read_replica_source_db_cluster_identifier={self.read_replica_source_db_cluster_identifier!r}")
            parts.append(f"percent_progress={self.percent_progress!r}")
            parts.append(f"multi_tenant={self.multi_tenant!r}")
            parts.append(f"dedicated_log_volume={self.dedicated_log_volume!r}")
            parts.append(f"is_storage_config_upgrade_available={self.is_storage_config_upgrade_available!r}")
            parts.append(f"engine_lifecycle_support={self.engine_lifecycle_support!r}")
            parts.append(f"additional_storage_volumes={self.additional_storage_volumes!r}")
            parts.append(f"storage_volume_status={self.storage_volume_status!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('e',)), EqPlan(fields=('e',)), FrozenPlan(fields=('e',), allow_dynamic_dunder_attr"
        "s=False), HashPlan(action='add', fields=('e',), cache=False), InitPlan(fields=(InitPlan.Field(name='e', annota"
        "tion=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('e"
        "',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPl"
        "an(fields=(ReprPlan.Field(name='e', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='09d620230085f2ec30d46bc47d392ca3f53879f5',
    op_ref_idents=(
        '__dataclass__init__fields__0__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'ListValueType'),
    ),
)
def _process_dataclass__09d620230085f2ec30d46bc47d392ca3f53879f5():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__0__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                e=self.e,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.e == other.e
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            'e',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            'e',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.e,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            e: __dataclass__init__fields__0__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'e', e)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"e={self.e!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('name', 'creation_date', 'bucket_region', 'bucket_arn')), EqPlan(fields=('name', '"
        "creation_date', 'bucket_region', 'bucket_arn')), FrozenPlan(fields=('__shape__', 'name', 'creation_date', 'buc"
        "ket_region', 'bucket_arn'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'creatio"
        "n_date', 'bucket_region', 'bucket_arn'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annot"
        "ation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annot"
        "ation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='creation_date', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init."
        "fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
        "e, validate=None, check_type=None), InitPlan.Field(name='bucket_region', annotation=OpRef(name='init.fields.3."
        "annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='bucket_arn', a"
        "nnotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory"
        "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None))"
        ", self_param='self', std_params=(), kw_only_params=('name', 'creation_date', 'bucket_region', 'bucket_arn'), f"
        "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field"
        "(name='name', kw_only=True, fn=None), ReprPlan.Field(name='creation_date', kw_only=True, fn=None), ReprPlan.Fi"
        "eld(name='bucket_region', kw_only=True, fn=None), ReprPlan.Field(name='bucket_arn', kw_only=True, fn=None)), i"
        "d=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='0ba4959af046e5f753c22c868059f5fc7bb853f8',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.s3', 'Bucket'),
    ),
)
def _process_dataclass__0ba4959af046e5f753c22c868059f5fc7bb853f8():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                name=self.name,
                creation_date=self.creation_date,
                bucket_region=self.bucket_region,
                bucket_arn=self.bucket_arn,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.name == other.name and
                self.creation_date == other.creation_date and
                self.bucket_region == other.bucket_region and
                self.bucket_arn == other.bucket_arn
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'name',
            'creation_date',
            'bucket_region',
            'bucket_arn',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'name',
            'creation_date',
            'bucket_region',
            'bucket_arn',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.name,
                self.creation_date,
                self.bucket_region,
                self.bucket_arn,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            creation_date: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            bucket_region: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            bucket_arn: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'name', name)
            __dataclass__object_setattr(self, 'creation_date', creation_date)
            __dataclass__object_setattr(self, 'bucket_region', bucket_region)
            __dataclass__object_setattr(self, 'bucket_arn', bucket_arn)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"name={self.name!r}")
            parts.append(f"creation_date={self.creation_date!r}")
            parts.append(f"bucket_region={self.bucket_region!r}")
            parts.append(f"bucket_arn={self.bucket_arn!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('size_in_gb', 'count', 'type')), EqPlan(fields=('size_in_gb', 'count', 'type')), F"
        "rozenPlan(fields=('__shape__', 'size_in_gb', 'count', 'type'), allow_dynamic_dunder_attrs=False), HashPlan(act"
        "ion='add', fields=('size_in_gb', 'count', 'type'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape"
        "__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='si"
        "ze_in_gb', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), def"
        "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
        "_type=None), InitPlan.Field(name='count', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(nam"
        "e='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.3.a"
        "nnotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), k"
        "w_only_params=('size_in_gb', 'count', 'type'), frozen=True, slots=False, post_init_params=None, init_fns=(), v"
        "alidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='size_in_gb', kw_only=True, fn=None), ReprPlan.Field(nam"
        "e='count', kw_only=True, fn=None), ReprPlan.Field(name='type', kw_only=True, fn=None)), id=False, terse=False,"
        " default_fn=None)))"
    ),
    plan_repr_sha1='0e4d14f08b2bf721ea85332e6840f6f9f2badb03',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DiskInfo'),
    ),
)
def _process_dataclass__0e4d14f08b2bf721ea85332e6840f6f9f2badb03():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                size_in_gb=self.size_in_gb,
                count=self.count,
                type=self.type,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.size_in_gb == other.size_in_gb and
                self.count == other.count and
                self.type == other.type
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'size_in_gb',
            'count',
            'type',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'size_in_gb',
            'count',
            'type',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.size_in_gb,
                self.count,
                self.type,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            size_in_gb: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            count: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            type: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'size_in_gb', size_in_gb)
            __dataclass__object_setattr(self, 'count', count)
            __dataclass__object_setattr(self, 'type', type)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"size_in_gb={self.size_in_gb!r}")
            parts.append(f"count={self.count!r}")
            parts.append(f"type={self.type!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('description', 'user_id', 'group_name', 'group_id', 'vpc_id', 'vpc_peering_connect"
        "ion_id', 'peering_status')), EqPlan(fields=('description', 'user_id', 'group_name', 'group_id', 'vpc_id', 'vpc"
        "_peering_connection_id', 'peering_status')), FrozenPlan(fields=('__shape__', 'description', 'user_id', 'group_"
        "name', 'group_id', 'vpc_id', 'vpc_peering_connection_id', 'peering_status'), allow_dynamic_dunder_attrs=False)"
        ", HashPlan(action='add', fields=('description', 'user_id', 'group_name', 'group_id', 'vpc_id', 'vpc_peering_co"
        "nnection_id', 'peering_status'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=Op"
        "Ref(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='description', annota"
        "tion=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='user_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields."
        "2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='group_name', annotation=OpRef(name='init.fields.3.annotation"
        "'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=F"
        "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_id', annotation=Op"
        "Ref(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init="
        "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
        "eld(name='vpc_id', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='vpc_peering_connection_id', annotation=OpRef(name='init.fields.6.ann"
        "otation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='peering_status', "
        "annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        "), self_param='self', std_params=(), kw_only_params=('description', 'user_id', 'group_name', 'group_id', 'vpc_"
        "id', 'vpc_peering_connection_id', 'peering_status'), frozen=True, slots=False, post_init_params=None, init_fns"
        "=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='description', kw_only=True, fn=None), ReprPlan.Fi"
        "eld(name='user_id', kw_only=True, fn=None), ReprPlan.Field(name='group_name', kw_only=True, fn=None), ReprPlan"
        ".Field(name='group_id', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPlan"
        ".Field(name='vpc_peering_connection_id', kw_only=True, fn=None), ReprPlan.Field(name='peering_status', kw_only"
        "=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='1345d9c80c309896fbf85a8241c28bcc211432e6',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'UserIdGroupPair'),
    ),
)
def _process_dataclass__1345d9c80c309896fbf85a8241c28bcc211432e6():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                description=self.description,
                user_id=self.user_id,
                group_name=self.group_name,
                group_id=self.group_id,
                vpc_id=self.vpc_id,
                vpc_peering_connection_id=self.vpc_peering_connection_id,
                peering_status=self.peering_status,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.description == other.description and
                self.user_id == other.user_id and
                self.group_name == other.group_name and
                self.group_id == other.group_id and
                self.vpc_id == other.vpc_id and
                self.vpc_peering_connection_id == other.vpc_peering_connection_id and
                self.peering_status == other.peering_status
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'description',
            'user_id',
            'group_name',
            'group_id',
            'vpc_id',
            'vpc_peering_connection_id',
            'peering_status',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'description',
            'user_id',
            'group_name',
            'group_id',
            'vpc_id',
            'vpc_peering_connection_id',
            'peering_status',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.description,
                self.user_id,
                self.group_name,
                self.group_id,
                self.vpc_id,
                self.vpc_peering_connection_id,
                self.peering_status,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            description: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            user_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            group_name: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            group_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            vpc_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            vpc_peering_connection_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            peering_status: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'user_id', user_id)
            __dataclass__object_setattr(self, 'group_name', group_name)
            __dataclass__object_setattr(self, 'group_id', group_id)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'vpc_peering_connection_id', vpc_peering_connection_id)
            __dataclass__object_setattr(self, 'peering_status', peering_status)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"description={self.description!r}")
            parts.append(f"user_id={self.user_id!r}")
            parts.append(f"group_name={self.group_name!r}")
            parts.append(f"group_id={self.group_id!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"vpc_peering_connection_id={self.vpc_peering_connection_id!r}")
            parts.append(f"peering_status={self.peering_status!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('delete_on_termination', 'iops', 'snapshot_id', 'volume_size', 'volume_type', 'kms"
        "_key_id', 'throughput', 'outpost_arn', 'availability_zone', 'encrypted', 'volume_initialization_rate', 'availa"
        "bility_zone_id')), EqPlan(fields=('delete_on_termination', 'iops', 'snapshot_id', 'volume_size', 'volume_type'"
        ", 'kms_key_id', 'throughput', 'outpost_arn', 'availability_zone', 'encrypted', 'volume_initialization_rate', '"
        "availability_zone_id')), FrozenPlan(fields=('__shape__', 'delete_on_termination', 'iops', 'snapshot_id', 'volu"
        "me_size', 'volume_type', 'kms_key_id', 'throughput', 'outpost_arn', 'availability_zone', 'encrypted', 'volume_"
        "initialization_rate', 'availability_zone_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', field"
        "s=('delete_on_termination', 'iops', 'snapshot_id', 'volume_size', 'volume_type', 'kms_key_id', 'throughput', '"
        "outpost_arn', 'availability_zone', 'encrypted', 'volume_initialization_rate', 'availability_zone_id'), cache=F"
        "alse), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), de"
        "fault=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='delete_on_termination', annotation=OpRef(name='init.fields.1"
        ".annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='iops', annota"
        "tion=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='snapshot_id', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fie"
        "lds.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='volume_size', annotation=OpRef(name='init.fields.4.annot"
        "ation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='volume_type', annot"
        "ation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='kms_key_id', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fie"
        "lds.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='throughput', annotation=OpRef(name='init.fields.7.annota"
        "tion'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='outpost_arn', annota"
        "tion=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='availability_zone', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='in"
        "it.fields.9.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='encrypted', annotation=OpRef(name='init.fields.10."
        "annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='volume_initia"
        "lization_rate', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default"
        "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
        ", check_type=None), InitPlan.Field(name='availability_zone_id', annotation=OpRef(name='init.fields.12.annotati"
        "on'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only"
        "_params=('delete_on_termination', 'iops', 'snapshot_id', 'volume_size', 'volume_type', 'kms_key_id', 'throughp"
        "ut', 'outpost_arn', 'availability_zone', 'encrypted', 'volume_initialization_rate', 'availability_zone_id'), f"
        "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field"
        "(name='delete_on_termination', kw_only=True, fn=None), ReprPlan.Field(name='iops', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='snapshot_id', kw_only=True, fn=None), ReprPlan.Field(name='volume_size', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='volume_type', kw_only=True, fn=None), ReprPlan.Field(name='kms_key_id', kw_only=True"
        ", fn=None), ReprPlan.Field(name='throughput', kw_only=True, fn=None), ReprPlan.Field(name='outpost_arn', kw_on"
        "ly=True, fn=None), ReprPlan.Field(name='availability_zone', kw_only=True, fn=None), ReprPlan.Field(name='encry"
        "pted', kw_only=True, fn=None), ReprPlan.Field(name='volume_initialization_rate', kw_only=True, fn=None), ReprP"
        "lan.Field(name='availability_zone_id', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='16c0b384718e3d82c8fe94582190fd670ad7af6e',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'EbsBlockDevice'),
    ),
)
def _process_dataclass__16c0b384718e3d82c8fe94582190fd670ad7af6e():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                delete_on_termination=self.delete_on_termination,
                iops=self.iops,
                snapshot_id=self.snapshot_id,
                volume_size=self.volume_size,
                volume_type=self.volume_type,
                kms_key_id=self.kms_key_id,
                throughput=self.throughput,
                outpost_arn=self.outpost_arn,
                availability_zone=self.availability_zone,
                encrypted=self.encrypted,
                volume_initialization_rate=self.volume_initialization_rate,
                availability_zone_id=self.availability_zone_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.delete_on_termination == other.delete_on_termination and
                self.iops == other.iops and
                self.snapshot_id == other.snapshot_id and
                self.volume_size == other.volume_size and
                self.volume_type == other.volume_type and
                self.kms_key_id == other.kms_key_id and
                self.throughput == other.throughput and
                self.outpost_arn == other.outpost_arn and
                self.availability_zone == other.availability_zone and
                self.encrypted == other.encrypted and
                self.volume_initialization_rate == other.volume_initialization_rate and
                self.availability_zone_id == other.availability_zone_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'delete_on_termination',
            'iops',
            'snapshot_id',
            'volume_size',
            'volume_type',
            'kms_key_id',
            'throughput',
            'outpost_arn',
            'availability_zone',
            'encrypted',
            'volume_initialization_rate',
            'availability_zone_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'delete_on_termination',
            'iops',
            'snapshot_id',
            'volume_size',
            'volume_type',
            'kms_key_id',
            'throughput',
            'outpost_arn',
            'availability_zone',
            'encrypted',
            'volume_initialization_rate',
            'availability_zone_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.delete_on_termination,
                self.iops,
                self.snapshot_id,
                self.volume_size,
                self.volume_type,
                self.kms_key_id,
                self.throughput,
                self.outpost_arn,
                self.availability_zone,
                self.encrypted,
                self.volume_initialization_rate,
                self.availability_zone_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            delete_on_termination: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            iops: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            snapshot_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            volume_size: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            volume_type: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            kms_key_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            throughput: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            outpost_arn: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            availability_zone: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            encrypted: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            volume_initialization_rate: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            availability_zone_id: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'delete_on_termination', delete_on_termination)
            __dataclass__object_setattr(self, 'iops', iops)
            __dataclass__object_setattr(self, 'snapshot_id', snapshot_id)
            __dataclass__object_setattr(self, 'volume_size', volume_size)
            __dataclass__object_setattr(self, 'volume_type', volume_type)
            __dataclass__object_setattr(self, 'kms_key_id', kms_key_id)
            __dataclass__object_setattr(self, 'throughput', throughput)
            __dataclass__object_setattr(self, 'outpost_arn', outpost_arn)
            __dataclass__object_setattr(self, 'availability_zone', availability_zone)
            __dataclass__object_setattr(self, 'encrypted', encrypted)
            __dataclass__object_setattr(self, 'volume_initialization_rate', volume_initialization_rate)
            __dataclass__object_setattr(self, 'availability_zone_id', availability_zone_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"delete_on_termination={self.delete_on_termination!r}")
            parts.append(f"iops={self.iops!r}")
            parts.append(f"snapshot_id={self.snapshot_id!r}")
            parts.append(f"volume_size={self.volume_size!r}")
            parts.append(f"volume_type={self.volume_type!r}")
            parts.append(f"kms_key_id={self.kms_key_id!r}")
            parts.append(f"throughput={self.throughput!r}")
            parts.append(f"outpost_arn={self.outpost_arn!r}")
            parts.append(f"availability_zone={self.availability_zone!r}")
            parts.append(f"encrypted={self.encrypted!r}")
            parts.append(f"volume_initialization_rate={self.volume_initialization_rate!r}")
            parts.append(f"availability_zone_id={self.availability_zone_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('accelerators', 'total_media_memory_in_mi_b')), EqPlan(fields=('accelerators', 'to"
        "tal_media_memory_in_mi_b')), FrozenPlan(fields=('__shape__', 'accelerators', 'total_media_memory_in_mi_b'), al"
        "low_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('accelerators', 'total_media_memory_in_mi_b'),"
        " cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotati"
        "on'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='accelerators', annotation=OpRef(name='init.fields.1."
        "annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='total_media_me"
        "mory_in_mi_b', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None)), self_param='self', std_params=(), kw_only_params=('accelerators', 'total_media_memory_in_mi_"
        "b'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan"
        ".Field(name='accelerators', kw_only=True, fn=None), ReprPlan.Field(name='total_media_memory_in_mi_b', kw_only="
        "True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='1816aa36f8e31af294f8bb11e610a1475b85c07d',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'MediaAcceleratorInfo'),
    ),
)
def _process_dataclass__1816aa36f8e31af294f8bb11e610a1475b85c07d():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                accelerators=self.accelerators,
                total_media_memory_in_mi_b=self.total_media_memory_in_mi_b,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.accelerators == other.accelerators and
                self.total_media_memory_in_mi_b == other.total_media_memory_in_mi_b
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'accelerators',
            'total_media_memory_in_mi_b',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'accelerators',
            'total_media_memory_in_mi_b',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.accelerators,
                self.total_media_memory_in_mi_b,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            accelerators: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            total_media_memory_in_mi_b: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'accelerators', accelerators)
            __dataclass__object_setattr(self, 'total_media_memory_in_mi_b', total_media_memory_in_mi_b)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"accelerators={self.accelerators!r}")
            parts.append(f"total_media_memory_in_mi_b={self.total_media_memory_in_mi_b!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('description', 'prefix_list_id')), EqPlan(fields=('description', 'prefix_list_id')"
        "), FrozenPlan(fields=('__shape__', 'description', 'prefix_list_id'), allow_dynamic_dunder_attrs=False), HashPl"
        "an(action='add', fields=('description', 'prefix_list_id'), cache=False), InitPlan(fields=(InitPlan.Field(name="
        "'__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True,"
        " override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='description', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='prefix_list_id', annotation=OpRef(name='init.fields.2.annotation'),"
        " default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_param"
        "s=('description', 'prefix_list_id'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fn"
        "s=()), ReprPlan(fields=(ReprPlan.Field(name='description', kw_only=True, fn=None), ReprPlan.Field(name='prefix"
        "_list_id', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='18d3544ece736395e2893d219c6c8cb4ef26e598',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'PrefixListId'),
    ),
)
def _process_dataclass__18d3544ece736395e2893d219c6c8cb4ef26e598():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                description=self.description,
                prefix_list_id=self.prefix_list_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.description == other.description and
                self.prefix_list_id == other.prefix_list_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'description',
            'prefix_list_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'description',
            'prefix_list_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.description,
                self.prefix_list_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            description: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            prefix_list_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'prefix_list_id', prefix_list_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"description={self.description!r}")
            parts.append(f"prefix_list_id={self.prefix_list_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('instance_ids', 'dry_run', 'filters', 'next_token', 'max_results')), EqPlan(fields"
        "=('instance_ids', 'dry_run', 'filters', 'next_token', 'max_results')), FrozenPlan(fields=('__shape__', 'instan"
        "ce_ids', 'dry_run', 'filters', 'next_token', 'max_results'), allow_dynamic_dunder_attrs=False), HashPlan(actio"
        "n='add', fields=('instance_ids', 'dry_run', 'filters', 'next_token', 'max_results'), cache=False), InitPlan(fi"
        "elds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, defaul"
        "t_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_t"
        "ype=None), InitPlan.Field(name='instance_ids', annotation=OpRef(name='init.fields.1.annotation'), default=OpRe"
        "f(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
        "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fi"
        "elds.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='filters"
        "', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='"
        "init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
        "e=None, validate=None, check_type=None), InitPlan.Field(name='max_results', annotation=OpRef(name='init.fields"
        ".5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=("
        "), kw_only_params=('instance_ids', 'dry_run', 'filters', 'next_token', 'max_results'), frozen=True, slots=Fals"
        "e, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='instance_ids', "
        "kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='filters', "
        "kw_only=True, fn=None), ReprPlan.Field(name='next_token', kw_only=True, fn=None), ReprPlan.Field(name='max_res"
        "ults', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='19c58eb9baa56cb23a597ed75f00bf082871babf',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeInstancesRequest'),
    ),
)
def _process_dataclass__19c58eb9baa56cb23a597ed75f00bf082871babf():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                instance_ids=self.instance_ids,
                dry_run=self.dry_run,
                filters=self.filters,
                next_token=self.next_token,
                max_results=self.max_results,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.instance_ids == other.instance_ids and
                self.dry_run == other.dry_run and
                self.filters == other.filters and
                self.next_token == other.next_token and
                self.max_results == other.max_results
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'dry_run',
            'filters',
            'next_token',
            'max_results',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'dry_run',
            'filters',
            'next_token',
            'max_results',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.instance_ids,
                self.dry_run,
                self.filters,
                self.next_token,
                self.max_results,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            instance_ids: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            dry_run: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            filters: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            next_token: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            max_results: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'instance_ids', instance_ids)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'filters', filters)
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'max_results', max_results)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"instance_ids={self.instance_ids!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"filters={self.filters!r}")
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"max_results={self.max_results!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('db_instance_identifier', 'db_snapshot_identifier')), EqPlan(fields=('db_instance_"
        "identifier', 'db_snapshot_identifier')), FrozenPlan(fields=('__shape__', 'db_instance_identifier', 'db_snapsho"
        "t_identifier'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('db_instance_identifier', 'd"
        "b_snapshot_identifier'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name"
        "='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_instance_identifier', ann"
        "otation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_snapshot"
        "_identifier', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), "
        "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
        "eck_type=None)), self_param='self', std_params=(), kw_only_params=('db_instance_identifier', 'db_snapshot_iden"
        "tifier'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Rep"
        "rPlan.Field(name='db_instance_identifier', kw_only=True, fn=None), ReprPlan.Field(name='db_snapshot_identifier"
        "', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='1bdfa49bf8aca9326c28bc8eb43f474569ed2369',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'StopDBInstanceMessage'),
    ),
)
def _process_dataclass__1bdfa49bf8aca9326c28bc8eb43f474569ed2369():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                db_instance_identifier=self.db_instance_identifier,
                db_snapshot_identifier=self.db_snapshot_identifier,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.db_instance_identifier == other.db_instance_identifier and
                self.db_snapshot_identifier == other.db_snapshot_identifier
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'db_instance_identifier',
            'db_snapshot_identifier',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'db_instance_identifier',
            'db_snapshot_identifier',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.db_instance_identifier,
                self.db_snapshot_identifier,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            db_instance_identifier: __dataclass__init__fields__1__annotation,
            db_snapshot_identifier: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'db_instance_identifier', db_instance_identifier)
            __dataclass__object_setattr(self, 'db_snapshot_identifier', db_snapshot_identifier)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"db_instance_identifier={self.db_instance_identifier!r}")
            parts.append(f"db_snapshot_identifier={self.db_snapshot_identifier!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('error_code', 'message')), EqPlan(fields=('error_code', 'message')), FrozenPlan(fi"
        "elds=('__shape__', 'error_code', 'message'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields="
        "('error_code', 'message'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(na"
        "me='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='error_code', annotation=Op"
        "Ref(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init="
        "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
        "eld(name='message', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None)), self_param='self', std_params=(), kw_only_params=('error_code', 'message'), frozen=True"
        ", slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='err"
        "or_code', kw_only=True, fn=None), ReprPlan.Field(name='message', kw_only=True, fn=None)), id=False, terse=Fals"
        "e, default_fn=None)))"
    ),
    plan_repr_sha1='1d985e02ba3b7e1901dfcdb20eb2f1da1c066cf3',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'EnvironmentError_'),
        ('ominfra.clouds.aws.models.services.lambda_', 'ImageConfigError'),
        ('ominfra.clouds.aws.models.services.lambda_', 'RuntimeVersionError'),
    ),
)
def _process_dataclass__1d985e02ba3b7e1901dfcdb20eb2f1da1c066cf3():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                error_code=self.error_code,
                message=self.message,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.error_code == other.error_code and
                self.message == other.message
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'error_code',
            'message',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'error_code',
            'message',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.error_code,
                self.message,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            error_code: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'error_code', error_code)
            __dataclass__object_setattr(self, 'message', message)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"error_code={self.error_code!r}")
            parts.append(f"message={self.message!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('key_names', 'key_pair_ids', 'include_public_key', 'dry_run', 'filters')), EqPlan("
        "fields=('key_names', 'key_pair_ids', 'include_public_key', 'dry_run', 'filters')), FrozenPlan(fields=('__shape"
        "__', 'key_names', 'key_pair_ids', 'include_public_key', 'dry_run', 'filters'), allow_dynamic_dunder_attrs=Fals"
        "e), HashPlan(action='add', fields=('key_names', 'key_pair_ids', 'include_public_key', 'dry_run', 'filters'), c"
        "ache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation"
        "'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='key_names', annotation=OpRef(name='init.fields.1.annot"
        "ation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='key_pair_ids', anno"
        "tation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='include_public_key', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name="
        "'init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.4."
        "annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='filters', anno"
        "tation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), s"
        "elf_param='self', std_params=(), kw_only_params=('key_names', 'key_pair_ids', 'include_public_key', 'dry_run',"
        " 'filters'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=("
        "ReprPlan.Field(name='key_names', kw_only=True, fn=None), ReprPlan.Field(name='key_pair_ids', kw_only=True, fn="
        "None), ReprPlan.Field(name='include_public_key', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_onl"
        "y=True, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn=None)), id=False, terse=False, default_fn=No"
        "ne)))"
    ),
    plan_repr_sha1='1fd36fa9dc2507c1276ccc642c36fd762eb7e331',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeKeyPairsRequest'),
    ),
)
def _process_dataclass__1fd36fa9dc2507c1276ccc642c36fd762eb7e331():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                key_names=self.key_names,
                key_pair_ids=self.key_pair_ids,
                include_public_key=self.include_public_key,
                dry_run=self.dry_run,
                filters=self.filters,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.key_names == other.key_names and
                self.key_pair_ids == other.key_pair_ids and
                self.include_public_key == other.include_public_key and
                self.dry_run == other.dry_run and
                self.filters == other.filters
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'key_names',
            'key_pair_ids',
            'include_public_key',
            'dry_run',
            'filters',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'key_names',
            'key_pair_ids',
            'include_public_key',
            'dry_run',
            'filters',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.key_names,
                self.key_pair_ids,
                self.include_public_key,
                self.dry_run,
                self.filters,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            key_names: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            key_pair_ids: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            include_public_key: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            dry_run: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            filters: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'key_names', key_names)
            __dataclass__object_setattr(self, 'key_pair_ids', key_pair_ids)
            __dataclass__object_setattr(self, 'include_public_key', include_public_key)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'filters', filters)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"key_names={self.key_names!r}")
            parts.append(f"key_pair_ids={self.key_pair_ids!r}")
            parts.append(f"include_public_key={self.include_public_key!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"filters={self.filters!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('db_instance_identifier',)), EqPlan(fields=('db_instance_identifier',)), FrozenPla"
        "n(fields=('__shape__', 'db_instance_identifier'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fi"
        "elds=('db_instance_identifier',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=O"
        "pRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_instance_identif"
        "ier', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std"
        "_params=(), kw_only_params=('db_instance_identifier',), frozen=True, slots=False, post_init_params=None, init_"
        "fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db_instance_identifier', kw_only=True, fn=None"
        "),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='2034c55d12ea687458603a4a24687aa6cff4ce7a',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'StartDBInstanceMessage'),
    ),
)
def _process_dataclass__2034c55d12ea687458603a4a24687aa6cff4ce7a():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                db_instance_identifier=self.db_instance_identifier,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.db_instance_identifier == other.db_instance_identifier
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'db_instance_identifier',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'db_instance_identifier',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.db_instance_identifier,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            db_instance_identifier: __dataclass__init__fields__1__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'db_instance_identifier', db_instance_identifier)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"db_instance_identifier={self.db_instance_identifier!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('device_name', 'ebs')), EqPlan(fields=('device_name', 'ebs')), FrozenPlan(fields=("
        "'__shape__', 'device_name', 'ebs'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('device_"
        "name', 'ebs'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fie"
        "lds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_"
        "VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='device_name', annotation=OpRef(name='i"
        "nit.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='e"
        "bs', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None)), self_param='self', std_params=(), kw_only_params=('device_name', 'ebs'), frozen=True, slots=False, pos"
        "t_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='device_name', kw_only"
        "=True, fn=None), ReprPlan.Field(name='ebs', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='242f4d6904080879b4d8ec0ef8f3b5f67e9fedcd',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceBlockDeviceMapping'),
    ),
)
def _process_dataclass__242f4d6904080879b4d8ec0ef8f3b5f67e9fedcd():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                device_name=self.device_name,
                ebs=self.ebs,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.device_name == other.device_name and
                self.ebs == other.ebs
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'device_name',
            'ebs',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'device_name',
            'ebs',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.device_name,
                self.ebs,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            device_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            ebs: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'device_name', device_name)
            __dataclass__object_setattr(self, 'ebs', ebs)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"device_name={self.device_name!r}")
            parts.append(f"ebs={self.ebs!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ipv6_address', 'public_ipv6_dns_name', 'is_primary_ipv6')), EqPlan(fields=('ipv6_"
        "address', 'public_ipv6_dns_name', 'is_primary_ipv6')), FrozenPlan(fields=('__shape__', 'ipv6_address', 'public"
        "_ipv6_dns_name', 'is_primary_ipv6'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ipv6_a"
        "ddress', 'public_ipv6_dns_name', 'is_primary_ipv6'), cache=False), InitPlan(fields=(InitPlan.Field(name='__sha"
        "pe__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "ipv6_address', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None), InitPlan.Field(name='public_ipv6_dns_name', annotation=OpRef(name='init.fields.2.annotation')"
        ", default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Fie"
        "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='is_primary_ipv6', annotati"
        "on=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_"
        "param='self', std_params=(), kw_only_params=('ipv6_address', 'public_ipv6_dns_name', 'is_primary_ipv6'), froze"
        "n=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
        "e='ipv6_address', kw_only=True, fn=None), ReprPlan.Field(name='public_ipv6_dns_name', kw_only=True, fn=None), "
        "ReprPlan.Field(name='is_primary_ipv6', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='24cdb7e6bf479781358d58f65e57cd2559550867',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NetworkInterfaceIpv6Address'),
    ),
)
def _process_dataclass__24cdb7e6bf479781358d58f65e57cd2559550867():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ipv6_address=self.ipv6_address,
                public_ipv6_dns_name=self.public_ipv6_dns_name,
                is_primary_ipv6=self.is_primary_ipv6,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ipv6_address == other.ipv6_address and
                self.public_ipv6_dns_name == other.public_ipv6_dns_name and
                self.is_primary_ipv6 == other.is_primary_ipv6
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ipv6_address',
            'public_ipv6_dns_name',
            'is_primary_ipv6',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ipv6_address',
            'public_ipv6_dns_name',
            'is_primary_ipv6',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ipv6_address,
                self.public_ipv6_dns_name,
                self.is_primary_ipv6,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ipv6_address: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            public_ipv6_dns_name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            is_primary_ipv6: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ipv6_address', ipv6_address)
            __dataclass__object_setattr(self, 'public_ipv6_dns_name', public_ipv6_dns_name)
            __dataclass__object_setattr(self, 'is_primary_ipv6', is_primary_ipv6)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ipv6_address={self.ipv6_address!r}")
            parts.append(f"public_ipv6_dns_name={self.public_ipv6_dns_name!r}")
            parts.append(f"is_primary_ipv6={self.is_primary_ipv6!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('internet_gateways', 'next_token')), EqPlan(fields=('internet_gateways', 'next_tok"
        "en')), FrozenPlan(fields=('__shape__', 'internet_gateways', 'next_token'), allow_dynamic_dunder_attrs=False), "
        "HashPlan(action='add', fields=('internet_gateways', 'next_token'), cache=False), InitPlan(fields=(InitPlan.Fie"
        "ld(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, in"
        "it=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='internet_gateways', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init."
        "fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
        "e, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.2.ann"
        "otation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_"
        "only_params=('internet_gateways', 'next_token'), frozen=True, slots=False, post_init_params=None, init_fns=(),"
        " validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='internet_gateways', kw_only=True, fn=None), ReprPlan."
        "Field(name='next_token', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='251cd990b64c55e68eb2b64e92e5badd57f6ae93',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeInternetGatewaysResult'),
    ),
)
def _process_dataclass__251cd990b64c55e68eb2b64e92e5badd57f6ae93():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                internet_gateways=self.internet_gateways,
                next_token=self.next_token,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.internet_gateways == other.internet_gateways and
                self.next_token == other.next_token
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'internet_gateways',
            'next_token',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'internet_gateways',
            'next_token',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.internet_gateways,
                self.next_token,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            internet_gateways: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            next_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'internet_gateways', internet_gateways)
            __dataclass__object_setattr(self, 'next_token', next_token)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"internet_gateways={self.internet_gateways!r}")
            parts.append(f"next_token={self.next_token!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('secret_arn', 'secret_status', 'kms_key_id')), EqPlan(fields=('secret_arn', 'secre"
        "t_status', 'kms_key_id')), FrozenPlan(fields=('__shape__', 'secret_arn', 'secret_status', 'kms_key_id'), allow"
        "_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('secret_arn', 'secret_status', 'kms_key_id'), cac"
        "he=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation')"
        ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='secret_arn', annotation=OpRef(name='init.fields.1.annota"
        "tion'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='secret_status', anno"
        "tation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='kms_key_id', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fi"
        "elds.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('secret_arn', 'secret_sta"
        "tus', 'kms_key_id'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan("
        "fields=(ReprPlan.Field(name='secret_arn', kw_only=True, fn=None), ReprPlan.Field(name='secret_status', kw_only"
        "=True, fn=None), ReprPlan.Field(name='kms_key_id', kw_only=True, fn=None)), id=False, terse=False, default_fn="
        "None)))"
    ),
    plan_repr_sha1='257988ac1433a45fc765065121e7c50a1887c0cd',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'MasterUserSecret'),
    ),
)
def _process_dataclass__257988ac1433a45fc765065121e7c50a1887c0cd():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                secret_arn=self.secret_arn,
                secret_status=self.secret_status,
                kms_key_id=self.kms_key_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.secret_arn == other.secret_arn and
                self.secret_status == other.secret_status and
                self.kms_key_id == other.kms_key_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'secret_arn',
            'secret_status',
            'kms_key_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'secret_arn',
            'secret_status',
            'kms_key_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.secret_arn,
                self.secret_status,
                self.kms_key_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            secret_arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            secret_status: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            kms_key_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'secret_arn', secret_arn)
            __dataclass__object_setattr(self, 'secret_status', secret_status)
            __dataclass__object_setattr(self, 'kms_key_id', kms_key_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"secret_arn={self.secret_arn!r}")
            parts.append(f"secret_status={self.secret_status!r}")
            parts.append(f"kms_key_id={self.kms_key_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('arn', 'id')), EqPlan(fields=('arn', 'id')), FrozenPlan(fields=('__shape__', 'arn'"
        ", 'id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('arn', 'id'), cache=False), InitPla"
        "n(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='arn', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(nam"
        "e='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='id', annotation=OpRef(name='init.fields.2.ann"
        "otation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_"
        "only_params=('arn', 'id'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Rep"
        "rPlan(fields=(ReprPlan.Field(name='arn', kw_only=True, fn=None), ReprPlan.Field(name='id', kw_only=True, fn=No"
        "ne)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='26074b459cb2fb0408156461ee64ccdb2fce7cad',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'IamInstanceProfile'),
    ),
)
def _process_dataclass__26074b459cb2fb0408156461ee64ccdb2fce7cad():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                arn=self.arn,
                id=self.id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.arn == other.arn and
                self.id == other.id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'arn',
            'id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'arn',
            'id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.arn,
                self.id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'arn', arn)
            __dataclass__object_setattr(self, 'id', id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"arn={self.arn!r}")
            parts.append(f"id={self.id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('principal',)), EqPlan(fields=('principal',)), FrozenPlan(fields=('__shape__', 'pr"
        "incipal'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('principal',), cache=False), Init"
        "Plan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None,"
        " default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='principal', annotation=OpRef(name='init.fields.1.annotation'), default="
        "OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('princ"
        "ipal',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Repr"
        "Plan.Field(name='principal', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='27b3607ff46bc04e13f6289e0a67ee2b47296301',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'OperatorRequest'),
    ),
)
def _process_dataclass__27b3607ff46bc04e13f6289e0a67ee2b47296301():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                principal=self.principal,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.principal == other.principal
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'principal',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'principal',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.principal,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            principal: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'principal', principal)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"principal={self.principal!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('name', 'input', 'output', 'errors')), FrozenPlan(fields=('name', 'input', 'output"
        "', 'errors'), allow_dynamic_dunder_attrs=False), InitPlan(fields=(InitPlan.Field(name='name', annotation=OpRef"
        "(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=F"
        "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='input', annotation=OpRef"
        "(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='output', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default')"
        ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='errors', annotation=OpRef(name='init.fields.3.annotation'), default=OpR"
        "ef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('name', '"
        "input', 'output', 'errors'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), R"
        "eprPlan(fields=(ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='input', kw_only=True,"
        " fn=None), ReprPlan.Field(name='output', kw_only=True, fn=None), ReprPlan.Field(name='errors', kw_only=True, f"
        "n=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='28e083342d85b6259c08f4deabe13615b48d50bd',
    op_ref_idents=(
        '__dataclass__init__fields__0__annotation',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Operation'),
    ),
)
def _process_dataclass__28e083342d85b6259c08f4deabe13615b48d50bd():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__0__annotation,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                name=self.name,
                input=self.input,
                output=self.output,
                errors=self.errors,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        __dataclass___setattr_frozen_fields = {
            'name',
            'input',
            'output',
            'errors',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            'name',
            'input',
            'output',
            'errors',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __init__(
            self,
            *,
            name: __dataclass__init__fields__0__annotation,
            input: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            output: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            errors: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'name', name)
            __dataclass__object_setattr(self, 'input', input)
            __dataclass__object_setattr(self, 'output', output)
            __dataclass__object_setattr(self, 'errors', errors)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"name={self.name!r}")
            parts.append(f"input={self.input!r}")
            parts.append(f"output={self.output!r}")
            parts.append(f"errors={self.errors!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('route_tables', 'next_token')), EqPlan(fields=('route_tables', 'next_token')), Fro"
        "zenPlan(fields=('__shape__', 'route_tables', 'next_token'), allow_dynamic_dunder_attrs=False), HashPlan(action"
        "='add', fields=('route_tables', 'next_token'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__',"
        " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='route_"
        "tables', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), defau"
        "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
        "ype=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef("
        "name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
        " coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('route_table"
        "s', 'next_token'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fi"
        "elds=(ReprPlan.Field(name='route_tables', kw_only=True, fn=None), ReprPlan.Field(name='next_token', kw_only=Tr"
        "ue, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='293e22721dacc741ea9c3a0f5dae702ad9468e87',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeRouteTablesResult'),
    ),
)
def _process_dataclass__293e22721dacc741ea9c3a0f5dae702ad9468e87():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                route_tables=self.route_tables,
                next_token=self.next_token,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.route_tables == other.route_tables and
                self.next_token == other.next_token
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'route_tables',
            'next_token',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'route_tables',
            'next_token',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.route_tables,
                self.next_token,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            route_tables: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            next_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'route_tables', route_tables)
            __dataclass__object_setattr(self, 'next_token', next_token)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"route_tables={self.route_tables!r}")
            parts.append(f"next_token={self.next_token!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('dry_run', 'instance_types', 'filters', 'max_results', 'next_token')), EqPlan(fiel"
        "ds=('dry_run', 'instance_types', 'filters', 'max_results', 'next_token')), FrozenPlan(fields=('__shape__', 'dr"
        "y_run', 'instance_types', 'filters', 'max_results', 'next_token'), allow_dynamic_dunder_attrs=False), HashPlan"
        "(action='add', fields=('dry_run', 'instance_types', 'filters', 'max_results', 'next_token'), cache=False), Ini"
        "tPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None"
        ", default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.1.annotation'), default=O"
        "pRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_types', annotation=OpRef(nam"
        "e='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='filters', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), d"
        "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='max_results', annotation=OpRef(name='init.fields.4.annotation'), default=O"
        "pRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='i"
        "nit.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', st"
        "d_params=(), kw_only_params=('dry_run', 'instance_types', 'filters', 'max_results', 'next_token'), frozen=True"
        ", slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='dry"
        "_run', kw_only=True, fn=None), ReprPlan.Field(name='instance_types', kw_only=True, fn=None), ReprPlan.Field(na"
        "me='filters', kw_only=True, fn=None), ReprPlan.Field(name='max_results', kw_only=True, fn=None), ReprPlan.Fiel"
        "d(name='next_token', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='2bd409abcc1fe65745575c019ddf571add03c9e8',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeInstanceTypesRequest'),
    ),
)
def _process_dataclass__2bd409abcc1fe65745575c019ddf571add03c9e8():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                dry_run=self.dry_run,
                instance_types=self.instance_types,
                filters=self.filters,
                max_results=self.max_results,
                next_token=self.next_token,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.dry_run == other.dry_run and
                self.instance_types == other.instance_types and
                self.filters == other.filters and
                self.max_results == other.max_results and
                self.next_token == other.next_token
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'dry_run',
            'instance_types',
            'filters',
            'max_results',
            'next_token',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'dry_run',
            'instance_types',
            'filters',
            'max_results',
            'next_token',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.dry_run,
                self.instance_types,
                self.filters,
                self.max_results,
                self.next_token,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            dry_run: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            instance_types: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            filters: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            max_results: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            next_token: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'instance_types', instance_types)
            __dataclass__object_setattr(self, 'filters', filters)
            __dataclass__object_setattr(self, 'max_results', max_results)
            __dataclass__object_setattr(self, 'next_token', next_token)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"instance_types={self.instance_types!r}")
            parts.append(f"filters={self.filters!r}")
            parts.append(f"max_results={self.max_results!r}")
            parts.append(f"next_token={self.next_token!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('internet_gateway_block_mode',)), EqPlan(fields=('internet_gateway_block_mode',)),"
        " FrozenPlan(fields=('__shape__', 'internet_gateway_block_mode'), allow_dynamic_dunder_attrs=False), HashPlan(a"
        "ction='add', fields=('internet_gateway_block_mode',), cache=False), InitPlan(fields=(InitPlan.Field(name='__sh"
        "ape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, over"
        "ride=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
        "'internet_gateway_block_mode', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fie"
        "lds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('internet_gateway_block_mo"
        "de',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPl"
        "an.Field(name='internet_gateway_block_mode', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)"
        "))"
    ),
    plan_repr_sha1='2feec5bda78e1c5735d34c1b7c47c422c88aaffe',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'BlockPublicAccessStates'),
    ),
)
def _process_dataclass__2feec5bda78e1c5735d34c1b7c47c422c88aaffe():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                internet_gateway_block_mode=self.internet_gateway_block_mode,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.internet_gateway_block_mode == other.internet_gateway_block_mode
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'internet_gateway_block_mode',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'internet_gateway_block_mode',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.internet_gateway_block_mode,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            internet_gateway_block_mode: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'internet_gateway_block_mode', internet_gateway_block_mode)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"internet_gateway_block_mode={self.internet_gateway_block_mode!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('variables', 'error')), EqPlan(fields=('variables', 'error')), FrozenPlan(fields=("
        "'__shape__', 'variables', 'error'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('variabl"
        "es', 'error'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fie"
        "lds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_"
        "VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='variables', annotation=OpRef(name='ini"
        "t.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='err"
        "or', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None)), self_param='self', std_params=(), kw_only_params=('variables', 'error'), frozen=True, slots=False, pos"
        "t_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='variables', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='error', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='317c843e53bb9dfbb0f4e22012dab481c78eee00',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'EnvironmentResponse'),
    ),
)
def _process_dataclass__317c843e53bb9dfbb0f4e22012dab481c78eee00():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                variables=self.variables,
                error=self.error,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.variables == other.variables and
                self.error == other.error
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'variables',
            'error',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'variables',
            'error',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.variables,
                self.error,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            variables: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            error: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'variables', variables)
            __dataclass__object_setattr(self, 'error', error)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"variables={self.variables!r}")
            parts.append(f"error={self.error!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('vpc_id', 'vpc_encryption_control_id', 'mode', 'state', 'state_message', 'resource"
        "_exclusions', 'tags')), EqPlan(fields=('vpc_id', 'vpc_encryption_control_id', 'mode', 'state', 'state_message'"
        ", 'resource_exclusions', 'tags')), FrozenPlan(fields=('__shape__', 'vpc_id', 'vpc_encryption_control_id', 'mod"
        "e', 'state', 'state_message', 'resource_exclusions', 'tags'), allow_dynamic_dunder_attrs=False), HashPlan(acti"
        "on='add', fields=('vpc_id', 'vpc_encryption_control_id', 'mode', 'state', 'state_message', 'resource_exclusion"
        "s', 'tags'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.field"
        "s.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VA"
        "R, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fie"
        "lds.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_encr"
        "yption_control_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='mode', annotation=OpRef(name='init.fields.3.annotation'), default=O"
        "pRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state', annotation=OpRef(name='init.f"
        "ields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=F"
        "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state_"
        "message', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='resource_exclusions', annotation=OpRef(name='init.fields.6.annotation'), defa"
        "ult=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='in"
        "it.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std"
        "_params=(), kw_only_params=('vpc_id', 'vpc_encryption_control_id', 'mode', 'state', 'state_message', 'resource"
        "_exclusions', 'tags'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPla"
        "n(fields=(ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPlan.Field(name='vpc_encryption_control_id"
        "', kw_only=True, fn=None), ReprPlan.Field(name='mode', kw_only=True, fn=None), ReprPlan.Field(name='state', kw"
        "_only=True, fn=None), ReprPlan.Field(name='state_message', kw_only=True, fn=None), ReprPlan.Field(name='resour"
        "ce_exclusions', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=True, fn=None)), id=False, terse=F"
        "alse, default_fn=None)))"
    ),
    plan_repr_sha1='320aefe088785f2aa267fdc198bbe8c5f4dbcf2c',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'VpcEncryptionControl'),
    ),
)
def _process_dataclass__320aefe088785f2aa267fdc198bbe8c5f4dbcf2c():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                vpc_id=self.vpc_id,
                vpc_encryption_control_id=self.vpc_encryption_control_id,
                mode=self.mode,
                state=self.state,
                state_message=self.state_message,
                resource_exclusions=self.resource_exclusions,
                tags=self.tags,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.vpc_id == other.vpc_id and
                self.vpc_encryption_control_id == other.vpc_encryption_control_id and
                self.mode == other.mode and
                self.state == other.state and
                self.state_message == other.state_message and
                self.resource_exclusions == other.resource_exclusions and
                self.tags == other.tags
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'vpc_id',
            'vpc_encryption_control_id',
            'mode',
            'state',
            'state_message',
            'resource_exclusions',
            'tags',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'vpc_id',
            'vpc_encryption_control_id',
            'mode',
            'state',
            'state_message',
            'resource_exclusions',
            'tags',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.vpc_id,
                self.vpc_encryption_control_id,
                self.mode,
                self.state,
                self.state_message,
                self.resource_exclusions,
                self.tags,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            vpc_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            vpc_encryption_control_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            mode: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            state: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            state_message: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            resource_exclusions: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            tags: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'vpc_encryption_control_id', vpc_encryption_control_id)
            __dataclass__object_setattr(self, 'mode', mode)
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'state_message', state_message)
            __dataclass__object_setattr(self, 'resource_exclusions', resource_exclusions)
            __dataclass__object_setattr(self, 'tags', tags)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"vpc_encryption_control_id={self.vpc_encryption_control_id!r}")
            parts.append(f"mode={self.mode!r}")
            parts.append(f"state={self.state!r}")
            parts.append(f"state_message={self.state_message!r}")
            parts.append(f"resource_exclusions={self.resource_exclusions!r}")
            parts.append(f"tags={self.tags!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('total_size_in_gb', 'disks', 'nvme_support', 'encryption_support')), EqPlan(fields"
        "=('total_size_in_gb', 'disks', 'nvme_support', 'encryption_support')), FrozenPlan(fields=('__shape__', 'total_"
        "size_in_gb', 'disks', 'nvme_support', 'encryption_support'), allow_dynamic_dunder_attrs=False), HashPlan(actio"
        "n='add', fields=('total_size_in_gb', 'disks', 'nvme_support', 'encryption_support'), cache=False), InitPlan(fi"
        "elds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, defaul"
        "t_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_t"
        "ype=None), InitPlan.Field(name='total_size_in_gb', annotation=OpRef(name='init.fields.1.annotation'), default="
        "OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='disks', annotation=OpRef(name='init."
        "fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override="
        "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='nvme_"
        "support', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='encryption_support', annotation=OpRef(name='init.fields.4.annotation'), defau"
        "lt=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType."
        "INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('to"
        "tal_size_in_gb', 'disks', 'nvme_support', 'encryption_support'), frozen=True, slots=False, post_init_params=No"
        "ne, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='total_size_in_gb', kw_only=True, fn=N"
        "one), ReprPlan.Field(name='disks', kw_only=True, fn=None), ReprPlan.Field(name='nvme_support', kw_only=True, f"
        "n=None), ReprPlan.Field(name='encryption_support', kw_only=True, fn=None)), id=False, terse=False, default_fn="
        "None)))"
    ),
    plan_repr_sha1='327236ea672fda2b2703a334052e0713bf4d89b0',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceStorageInfo'),
    ),
)
def _process_dataclass__327236ea672fda2b2703a334052e0713bf4d89b0():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                total_size_in_gb=self.total_size_in_gb,
                disks=self.disks,
                nvme_support=self.nvme_support,
                encryption_support=self.encryption_support,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.total_size_in_gb == other.total_size_in_gb and
                self.disks == other.disks and
                self.nvme_support == other.nvme_support and
                self.encryption_support == other.encryption_support
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'total_size_in_gb',
            'disks',
            'nvme_support',
            'encryption_support',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'total_size_in_gb',
            'disks',
            'nvme_support',
            'encryption_support',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.total_size_in_gb,
                self.disks,
                self.nvme_support,
                self.encryption_support,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            total_size_in_gb: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            disks: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            nvme_support: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            encryption_support: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'total_size_in_gb', total_size_in_gb)
            __dataclass__object_setattr(self, 'disks', disks)
            __dataclass__object_setattr(self, 'nvme_support', nvme_support)
            __dataclass__object_setattr(self, 'encryption_support', encryption_support)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"total_size_in_gb={self.total_size_in_gb!r}")
            parts.append(f"disks={self.disks!r}")
            parts.append(f"nvme_support={self.nvme_support!r}")
            parts.append(f"encryption_support={self.encryption_support!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('log_format', 'application_log_level', 'system_log_level', 'log_group')), EqPlan(f"
        "ields=('log_format', 'application_log_level', 'system_log_level', 'log_group')), FrozenPlan(fields=('__shape__"
        "', 'log_format', 'application_log_level', 'system_log_level', 'log_group'), allow_dynamic_dunder_attrs=False),"
        " HashPlan(action='add', fields=('log_format', 'application_log_level', 'system_log_level', 'log_group'), cache"
        "=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), "
        "default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='log_format', annotation=OpRef(name='init.fields.1.annotati"
        "on'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type"
        "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='application_log_level'"
        ", annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='system_log_level', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(n"
        "ame='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
        "coerce=None, validate=None, check_type=None), InitPlan.Field(name='log_group', annotation=OpRef(name='init.fie"
        "lds.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_param"
        "s=(), kw_only_params=('log_format', 'application_log_level', 'system_log_level', 'log_group'), frozen=True, sl"
        "ots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='log_for"
        "mat', kw_only=True, fn=None), ReprPlan.Field(name='application_log_level', kw_only=True, fn=None), ReprPlan.Fi"
        "eld(name='system_log_level', kw_only=True, fn=None), ReprPlan.Field(name='log_group', kw_only=True, fn=None)),"
        " id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='3789e83e8304a69b04615c05af44097dc01b657f',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'LoggingConfig'),
    ),
)
def _process_dataclass__3789e83e8304a69b04615c05af44097dc01b657f():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                log_format=self.log_format,
                application_log_level=self.application_log_level,
                system_log_level=self.system_log_level,
                log_group=self.log_group,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.log_format == other.log_format and
                self.application_log_level == other.application_log_level and
                self.system_log_level == other.system_log_level and
                self.log_group == other.log_group
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'log_format',
            'application_log_level',
            'system_log_level',
            'log_group',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'log_format',
            'application_log_level',
            'system_log_level',
            'log_group',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.log_format,
                self.application_log_level,
                self.system_log_level,
                self.log_group,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            log_format: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            application_log_level: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            system_log_level: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            log_group: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'log_format', log_format)
            __dataclass__object_setattr(self, 'application_log_level', application_log_level)
            __dataclass__object_setattr(self, 'system_log_level', system_log_level)
            __dataclass__object_setattr(self, 'log_group', log_group)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"log_format={self.log_format!r}")
            parts.append(f"application_log_level={self.application_log_level!r}")
            parts.append(f"system_log_level={self.system_log_level!r}")
            parts.append(f"log_group={self.log_group!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('master_region', 'function_version', 'marker', 'max_items')), EqPlan(fields=('mast"
        "er_region', 'function_version', 'marker', 'max_items')), FrozenPlan(fields=('__shape__', 'master_region', 'fun"
        "ction_version', 'marker', 'max_items'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('mas"
        "ter_region', 'function_version', 'marker', 'max_items'), cache=False), InitPlan(fields=(InitPlan.Field(name='_"
        "_shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='master_region', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='function_version', annotation=OpRef(name='init.fields.2.annotation'"
        "), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='marker', annotation=OpRef"
        "(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='max_items', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None)), self_param='self', std_params=(), kw_only_params=('master_region', 'function_version', '"
        "marker', 'max_items'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPla"
        "n(fields=(ReprPlan.Field(name='master_region', kw_only=True, fn=None), ReprPlan.Field(name='function_version',"
        " kw_only=True, fn=None), ReprPlan.Field(name='marker', kw_only=True, fn=None), ReprPlan.Field(name='max_items'"
        ", kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='380cb4006162c5599b728986e1364c0bb6b53532',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'ListFunctionsRequest'),
    ),
)
def _process_dataclass__380cb4006162c5599b728986e1364c0bb6b53532():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                master_region=self.master_region,
                function_version=self.function_version,
                marker=self.marker,
                max_items=self.max_items,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.master_region == other.master_region and
                self.function_version == other.function_version and
                self.marker == other.marker and
                self.max_items == other.max_items
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'master_region',
            'function_version',
            'marker',
            'max_items',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'master_region',
            'function_version',
            'marker',
            'max_items',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.master_region,
                self.function_version,
                self.marker,
                self.max_items,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            master_region: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            function_version: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            marker: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            max_items: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'master_region', master_region)
            __dataclass__object_setattr(self, 'function_version', function_version)
            __dataclass__object_setattr(self, 'marker', marker)
            __dataclass__object_setattr(self, 'max_items', max_items)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"master_region={self.master_region!r}")
            parts.append(f"function_version={self.function_version!r}")
            parts.append(f"marker={self.marker!r}")
            parts.append(f"max_items={self.max_items!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('elastic_inference_accelerator_arn', 'elastic_inference_accelerator_association_id"
        "', 'elastic_inference_accelerator_association_state', 'elastic_inference_accelerator_association_time')), EqPl"
        "an(fields=('elastic_inference_accelerator_arn', 'elastic_inference_accelerator_association_id', 'elastic_infer"
        "ence_accelerator_association_state', 'elastic_inference_accelerator_association_time')), FrozenPlan(fields=('_"
        "_shape__', 'elastic_inference_accelerator_arn', 'elastic_inference_accelerator_association_id', 'elastic_infer"
        "ence_accelerator_association_state', 'elastic_inference_accelerator_association_time'), allow_dynamic_dunder_a"
        "ttrs=False), HashPlan(action='add', fields=('elastic_inference_accelerator_arn', 'elastic_inference_accelerato"
        "r_association_id', 'elastic_inference_accelerator_association_state', 'elastic_inference_accelerator_associati"
        "on_time'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields."
        "0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR,"
        " coerce=None, validate=None, check_type=None), InitPlan.Field(name='elastic_inference_accelerator_arn', annota"
        "tion=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='elastic_inference_accelerator_association_id', annotation=OpRef(name='init.fields.2.annotatio"
        "n'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type="
        "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='elastic_inference_accel"
        "erator_association_state', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields."
        "3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='elastic_inference_accelerator_association_time', annotation="
        "OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_par"
        "am='self', std_params=(), kw_only_params=('elastic_inference_accelerator_arn', 'elastic_inference_accelerator_"
        "association_id', 'elastic_inference_accelerator_association_state', 'elastic_inference_accelerator_association"
        "_time'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Repr"
        "Plan.Field(name='elastic_inference_accelerator_arn', kw_only=True, fn=None), ReprPlan.Field(name='elastic_infe"
        "rence_accelerator_association_id', kw_only=True, fn=None), ReprPlan.Field(name='elastic_inference_accelerator_"
        "association_state', kw_only=True, fn=None), ReprPlan.Field(name='elastic_inference_accelerator_association_tim"
        "e', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='38372d55a38969f4bb824633424abf668717c1f4',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'ElasticInferenceAcceleratorAssociation'),
    ),
)
def _process_dataclass__38372d55a38969f4bb824633424abf668717c1f4():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                elastic_inference_accelerator_arn=self.elastic_inference_accelerator_arn,
                elastic_inference_accelerator_association_id=self.elastic_inference_accelerator_association_id,
                elastic_inference_accelerator_association_state=self.elastic_inference_accelerator_association_state,
                elastic_inference_accelerator_association_time=self.elastic_inference_accelerator_association_time,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.elastic_inference_accelerator_arn == other.elastic_inference_accelerator_arn and
                self.elastic_inference_accelerator_association_id == other.elastic_inference_accelerator_association_id and
                self.elastic_inference_accelerator_association_state == other.elastic_inference_accelerator_association_state and
                self.elastic_inference_accelerator_association_time == other.elastic_inference_accelerator_association_time
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'elastic_inference_accelerator_arn',
            'elastic_inference_accelerator_association_id',
            'elastic_inference_accelerator_association_state',
            'elastic_inference_accelerator_association_time',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'elastic_inference_accelerator_arn',
            'elastic_inference_accelerator_association_id',
            'elastic_inference_accelerator_association_state',
            'elastic_inference_accelerator_association_time',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.elastic_inference_accelerator_arn,
                self.elastic_inference_accelerator_association_id,
                self.elastic_inference_accelerator_association_state,
                self.elastic_inference_accelerator_association_time,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            elastic_inference_accelerator_arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            elastic_inference_accelerator_association_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            elastic_inference_accelerator_association_state: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            elastic_inference_accelerator_association_time: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'elastic_inference_accelerator_arn', elastic_inference_accelerator_arn)
            __dataclass__object_setattr(self, 'elastic_inference_accelerator_association_id', elastic_inference_accelerator_association_id)
            __dataclass__object_setattr(self, 'elastic_inference_accelerator_association_state', elastic_inference_accelerator_association_state)
            __dataclass__object_setattr(self, 'elastic_inference_accelerator_association_time', elastic_inference_accelerator_association_time)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"elastic_inference_accelerator_arn={self.elastic_inference_accelerator_arn!r}")
            parts.append(f"elastic_inference_accelerator_association_id={self.elastic_inference_accelerator_association_id!r}")
            parts.append(f"elastic_inference_accelerator_association_state={self.elastic_inference_accelerator_association_state!r}")
            parts.append(f"elastic_inference_accelerator_association_time={self.elastic_inference_accelerator_association_time!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('block_device_mappings', 'image_id', 'instance_type', 'ipv6_address_count', 'ipv6_"
        "addresses', 'kernel_id', 'key_name', 'max_count', 'min_count', 'monitoring', 'placement', 'ramdisk_id', 'secur"
        "ity_group_ids', 'security_groups', 'subnet_id', 'user_data', 'elastic_gpu_specification', 'elastic_inference_a"
        "ccelerators', 'tag_specifications', 'launch_template', 'instance_market_options', 'credit_specification', 'cpu"
        "_options', 'capacity_reservation_specification', 'hibernation_options', 'license_specifications', 'metadata_op"
        "tions', 'enclave_options', 'private_dns_name_options', 'maintenance_options', 'disable_api_stop', 'enable_prim"
        "ary_ipv6', 'network_performance_options', 'operator', 'dry_run', 'disable_api_termination', 'instance_initiate"
        "d_shutdown_behavior', 'private_ip_address', 'client_token', 'additional_info', 'network_interfaces', 'iam_inst"
        "ance_profile', 'ebs_optimized')), EqPlan(fields=('block_device_mappings', 'image_id', 'instance_type', 'ipv6_a"
        "ddress_count', 'ipv6_addresses', 'kernel_id', 'key_name', 'max_count', 'min_count', 'monitoring', 'placement',"
        " 'ramdisk_id', 'security_group_ids', 'security_groups', 'subnet_id', 'user_data', 'elastic_gpu_specification',"
        " 'elastic_inference_accelerators', 'tag_specifications', 'launch_template', 'instance_market_options', 'credit"
        "_specification', 'cpu_options', 'capacity_reservation_specification', 'hibernation_options', 'license_specific"
        "ations', 'metadata_options', 'enclave_options', 'private_dns_name_options', 'maintenance_options', 'disable_ap"
        "i_stop', 'enable_primary_ipv6', 'network_performance_options', 'operator', 'dry_run', 'disable_api_termination"
        "', 'instance_initiated_shutdown_behavior', 'private_ip_address', 'client_token', 'additional_info', 'network_i"
        "nterfaces', 'iam_instance_profile', 'ebs_optimized')), FrozenPlan(fields=('__shape__', 'block_device_mappings'"
        ", 'image_id', 'instance_type', 'ipv6_address_count', 'ipv6_addresses', 'kernel_id', 'key_name', 'max_count', '"
        "min_count', 'monitoring', 'placement', 'ramdisk_id', 'security_group_ids', 'security_groups', 'subnet_id', 'us"
        "er_data', 'elastic_gpu_specification', 'elastic_inference_accelerators', 'tag_specifications', 'launch_templat"
        "e', 'instance_market_options', 'credit_specification', 'cpu_options', 'capacity_reservation_specification', 'h"
        "ibernation_options', 'license_specifications', 'metadata_options', 'enclave_options', 'private_dns_name_option"
        "s', 'maintenance_options', 'disable_api_stop', 'enable_primary_ipv6', 'network_performance_options', 'operator"
        "', 'dry_run', 'disable_api_termination', 'instance_initiated_shutdown_behavior', 'private_ip_address', 'client"
        "_token', 'additional_info', 'network_interfaces', 'iam_instance_profile', 'ebs_optimized'), allow_dynamic_dund"
        "er_attrs=False), HashPlan(action='add', fields=('block_device_mappings', 'image_id', 'instance_type', 'ipv6_ad"
        "dress_count', 'ipv6_addresses', 'kernel_id', 'key_name', 'max_count', 'min_count', 'monitoring', 'placement', "
        "'ramdisk_id', 'security_group_ids', 'security_groups', 'subnet_id', 'user_data', 'elastic_gpu_specification', "
        "'elastic_inference_accelerators', 'tag_specifications', 'launch_template', 'instance_market_options', 'credit_"
        "specification', 'cpu_options', 'capacity_reservation_specification', 'hibernation_options', 'license_specifica"
        "tions', 'metadata_options', 'enclave_options', 'private_dns_name_options', 'maintenance_options', 'disable_api"
        "_stop', 'enable_primary_ipv6', 'network_performance_options', 'operator', 'dry_run', 'disable_api_termination'"
        ", 'instance_initiated_shutdown_behavior', 'private_ip_address', 'client_token', 'additional_info', 'network_in"
        "terfaces', 'iam_instance_profile', 'ebs_optimized'), cache=False), InitPlan(fields=(InitPlan.Field(name='__sha"
        "pe__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "block_device_mappings', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='image_id', annotation=OpRef(name='init.fields.2.annotation'), d"
        "efault=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_type', annotation=Op"
        "Ref(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init="
        "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
        "eld(name='ipv6_address_count', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fie"
        "lds.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='ipv6_addresses', annotation=OpRef(name='init.fields.5.an"
        "notation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, fiel"
        "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='kernel_id', anno"
        "tation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='key_name', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fiel"
        "ds.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None), InitPlan.Field(name='max_count', annotation=OpRef(name='init.fields.8.annotati"
        "on'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
        "e, validate=None, check_type=None), InitPlan.Field(name='min_count', annotation=OpRef(name='init.fields.9.anno"
        "tation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='monitoring', annotation=OpRef(name='init.fields.1"
        "0.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='placement',"
        " annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='ramdisk_id', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name="
        "'init.fields.12.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='security_group_ids', annotation=OpRef(name='in"
        "it.fields.13.annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, over"
        "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "security_groups', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='subnet_id', annotation=OpRef(name='init.fields.15.annotation'), def"
        "ault=OpRef(name='init.fields.15.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='user_data', annotation=OpRef(n"
        "ame='init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='elastic_gpu_specification', annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='ini"
        "t.fields.17.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='elastic_inference_accelerators', annotation=OpRef("
        "name='init.fields.18.annotation'), default=OpRef(name='init.fields.18.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='tag_specifications', annotation=OpRef(name='init.fields.19.annotation'), default=OpRef(name='init.fiel"
        "ds.19.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='launch_template', annotation=OpRef(name='init.fields.20."
        "annotation'), default=OpRef(name='init.fields.20.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_mark"
        "et_options', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='init.fields.21.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None), InitPlan.Field(name='credit_specification', annotation=OpRef(name='init.fields.22.annotation'"
        "), default=OpRef(name='init.fields.22.default'), default_factory=None, init=True, override=False, field_type=F"
        "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cpu_options', annotation"
        "=OpRef(name='init.fields.23.annotation'), default=OpRef(name='init.fields.23.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='capacity_reservation_specification', annotation=OpRef(name='init.fields.24.annotation'), defaul"
        "t=OpRef(name='init.fields.24.default'), default_factory=None, init=True, override=False, field_type=FieldType."
        "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='hibernation_options', annotation="
        "OpRef(name='init.fields.25.annotation'), default=OpRef(name='init.fields.25.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='license_specifications', annotation=OpRef(name='init.fields.26.annotation'), default=OpRef(name="
        "'init.fields.26.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='metadata_options', annotation=OpRef(name='init"
        ".fields.27.annotation'), default=OpRef(name='init.fields.27.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='en"
        "clave_options', annotation=OpRef(name='init.fields.28.annotation'), default=OpRef(name='init.fields.28.default"
        "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
        ", check_type=None), InitPlan.Field(name='private_dns_name_options', annotation=OpRef(name='init.fields.29.anno"
        "tation'), default=OpRef(name='init.fields.29.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maintenance_optio"
        "ns', annotation=OpRef(name='init.fields.30.annotation'), default=OpRef(name='init.fields.30.default'), default"
        "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='disable_api_stop', annotation=OpRef(name='init.fields.31.annotation'), default=O"
        "pRef(name='init.fields.31.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='enable_primary_ipv6', annotation=OpR"
        "ef(name='init.fields.32.annotation'), default=OpRef(name='init.fields.32.default'), default_factory=None, init"
        "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
        "ield(name='network_performance_options', annotation=OpRef(name='init.fields.33.annotation'), default=OpRef(nam"
        "e='init.fields.33.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
        "oerce=None, validate=None, check_type=None), InitPlan.Field(name='operator', annotation=OpRef(name='init.field"
        "s.34.annotation'), default=OpRef(name='init.fields.34.default'), default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run'"
        ", annotation=OpRef(name='init.fields.35.annotation'), default=OpRef(name='init.fields.35.default'), default_fa"
        "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
        "one), InitPlan.Field(name='disable_api_termination', annotation=OpRef(name='init.fields.36.annotation'), defau"
        "lt=OpRef(name='init.fields.36.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_initiated_shutdown_beha"
        "vior', annotation=OpRef(name='init.fields.37.annotation'), default=OpRef(name='init.fields.37.default'), defau"
        "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
        "ype=None), InitPlan.Field(name='private_ip_address', annotation=OpRef(name='init.fields.38.annotation'), defau"
        "lt=OpRef(name='init.fields.38.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='client_token', annotation=OpRef("
        "name='init.fields.39.annotation'), default=OpRef(name='init.fields.39.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='additional_info', annotation=OpRef(name='init.fields.40.annotation'), default=OpRef(name='init.fields."
        "40.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='network_interfaces', annotation=OpRef(name='init.fields.41."
        "annotation'), default=OpRef(name='init.fields.41.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='iam_instance_"
        "profile', annotation=OpRef(name='init.fields.42.annotation'), default=OpRef(name='init.fields.42.default'), de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
        "k_type=None), InitPlan.Field(name='ebs_optimized', annotation=OpRef(name='init.fields.43.annotation'), default"
        "=OpRef(name='init.fields.43.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
        "NSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('blo"
        "ck_device_mappings', 'image_id', 'instance_type', 'ipv6_address_count', 'ipv6_addresses', 'kernel_id', 'key_na"
        "me', 'max_count', 'min_count', 'monitoring', 'placement', 'ramdisk_id', 'security_group_ids', 'security_groups"
        "', 'subnet_id', 'user_data', 'elastic_gpu_specification', 'elastic_inference_accelerators', 'tag_specification"
        "s', 'launch_template', 'instance_market_options', 'credit_specification', 'cpu_options', 'capacity_reservation"
        "_specification', 'hibernation_options', 'license_specifications', 'metadata_options', 'enclave_options', 'priv"
        "ate_dns_name_options', 'maintenance_options', 'disable_api_stop', 'enable_primary_ipv6', 'network_performance_"
        "options', 'operator', 'dry_run', 'disable_api_termination', 'instance_initiated_shutdown_behavior', 'private_i"
        "p_address', 'client_token', 'additional_info', 'network_interfaces', 'iam_instance_profile', 'ebs_optimized'),"
        " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Fie"
        "ld(name='block_device_mappings', kw_only=True, fn=None), ReprPlan.Field(name='image_id', kw_only=True, fn=None"
        "), ReprPlan.Field(name='instance_type', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_address_count', kw_o"
        "nly=True, fn=None), ReprPlan.Field(name='ipv6_addresses', kw_only=True, fn=None), ReprPlan.Field(name='kernel_"
        "id', kw_only=True, fn=None), ReprPlan.Field(name='key_name', kw_only=True, fn=None), ReprPlan.Field(name='max_"
        "count', kw_only=True, fn=None), ReprPlan.Field(name='min_count', kw_only=True, fn=None), ReprPlan.Field(name='"
        "monitoring', kw_only=True, fn=None), ReprPlan.Field(name='placement', kw_only=True, fn=None), ReprPlan.Field(n"
        "ame='ramdisk_id', kw_only=True, fn=None), ReprPlan.Field(name='security_group_ids', kw_only=True, fn=None), Re"
        "prPlan.Field(name='security_groups', kw_only=True, fn=None), ReprPlan.Field(name='subnet_id', kw_only=True, fn"
        "=None), ReprPlan.Field(name='user_data', kw_only=True, fn=None), ReprPlan.Field(name='elastic_gpu_specificatio"
        "n', kw_only=True, fn=None), ReprPlan.Field(name='elastic_inference_accelerators', kw_only=True, fn=None), Repr"
        "Plan.Field(name='tag_specifications', kw_only=True, fn=None), ReprPlan.Field(name='launch_template', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='instance_market_options', kw_only=True, fn=None), ReprPlan.Field(name='cre"
        "dit_specification', kw_only=True, fn=None), ReprPlan.Field(name='cpu_options', kw_only=True, fn=None), ReprPla"
        "n.Field(name='capacity_reservation_specification', kw_only=True, fn=None), ReprPlan.Field(name='hibernation_op"
        "tions', kw_only=True, fn=None), ReprPlan.Field(name='license_specifications', kw_only=True, fn=None), ReprPlan"
        ".Field(name='metadata_options', kw_only=True, fn=None), ReprPlan.Field(name='enclave_options', kw_only=True, f"
        "n=None), ReprPlan.Field(name='private_dns_name_options', kw_only=True, fn=None), ReprPlan.Field(name='maintena"
        "nce_options', kw_only=True, fn=None), ReprPlan.Field(name='disable_api_stop', kw_only=True, fn=None), ReprPlan"
        ".Field(name='enable_primary_ipv6', kw_only=True, fn=None), ReprPlan.Field(name='network_performance_options', "
        "kw_only=True, fn=None), ReprPlan.Field(name='operator', kw_only=True, fn=None), ReprPlan.Field(name='dry_run',"
        " kw_only=True, fn=None), ReprPlan.Field(name='disable_api_termination', kw_only=True, fn=None), ReprPlan.Field"
        "(name='instance_initiated_shutdown_behavior', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_address'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='client_token', kw_only=True, fn=None), ReprPlan.Field(name='add"
        "itional_info', kw_only=True, fn=None), ReprPlan.Field(name='network_interfaces', kw_only=True, fn=None), ReprP"
        "lan.Field(name='iam_instance_profile', kw_only=True, fn=None), ReprPlan.Field(name='ebs_optimized', kw_only=Tr"
        "ue, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='38db1e6f17b46debfe1fe98a6634a87377979b95',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__24__annotation',
        '__dataclass__init__fields__24__default',
        '__dataclass__init__fields__25__annotation',
        '__dataclass__init__fields__25__default',
        '__dataclass__init__fields__26__annotation',
        '__dataclass__init__fields__26__default',
        '__dataclass__init__fields__27__annotation',
        '__dataclass__init__fields__27__default',
        '__dataclass__init__fields__28__annotation',
        '__dataclass__init__fields__28__default',
        '__dataclass__init__fields__29__annotation',
        '__dataclass__init__fields__29__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__30__annotation',
        '__dataclass__init__fields__30__default',
        '__dataclass__init__fields__31__annotation',
        '__dataclass__init__fields__31__default',
        '__dataclass__init__fields__32__annotation',
        '__dataclass__init__fields__32__default',
        '__dataclass__init__fields__33__annotation',
        '__dataclass__init__fields__33__default',
        '__dataclass__init__fields__34__annotation',
        '__dataclass__init__fields__34__default',
        '__dataclass__init__fields__35__annotation',
        '__dataclass__init__fields__35__default',
        '__dataclass__init__fields__36__annotation',
        '__dataclass__init__fields__36__default',
        '__dataclass__init__fields__37__annotation',
        '__dataclass__init__fields__37__default',
        '__dataclass__init__fields__38__annotation',
        '__dataclass__init__fields__38__default',
        '__dataclass__init__fields__39__annotation',
        '__dataclass__init__fields__39__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__40__annotation',
        '__dataclass__init__fields__40__default',
        '__dataclass__init__fields__41__annotation',
        '__dataclass__init__fields__41__default',
        '__dataclass__init__fields__42__annotation',
        '__dataclass__init__fields__42__default',
        '__dataclass__init__fields__43__annotation',
        '__dataclass__init__fields__43__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__9__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'RunInstancesRequest'),
    ),
)
def _process_dataclass__38db1e6f17b46debfe1fe98a6634a87377979b95():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__24__annotation,
        __dataclass__init__fields__24__default,
        __dataclass__init__fields__25__annotation,
        __dataclass__init__fields__25__default,
        __dataclass__init__fields__26__annotation,
        __dataclass__init__fields__26__default,
        __dataclass__init__fields__27__annotation,
        __dataclass__init__fields__27__default,
        __dataclass__init__fields__28__annotation,
        __dataclass__init__fields__28__default,
        __dataclass__init__fields__29__annotation,
        __dataclass__init__fields__29__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__30__annotation,
        __dataclass__init__fields__30__default,
        __dataclass__init__fields__31__annotation,
        __dataclass__init__fields__31__default,
        __dataclass__init__fields__32__annotation,
        __dataclass__init__fields__32__default,
        __dataclass__init__fields__33__annotation,
        __dataclass__init__fields__33__default,
        __dataclass__init__fields__34__annotation,
        __dataclass__init__fields__34__default,
        __dataclass__init__fields__35__annotation,
        __dataclass__init__fields__35__default,
        __dataclass__init__fields__36__annotation,
        __dataclass__init__fields__36__default,
        __dataclass__init__fields__37__annotation,
        __dataclass__init__fields__37__default,
        __dataclass__init__fields__38__annotation,
        __dataclass__init__fields__38__default,
        __dataclass__init__fields__39__annotation,
        __dataclass__init__fields__39__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__40__annotation,
        __dataclass__init__fields__40__default,
        __dataclass__init__fields__41__annotation,
        __dataclass__init__fields__41__default,
        __dataclass__init__fields__42__annotation,
        __dataclass__init__fields__42__default,
        __dataclass__init__fields__43__annotation,
        __dataclass__init__fields__43__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__9__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                block_device_mappings=self.block_device_mappings,
                image_id=self.image_id,
                instance_type=self.instance_type,
                ipv6_address_count=self.ipv6_address_count,
                ipv6_addresses=self.ipv6_addresses,
                kernel_id=self.kernel_id,
                key_name=self.key_name,
                max_count=self.max_count,
                min_count=self.min_count,
                monitoring=self.monitoring,
                placement=self.placement,
                ramdisk_id=self.ramdisk_id,
                security_group_ids=self.security_group_ids,
                security_groups=self.security_groups,
                subnet_id=self.subnet_id,
                user_data=self.user_data,
                elastic_gpu_specification=self.elastic_gpu_specification,
                elastic_inference_accelerators=self.elastic_inference_accelerators,
                tag_specifications=self.tag_specifications,
                launch_template=self.launch_template,
                instance_market_options=self.instance_market_options,
                credit_specification=self.credit_specification,
                cpu_options=self.cpu_options,
                capacity_reservation_specification=self.capacity_reservation_specification,
                hibernation_options=self.hibernation_options,
                license_specifications=self.license_specifications,
                metadata_options=self.metadata_options,
                enclave_options=self.enclave_options,
                private_dns_name_options=self.private_dns_name_options,
                maintenance_options=self.maintenance_options,
                disable_api_stop=self.disable_api_stop,
                enable_primary_ipv6=self.enable_primary_ipv6,
                network_performance_options=self.network_performance_options,
                operator=self.operator,
                dry_run=self.dry_run,
                disable_api_termination=self.disable_api_termination,
                instance_initiated_shutdown_behavior=self.instance_initiated_shutdown_behavior,
                private_ip_address=self.private_ip_address,
                client_token=self.client_token,
                additional_info=self.additional_info,
                network_interfaces=self.network_interfaces,
                iam_instance_profile=self.iam_instance_profile,
                ebs_optimized=self.ebs_optimized,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.block_device_mappings == other.block_device_mappings and
                self.image_id == other.image_id and
                self.instance_type == other.instance_type and
                self.ipv6_address_count == other.ipv6_address_count and
                self.ipv6_addresses == other.ipv6_addresses and
                self.kernel_id == other.kernel_id and
                self.key_name == other.key_name and
                self.max_count == other.max_count and
                self.min_count == other.min_count and
                self.monitoring == other.monitoring and
                self.placement == other.placement and
                self.ramdisk_id == other.ramdisk_id and
                self.security_group_ids == other.security_group_ids and
                self.security_groups == other.security_groups and
                self.subnet_id == other.subnet_id and
                self.user_data == other.user_data and
                self.elastic_gpu_specification == other.elastic_gpu_specification and
                self.elastic_inference_accelerators == other.elastic_inference_accelerators and
                self.tag_specifications == other.tag_specifications and
                self.launch_template == other.launch_template and
                self.instance_market_options == other.instance_market_options and
                self.credit_specification == other.credit_specification and
                self.cpu_options == other.cpu_options and
                self.capacity_reservation_specification == other.capacity_reservation_specification and
                self.hibernation_options == other.hibernation_options and
                self.license_specifications == other.license_specifications and
                self.metadata_options == other.metadata_options and
                self.enclave_options == other.enclave_options and
                self.private_dns_name_options == other.private_dns_name_options and
                self.maintenance_options == other.maintenance_options and
                self.disable_api_stop == other.disable_api_stop and
                self.enable_primary_ipv6 == other.enable_primary_ipv6 and
                self.network_performance_options == other.network_performance_options and
                self.operator == other.operator and
                self.dry_run == other.dry_run and
                self.disable_api_termination == other.disable_api_termination and
                self.instance_initiated_shutdown_behavior == other.instance_initiated_shutdown_behavior and
                self.private_ip_address == other.private_ip_address and
                self.client_token == other.client_token and
                self.additional_info == other.additional_info and
                self.network_interfaces == other.network_interfaces and
                self.iam_instance_profile == other.iam_instance_profile and
                self.ebs_optimized == other.ebs_optimized
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'block_device_mappings',
            'image_id',
            'instance_type',
            'ipv6_address_count',
            'ipv6_addresses',
            'kernel_id',
            'key_name',
            'max_count',
            'min_count',
            'monitoring',
            'placement',
            'ramdisk_id',
            'security_group_ids',
            'security_groups',
            'subnet_id',
            'user_data',
            'elastic_gpu_specification',
            'elastic_inference_accelerators',
            'tag_specifications',
            'launch_template',
            'instance_market_options',
            'credit_specification',
            'cpu_options',
            'capacity_reservation_specification',
            'hibernation_options',
            'license_specifications',
            'metadata_options',
            'enclave_options',
            'private_dns_name_options',
            'maintenance_options',
            'disable_api_stop',
            'enable_primary_ipv6',
            'network_performance_options',
            'operator',
            'dry_run',
            'disable_api_termination',
            'instance_initiated_shutdown_behavior',
            'private_ip_address',
            'client_token',
            'additional_info',
            'network_interfaces',
            'iam_instance_profile',
            'ebs_optimized',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'block_device_mappings',
            'image_id',
            'instance_type',
            'ipv6_address_count',
            'ipv6_addresses',
            'kernel_id',
            'key_name',
            'max_count',
            'min_count',
            'monitoring',
            'placement',
            'ramdisk_id',
            'security_group_ids',
            'security_groups',
            'subnet_id',
            'user_data',
            'elastic_gpu_specification',
            'elastic_inference_accelerators',
            'tag_specifications',
            'launch_template',
            'instance_market_options',
            'credit_specification',
            'cpu_options',
            'capacity_reservation_specification',
            'hibernation_options',
            'license_specifications',
            'metadata_options',
            'enclave_options',
            'private_dns_name_options',
            'maintenance_options',
            'disable_api_stop',
            'enable_primary_ipv6',
            'network_performance_options',
            'operator',
            'dry_run',
            'disable_api_termination',
            'instance_initiated_shutdown_behavior',
            'private_ip_address',
            'client_token',
            'additional_info',
            'network_interfaces',
            'iam_instance_profile',
            'ebs_optimized',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.block_device_mappings,
                self.image_id,
                self.instance_type,
                self.ipv6_address_count,
                self.ipv6_addresses,
                self.kernel_id,
                self.key_name,
                self.max_count,
                self.min_count,
                self.monitoring,
                self.placement,
                self.ramdisk_id,
                self.security_group_ids,
                self.security_groups,
                self.subnet_id,
                self.user_data,
                self.elastic_gpu_specification,
                self.elastic_inference_accelerators,
                self.tag_specifications,
                self.launch_template,
                self.instance_market_options,
                self.credit_specification,
                self.cpu_options,
                self.capacity_reservation_specification,
                self.hibernation_options,
                self.license_specifications,
                self.metadata_options,
                self.enclave_options,
                self.private_dns_name_options,
                self.maintenance_options,
                self.disable_api_stop,
                self.enable_primary_ipv6,
                self.network_performance_options,
                self.operator,
                self.dry_run,
                self.disable_api_termination,
                self.instance_initiated_shutdown_behavior,
                self.private_ip_address,
                self.client_token,
                self.additional_info,
                self.network_interfaces,
                self.iam_instance_profile,
                self.ebs_optimized,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            block_device_mappings: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            image_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            instance_type: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            ipv6_address_count: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            ipv6_addresses: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            kernel_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            key_name: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            max_count: __dataclass__init__fields__8__annotation,
            min_count: __dataclass__init__fields__9__annotation,
            monitoring: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            placement: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            ramdisk_id: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            security_group_ids: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            security_groups: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            subnet_id: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            user_data: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            elastic_gpu_specification: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            elastic_inference_accelerators: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            tag_specifications: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            launch_template: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            instance_market_options: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            credit_specification: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            cpu_options: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
            capacity_reservation_specification: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
            hibernation_options: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
            license_specifications: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
            metadata_options: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
            enclave_options: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
            private_dns_name_options: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
            maintenance_options: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
            disable_api_stop: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
            enable_primary_ipv6: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
            network_performance_options: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
            operator: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
            dry_run: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
            disable_api_termination: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
            instance_initiated_shutdown_behavior: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
            private_ip_address: __dataclass__init__fields__38__annotation = __dataclass__init__fields__38__default,
            client_token: __dataclass__init__fields__39__annotation = __dataclass__init__fields__39__default,
            additional_info: __dataclass__init__fields__40__annotation = __dataclass__init__fields__40__default,
            network_interfaces: __dataclass__init__fields__41__annotation = __dataclass__init__fields__41__default,
            iam_instance_profile: __dataclass__init__fields__42__annotation = __dataclass__init__fields__42__default,
            ebs_optimized: __dataclass__init__fields__43__annotation = __dataclass__init__fields__43__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'block_device_mappings', block_device_mappings)
            __dataclass__object_setattr(self, 'image_id', image_id)
            __dataclass__object_setattr(self, 'instance_type', instance_type)
            __dataclass__object_setattr(self, 'ipv6_address_count', ipv6_address_count)
            __dataclass__object_setattr(self, 'ipv6_addresses', ipv6_addresses)
            __dataclass__object_setattr(self, 'kernel_id', kernel_id)
            __dataclass__object_setattr(self, 'key_name', key_name)
            __dataclass__object_setattr(self, 'max_count', max_count)
            __dataclass__object_setattr(self, 'min_count', min_count)
            __dataclass__object_setattr(self, 'monitoring', monitoring)
            __dataclass__object_setattr(self, 'placement', placement)
            __dataclass__object_setattr(self, 'ramdisk_id', ramdisk_id)
            __dataclass__object_setattr(self, 'security_group_ids', security_group_ids)
            __dataclass__object_setattr(self, 'security_groups', security_groups)
            __dataclass__object_setattr(self, 'subnet_id', subnet_id)
            __dataclass__object_setattr(self, 'user_data', user_data)
            __dataclass__object_setattr(self, 'elastic_gpu_specification', elastic_gpu_specification)
            __dataclass__object_setattr(self, 'elastic_inference_accelerators', elastic_inference_accelerators)
            __dataclass__object_setattr(self, 'tag_specifications', tag_specifications)
            __dataclass__object_setattr(self, 'launch_template', launch_template)
            __dataclass__object_setattr(self, 'instance_market_options', instance_market_options)
            __dataclass__object_setattr(self, 'credit_specification', credit_specification)
            __dataclass__object_setattr(self, 'cpu_options', cpu_options)
            __dataclass__object_setattr(self, 'capacity_reservation_specification', capacity_reservation_specification)
            __dataclass__object_setattr(self, 'hibernation_options', hibernation_options)
            __dataclass__object_setattr(self, 'license_specifications', license_specifications)
            __dataclass__object_setattr(self, 'metadata_options', metadata_options)
            __dataclass__object_setattr(self, 'enclave_options', enclave_options)
            __dataclass__object_setattr(self, 'private_dns_name_options', private_dns_name_options)
            __dataclass__object_setattr(self, 'maintenance_options', maintenance_options)
            __dataclass__object_setattr(self, 'disable_api_stop', disable_api_stop)
            __dataclass__object_setattr(self, 'enable_primary_ipv6', enable_primary_ipv6)
            __dataclass__object_setattr(self, 'network_performance_options', network_performance_options)
            __dataclass__object_setattr(self, 'operator', operator)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'disable_api_termination', disable_api_termination)
            __dataclass__object_setattr(self, 'instance_initiated_shutdown_behavior', instance_initiated_shutdown_behavior)
            __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)
            __dataclass__object_setattr(self, 'client_token', client_token)
            __dataclass__object_setattr(self, 'additional_info', additional_info)
            __dataclass__object_setattr(self, 'network_interfaces', network_interfaces)
            __dataclass__object_setattr(self, 'iam_instance_profile', iam_instance_profile)
            __dataclass__object_setattr(self, 'ebs_optimized', ebs_optimized)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"block_device_mappings={self.block_device_mappings!r}")
            parts.append(f"image_id={self.image_id!r}")
            parts.append(f"instance_type={self.instance_type!r}")
            parts.append(f"ipv6_address_count={self.ipv6_address_count!r}")
            parts.append(f"ipv6_addresses={self.ipv6_addresses!r}")
            parts.append(f"kernel_id={self.kernel_id!r}")
            parts.append(f"key_name={self.key_name!r}")
            parts.append(f"max_count={self.max_count!r}")
            parts.append(f"min_count={self.min_count!r}")
            parts.append(f"monitoring={self.monitoring!r}")
            parts.append(f"placement={self.placement!r}")
            parts.append(f"ramdisk_id={self.ramdisk_id!r}")
            parts.append(f"security_group_ids={self.security_group_ids!r}")
            parts.append(f"security_groups={self.security_groups!r}")
            parts.append(f"subnet_id={self.subnet_id!r}")
            parts.append(f"user_data={self.user_data!r}")
            parts.append(f"elastic_gpu_specification={self.elastic_gpu_specification!r}")
            parts.append(f"elastic_inference_accelerators={self.elastic_inference_accelerators!r}")
            parts.append(f"tag_specifications={self.tag_specifications!r}")
            parts.append(f"launch_template={self.launch_template!r}")
            parts.append(f"instance_market_options={self.instance_market_options!r}")
            parts.append(f"credit_specification={self.credit_specification!r}")
            parts.append(f"cpu_options={self.cpu_options!r}")
            parts.append(f"capacity_reservation_specification={self.capacity_reservation_specification!r}")
            parts.append(f"hibernation_options={self.hibernation_options!r}")
            parts.append(f"license_specifications={self.license_specifications!r}")
            parts.append(f"metadata_options={self.metadata_options!r}")
            parts.append(f"enclave_options={self.enclave_options!r}")
            parts.append(f"private_dns_name_options={self.private_dns_name_options!r}")
            parts.append(f"maintenance_options={self.maintenance_options!r}")
            parts.append(f"disable_api_stop={self.disable_api_stop!r}")
            parts.append(f"enable_primary_ipv6={self.enable_primary_ipv6!r}")
            parts.append(f"network_performance_options={self.network_performance_options!r}")
            parts.append(f"operator={self.operator!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"disable_api_termination={self.disable_api_termination!r}")
            parts.append(f"instance_initiated_shutdown_behavior={self.instance_initiated_shutdown_behavior!r}")
            parts.append(f"private_ip_address={self.private_ip_address!r}")
            parts.append(f"client_token={self.client_token!r}")
            parts.append(f"additional_info={self.additional_info!r}")
            parts.append(f"network_interfaces={self.network_interfaces!r}")
            parts.append(f"iam_instance_profile={self.iam_instance_profile!r}")
            parts.append(f"ebs_optimized={self.ebs_optimized!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('arn', 'name')), EqPlan(fields=('arn', 'name')), FrozenPlan(fields=('__shape__', '"
        "arn', 'name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('arn', 'name'), cache=False),"
        " InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default="
        "None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=N"
        "one, check_type=None), InitPlan.Field(name='arn', annotation=OpRef(name='init.fields.1.annotation'), default=O"
        "pRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fi"
        "elds.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_para"
        "ms=(), kw_only_params=('arn', 'name'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_"
        "fns=()), ReprPlan(fields=(ReprPlan.Field(name='arn', kw_only=True, fn=None), ReprPlan.Field(name='name', kw_on"
        "ly=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='393cef70a0276465bcd054e4c1e3f3361f57d405',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'IamInstanceProfileSpecification'),
    ),
)
def _process_dataclass__393cef70a0276465bcd054e4c1e3f3361f57d405():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                arn=self.arn,
                name=self.name,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.arn == other.arn and
                self.name == other.name
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'arn',
            'name',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'arn',
            'name',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.arn,
                self.name,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'arn', arn)
            __dataclass__object_setattr(self, 'name', name)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"arn={self.arn!r}")
            parts.append(f"name={self.name!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('default_v_cpus', 'default_cores', 'default_threads_per_core', 'valid_cores', 'val"
        "id_threads_per_core')), EqPlan(fields=('default_v_cpus', 'default_cores', 'default_threads_per_core', 'valid_c"
        "ores', 'valid_threads_per_core')), FrozenPlan(fields=('__shape__', 'default_v_cpus', 'default_cores', 'default"
        "_threads_per_core', 'valid_cores', 'valid_threads_per_core'), allow_dynamic_dunder_attrs=False), HashPlan(acti"
        "on='add', fields=('default_v_cpus', 'default_cores', 'default_threads_per_core', 'valid_cores', 'valid_threads"
        "_per_core'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.field"
        "s.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VA"
        "R, coerce=None, validate=None, check_type=None), InitPlan.Field(name='default_v_cpus', annotation=OpRef(name='"
        "init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, over"
        "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "default_cores', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default')"
        ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='default_threads_per_core', annotation=OpRef(name='init.fields.3.annotat"
        "ion'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='valid_cores', annotat"
        "ion=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None,"
        " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
        "lan.Field(name='valid_threads_per_core', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name"
        "='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('default_v_cpus'"
        ", 'default_cores', 'default_threads_per_core', 'valid_cores', 'valid_threads_per_core'), frozen=True, slots=Fa"
        "lse, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='default_v_cpu"
        "s', kw_only=True, fn=None), ReprPlan.Field(name='default_cores', kw_only=True, fn=None), ReprPlan.Field(name='"
        "default_threads_per_core', kw_only=True, fn=None), ReprPlan.Field(name='valid_cores', kw_only=True, fn=None), "
        "ReprPlan.Field(name='valid_threads_per_core', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)"
        "))"
    ),
    plan_repr_sha1='3b2bc736efeacacf1a96fc040e201359b4679dd7',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'VCpuInfo'),
    ),
)
def _process_dataclass__3b2bc736efeacacf1a96fc040e201359b4679dd7():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                default_v_cpus=self.default_v_cpus,
                default_cores=self.default_cores,
                default_threads_per_core=self.default_threads_per_core,
                valid_cores=self.valid_cores,
                valid_threads_per_core=self.valid_threads_per_core,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.default_v_cpus == other.default_v_cpus and
                self.default_cores == other.default_cores and
                self.default_threads_per_core == other.default_threads_per_core and
                self.valid_cores == other.valid_cores and
                self.valid_threads_per_core == other.valid_threads_per_core
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'default_v_cpus',
            'default_cores',
            'default_threads_per_core',
            'valid_cores',
            'valid_threads_per_core',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'default_v_cpus',
            'default_cores',
            'default_threads_per_core',
            'valid_cores',
            'valid_threads_per_core',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.default_v_cpus,
                self.default_cores,
                self.default_threads_per_core,
                self.valid_cores,
                self.valid_threads_per_core,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            default_v_cpus: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            default_cores: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            default_threads_per_core: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            valid_cores: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            valid_threads_per_core: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'default_v_cpus', default_v_cpus)
            __dataclass__object_setattr(self, 'default_cores', default_cores)
            __dataclass__object_setattr(self, 'default_threads_per_core', default_threads_per_core)
            __dataclass__object_setattr(self, 'valid_cores', valid_cores)
            __dataclass__object_setattr(self, 'valid_threads_per_core', valid_threads_per_core)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"default_v_cpus={self.default_v_cpus!r}")
            parts.append(f"default_cores={self.default_cores!r}")
            parts.append(f"default_threads_per_core={self.default_threads_per_core!r}")
            parts.append(f"valid_cores={self.valid_cores!r}")
            parts.append(f"valid_threads_per_core={self.valid_threads_per_core!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('instance_ids', 'additional_info', 'dry_run')), EqPlan(fields=('instance_ids', 'ad"
        "ditional_info', 'dry_run')), FrozenPlan(fields=('__shape__', 'instance_ids', 'additional_info', 'dry_run'), al"
        "low_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('instance_ids', 'additional_info', 'dry_run'),"
        " cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotati"
        "on'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='instance_ids', annotation=OpRef(name='init.fields.1."
        "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='additional_info', annotation=OpRef(name='init"
        ".fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override"
        "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_"
        "run', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None)), self_param='self', std_params=(), kw_only_params=('instance_ids', 'additional_info', 'dry_run'), froz"
        "en=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(na"
        "me='instance_ids', kw_only=True, fn=None), ReprPlan.Field(name='additional_info', kw_only=True, fn=None), Repr"
        "Plan.Field(name='dry_run', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='3c289e0fbc4af42ddd56e4a3c5ca5d6381a09a3e',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'StartInstancesRequest'),
    ),
)
def _process_dataclass__3c289e0fbc4af42ddd56e4a3c5ca5d6381a09a3e():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                instance_ids=self.instance_ids,
                additional_info=self.additional_info,
                dry_run=self.dry_run,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.instance_ids == other.instance_ids and
                self.additional_info == other.additional_info and
                self.dry_run == other.dry_run
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'additional_info',
            'dry_run',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'additional_info',
            'dry_run',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.instance_ids,
                self.additional_info,
                self.dry_run,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            instance_ids: __dataclass__init__fields__1__annotation,
            additional_info: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            dry_run: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'instance_ids', instance_ids)
            __dataclass__object_setattr(self, 'additional_info', additional_info)
            __dataclass__object_setattr(self, 'dry_run', dry_run)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"instance_ids={self.instance_ids!r}")
            parts.append(f"additional_info={self.additional_info!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('vpc_security_group_id', 'status')), EqPlan(fields=('vpc_security_group_id', 'stat"
        "us')), FrozenPlan(fields=('__shape__', 'vpc_security_group_id', 'status'), allow_dynamic_dunder_attrs=False), "
        "HashPlan(action='add', fields=('vpc_security_group_id', 'status'), cache=False), InitPlan(fields=(InitPlan.Fie"
        "ld(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, in"
        "it=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='vpc_security_group_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='i"
        "nit.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='status', annotation=OpRef(name='init.fields.2.ann"
        "otation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_"
        "only_params=('vpc_security_group_id', 'status'), frozen=True, slots=False, post_init_params=None, init_fns=(),"
        " validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='vpc_security_group_id', kw_only=True, fn=None), ReprP"
        "lan.Field(name='status', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='3d0aa6d7bd2c7a9f510ef82abbbea50c5d70db25',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'VpcSecurityGroupMembership'),
    ),
)
def _process_dataclass__3d0aa6d7bd2c7a9f510ef82abbbea50c5d70db25():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                vpc_security_group_id=self.vpc_security_group_id,
                status=self.status,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.vpc_security_group_id == other.vpc_security_group_id and
                self.status == other.status
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'vpc_security_group_id',
            'status',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'vpc_security_group_id',
            'status',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.vpc_security_group_id,
                self.status,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            vpc_security_group_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            status: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'vpc_security_group_id', vpc_security_group_id)
            __dataclass__object_setattr(self, 'status', status)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"vpc_security_group_id={self.vpc_security_group_id!r}")
            parts.append(f"status={self.status!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('managed', 'principal')), EqPlan(fields=('managed', 'principal')), FrozenPlan(fiel"
        "ds=('__shape__', 'managed', 'principal'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('m"
        "anaged', 'principal'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='"
        "init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='managed', annotation=OpRef(nam"
        "e='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='principal', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None)), self_param='self', std_params=(), kw_only_params=('managed', 'principal'), frozen=True, slot"
        "s=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='managed',"
        " kw_only=True, fn=None), ReprPlan.Field(name='principal', kw_only=True, fn=None)), id=False, terse=False, defa"
        "ult_fn=None)))"
    ),
    plan_repr_sha1='3db983948f839eb4e1e64db71fc93230245732f1',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'OperatorResponse'),
    ),
)
def _process_dataclass__3db983948f839eb4e1e64db71fc93230245732f1():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                managed=self.managed,
                principal=self.principal,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.managed == other.managed and
                self.principal == other.principal
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'managed',
            'principal',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'managed',
            'principal',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.managed,
                self.principal,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            managed: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            principal: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'managed', managed)
            __dataclass__object_setattr(self, 'principal', principal)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"managed={self.managed!r}")
            parts.append(f"principal={self.principal!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('gateway_id',)), EqPlan(fields=('gateway_id',)), FrozenPlan(fields=('__shape__', '"
        "gateway_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('gateway_id',), cache=False), "
        "InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=N"
        "one, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='gateway_id', annotation=OpRef(name='init.fields.1.annotation'), def"
        "ault=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('"
        "gateway_id',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields"
        "=(ReprPlan.Field(name='gateway_id', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='3dd2aca645dbc2b2649d807760268465d937e2f3',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'PropagatingVgw'),
    ),
)
def _process_dataclass__3dd2aca645dbc2b2649d807760268465d937e2f3():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                gateway_id=self.gateway_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.gateway_id == other.gateway_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'gateway_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'gateway_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.gateway_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            gateway_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'gateway_id', gateway_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"gateway_id={self.gateway_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('mode',)), EqPlan(fields=('mode',)), FrozenPlan(fields=('__shape__', 'mode'), allo"
        "w_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('mode',), cache=False), InitPlan(fields=(InitPla"
        "n.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='mode', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('mode',), frozen=True, slots=Fa"
        "lse, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='mode', kw_onl"
        "y=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='3e1414118d801b3653e991849c989db02da4f8ab',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'TracingConfigResponse'),
    ),
)
def _process_dataclass__3e1414118d801b3653e991849c989db02da4f8ab():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                mode=self.mode,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.mode == other.mode
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'mode',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'mode',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.mode,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            mode: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'mode', mode)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"mode={self.mode!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('http_tokens', 'http_put_response_hop_limit', 'http_endpoint', 'http_protocol_ipv6"
        "', 'instance_metadata_tags')), EqPlan(fields=('http_tokens', 'http_put_response_hop_limit', 'http_endpoint', '"
        "http_protocol_ipv6', 'instance_metadata_tags')), FrozenPlan(fields=('__shape__', 'http_tokens', 'http_put_resp"
        "onse_hop_limit', 'http_endpoint', 'http_protocol_ipv6', 'instance_metadata_tags'), allow_dynamic_dunder_attrs="
        "False), HashPlan(action='add', fields=('http_tokens', 'http_put_response_hop_limit', 'http_endpoint', 'http_pr"
        "otocol_ipv6', 'instance_metadata_tags'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annot"
        "ation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='http_tokens'"
        ", annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='http_put_response_hop_limit', annotation=OpRef(name='init.fields.2.annotation'), defa"
        "ult=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='http_endpoint', annotation=OpRef"
        "(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='http_protocol_ipv6', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields"
        ".4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='instance_metadata_tags', annotation=OpRef(name='init.fields"
        ".5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=("
        "), kw_only_params=('http_tokens', 'http_put_response_hop_limit', 'http_endpoint', 'http_protocol_ipv6', 'insta"
        "nce_metadata_tags'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan("
        "fields=(ReprPlan.Field(name='http_tokens', kw_only=True, fn=None), ReprPlan.Field(name='http_put_response_hop_"
        "limit', kw_only=True, fn=None), ReprPlan.Field(name='http_endpoint', kw_only=True, fn=None), ReprPlan.Field(na"
        "me='http_protocol_ipv6', kw_only=True, fn=None), ReprPlan.Field(name='instance_metadata_tags', kw_only=True, f"
        "n=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='3e4817a067658e230deaa09e6f1a8cc25225d31c',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceMetadataOptionsRequest'),
    ),
)
def _process_dataclass__3e4817a067658e230deaa09e6f1a8cc25225d31c():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                http_tokens=self.http_tokens,
                http_put_response_hop_limit=self.http_put_response_hop_limit,
                http_endpoint=self.http_endpoint,
                http_protocol_ipv6=self.http_protocol_ipv6,
                instance_metadata_tags=self.instance_metadata_tags,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.http_tokens == other.http_tokens and
                self.http_put_response_hop_limit == other.http_put_response_hop_limit and
                self.http_endpoint == other.http_endpoint and
                self.http_protocol_ipv6 == other.http_protocol_ipv6 and
                self.instance_metadata_tags == other.instance_metadata_tags
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'http_tokens',
            'http_put_response_hop_limit',
            'http_endpoint',
            'http_protocol_ipv6',
            'instance_metadata_tags',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'http_tokens',
            'http_put_response_hop_limit',
            'http_endpoint',
            'http_protocol_ipv6',
            'instance_metadata_tags',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.http_tokens,
                self.http_put_response_hop_limit,
                self.http_endpoint,
                self.http_protocol_ipv6,
                self.instance_metadata_tags,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            http_tokens: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            http_put_response_hop_limit: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            http_endpoint: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            http_protocol_ipv6: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            instance_metadata_tags: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'http_tokens', http_tokens)
            __dataclass__object_setattr(self, 'http_put_response_hop_limit', http_put_response_hop_limit)
            __dataclass__object_setattr(self, 'http_endpoint', http_endpoint)
            __dataclass__object_setattr(self, 'http_protocol_ipv6', http_protocol_ipv6)
            __dataclass__object_setattr(self, 'instance_metadata_tags', instance_metadata_tags)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"http_tokens={self.http_tokens!r}")
            parts.append(f"http_put_response_hop_limit={self.http_put_response_hop_limit!r}")
            parts.append(f"http_endpoint={self.http_endpoint!r}")
            parts.append(f"http_protocol_ipv6={self.http_protocol_ipv6!r}")
            parts.append(f"instance_metadata_tags={self.instance_metadata_tags!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('product_code_id', 'product_code_type')), EqPlan(fields=('product_code_id', 'produ"
        "ct_code_type')), FrozenPlan(fields=('__shape__', 'product_code_id', 'product_code_type'), allow_dynamic_dunder"
        "_attrs=False), HashPlan(action='add', fields=('product_code_id', 'product_code_type'), cache=False), InitPlan("
        "fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check"
        "_type=None), InitPlan.Field(name='product_code_id', annotation=OpRef(name='init.fields.1.annotation'), default"
        "=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
        "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='product_code_type', annotation=OpRe"
        "f(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='"
        "self', std_params=(), kw_only_params=('product_code_id', 'product_code_type'), frozen=True, slots=False, post_"
        "init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='product_code_id', kw_on"
        "ly=True, fn=None), ReprPlan.Field(name='product_code_type', kw_only=True, fn=None)), id=False, terse=False, de"
        "fault_fn=None)))"
    ),
    plan_repr_sha1='3e88e14547154097971278ad025811e2dd1154c4',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'ProductCode'),
    ),
)
def _process_dataclass__3e88e14547154097971278ad025811e2dd1154c4():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                product_code_id=self.product_code_id,
                product_code_type=self.product_code_type,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.product_code_id == other.product_code_id and
                self.product_code_type == other.product_code_type
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'product_code_id',
            'product_code_type',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'product_code_id',
            'product_code_type',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.product_code_id,
                self.product_code_type,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            product_code_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            product_code_type: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'product_code_id', product_code_id)
            __dataclass__object_setattr(self, 'product_code_type', product_code_type)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"product_code_id={self.product_code_id!r}")
            parts.append(f"product_code_type={self.product_code_type!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('count', 'version')), EqPlan(fields=('count', 'version')), FrozenPlan(fields=('__s"
        "hape__', 'count', 'version'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('count', 'vers"
        "ion'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.an"
        "notation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='count', annotation=OpRef(name='init.fields.1.a"
        "nnotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='version', annot"
        "ation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), se"
        "lf_param='self', std_params=(), kw_only_params=('count', 'version'), frozen=True, slots=False, post_init_param"
        "s=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='count', kw_only=True, fn=None), R"
        "eprPlan.Field(name='version', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='3fbe620c1e5b283d887815f698c446f82f447c36',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NeuronDeviceCoreInfo'),
    ),
)
def _process_dataclass__3fbe620c1e5b283d887815f698c446f82f447c36():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                count=self.count,
                version=self.version,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.count == other.count and
                self.version == other.version
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'count',
            'version',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'count',
            'version',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.count,
                self.version,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            count: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            version: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'count', count)
            __dataclass__object_setattr(self, 'version', version)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"count={self.count!r}")
            parts.append(f"version={self.version!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('display_name', 'i_d')), EqPlan(fields=('display_name', 'i_d')), FrozenPlan(fields"
        "=('__shape__', 'display_name', 'i_d'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('disp"
        "lay_name', 'i_d'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init"
        ".fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CL"
        "ASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='display_name', annotation=OpRef(na"
        "me='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='i_d', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None)), self_param='self', std_params=(), kw_only_params=('display_name', 'i_d'), frozen=True, slots=Fals"
        "e, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='display_name', "
        "kw_only=True, fn=None), ReprPlan.Field(name='i_d', kw_only=True, fn=None)), id=False, terse=False, default_fn="
        "None)))"
    ),
    plan_repr_sha1='406cda8dbd315809e1f63f385601152edbb21e83',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.s3', 'Owner'),
    ),
)
def _process_dataclass__406cda8dbd315809e1f63f385601152edbb21e83():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                display_name=self.display_name,
                i_d=self.i_d,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.display_name == other.display_name and
                self.i_d == other.i_d
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'display_name',
            'i_d',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'display_name',
            'i_d',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.display_name,
                self.i_d,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            display_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            i_d: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'display_name', display_name)
            __dataclass__object_setattr(self, 'i_d', i_d)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"display_name={self.display_name!r}")
            parts.append(f"i_d={self.i_d!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('description', 'cidr_ip')), EqPlan(fields=('description', 'cidr_ip')), FrozenPlan("
        "fields=('__shape__', 'description', 'cidr_ip'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fiel"
        "ds=('description', 'cidr_ip'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRe"
        "f(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type="
        "FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='description', annotati"
        "on=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='cidr_ip', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('description', 'cidr_ip'), froze"
        "n=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
        "e='description', kw_only=True, fn=None), ReprPlan.Field(name='cidr_ip', kw_only=True, fn=None)), id=False, ter"
        "se=False, default_fn=None)))"
    ),
    plan_repr_sha1='4660e5b1925be3722ad32bb3aa7b0aa078aa4ea0',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'IpRange'),
    ),
)
def _process_dataclass__4660e5b1925be3722ad32bb3aa7b0aa078aa4ea0():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                description=self.description,
                cidr_ip=self.cidr_ip,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.description == other.description and
                self.cidr_ip == other.cidr_ip
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'description',
            'cidr_ip',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'description',
            'cidr_ip',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.description,
                self.cidr_ip,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            description: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            cidr_ip: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'cidr_ip', cidr_ip)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"description={self.description!r}")
            parts.append(f"cidr_ip={self.cidr_ip!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('type', 'message')), EqPlan(fields=('type', 'message')), FrozenPlan(fields=('__sha"
        "pe__', 'type', 'message'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('type', 'message'"
        "), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annota"
        "tion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.1.annota"
        "tion'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='message', annotation"
        "=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_pa"
        "ram='self', std_params=(), kw_only_params=('type', 'message'), frozen=True, slots=False, post_init_params=None"
        ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='type', kw_only=True, fn=None), ReprPlan"
        ".Field(name='message', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='4727185bc15d0b892fa2952d4b56ab294b06b6b7',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'InvalidParameterValueException'),
        ('ominfra.clouds.aws.models.services.lambda_', 'ServiceException'),
    ),
)
def _process_dataclass__4727185bc15d0b892fa2952d4b56ab294b06b6b7():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                type=self.type,
                message=self.message,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.type == other.type and
                self.message == other.message
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'type',
            'message',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'type',
            'message',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.type,
                self.message,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'type', type)
            __dataclass__object_setattr(self, 'message', message)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"type={self.type!r}")
            parts.append(f"message={self.message!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('buckets', 'owner', 'continuation_token', 'prefix')), EqPlan(fields=('buckets', 'o"
        "wner', 'continuation_token', 'prefix')), FrozenPlan(fields=('__shape__', 'buckets', 'owner', 'continuation_tok"
        "en', 'prefix'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('buckets', 'owner', 'continu"
        "ation_token', 'prefix'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name"
        "='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='buckets', annotation=OpRef(n"
        "ame='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='owner', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), d"
        "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='continuation_token', annotation=OpRef(name='init.fields.3.annotation'), de"
        "fault=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='prefix', annotation=OpRef(name"
        "='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, ov"
        "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self',"
        " std_params=(), kw_only_params=('buckets', 'owner', 'continuation_token', 'prefix'), frozen=True, slots=False,"
        " post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='buckets', kw_only"
        "=True, fn=None), ReprPlan.Field(name='owner', kw_only=True, fn=None), ReprPlan.Field(name='continuation_token'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='prefix', kw_only=True, fn=None)), id=False, terse=False, defaul"
        "t_fn=None)))"
    ),
    plan_repr_sha1='49305ebba61e91e8f6d7f880182941b9410aa17a',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.s3', 'ListBucketsOutput'),
    ),
)
def _process_dataclass__49305ebba61e91e8f6d7f880182941b9410aa17a():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                buckets=self.buckets,
                owner=self.owner,
                continuation_token=self.continuation_token,
                prefix=self.prefix,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.buckets == other.buckets and
                self.owner == other.owner and
                self.continuation_token == other.continuation_token and
                self.prefix == other.prefix
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'buckets',
            'owner',
            'continuation_token',
            'prefix',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'buckets',
            'owner',
            'continuation_token',
            'prefix',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.buckets,
                self.owner,
                self.continuation_token,
                self.prefix,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            buckets: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            owner: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            continuation_token: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            prefix: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'buckets', buckets)
            __dataclass__object_setattr(self, 'owner', owner)
            __dataclass__object_setattr(self, 'continuation_token', continuation_token)
            __dataclass__object_setattr(self, 'prefix', prefix)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"buckets={self.buckets!r}")
            parts.append(f"owner={self.owner!r}")
            parts.append(f"continuation_token={self.continuation_token!r}")
            parts.append(f"prefix={self.prefix!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('code', 'message')), EqPlan(fields=('code', 'message')), FrozenPlan(fields=('__sha"
        "pe__', 'code', 'message'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('code', 'message'"
        "), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annota"
        "tion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='code', annotation=OpRef(name='init.fields.1.annota"
        "tion'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='message', annotation"
        "=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_pa"
        "ram='self', std_params=(), kw_only_params=('code', 'message'), frozen=True, slots=False, post_init_params=None"
        ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='code', kw_only=True, fn=None), ReprPlan"
        ".Field(name='message', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='498779f0c9503dc1e5e39f1a2c431bda47dbae98',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'StateReason'),
    ),
)
def _process_dataclass__498779f0c9503dc1e5e39f1a2c431bda47dbae98():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                code=self.code,
                message=self.message,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.code == other.code and
                self.message == other.message
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'code',
            'message',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'code',
            'message',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.code,
                self.message,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            code: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'code', code)
            __dataclass__object_setattr(self, 'message', message)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"code={self.code!r}")
            parts.append(f"message={self.message!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('key_pairs',)), EqPlan(fields=('key_pairs',)), FrozenPlan(fields=('__shape__', 'ke"
        "y_pairs'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('key_pairs',), cache=False), Init"
        "Plan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None,"
        " default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='key_pairs', annotation=OpRef(name='init.fields.1.annotation'), default="
        "OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('key_p"
        "airs',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Repr"
        "Plan.Field(name='key_pairs', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='4b49492b20c45bb1a0965b2b0e07bf000df295d7',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeKeyPairsResult'),
    ),
)
def _process_dataclass__4b49492b20c45bb1a0965b2b0e07bf000df295d7():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                key_pairs=self.key_pairs,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.key_pairs == other.key_pairs
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'key_pairs',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'key_pairs',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.key_pairs,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            key_pairs: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'key_pairs', key_pairs)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"key_pairs={self.key_pairs!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('reservation_id', 'owner_id', 'requester_id', 'groups', 'instances')), EqPlan(fiel"
        "ds=('reservation_id', 'owner_id', 'requester_id', 'groups', 'instances')), FrozenPlan(fields=('__shape__', 're"
        "servation_id', 'owner_id', 'requester_id', 'groups', 'instances'), allow_dynamic_dunder_attrs=False), HashPlan"
        "(action='add', fields=('reservation_id', 'owner_id', 'requester_id', 'groups', 'instances'), cache=False), Ini"
        "tPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None"
        ", default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='reservation_id', annotation=OpRef(name='init.fields.1.annotation'), de"
        "fault=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='owner_id', annotation=OpRef(na"
        "me='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='requester_id', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='groups', annotation=OpRef(name='init.fields.4.annotation'), default="
        "OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instances', annotation=OpRef(name='i"
        "nit.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', st"
        "d_params=(), kw_only_params=('reservation_id', 'owner_id', 'requester_id', 'groups', 'instances'), frozen=True"
        ", slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='res"
        "ervation_id', kw_only=True, fn=None), ReprPlan.Field(name='owner_id', kw_only=True, fn=None), ReprPlan.Field(n"
        "ame='requester_id', kw_only=True, fn=None), ReprPlan.Field(name='groups', kw_only=True, fn=None), ReprPlan.Fie"
        "ld(name='instances', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='4dcdc31a11266b0f3715b509ae10ced769c8d571',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Reservation'),
    ),
)
def _process_dataclass__4dcdc31a11266b0f3715b509ae10ced769c8d571():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                reservation_id=self.reservation_id,
                owner_id=self.owner_id,
                requester_id=self.requester_id,
                groups=self.groups,
                instances=self.instances,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.reservation_id == other.reservation_id and
                self.owner_id == other.owner_id and
                self.requester_id == other.requester_id and
                self.groups == other.groups and
                self.instances == other.instances
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'reservation_id',
            'owner_id',
            'requester_id',
            'groups',
            'instances',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'reservation_id',
            'owner_id',
            'requester_id',
            'groups',
            'instances',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.reservation_id,
                self.owner_id,
                self.requester_id,
                self.groups,
                self.instances,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            reservation_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            owner_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            requester_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            groups: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            instances: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'reservation_id', reservation_id)
            __dataclass__object_setattr(self, 'owner_id', owner_id)
            __dataclass__object_setattr(self, 'requester_id', requester_id)
            __dataclass__object_setattr(self, 'groups', groups)
            __dataclass__object_setattr(self, 'instances', instances)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"reservation_id={self.reservation_id!r}")
            parts.append(f"owner_id={self.owner_id!r}")
            parts.append(f"requester_id={self.requester_id!r}")
            parts.append(f"groups={self.groups!r}")
            parts.append(f"instances={self.instances!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('count', 'name', 'core_info', 'memory_info')), EqPlan(fields=('count', 'name', 'co"
        "re_info', 'memory_info')), FrozenPlan(fields=('__shape__', 'count', 'name', 'core_info', 'memory_info'), allow"
        "_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('count', 'name', 'core_info', 'memory_info'), cac"
        "he=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation')"
        ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='count', annotation=OpRef(name='init.fields.1.annotation'"
        "), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(n"
        "ame='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='core_info', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='memory_info', annotation=OpRef(name='init.fields.4.annotation'), defau"
        "lt=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType."
        "INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('co"
        "unt', 'name', 'core_info', 'memory_info'), frozen=True, slots=False, post_init_params=None, init_fns=(), valid"
        "ate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='count', kw_only=True, fn=None), ReprPlan.Field(name='name',"
        " kw_only=True, fn=None), ReprPlan.Field(name='core_info', kw_only=True, fn=None), ReprPlan.Field(name='memory_"
        "info', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='4e1bc1b87764803cdd93079441753724a6ce4e6e',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NeuronDeviceInfo'),
    ),
)
def _process_dataclass__4e1bc1b87764803cdd93079441753724a6ce4e6e():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                count=self.count,
                name=self.name,
                core_info=self.core_info,
                memory_info=self.memory_info,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.count == other.count and
                self.name == other.name and
                self.core_info == other.core_info and
                self.memory_info == other.memory_info
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'count',
            'name',
            'core_info',
            'memory_info',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'count',
            'name',
            'core_info',
            'memory_info',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.count,
                self.name,
                self.core_info,
                self.memory_info,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            count: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            core_info: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            memory_info: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'count', count)
            __dataclass__object_setattr(self, 'name', name)
            __dataclass__object_setattr(self, 'core_info', core_info)
            __dataclass__object_setattr(self, 'memory_info', memory_info)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"count={self.count!r}")
            parts.append(f"name={self.name!r}")
            parts.append(f"core_info={self.core_info!r}")
            parts.append(f"memory_info={self.memory_info!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('prefix',)), EqPlan(fields=('prefix',)), FrozenPlan(fields=('__shape__', 'prefix')"
        ", allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('prefix',), cache=False), InitPlan(fields="
        "(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=N"
        "one), InitPlan.Field(name='prefix', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='ini"
        "t.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
        "one, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('prefix',), frozen=Tr"
        "ue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='p"
        "refix', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='50832bf2c74ab08578a3f9566ba6bd3f114aa4fd',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.s3', 'CommonPrefix'),
    ),
)
def _process_dataclass__50832bf2c74ab08578a3f9566ba6bd3f114aa4fd():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                prefix=self.prefix,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.prefix == other.prefix
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'prefix',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'prefix',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.prefix,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            prefix: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'prefix', prefix)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"prefix={self.prefix!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('baseline_bandwidth_in_mbips', 'baseline_throughput_in_mbps', 'baseline_iops', 'ma"
        "ximum_bandwidth_in_mbips', 'maximum_throughput_in_mbps', 'maximum_iops')), EqPlan(fields=('baseline_bandwidth_"
        "in_mbips', 'baseline_throughput_in_mbps', 'baseline_iops', 'maximum_bandwidth_in_mbips', 'maximum_throughput_i"
        "n_mbps', 'maximum_iops')), FrozenPlan(fields=('__shape__', 'baseline_bandwidth_in_mbips', 'baseline_throughput"
        "_in_mbps', 'baseline_iops', 'maximum_bandwidth_in_mbips', 'maximum_throughput_in_mbps', 'maximum_iops'), allow"
        "_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('baseline_bandwidth_in_mbips', 'baseline_throughp"
        "ut_in_mbps', 'baseline_iops', 'maximum_bandwidth_in_mbips', 'maximum_throughput_in_mbps', 'maximum_iops'), cac"
        "he=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation')"
        ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='baseline_bandwidth_in_mbips', annotation=OpRef(name='ini"
        "t.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='bas"
        "eline_throughput_in_mbps', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields."
        "2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='baseline_iops', annotation=OpRef(name='init.fields.3.annotat"
        "ion'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maximum_bandwidth_in_"
        "mbips', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), defaul"
        "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
        "pe=None), InitPlan.Field(name='maximum_throughput_in_mbps', annotation=OpRef(name='init.fields.5.annotation'),"
        " default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maximum_iops', annotation=O"
        "pRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init"
        "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_para"
        "m='self', std_params=(), kw_only_params=('baseline_bandwidth_in_mbips', 'baseline_throughput_in_mbps', 'baseli"
        "ne_iops', 'maximum_bandwidth_in_mbips', 'maximum_throughput_in_mbps', 'maximum_iops'), frozen=True, slots=Fals"
        "e, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='baseline_bandwi"
        "dth_in_mbips', kw_only=True, fn=None), ReprPlan.Field(name='baseline_throughput_in_mbps', kw_only=True, fn=Non"
        "e), ReprPlan.Field(name='baseline_iops', kw_only=True, fn=None), ReprPlan.Field(name='maximum_bandwidth_in_mbi"
        "ps', kw_only=True, fn=None), ReprPlan.Field(name='maximum_throughput_in_mbps', kw_only=True, fn=None), ReprPla"
        "n.Field(name='maximum_iops', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='51006c1b622c9ec07035558b55fb10d01681ba12',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'EbsOptimizedInfo'),
    ),
)
def _process_dataclass__51006c1b622c9ec07035558b55fb10d01681ba12():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                baseline_bandwidth_in_mbips=self.baseline_bandwidth_in_mbips,
                baseline_throughput_in_mbps=self.baseline_throughput_in_mbps,
                baseline_iops=self.baseline_iops,
                maximum_bandwidth_in_mbips=self.maximum_bandwidth_in_mbips,
                maximum_throughput_in_mbps=self.maximum_throughput_in_mbps,
                maximum_iops=self.maximum_iops,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.baseline_bandwidth_in_mbips == other.baseline_bandwidth_in_mbips and
                self.baseline_throughput_in_mbps == other.baseline_throughput_in_mbps and
                self.baseline_iops == other.baseline_iops and
                self.maximum_bandwidth_in_mbips == other.maximum_bandwidth_in_mbips and
                self.maximum_throughput_in_mbps == other.maximum_throughput_in_mbps and
                self.maximum_iops == other.maximum_iops
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'baseline_bandwidth_in_mbips',
            'baseline_throughput_in_mbps',
            'baseline_iops',
            'maximum_bandwidth_in_mbips',
            'maximum_throughput_in_mbps',
            'maximum_iops',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'baseline_bandwidth_in_mbips',
            'baseline_throughput_in_mbps',
            'baseline_iops',
            'maximum_bandwidth_in_mbips',
            'maximum_throughput_in_mbps',
            'maximum_iops',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.baseline_bandwidth_in_mbips,
                self.baseline_throughput_in_mbps,
                self.baseline_iops,
                self.maximum_bandwidth_in_mbips,
                self.maximum_throughput_in_mbps,
                self.maximum_iops,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            baseline_bandwidth_in_mbips: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            baseline_throughput_in_mbps: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            baseline_iops: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            maximum_bandwidth_in_mbips: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            maximum_throughput_in_mbps: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            maximum_iops: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'baseline_bandwidth_in_mbips', baseline_bandwidth_in_mbips)
            __dataclass__object_setattr(self, 'baseline_throughput_in_mbps', baseline_throughput_in_mbps)
            __dataclass__object_setattr(self, 'baseline_iops', baseline_iops)
            __dataclass__object_setattr(self, 'maximum_bandwidth_in_mbips', maximum_bandwidth_in_mbips)
            __dataclass__object_setattr(self, 'maximum_throughput_in_mbps', maximum_throughput_in_mbps)
            __dataclass__object_setattr(self, 'maximum_iops', maximum_iops)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"baseline_bandwidth_in_mbips={self.baseline_bandwidth_in_mbips!r}")
            parts.append(f"baseline_throughput_in_mbps={self.baseline_throughput_in_mbps!r}")
            parts.append(f"baseline_iops={self.baseline_iops!r}")
            parts.append(f"maximum_bandwidth_in_mbips={self.maximum_bandwidth_in_mbips!r}")
            parts.append(f"maximum_throughput_in_mbps={self.maximum_throughput_in_mbps!r}")
            parts.append(f"maximum_iops={self.maximum_iops!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('acl', 'body', 'bucket', 'cache_control', 'content_disposition', 'content_encoding"
        "', 'content_language', 'content_length', 'content_md5', 'content_type', 'checksum_algorithm', 'checksum_crc32'"
        ", 'checksum_crc32c', 'checksum_crc64_nvme', 'checksum_sha1', 'checksum_sha256', 'expires', 'if_match', 'if_non"
        "e_match', 'grant_full_control', 'grant_read', 'grant_read_acp', 'grant_write_acp', 'key', 'write_offset_bytes'"
        ", 'metadata', 'server_side_encryption', 'storage_class', 'website_redirect_location', 'sse_customer_algorithm'"
        ", 'sse_customer_key', 'sse_customer_key_md5', 'sse_kms_key_id', 'sse_kms_encryption_context', 'bucket_key_enab"
        "led', 'request_payer', 'tagging', 'object_lock_mode', 'object_lock_retain_until_date', 'object_lock_legal_hold"
        "_status', 'expected_bucket_owner')), EqPlan(fields=('acl', 'body', 'bucket', 'cache_control', 'content_disposi"
        "tion', 'content_encoding', 'content_language', 'content_length', 'content_md5', 'content_type', 'checksum_algo"
        "rithm', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc64_nvme', 'checksum_sha1', 'checksum_sha256', 'expir"
        "es', 'if_match', 'if_none_match', 'grant_full_control', 'grant_read', 'grant_read_acp', 'grant_write_acp', 'ke"
        "y', 'write_offset_bytes', 'metadata', 'server_side_encryption', 'storage_class', 'website_redirect_location', "
        "'sse_customer_algorithm', 'sse_customer_key', 'sse_customer_key_md5', 'sse_kms_key_id', 'sse_kms_encryption_co"
        "ntext', 'bucket_key_enabled', 'request_payer', 'tagging', 'object_lock_mode', 'object_lock_retain_until_date',"
        " 'object_lock_legal_hold_status', 'expected_bucket_owner')), FrozenPlan(fields=('__shape__', 'acl', 'body', 'b"
        "ucket', 'cache_control', 'content_disposition', 'content_encoding', 'content_language', 'content_length', 'con"
        "tent_md5', 'content_type', 'checksum_algorithm', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc64_nvme', '"
        "checksum_sha1', 'checksum_sha256', 'expires', 'if_match', 'if_none_match', 'grant_full_control', 'grant_read',"
        " 'grant_read_acp', 'grant_write_acp', 'key', 'write_offset_bytes', 'metadata', 'server_side_encryption', 'stor"
        "age_class', 'website_redirect_location', 'sse_customer_algorithm', 'sse_customer_key', 'sse_customer_key_md5',"
        " 'sse_kms_key_id', 'sse_kms_encryption_context', 'bucket_key_enabled', 'request_payer', 'tagging', 'object_loc"
        "k_mode', 'object_lock_retain_until_date', 'object_lock_legal_hold_status', 'expected_bucket_owner'), allow_dyn"
        "amic_dunder_attrs=False), HashPlan(action='add', fields=('acl', 'body', 'bucket', 'cache_control', 'content_di"
        "sposition', 'content_encoding', 'content_language', 'content_length', 'content_md5', 'content_type', 'checksum"
        "_algorithm', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc64_nvme', 'checksum_sha1', 'checksum_sha256', '"
        "expires', 'if_match', 'if_none_match', 'grant_full_control', 'grant_read', 'grant_read_acp', 'grant_write_acp'"
        ", 'key', 'write_offset_bytes', 'metadata', 'server_side_encryption', 'storage_class', 'website_redirect_locati"
        "on', 'sse_customer_algorithm', 'sse_customer_key', 'sse_customer_key_md5', 'sse_kms_key_id', 'sse_kms_encrypti"
        "on_context', 'bucket_key_enabled', 'request_payer', 'tagging', 'object_lock_mode', 'object_lock_retain_until_d"
        "ate', 'object_lock_legal_hold_status', 'expected_bucket_owner'), cache=False), InitPlan(fields=(InitPlan.Field"
        "(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init"
        "=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='acl', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default"
        "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
        ", check_type=None), InitPlan.Field(name='body', annotation=OpRef(name='init.fields.2.annotation'), default=OpR"
        "ef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='bucket', annotation=OpRef(name='init.fi"
        "elds.3.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
        "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cache_control', annotation=OpRef(name="
        "'init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
        "'content_disposition', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.de"
        "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
        "=None, check_type=None), InitPlan.Field(name='content_encoding', annotation=OpRef(name='init.fields.6.annotati"
        "on'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type"
        "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='content_language', ann"
        "otation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='content_length', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='in"
        "it.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='content_md5', annotation=OpRef(name='init.fields.9"
        ".annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='content_type'"
        ", annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_fa"
        "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
        "one), InitPlan.Field(name='checksum_algorithm', annotation=OpRef(name='init.fields.11.annotation'), default=Op"
        "Ref(name='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='checksum_crc32', annotation=OpRef(nam"
        "e='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='checksum_crc32c', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='checksum_crc64_nvme', annotation=OpRef(name='init.fields.14.an"
        "notation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='checksum_sha1',"
        " annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='checksum_sha256', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef("
        "name='init.fields.16.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='expires', annotation=OpRef(name='init.fie"
        "lds.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=True, override=F"
        "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='if_mat"
        "ch', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.18.default'), default"
        "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='if_none_match', annotation=OpRef(name='init.fields.19.annotation'), default=OpRe"
        "f(name='init.fields.19.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='grant_full_control', annotation=OpRef(n"
        "ame='init.fields.20.annotation'), default=OpRef(name='init.fields.20.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='grant_read', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='init.fields.21.def"
        "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
        "None, check_type=None), InitPlan.Field(name='grant_read_acp', annotation=OpRef(name='init.fields.22.annotation"
        "'), default=OpRef(name='init.fields.22.default'), default_factory=None, init=True, override=False, field_type="
        "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='grant_write_acp', annot"
        "ation=OpRef(name='init.fields.23.annotation'), default=OpRef(name='init.fields.23.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='key', annotation=OpRef(name='init.fields.24.annotation'), default=None, default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='write_offset_bytes', annotation=OpRef(name='init.fields.25.annotation'), default=OpRef(name"
        "='init.fields.25.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='metadata', annotation=OpRef(name='init.fields"
        ".26.annotation'), default=OpRef(name='init.fields.26.default'), default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='server_si"
        "de_encryption', annotation=OpRef(name='init.fields.27.annotation'), default=OpRef(name='init.fields.27.default"
        "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
        ", check_type=None), InitPlan.Field(name='storage_class', annotation=OpRef(name='init.fields.28.annotation'), d"
        "efault=OpRef(name='init.fields.28.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='website_redirect_location', "
        "annotation=OpRef(name='init.fields.29.annotation'), default=OpRef(name='init.fields.29.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='sse_customer_algorithm', annotation=OpRef(name='init.fields.30.annotation'), default="
        "OpRef(name='init.fields.30.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
        "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='sse_customer_key', annotation=OpRef"
        "(name='init.fields.31.annotation'), default=OpRef(name='init.fields.31.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
        "ld(name='sse_customer_key_md5', annotation=OpRef(name='init.fields.32.annotation'), default=OpRef(name='init.f"
        "ields.32.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
        "e, validate=None, check_type=None), InitPlan.Field(name='sse_kms_key_id', annotation=OpRef(name='init.fields.3"
        "3.annotation'), default=OpRef(name='init.fields.33.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='sse_kms_enc"
        "ryption_context', annotation=OpRef(name='init.fields.34.annotation'), default=OpRef(name='init.fields.34.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='bucket_key_enabled', annotation=OpRef(name='init.fields.35.annotati"
        "on'), default=OpRef(name='init.fields.35.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='request_payer', annot"
        "ation=OpRef(name='init.fields.36.annotation'), default=OpRef(name='init.fields.36.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='tagging', annotation=OpRef(name='init.fields.37.annotation'), default=OpRef(name='init.fie"
        "lds.37.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='object_lock_mode', annotation=OpRef(name='init.fields.3"
        "8.annotation'), default=OpRef(name='init.fields.38.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='object_lock"
        "_retain_until_date', annotation=OpRef(name='init.fields.39.annotation'), default=OpRef(name='init.fields.39.de"
        "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
        "=None, check_type=None), InitPlan.Field(name='object_lock_legal_hold_status', annotation=OpRef(name='init.fiel"
        "ds.40.annotation'), default=OpRef(name='init.fields.40.default'), default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='expecte"
        "d_bucket_owner', annotation=OpRef(name='init.fields.41.annotation'), default=OpRef(name='init.fields.41.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None)), self_param='self', std_params=(), kw_only_params=('acl', 'body', 'bucket', 'cache_contro"
        "l', 'content_disposition', 'content_encoding', 'content_language', 'content_length', 'content_md5', 'content_t"
        "ype', 'checksum_algorithm', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc64_nvme', 'checksum_sha1', 'chec"
        "ksum_sha256', 'expires', 'if_match', 'if_none_match', 'grant_full_control', 'grant_read', 'grant_read_acp', 'g"
        "rant_write_acp', 'key', 'write_offset_bytes', 'metadata', 'server_side_encryption', 'storage_class', 'website_"
        "redirect_location', 'sse_customer_algorithm', 'sse_customer_key', 'sse_customer_key_md5', 'sse_kms_key_id', 's"
        "se_kms_encryption_context', 'bucket_key_enabled', 'request_payer', 'tagging', 'object_lock_mode', 'object_lock"
        "_retain_until_date', 'object_lock_legal_hold_status', 'expected_bucket_owner'), frozen=True, slots=False, post"
        "_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='acl', kw_only=True, fn"
        "=None), ReprPlan.Field(name='body', kw_only=True, fn=None), ReprPlan.Field(name='bucket', kw_only=True, fn=Non"
        "e), ReprPlan.Field(name='cache_control', kw_only=True, fn=None), ReprPlan.Field(name='content_disposition', kw"
        "_only=True, fn=None), ReprPlan.Field(name='content_encoding', kw_only=True, fn=None), ReprPlan.Field(name='con"
        "tent_language', kw_only=True, fn=None), ReprPlan.Field(name='content_length', kw_only=True, fn=None), ReprPlan"
        ".Field(name='content_md5', kw_only=True, fn=None), ReprPlan.Field(name='content_type', kw_only=True, fn=None),"
        " ReprPlan.Field(name='checksum_algorithm', kw_only=True, fn=None), ReprPlan.Field(name='checksum_crc32', kw_on"
        "ly=True, fn=None), ReprPlan.Field(name='checksum_crc32c', kw_only=True, fn=None), ReprPlan.Field(name='checksu"
        "m_crc64_nvme', kw_only=True, fn=None), ReprPlan.Field(name='checksum_sha1', kw_only=True, fn=None), ReprPlan.F"
        "ield(name='checksum_sha256', kw_only=True, fn=None), ReprPlan.Field(name='expires', kw_only=True, fn=None), Re"
        "prPlan.Field(name='if_match', kw_only=True, fn=None), ReprPlan.Field(name='if_none_match', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='grant_full_control', kw_only=True, fn=None), ReprPlan.Field(name='grant_read', kw_on"
        "ly=True, fn=None), ReprPlan.Field(name='grant_read_acp', kw_only=True, fn=None), ReprPlan.Field(name='grant_wr"
        "ite_acp', kw_only=True, fn=None), ReprPlan.Field(name='key', kw_only=True, fn=None), ReprPlan.Field(name='writ"
        "e_offset_bytes', kw_only=True, fn=None), ReprPlan.Field(name='metadata', kw_only=True, fn=None), ReprPlan.Fiel"
        "d(name='server_side_encryption', kw_only=True, fn=None), ReprPlan.Field(name='storage_class', kw_only=True, fn"
        "=None), ReprPlan.Field(name='website_redirect_location', kw_only=True, fn=None), ReprPlan.Field(name='sse_cust"
        "omer_algorithm', kw_only=True, fn=None), ReprPlan.Field(name='sse_customer_key', kw_only=True, fn=None), ReprP"
        "lan.Field(name='sse_customer_key_md5', kw_only=True, fn=None), ReprPlan.Field(name='sse_kms_key_id', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='sse_kms_encryption_context', kw_only=True, fn=None), ReprPlan.Field(name='"
        "bucket_key_enabled', kw_only=True, fn=None), ReprPlan.Field(name='request_payer', kw_only=True, fn=None), Repr"
        "Plan.Field(name='tagging', kw_only=True, fn=None), ReprPlan.Field(name='object_lock_mode', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='object_lock_retain_until_date', kw_only=True, fn=None), ReprPlan.Field(name='object_"
        "lock_legal_hold_status', kw_only=True, fn=None), ReprPlan.Field(name='expected_bucket_owner', kw_only=True, fn"
        "=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='535e96529b1f67744a3e847d23f0a2d66f777a4e',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__24__annotation',
        '__dataclass__init__fields__25__annotation',
        '__dataclass__init__fields__25__default',
        '__dataclass__init__fields__26__annotation',
        '__dataclass__init__fields__26__default',
        '__dataclass__init__fields__27__annotation',
        '__dataclass__init__fields__27__default',
        '__dataclass__init__fields__28__annotation',
        '__dataclass__init__fields__28__default',
        '__dataclass__init__fields__29__annotation',
        '__dataclass__init__fields__29__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__30__annotation',
        '__dataclass__init__fields__30__default',
        '__dataclass__init__fields__31__annotation',
        '__dataclass__init__fields__31__default',
        '__dataclass__init__fields__32__annotation',
        '__dataclass__init__fields__32__default',
        '__dataclass__init__fields__33__annotation',
        '__dataclass__init__fields__33__default',
        '__dataclass__init__fields__34__annotation',
        '__dataclass__init__fields__34__default',
        '__dataclass__init__fields__35__annotation',
        '__dataclass__init__fields__35__default',
        '__dataclass__init__fields__36__annotation',
        '__dataclass__init__fields__36__default',
        '__dataclass__init__fields__37__annotation',
        '__dataclass__init__fields__37__default',
        '__dataclass__init__fields__38__annotation',
        '__dataclass__init__fields__38__default',
        '__dataclass__init__fields__39__annotation',
        '__dataclass__init__fields__39__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__40__annotation',
        '__dataclass__init__fields__40__default',
        '__dataclass__init__fields__41__annotation',
        '__dataclass__init__fields__41__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.s3', 'PutObjectRequest'),
    ),
)
def _process_dataclass__535e96529b1f67744a3e847d23f0a2d66f777a4e():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__24__annotation,
        __dataclass__init__fields__25__annotation,
        __dataclass__init__fields__25__default,
        __dataclass__init__fields__26__annotation,
        __dataclass__init__fields__26__default,
        __dataclass__init__fields__27__annotation,
        __dataclass__init__fields__27__default,
        __dataclass__init__fields__28__annotation,
        __dataclass__init__fields__28__default,
        __dataclass__init__fields__29__annotation,
        __dataclass__init__fields__29__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__30__annotation,
        __dataclass__init__fields__30__default,
        __dataclass__init__fields__31__annotation,
        __dataclass__init__fields__31__default,
        __dataclass__init__fields__32__annotation,
        __dataclass__init__fields__32__default,
        __dataclass__init__fields__33__annotation,
        __dataclass__init__fields__33__default,
        __dataclass__init__fields__34__annotation,
        __dataclass__init__fields__34__default,
        __dataclass__init__fields__35__annotation,
        __dataclass__init__fields__35__default,
        __dataclass__init__fields__36__annotation,
        __dataclass__init__fields__36__default,
        __dataclass__init__fields__37__annotation,
        __dataclass__init__fields__37__default,
        __dataclass__init__fields__38__annotation,
        __dataclass__init__fields__38__default,
        __dataclass__init__fields__39__annotation,
        __dataclass__init__fields__39__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__40__annotation,
        __dataclass__init__fields__40__default,
        __dataclass__init__fields__41__annotation,
        __dataclass__init__fields__41__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                acl=self.acl,
                body=self.body,
                bucket=self.bucket,
                cache_control=self.cache_control,
                content_disposition=self.content_disposition,
                content_encoding=self.content_encoding,
                content_language=self.content_language,
                content_length=self.content_length,
                content_md5=self.content_md5,
                content_type=self.content_type,
                checksum_algorithm=self.checksum_algorithm,
                checksum_crc32=self.checksum_crc32,
                checksum_crc32c=self.checksum_crc32c,
                checksum_crc64_nvme=self.checksum_crc64_nvme,
                checksum_sha1=self.checksum_sha1,
                checksum_sha256=self.checksum_sha256,
                expires=self.expires,
                if_match=self.if_match,
                if_none_match=self.if_none_match,
                grant_full_control=self.grant_full_control,
                grant_read=self.grant_read,
                grant_read_acp=self.grant_read_acp,
                grant_write_acp=self.grant_write_acp,
                key=self.key,
                write_offset_bytes=self.write_offset_bytes,
                metadata=self.metadata,
                server_side_encryption=self.server_side_encryption,
                storage_class=self.storage_class,
                website_redirect_location=self.website_redirect_location,
                sse_customer_algorithm=self.sse_customer_algorithm,
                sse_customer_key=self.sse_customer_key,
                sse_customer_key_md5=self.sse_customer_key_md5,
                sse_kms_key_id=self.sse_kms_key_id,
                sse_kms_encryption_context=self.sse_kms_encryption_context,
                bucket_key_enabled=self.bucket_key_enabled,
                request_payer=self.request_payer,
                tagging=self.tagging,
                object_lock_mode=self.object_lock_mode,
                object_lock_retain_until_date=self.object_lock_retain_until_date,
                object_lock_legal_hold_status=self.object_lock_legal_hold_status,
                expected_bucket_owner=self.expected_bucket_owner,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.acl == other.acl and
                self.body == other.body and
                self.bucket == other.bucket and
                self.cache_control == other.cache_control and
                self.content_disposition == other.content_disposition and
                self.content_encoding == other.content_encoding and
                self.content_language == other.content_language and
                self.content_length == other.content_length and
                self.content_md5 == other.content_md5 and
                self.content_type == other.content_type and
                self.checksum_algorithm == other.checksum_algorithm and
                self.checksum_crc32 == other.checksum_crc32 and
                self.checksum_crc32c == other.checksum_crc32c and
                self.checksum_crc64_nvme == other.checksum_crc64_nvme and
                self.checksum_sha1 == other.checksum_sha1 and
                self.checksum_sha256 == other.checksum_sha256 and
                self.expires == other.expires and
                self.if_match == other.if_match and
                self.if_none_match == other.if_none_match and
                self.grant_full_control == other.grant_full_control and
                self.grant_read == other.grant_read and
                self.grant_read_acp == other.grant_read_acp and
                self.grant_write_acp == other.grant_write_acp and
                self.key == other.key and
                self.write_offset_bytes == other.write_offset_bytes and
                self.metadata == other.metadata and
                self.server_side_encryption == other.server_side_encryption and
                self.storage_class == other.storage_class and
                self.website_redirect_location == other.website_redirect_location and
                self.sse_customer_algorithm == other.sse_customer_algorithm and
                self.sse_customer_key == other.sse_customer_key and
                self.sse_customer_key_md5 == other.sse_customer_key_md5 and
                self.sse_kms_key_id == other.sse_kms_key_id and
                self.sse_kms_encryption_context == other.sse_kms_encryption_context and
                self.bucket_key_enabled == other.bucket_key_enabled and
                self.request_payer == other.request_payer and
                self.tagging == other.tagging and
                self.object_lock_mode == other.object_lock_mode and
                self.object_lock_retain_until_date == other.object_lock_retain_until_date and
                self.object_lock_legal_hold_status == other.object_lock_legal_hold_status and
                self.expected_bucket_owner == other.expected_bucket_owner
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'acl',
            'body',
            'bucket',
            'cache_control',
            'content_disposition',
            'content_encoding',
            'content_language',
            'content_length',
            'content_md5',
            'content_type',
            'checksum_algorithm',
            'checksum_crc32',
            'checksum_crc32c',
            'checksum_crc64_nvme',
            'checksum_sha1',
            'checksum_sha256',
            'expires',
            'if_match',
            'if_none_match',
            'grant_full_control',
            'grant_read',
            'grant_read_acp',
            'grant_write_acp',
            'key',
            'write_offset_bytes',
            'metadata',
            'server_side_encryption',
            'storage_class',
            'website_redirect_location',
            'sse_customer_algorithm',
            'sse_customer_key',
            'sse_customer_key_md5',
            'sse_kms_key_id',
            'sse_kms_encryption_context',
            'bucket_key_enabled',
            'request_payer',
            'tagging',
            'object_lock_mode',
            'object_lock_retain_until_date',
            'object_lock_legal_hold_status',
            'expected_bucket_owner',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'acl',
            'body',
            'bucket',
            'cache_control',
            'content_disposition',
            'content_encoding',
            'content_language',
            'content_length',
            'content_md5',
            'content_type',
            'checksum_algorithm',
            'checksum_crc32',
            'checksum_crc32c',
            'checksum_crc64_nvme',
            'checksum_sha1',
            'checksum_sha256',
            'expires',
            'if_match',
            'if_none_match',
            'grant_full_control',
            'grant_read',
            'grant_read_acp',
            'grant_write_acp',
            'key',
            'write_offset_bytes',
            'metadata',
            'server_side_encryption',
            'storage_class',
            'website_redirect_location',
            'sse_customer_algorithm',
            'sse_customer_key',
            'sse_customer_key_md5',
            'sse_kms_key_id',
            'sse_kms_encryption_context',
            'bucket_key_enabled',
            'request_payer',
            'tagging',
            'object_lock_mode',
            'object_lock_retain_until_date',
            'object_lock_legal_hold_status',
            'expected_bucket_owner',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.acl,
                self.body,
                self.bucket,
                self.cache_control,
                self.content_disposition,
                self.content_encoding,
                self.content_language,
                self.content_length,
                self.content_md5,
                self.content_type,
                self.checksum_algorithm,
                self.checksum_crc32,
                self.checksum_crc32c,
                self.checksum_crc64_nvme,
                self.checksum_sha1,
                self.checksum_sha256,
                self.expires,
                self.if_match,
                self.if_none_match,
                self.grant_full_control,
                self.grant_read,
                self.grant_read_acp,
                self.grant_write_acp,
                self.key,
                self.write_offset_bytes,
                self.metadata,
                self.server_side_encryption,
                self.storage_class,
                self.website_redirect_location,
                self.sse_customer_algorithm,
                self.sse_customer_key,
                self.sse_customer_key_md5,
                self.sse_kms_key_id,
                self.sse_kms_encryption_context,
                self.bucket_key_enabled,
                self.request_payer,
                self.tagging,
                self.object_lock_mode,
                self.object_lock_retain_until_date,
                self.object_lock_legal_hold_status,
                self.expected_bucket_owner,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            acl: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            body: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            bucket: __dataclass__init__fields__3__annotation,
            cache_control: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            content_disposition: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            content_encoding: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            content_language: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            content_length: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            content_md5: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            content_type: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            checksum_algorithm: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            checksum_crc32: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            checksum_crc32c: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            checksum_crc64_nvme: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            checksum_sha1: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            checksum_sha256: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            expires: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            if_match: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            if_none_match: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            grant_full_control: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            grant_read: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            grant_read_acp: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            grant_write_acp: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
            key: __dataclass__init__fields__24__annotation,
            write_offset_bytes: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
            metadata: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
            server_side_encryption: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
            storage_class: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
            website_redirect_location: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
            sse_customer_algorithm: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
            sse_customer_key: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
            sse_customer_key_md5: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
            sse_kms_key_id: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
            sse_kms_encryption_context: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
            bucket_key_enabled: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
            request_payer: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
            tagging: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
            object_lock_mode: __dataclass__init__fields__38__annotation = __dataclass__init__fields__38__default,
            object_lock_retain_until_date: __dataclass__init__fields__39__annotation = __dataclass__init__fields__39__default,
            object_lock_legal_hold_status: __dataclass__init__fields__40__annotation = __dataclass__init__fields__40__default,
            expected_bucket_owner: __dataclass__init__fields__41__annotation = __dataclass__init__fields__41__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'acl', acl)
            __dataclass__object_setattr(self, 'body', body)
            __dataclass__object_setattr(self, 'bucket', bucket)
            __dataclass__object_setattr(self, 'cache_control', cache_control)
            __dataclass__object_setattr(self, 'content_disposition', content_disposition)
            __dataclass__object_setattr(self, 'content_encoding', content_encoding)
            __dataclass__object_setattr(self, 'content_language', content_language)
            __dataclass__object_setattr(self, 'content_length', content_length)
            __dataclass__object_setattr(self, 'content_md5', content_md5)
            __dataclass__object_setattr(self, 'content_type', content_type)
            __dataclass__object_setattr(self, 'checksum_algorithm', checksum_algorithm)
            __dataclass__object_setattr(self, 'checksum_crc32', checksum_crc32)
            __dataclass__object_setattr(self, 'checksum_crc32c', checksum_crc32c)
            __dataclass__object_setattr(self, 'checksum_crc64_nvme', checksum_crc64_nvme)
            __dataclass__object_setattr(self, 'checksum_sha1', checksum_sha1)
            __dataclass__object_setattr(self, 'checksum_sha256', checksum_sha256)
            __dataclass__object_setattr(self, 'expires', expires)
            __dataclass__object_setattr(self, 'if_match', if_match)
            __dataclass__object_setattr(self, 'if_none_match', if_none_match)
            __dataclass__object_setattr(self, 'grant_full_control', grant_full_control)
            __dataclass__object_setattr(self, 'grant_read', grant_read)
            __dataclass__object_setattr(self, 'grant_read_acp', grant_read_acp)
            __dataclass__object_setattr(self, 'grant_write_acp', grant_write_acp)
            __dataclass__object_setattr(self, 'key', key)
            __dataclass__object_setattr(self, 'write_offset_bytes', write_offset_bytes)
            __dataclass__object_setattr(self, 'metadata', metadata)
            __dataclass__object_setattr(self, 'server_side_encryption', server_side_encryption)
            __dataclass__object_setattr(self, 'storage_class', storage_class)
            __dataclass__object_setattr(self, 'website_redirect_location', website_redirect_location)
            __dataclass__object_setattr(self, 'sse_customer_algorithm', sse_customer_algorithm)
            __dataclass__object_setattr(self, 'sse_customer_key', sse_customer_key)
            __dataclass__object_setattr(self, 'sse_customer_key_md5', sse_customer_key_md5)
            __dataclass__object_setattr(self, 'sse_kms_key_id', sse_kms_key_id)
            __dataclass__object_setattr(self, 'sse_kms_encryption_context', sse_kms_encryption_context)
            __dataclass__object_setattr(self, 'bucket_key_enabled', bucket_key_enabled)
            __dataclass__object_setattr(self, 'request_payer', request_payer)
            __dataclass__object_setattr(self, 'tagging', tagging)
            __dataclass__object_setattr(self, 'object_lock_mode', object_lock_mode)
            __dataclass__object_setattr(self, 'object_lock_retain_until_date', object_lock_retain_until_date)
            __dataclass__object_setattr(self, 'object_lock_legal_hold_status', object_lock_legal_hold_status)
            __dataclass__object_setattr(self, 'expected_bucket_owner', expected_bucket_owner)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"acl={self.acl!r}")
            parts.append(f"body={self.body!r}")
            parts.append(f"bucket={self.bucket!r}")
            parts.append(f"cache_control={self.cache_control!r}")
            parts.append(f"content_disposition={self.content_disposition!r}")
            parts.append(f"content_encoding={self.content_encoding!r}")
            parts.append(f"content_language={self.content_language!r}")
            parts.append(f"content_length={self.content_length!r}")
            parts.append(f"content_md5={self.content_md5!r}")
            parts.append(f"content_type={self.content_type!r}")
            parts.append(f"checksum_algorithm={self.checksum_algorithm!r}")
            parts.append(f"checksum_crc32={self.checksum_crc32!r}")
            parts.append(f"checksum_crc32c={self.checksum_crc32c!r}")
            parts.append(f"checksum_crc64_nvme={self.checksum_crc64_nvme!r}")
            parts.append(f"checksum_sha1={self.checksum_sha1!r}")
            parts.append(f"checksum_sha256={self.checksum_sha256!r}")
            parts.append(f"expires={self.expires!r}")
            parts.append(f"if_match={self.if_match!r}")
            parts.append(f"if_none_match={self.if_none_match!r}")
            parts.append(f"grant_full_control={self.grant_full_control!r}")
            parts.append(f"grant_read={self.grant_read!r}")
            parts.append(f"grant_read_acp={self.grant_read_acp!r}")
            parts.append(f"grant_write_acp={self.grant_write_acp!r}")
            parts.append(f"key={self.key!r}")
            parts.append(f"write_offset_bytes={self.write_offset_bytes!r}")
            parts.append(f"metadata={self.metadata!r}")
            parts.append(f"server_side_encryption={self.server_side_encryption!r}")
            parts.append(f"storage_class={self.storage_class!r}")
            parts.append(f"website_redirect_location={self.website_redirect_location!r}")
            parts.append(f"sse_customer_algorithm={self.sse_customer_algorithm!r}")
            parts.append(f"sse_customer_key={self.sse_customer_key!r}")
            parts.append(f"sse_customer_key_md5={self.sse_customer_key_md5!r}")
            parts.append(f"sse_kms_key_id={self.sse_kms_key_id!r}")
            parts.append(f"sse_kms_encryption_context={self.sse_kms_encryption_context!r}")
            parts.append(f"bucket_key_enabled={self.bucket_key_enabled!r}")
            parts.append(f"request_payer={self.request_payer!r}")
            parts.append(f"tagging={self.tagging!r}")
            parts.append(f"object_lock_mode={self.object_lock_mode!r}")
            parts.append(f"object_lock_retain_until_date={self.object_lock_retain_until_date!r}")
            parts.append(f"object_lock_legal_hold_status={self.object_lock_legal_hold_status!r}")
            parts.append(f"expected_bucket_owner={self.expected_bucket_owner!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ebs_optimized_support', 'encryption_support', 'ebs_optimized_info', 'nvme_support"
        "', 'maximum_ebs_attachments', 'attachment_limit_type')), EqPlan(fields=('ebs_optimized_support', 'encryption_s"
        "upport', 'ebs_optimized_info', 'nvme_support', 'maximum_ebs_attachments', 'attachment_limit_type')), FrozenPla"
        "n(fields=('__shape__', 'ebs_optimized_support', 'encryption_support', 'ebs_optimized_info', 'nvme_support', 'm"
        "aximum_ebs_attachments', 'attachment_limit_type'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', f"
        "ields=('ebs_optimized_support', 'encryption_support', 'ebs_optimized_info', 'nvme_support', 'maximum_ebs_attac"
        "hments', 'attachment_limit_type'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation="
        "OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ebs_optimized_supp"
        "ort', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='encryption_support', annotation=OpRef(name='init.fields.2.annotation'), default=O"
        "pRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ebs_optimized_info', annotation=OpRef"
        "(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='nvme_support', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.def"
        "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
        "None, check_type=None), InitPlan.Field(name='maximum_ebs_attachments', annotation=OpRef(name='init.fields.5.an"
        "notation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, fiel"
        "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='attachment_limit"
        "_type', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), defaul"
        "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
        "pe=None)), self_param='self', std_params=(), kw_only_params=('ebs_optimized_support', 'encryption_support', 'e"
        "bs_optimized_info', 'nvme_support', 'maximum_ebs_attachments', 'attachment_limit_type'), frozen=True, slots=Fa"
        "lse, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ebs_optimized"
        "_support', kw_only=True, fn=None), ReprPlan.Field(name='encryption_support', kw_only=True, fn=None), ReprPlan."
        "Field(name='ebs_optimized_info', kw_only=True, fn=None), ReprPlan.Field(name='nvme_support', kw_only=True, fn="
        "None), ReprPlan.Field(name='maximum_ebs_attachments', kw_only=True, fn=None), ReprPlan.Field(name='attachment_"
        "limit_type', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='537a23d4158e2fdeb7190c4a89f243a4bde76bb6',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'EbsInfo'),
    ),
)
def _process_dataclass__537a23d4158e2fdeb7190c4a89f243a4bde76bb6():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ebs_optimized_support=self.ebs_optimized_support,
                encryption_support=self.encryption_support,
                ebs_optimized_info=self.ebs_optimized_info,
                nvme_support=self.nvme_support,
                maximum_ebs_attachments=self.maximum_ebs_attachments,
                attachment_limit_type=self.attachment_limit_type,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ebs_optimized_support == other.ebs_optimized_support and
                self.encryption_support == other.encryption_support and
                self.ebs_optimized_info == other.ebs_optimized_info and
                self.nvme_support == other.nvme_support and
                self.maximum_ebs_attachments == other.maximum_ebs_attachments and
                self.attachment_limit_type == other.attachment_limit_type
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ebs_optimized_support',
            'encryption_support',
            'ebs_optimized_info',
            'nvme_support',
            'maximum_ebs_attachments',
            'attachment_limit_type',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ebs_optimized_support',
            'encryption_support',
            'ebs_optimized_info',
            'nvme_support',
            'maximum_ebs_attachments',
            'attachment_limit_type',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ebs_optimized_support,
                self.encryption_support,
                self.ebs_optimized_info,
                self.nvme_support,
                self.maximum_ebs_attachments,
                self.attachment_limit_type,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ebs_optimized_support: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            encryption_support: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            ebs_optimized_info: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            nvme_support: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            maximum_ebs_attachments: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            attachment_limit_type: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ebs_optimized_support', ebs_optimized_support)
            __dataclass__object_setattr(self, 'encryption_support', encryption_support)
            __dataclass__object_setattr(self, 'ebs_optimized_info', ebs_optimized_info)
            __dataclass__object_setattr(self, 'nvme_support', nvme_support)
            __dataclass__object_setattr(self, 'maximum_ebs_attachments', maximum_ebs_attachments)
            __dataclass__object_setattr(self, 'attachment_limit_type', attachment_limit_type)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ebs_optimized_support={self.ebs_optimized_support!r}")
            parts.append(f"encryption_support={self.encryption_support!r}")
            parts.append(f"ebs_optimized_info={self.ebs_optimized_info!r}")
            parts.append(f"nvme_support={self.nvme_support!r}")
            parts.append(f"maximum_ebs_attachments={self.maximum_ebs_attachments!r}")
            parts.append(f"attachment_limit_type={self.attachment_limit_type!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('domain', 'status', 'fqdn', 'iam_role_name', 'ou', 'auth_secret_arn', 'dns_ips')),"
        " EqPlan(fields=('domain', 'status', 'fqdn', 'iam_role_name', 'ou', 'auth_secret_arn', 'dns_ips')), FrozenPlan("
        "fields=('__shape__', 'domain', 'status', 'fqdn', 'iam_role_name', 'ou', 'auth_secret_arn', 'dns_ips'), allow_d"
        "ynamic_dunder_attrs=False), HashPlan(action='add', fields=('domain', 'status', 'fqdn', 'iam_role_name', 'ou', "
        "'auth_secret_arn', 'dns_ips'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRe"
        "f(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type="
        "FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='domain', annotation=Op"
        "Ref(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init="
        "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
        "eld(name='status', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='fqdn', annotation=OpRef(name='init.fields.3.annotation'), default=Op"
        "Ref(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
        "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='iam_role_name', annotation=OpRef(name="
        "'init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
        "'ou', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='auth_secret_arn', annotation=OpRef(name='init.fields.6.annotation'), default=OpRe"
        "f(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
        "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dns_ips', annotation=OpRef(name='init.fi"
        "elds.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_para"
        "ms=(), kw_only_params=('domain', 'status', 'fqdn', 'iam_role_name', 'ou', 'auth_secret_arn', 'dns_ips'), froze"
        "n=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
        "e='domain', kw_only=True, fn=None), ReprPlan.Field(name='status', kw_only=True, fn=None), ReprPlan.Field(name="
        "'fqdn', kw_only=True, fn=None), ReprPlan.Field(name='iam_role_name', kw_only=True, fn=None), ReprPlan.Field(na"
        "me='ou', kw_only=True, fn=None), ReprPlan.Field(name='auth_secret_arn', kw_only=True, fn=None), ReprPlan.Field"
        "(name='dns_ips', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='54b1a8431e5cb54950012516c8c38115234b7eb1',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'DomainMembership'),
    ),
)
def _process_dataclass__54b1a8431e5cb54950012516c8c38115234b7eb1():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                domain=self.domain,
                status=self.status,
                fqdn=self.fqdn,
                iam_role_name=self.iam_role_name,
                ou=self.ou,
                auth_secret_arn=self.auth_secret_arn,
                dns_ips=self.dns_ips,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.domain == other.domain and
                self.status == other.status and
                self.fqdn == other.fqdn and
                self.iam_role_name == other.iam_role_name and
                self.ou == other.ou and
                self.auth_secret_arn == other.auth_secret_arn and
                self.dns_ips == other.dns_ips
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'domain',
            'status',
            'fqdn',
            'iam_role_name',
            'ou',
            'auth_secret_arn',
            'dns_ips',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'domain',
            'status',
            'fqdn',
            'iam_role_name',
            'ou',
            'auth_secret_arn',
            'dns_ips',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.domain,
                self.status,
                self.fqdn,
                self.iam_role_name,
                self.ou,
                self.auth_secret_arn,
                self.dns_ips,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            domain: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            status: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            fqdn: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            iam_role_name: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            ou: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            auth_secret_arn: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            dns_ips: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'domain', domain)
            __dataclass__object_setattr(self, 'status', status)
            __dataclass__object_setattr(self, 'fqdn', fqdn)
            __dataclass__object_setattr(self, 'iam_role_name', iam_role_name)
            __dataclass__object_setattr(self, 'ou', ou)
            __dataclass__object_setattr(self, 'auth_secret_arn', auth_secret_arn)
            __dataclass__object_setattr(self, 'dns_ips', dns_ips)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"domain={self.domain!r}")
            parts.append(f"status={self.status!r}")
            parts.append(f"fqdn={self.fqdn!r}")
            parts.append(f"iam_role_name={self.iam_role_name!r}")
            parts.append(f"ou={self.ou!r}")
            parts.append(f"auth_secret_arn={self.auth_secret_arn!r}")
            parts.append(f"dns_ips={self.dns_ips!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('supported_strategies',)), EqPlan(fields=('supported_strategies',)), FrozenPlan(fi"
        "elds=('__shape__', 'supported_strategies'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=("
        "'supported_strategies',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(nam"
        "e='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Field"
        "Type.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='supported_strategies', anno"
        "tation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), s"
        "elf_param='self', std_params=(), kw_only_params=('supported_strategies',), frozen=True, slots=False, post_init"
        "_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='supported_strategies', kw_o"
        "nly=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='55379d54f30130a79aa6c48675259cc882cf4d61',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'PlacementGroupInfo'),
    ),
)
def _process_dataclass__55379d54f30130a79aa6c48675259cc882cf4d61():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                supported_strategies=self.supported_strategies,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.supported_strategies == other.supported_strategies
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'supported_strategies',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'supported_strategies',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.supported_strategies,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            supported_strategies: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'supported_strategies', supported_strategies)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"supported_strategies={self.supported_strategies!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('launch_template_id', 'launch_template_name', 'version')), EqPlan(fields=('launch_"
        "template_id', 'launch_template_name', 'version')), FrozenPlan(fields=('__shape__', 'launch_template_id', 'laun"
        "ch_template_name', 'version'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('launch_templ"
        "ate_id', 'launch_template_name', 'version'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', a"
        "nnotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='launch_t"
        "emplate_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), d"
        "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='launch_template_name', annotation=OpRef(name='init.fields.2.annotation'), "
        "default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='version', annotation=OpRef(n"
        "ame='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='sel"
        "f', std_params=(), kw_only_params=('launch_template_id', 'launch_template_name', 'version'), frozen=True, slot"
        "s=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='launch_te"
        "mplate_id', kw_only=True, fn=None), ReprPlan.Field(name='launch_template_name', kw_only=True, fn=None), ReprPl"
        "an.Field(name='version', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='555a882d1a60f1e571d59e5fc7bb3508ed9a02a4',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'LaunchTemplateSpecification'),
    ),
)
def _process_dataclass__555a882d1a60f1e571d59e5fc7bb3508ed9a02a4():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                launch_template_id=self.launch_template_id,
                launch_template_name=self.launch_template_name,
                version=self.version,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.launch_template_id == other.launch_template_id and
                self.launch_template_name == other.launch_template_name and
                self.version == other.version
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'launch_template_id',
            'launch_template_name',
            'version',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'launch_template_id',
            'launch_template_name',
            'version',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.launch_template_id,
                self.launch_template_name,
                self.version,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            launch_template_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            launch_template_name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            version: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'launch_template_id', launch_template_id)
            __dataclass__object_setattr(self, 'launch_template_name', launch_template_name)
            __dataclass__object_setattr(self, 'version', version)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"launch_template_id={self.launch_template_id!r}")
            parts.append(f"launch_template_name={self.launch_template_name!r}")
            parts.append(f"version={self.version!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('max_price', 'spot_instance_type', 'block_duration_minutes', 'valid_until', 'insta"
        "nce_interruption_behavior')), EqPlan(fields=('max_price', 'spot_instance_type', 'block_duration_minutes', 'val"
        "id_until', 'instance_interruption_behavior')), FrozenPlan(fields=('__shape__', 'max_price', 'spot_instance_typ"
        "e', 'block_duration_minutes', 'valid_until', 'instance_interruption_behavior'), allow_dynamic_dunder_attrs=Fal"
        "se), HashPlan(action='add', fields=('max_price', 'spot_instance_type', 'block_duration_minutes', 'valid_until'"
        ", 'instance_interruption_behavior'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotatio"
        "n=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field"
        "_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_price', anno"
        "tation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='spot_instance_type', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name="
        "'init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None), InitPlan.Field(name='block_duration_minutes', annotation=OpRef(name="
        "'init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
        "'valid_until', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None), InitPlan.Field(name='instance_interruption_behavior', annotation=OpRef(name='init.fields.5.an"
        "notation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, fiel"
        "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw"
        "_only_params=('max_price', 'spot_instance_type', 'block_duration_minutes', 'valid_until', 'instance_interrupti"
        "on_behavior'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields"
        "=(ReprPlan.Field(name='max_price', kw_only=True, fn=None), ReprPlan.Field(name='spot_instance_type', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='block_duration_minutes', kw_only=True, fn=None), ReprPlan.Field(name='vali"
        "d_until', kw_only=True, fn=None), ReprPlan.Field(name='instance_interruption_behavior', kw_only=True, fn=None)"
        "), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='55e8d0b1f86c2e6ba251537033deded72da1e0b9',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'SpotMarketOptions'),
    ),
)
def _process_dataclass__55e8d0b1f86c2e6ba251537033deded72da1e0b9():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                max_price=self.max_price,
                spot_instance_type=self.spot_instance_type,
                block_duration_minutes=self.block_duration_minutes,
                valid_until=self.valid_until,
                instance_interruption_behavior=self.instance_interruption_behavior,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.max_price == other.max_price and
                self.spot_instance_type == other.spot_instance_type and
                self.block_duration_minutes == other.block_duration_minutes and
                self.valid_until == other.valid_until and
                self.instance_interruption_behavior == other.instance_interruption_behavior
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'max_price',
            'spot_instance_type',
            'block_duration_minutes',
            'valid_until',
            'instance_interruption_behavior',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'max_price',
            'spot_instance_type',
            'block_duration_minutes',
            'valid_until',
            'instance_interruption_behavior',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.max_price,
                self.spot_instance_type,
                self.block_duration_minutes,
                self.valid_until,
                self.instance_interruption_behavior,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            max_price: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            spot_instance_type: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            block_duration_minutes: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            valid_until: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            instance_interruption_behavior: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'max_price', max_price)
            __dataclass__object_setattr(self, 'spot_instance_type', spot_instance_type)
            __dataclass__object_setattr(self, 'block_duration_minutes', block_duration_minutes)
            __dataclass__object_setattr(self, 'valid_until', valid_until)
            __dataclass__object_setattr(self, 'instance_interruption_behavior', instance_interruption_behavior)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"max_price={self.max_price!r}")
            parts.append(f"spot_instance_type={self.spot_instance_type!r}")
            parts.append(f"block_duration_minutes={self.block_duration_minutes!r}")
            parts.append(f"valid_until={self.valid_until!r}")
            parts.append(f"instance_interruption_behavior={self.instance_interruption_behavior!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('lambda_managed_instances_capacity_provider_config',)), EqPlan(fields=('lambda_man"
        "aged_instances_capacity_provider_config',)), FrozenPlan(fields=('__shape__', 'lambda_managed_instances_capacit"
        "y_provider_config'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('lambda_managed_instanc"
        "es_capacity_provider_config',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpR"
        "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
        "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='lambda_managed_instan"
        "ces_capacity_provider_config', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        "), self_param='self', std_params=(), kw_only_params=('lambda_managed_instances_capacity_provider_config',), fr"
        "ozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field("
        "name='lambda_managed_instances_capacity_provider_config', kw_only=True, fn=None),), id=False, terse=False, def"
        "ault_fn=None)))"
    ),
    plan_repr_sha1='56a73cc80905fe58ffa6800ba93fc9b519922728',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'CapacityProviderConfig'),
    ),
)
def _process_dataclass__56a73cc80905fe58ffa6800ba93fc9b519922728():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                lambda_managed_instances_capacity_provider_config=self.lambda_managed_instances_capacity_provider_config,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.lambda_managed_instances_capacity_provider_config == other.lambda_managed_instances_capacity_provider_config
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'lambda_managed_instances_capacity_provider_config',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'lambda_managed_instances_capacity_provider_config',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.lambda_managed_instances_capacity_provider_config,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            lambda_managed_instances_capacity_provider_config: __dataclass__init__fields__1__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'lambda_managed_instances_capacity_provider_config', lambda_managed_instances_capacity_provider_config)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"lambda_managed_instances_capacity_provider_config={self.lambda_managed_instances_capacity_provider_config!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('instance_type', 'current_generation', 'free_tier_eligible', 'supported_usage_clas"
        "ses', 'supported_root_device_types', 'supported_virtualization_types', 'bare_metal', 'hypervisor', 'processor_"
        "info', 'v_cpu_info', 'memory_info', 'instance_storage_supported', 'instance_storage_info', 'ebs_info', 'networ"
        "k_info', 'gpu_info', 'fpga_info', 'placement_group_info', 'inference_accelerator_info', 'hibernation_supported"
        "', 'burstable_performance_supported', 'dedicated_hosts_supported', 'auto_recovery_supported', 'supported_boot_"
        "modes', 'nitro_enclaves_support', 'nitro_tpm_support', 'nitro_tpm_info', 'media_accelerator_info', 'neuron_inf"
        "o', 'phc_support', 'reboot_migration_support')), EqPlan(fields=('instance_type', 'current_generation', 'free_t"
        "ier_eligible', 'supported_usage_classes', 'supported_root_device_types', 'supported_virtualization_types', 'ba"
        "re_metal', 'hypervisor', 'processor_info', 'v_cpu_info', 'memory_info', 'instance_storage_supported', 'instanc"
        "e_storage_info', 'ebs_info', 'network_info', 'gpu_info', 'fpga_info', 'placement_group_info', 'inference_accel"
        "erator_info', 'hibernation_supported', 'burstable_performance_supported', 'dedicated_hosts_supported', 'auto_r"
        "ecovery_supported', 'supported_boot_modes', 'nitro_enclaves_support', 'nitro_tpm_support', 'nitro_tpm_info', '"
        "media_accelerator_info', 'neuron_info', 'phc_support', 'reboot_migration_support')), FrozenPlan(fields=('__sha"
        "pe__', 'instance_type', 'current_generation', 'free_tier_eligible', 'supported_usage_classes', 'supported_root"
        "_device_types', 'supported_virtualization_types', 'bare_metal', 'hypervisor', 'processor_info', 'v_cpu_info', "
        "'memory_info', 'instance_storage_supported', 'instance_storage_info', 'ebs_info', 'network_info', 'gpu_info', "
        "'fpga_info', 'placement_group_info', 'inference_accelerator_info', 'hibernation_supported', 'burstable_perform"
        "ance_supported', 'dedicated_hosts_supported', 'auto_recovery_supported', 'supported_boot_modes', 'nitro_enclav"
        "es_support', 'nitro_tpm_support', 'nitro_tpm_info', 'media_accelerator_info', 'neuron_info', 'phc_support', 'r"
        "eboot_migration_support'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('instance_type', "
        "'current_generation', 'free_tier_eligible', 'supported_usage_classes', 'supported_root_device_types', 'support"
        "ed_virtualization_types', 'bare_metal', 'hypervisor', 'processor_info', 'v_cpu_info', 'memory_info', 'instance"
        "_storage_supported', 'instance_storage_info', 'ebs_info', 'network_info', 'gpu_info', 'fpga_info', 'placement_"
        "group_info', 'inference_accelerator_info', 'hibernation_supported', 'burstable_performance_supported', 'dedica"
        "ted_hosts_supported', 'auto_recovery_supported', 'supported_boot_modes', 'nitro_enclaves_support', 'nitro_tpm_"
        "support', 'nitro_tpm_info', 'media_accelerator_info', 'neuron_info', 'phc_support', 'reboot_migration_support'"
        "), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annota"
        "tion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='instance_type', annotation=OpRef(name='init.fields"
        ".1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='current_gen"
        "eration', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='free_tier_eligible', annotation=OpRef(name='init.fields.3.annotation'), defau"
        "lt=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType."
        "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='supported_usage_classes', annotat"
        "ion=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None,"
        " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
        "lan.Field(name='supported_root_device_types', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef"
        "(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='supported_virtualization_types', annotati"
        "on=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='bare_metal', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields"
        ".7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='hypervisor', annotation=OpRef(name='init.fields.8.annotatio"
        "n'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type="
        "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='processor_info', annota"
        "tion=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='v_cpu_info', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fie"
        "lds.10.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='memory_info', annotation=OpRef(name='init.fields.11.ann"
        "otation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=False, fiel"
        "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_storage"
        "_supported', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None), InitPlan.Field(name='instance_storage_info', annotation=OpRef(name='init.fields.13.annotation"
        "'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=False, field_type="
        "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ebs_info', annotation=O"
        "pRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
        ".Field(name='network_info', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.field"
        "s.15.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None), InitPlan.Field(name='gpu_info', annotation=OpRef(name='init.fields.16.annotati"
        "on'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='fpga_info', annotatio"
        "n=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None,"
        " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
        "lan.Field(name='placement_group_info', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name="
        "'init.fields.18.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='inference_accelerator_info', annotation=OpRef("
        "name='init.fields.19.annotation'), default=OpRef(name='init.fields.19.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='hibernation_supported', annotation=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.f"
        "ields.20.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
        "e, validate=None, check_type=None), InitPlan.Field(name='burstable_performance_supported', annotation=OpRef(na"
        "me='init.fields.21.annotation'), default=OpRef(name='init.fields.21.default'), default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='dedicated_hosts_supported', annotation=OpRef(name='init.fields.22.annotation'), default=OpRef(name='init"
        ".fields.22.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
        "one, validate=None, check_type=None), InitPlan.Field(name='auto_recovery_supported', annotation=OpRef(name='in"
        "it.fields.23.annotation'), default=OpRef(name='init.fields.23.default'), default_factory=None, init=True, over"
        "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "supported_boot_modes', annotation=OpRef(name='init.fields.24.annotation'), default=OpRef(name='init.fields.24."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='nitro_enclaves_support', annotation=OpRef(name='init.fields.25"
        ".annotation'), default=OpRef(name='init.fields.25.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='nitro_tpm_su"
        "pport', annotation=OpRef(name='init.fields.26.annotation'), default=OpRef(name='init.fields.26.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='nitro_tpm_info', annotation=OpRef(name='init.fields.27.annotation'), default="
        "OpRef(name='init.fields.27.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
        "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='media_accelerator_info', annotation"
        "=OpRef(name='init.fields.28.annotation'), default=OpRef(name='init.fields.28.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='neuron_info', annotation=OpRef(name='init.fields.29.annotation'), default=OpRef(name='init.fiel"
        "ds.29.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='phc_support', annotation=OpRef(name='init.fields.30.anno"
        "tation'), default=OpRef(name='init.fields.30.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='reboot_migration_"
        "support', annotation=OpRef(name='init.fields.31.annotation'), default=OpRef(name='init.fields.31.default'), de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
        "k_type=None)), self_param='self', std_params=(), kw_only_params=('instance_type', 'current_generation', 'free_"
        "tier_eligible', 'supported_usage_classes', 'supported_root_device_types', 'supported_virtualization_types', 'b"
        "are_metal', 'hypervisor', 'processor_info', 'v_cpu_info', 'memory_info', 'instance_storage_supported', 'instan"
        "ce_storage_info', 'ebs_info', 'network_info', 'gpu_info', 'fpga_info', 'placement_group_info', 'inference_acce"
        "lerator_info', 'hibernation_supported', 'burstable_performance_supported', 'dedicated_hosts_supported', 'auto_"
        "recovery_supported', 'supported_boot_modes', 'nitro_enclaves_support', 'nitro_tpm_support', 'nitro_tpm_info', "
        "'media_accelerator_info', 'neuron_info', 'phc_support', 'reboot_migration_support'), frozen=True, slots=False,"
        " post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='instance_type', k"
        "w_only=True, fn=None), ReprPlan.Field(name='current_generation', kw_only=True, fn=None), ReprPlan.Field(name='"
        "free_tier_eligible', kw_only=True, fn=None), ReprPlan.Field(name='supported_usage_classes', kw_only=True, fn=N"
        "one), ReprPlan.Field(name='supported_root_device_types', kw_only=True, fn=None), ReprPlan.Field(name='supporte"
        "d_virtualization_types', kw_only=True, fn=None), ReprPlan.Field(name='bare_metal', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='hypervisor', kw_only=True, fn=None), ReprPlan.Field(name='processor_info', kw_only=True, fn="
        "None), ReprPlan.Field(name='v_cpu_info', kw_only=True, fn=None), ReprPlan.Field(name='memory_info', kw_only=Tr"
        "ue, fn=None), ReprPlan.Field(name='instance_storage_supported', kw_only=True, fn=None), ReprPlan.Field(name='i"
        "nstance_storage_info', kw_only=True, fn=None), ReprPlan.Field(name='ebs_info', kw_only=True, fn=None), ReprPla"
        "n.Field(name='network_info', kw_only=True, fn=None), ReprPlan.Field(name='gpu_info', kw_only=True, fn=None), R"
        "eprPlan.Field(name='fpga_info', kw_only=True, fn=None), ReprPlan.Field(name='placement_group_info', kw_only=Tr"
        "ue, fn=None), ReprPlan.Field(name='inference_accelerator_info', kw_only=True, fn=None), ReprPlan.Field(name='h"
        "ibernation_supported', kw_only=True, fn=None), ReprPlan.Field(name='burstable_performance_supported', kw_only="
        "True, fn=None), ReprPlan.Field(name='dedicated_hosts_supported', kw_only=True, fn=None), ReprPlan.Field(name='"
        "auto_recovery_supported', kw_only=True, fn=None), ReprPlan.Field(name='supported_boot_modes', kw_only=True, fn"
        "=None), ReprPlan.Field(name='nitro_enclaves_support', kw_only=True, fn=None), ReprPlan.Field(name='nitro_tpm_s"
        "upport', kw_only=True, fn=None), ReprPlan.Field(name='nitro_tpm_info', kw_only=True, fn=None), ReprPlan.Field("
        "name='media_accelerator_info', kw_only=True, fn=None), ReprPlan.Field(name='neuron_info', kw_only=True, fn=Non"
        "e), ReprPlan.Field(name='phc_support', kw_only=True, fn=None), ReprPlan.Field(name='reboot_migration_support',"
        " kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='56c553d8f420a0280fd167f1a8f110cec5d9f296',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__24__annotation',
        '__dataclass__init__fields__24__default',
        '__dataclass__init__fields__25__annotation',
        '__dataclass__init__fields__25__default',
        '__dataclass__init__fields__26__annotation',
        '__dataclass__init__fields__26__default',
        '__dataclass__init__fields__27__annotation',
        '__dataclass__init__fields__27__default',
        '__dataclass__init__fields__28__annotation',
        '__dataclass__init__fields__28__default',
        '__dataclass__init__fields__29__annotation',
        '__dataclass__init__fields__29__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__30__annotation',
        '__dataclass__init__fields__30__default',
        '__dataclass__init__fields__31__annotation',
        '__dataclass__init__fields__31__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceTypeInfo'),
    ),
)
def _process_dataclass__56c553d8f420a0280fd167f1a8f110cec5d9f296():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__24__annotation,
        __dataclass__init__fields__24__default,
        __dataclass__init__fields__25__annotation,
        __dataclass__init__fields__25__default,
        __dataclass__init__fields__26__annotation,
        __dataclass__init__fields__26__default,
        __dataclass__init__fields__27__annotation,
        __dataclass__init__fields__27__default,
        __dataclass__init__fields__28__annotation,
        __dataclass__init__fields__28__default,
        __dataclass__init__fields__29__annotation,
        __dataclass__init__fields__29__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__30__annotation,
        __dataclass__init__fields__30__default,
        __dataclass__init__fields__31__annotation,
        __dataclass__init__fields__31__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                instance_type=self.instance_type,
                current_generation=self.current_generation,
                free_tier_eligible=self.free_tier_eligible,
                supported_usage_classes=self.supported_usage_classes,
                supported_root_device_types=self.supported_root_device_types,
                supported_virtualization_types=self.supported_virtualization_types,
                bare_metal=self.bare_metal,
                hypervisor=self.hypervisor,
                processor_info=self.processor_info,
                v_cpu_info=self.v_cpu_info,
                memory_info=self.memory_info,
                instance_storage_supported=self.instance_storage_supported,
                instance_storage_info=self.instance_storage_info,
                ebs_info=self.ebs_info,
                network_info=self.network_info,
                gpu_info=self.gpu_info,
                fpga_info=self.fpga_info,
                placement_group_info=self.placement_group_info,
                inference_accelerator_info=self.inference_accelerator_info,
                hibernation_supported=self.hibernation_supported,
                burstable_performance_supported=self.burstable_performance_supported,
                dedicated_hosts_supported=self.dedicated_hosts_supported,
                auto_recovery_supported=self.auto_recovery_supported,
                supported_boot_modes=self.supported_boot_modes,
                nitro_enclaves_support=self.nitro_enclaves_support,
                nitro_tpm_support=self.nitro_tpm_support,
                nitro_tpm_info=self.nitro_tpm_info,
                media_accelerator_info=self.media_accelerator_info,
                neuron_info=self.neuron_info,
                phc_support=self.phc_support,
                reboot_migration_support=self.reboot_migration_support,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.instance_type == other.instance_type and
                self.current_generation == other.current_generation and
                self.free_tier_eligible == other.free_tier_eligible and
                self.supported_usage_classes == other.supported_usage_classes and
                self.supported_root_device_types == other.supported_root_device_types and
                self.supported_virtualization_types == other.supported_virtualization_types and
                self.bare_metal == other.bare_metal and
                self.hypervisor == other.hypervisor and
                self.processor_info == other.processor_info and
                self.v_cpu_info == other.v_cpu_info and
                self.memory_info == other.memory_info and
                self.instance_storage_supported == other.instance_storage_supported and
                self.instance_storage_info == other.instance_storage_info and
                self.ebs_info == other.ebs_info and
                self.network_info == other.network_info and
                self.gpu_info == other.gpu_info and
                self.fpga_info == other.fpga_info and
                self.placement_group_info == other.placement_group_info and
                self.inference_accelerator_info == other.inference_accelerator_info and
                self.hibernation_supported == other.hibernation_supported and
                self.burstable_performance_supported == other.burstable_performance_supported and
                self.dedicated_hosts_supported == other.dedicated_hosts_supported and
                self.auto_recovery_supported == other.auto_recovery_supported and
                self.supported_boot_modes == other.supported_boot_modes and
                self.nitro_enclaves_support == other.nitro_enclaves_support and
                self.nitro_tpm_support == other.nitro_tpm_support and
                self.nitro_tpm_info == other.nitro_tpm_info and
                self.media_accelerator_info == other.media_accelerator_info and
                self.neuron_info == other.neuron_info and
                self.phc_support == other.phc_support and
                self.reboot_migration_support == other.reboot_migration_support
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'instance_type',
            'current_generation',
            'free_tier_eligible',
            'supported_usage_classes',
            'supported_root_device_types',
            'supported_virtualization_types',
            'bare_metal',
            'hypervisor',
            'processor_info',
            'v_cpu_info',
            'memory_info',
            'instance_storage_supported',
            'instance_storage_info',
            'ebs_info',
            'network_info',
            'gpu_info',
            'fpga_info',
            'placement_group_info',
            'inference_accelerator_info',
            'hibernation_supported',
            'burstable_performance_supported',
            'dedicated_hosts_supported',
            'auto_recovery_supported',
            'supported_boot_modes',
            'nitro_enclaves_support',
            'nitro_tpm_support',
            'nitro_tpm_info',
            'media_accelerator_info',
            'neuron_info',
            'phc_support',
            'reboot_migration_support',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'instance_type',
            'current_generation',
            'free_tier_eligible',
            'supported_usage_classes',
            'supported_root_device_types',
            'supported_virtualization_types',
            'bare_metal',
            'hypervisor',
            'processor_info',
            'v_cpu_info',
            'memory_info',
            'instance_storage_supported',
            'instance_storage_info',
            'ebs_info',
            'network_info',
            'gpu_info',
            'fpga_info',
            'placement_group_info',
            'inference_accelerator_info',
            'hibernation_supported',
            'burstable_performance_supported',
            'dedicated_hosts_supported',
            'auto_recovery_supported',
            'supported_boot_modes',
            'nitro_enclaves_support',
            'nitro_tpm_support',
            'nitro_tpm_info',
            'media_accelerator_info',
            'neuron_info',
            'phc_support',
            'reboot_migration_support',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.instance_type,
                self.current_generation,
                self.free_tier_eligible,
                self.supported_usage_classes,
                self.supported_root_device_types,
                self.supported_virtualization_types,
                self.bare_metal,
                self.hypervisor,
                self.processor_info,
                self.v_cpu_info,
                self.memory_info,
                self.instance_storage_supported,
                self.instance_storage_info,
                self.ebs_info,
                self.network_info,
                self.gpu_info,
                self.fpga_info,
                self.placement_group_info,
                self.inference_accelerator_info,
                self.hibernation_supported,
                self.burstable_performance_supported,
                self.dedicated_hosts_supported,
                self.auto_recovery_supported,
                self.supported_boot_modes,
                self.nitro_enclaves_support,
                self.nitro_tpm_support,
                self.nitro_tpm_info,
                self.media_accelerator_info,
                self.neuron_info,
                self.phc_support,
                self.reboot_migration_support,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            instance_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            current_generation: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            free_tier_eligible: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            supported_usage_classes: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            supported_root_device_types: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            supported_virtualization_types: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            bare_metal: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            hypervisor: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            processor_info: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            v_cpu_info: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            memory_info: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            instance_storage_supported: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            instance_storage_info: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            ebs_info: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            network_info: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            gpu_info: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            fpga_info: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            placement_group_info: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            inference_accelerator_info: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            hibernation_supported: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            burstable_performance_supported: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            dedicated_hosts_supported: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            auto_recovery_supported: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
            supported_boot_modes: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
            nitro_enclaves_support: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
            nitro_tpm_support: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
            nitro_tpm_info: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
            media_accelerator_info: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
            neuron_info: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
            phc_support: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
            reboot_migration_support: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'instance_type', instance_type)
            __dataclass__object_setattr(self, 'current_generation', current_generation)
            __dataclass__object_setattr(self, 'free_tier_eligible', free_tier_eligible)
            __dataclass__object_setattr(self, 'supported_usage_classes', supported_usage_classes)
            __dataclass__object_setattr(self, 'supported_root_device_types', supported_root_device_types)
            __dataclass__object_setattr(self, 'supported_virtualization_types', supported_virtualization_types)
            __dataclass__object_setattr(self, 'bare_metal', bare_metal)
            __dataclass__object_setattr(self, 'hypervisor', hypervisor)
            __dataclass__object_setattr(self, 'processor_info', processor_info)
            __dataclass__object_setattr(self, 'v_cpu_info', v_cpu_info)
            __dataclass__object_setattr(self, 'memory_info', memory_info)
            __dataclass__object_setattr(self, 'instance_storage_supported', instance_storage_supported)
            __dataclass__object_setattr(self, 'instance_storage_info', instance_storage_info)
            __dataclass__object_setattr(self, 'ebs_info', ebs_info)
            __dataclass__object_setattr(self, 'network_info', network_info)
            __dataclass__object_setattr(self, 'gpu_info', gpu_info)
            __dataclass__object_setattr(self, 'fpga_info', fpga_info)
            __dataclass__object_setattr(self, 'placement_group_info', placement_group_info)
            __dataclass__object_setattr(self, 'inference_accelerator_info', inference_accelerator_info)
            __dataclass__object_setattr(self, 'hibernation_supported', hibernation_supported)
            __dataclass__object_setattr(self, 'burstable_performance_supported', burstable_performance_supported)
            __dataclass__object_setattr(self, 'dedicated_hosts_supported', dedicated_hosts_supported)
            __dataclass__object_setattr(self, 'auto_recovery_supported', auto_recovery_supported)
            __dataclass__object_setattr(self, 'supported_boot_modes', supported_boot_modes)
            __dataclass__object_setattr(self, 'nitro_enclaves_support', nitro_enclaves_support)
            __dataclass__object_setattr(self, 'nitro_tpm_support', nitro_tpm_support)
            __dataclass__object_setattr(self, 'nitro_tpm_info', nitro_tpm_info)
            __dataclass__object_setattr(self, 'media_accelerator_info', media_accelerator_info)
            __dataclass__object_setattr(self, 'neuron_info', neuron_info)
            __dataclass__object_setattr(self, 'phc_support', phc_support)
            __dataclass__object_setattr(self, 'reboot_migration_support', reboot_migration_support)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"instance_type={self.instance_type!r}")
            parts.append(f"current_generation={self.current_generation!r}")
            parts.append(f"free_tier_eligible={self.free_tier_eligible!r}")
            parts.append(f"supported_usage_classes={self.supported_usage_classes!r}")
            parts.append(f"supported_root_device_types={self.supported_root_device_types!r}")
            parts.append(f"supported_virtualization_types={self.supported_virtualization_types!r}")
            parts.append(f"bare_metal={self.bare_metal!r}")
            parts.append(f"hypervisor={self.hypervisor!r}")
            parts.append(f"processor_info={self.processor_info!r}")
            parts.append(f"v_cpu_info={self.v_cpu_info!r}")
            parts.append(f"memory_info={self.memory_info!r}")
            parts.append(f"instance_storage_supported={self.instance_storage_supported!r}")
            parts.append(f"instance_storage_info={self.instance_storage_info!r}")
            parts.append(f"ebs_info={self.ebs_info!r}")
            parts.append(f"network_info={self.network_info!r}")
            parts.append(f"gpu_info={self.gpu_info!r}")
            parts.append(f"fpga_info={self.fpga_info!r}")
            parts.append(f"placement_group_info={self.placement_group_info!r}")
            parts.append(f"inference_accelerator_info={self.inference_accelerator_info!r}")
            parts.append(f"hibernation_supported={self.hibernation_supported!r}")
            parts.append(f"burstable_performance_supported={self.burstable_performance_supported!r}")
            parts.append(f"dedicated_hosts_supported={self.dedicated_hosts_supported!r}")
            parts.append(f"auto_recovery_supported={self.auto_recovery_supported!r}")
            parts.append(f"supported_boot_modes={self.supported_boot_modes!r}")
            parts.append(f"nitro_enclaves_support={self.nitro_enclaves_support!r}")
            parts.append(f"nitro_tpm_support={self.nitro_tpm_support!r}")
            parts.append(f"nitro_tpm_info={self.nitro_tpm_info!r}")
            parts.append(f"media_accelerator_info={self.media_accelerator_info!r}")
            parts.append(f"neuron_info={self.neuron_info!r}")
            parts.append(f"phc_support={self.phc_support!r}")
            parts.append(f"reboot_migration_support={self.reboot_migration_support!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('next_token', 'reservations')), EqPlan(fields=('next_token', 'reservations')), Fro"
        "zenPlan(fields=('__shape__', 'next_token', 'reservations'), allow_dynamic_dunder_attrs=False), HashPlan(action"
        "='add', fields=('next_token', 'reservations'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__',"
        " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_t"
        "oken', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default"
        "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='reservations', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef("
        "name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
        " coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('next_token'"
        ", 'reservations'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fi"
        "elds=(ReprPlan.Field(name='next_token', kw_only=True, fn=None), ReprPlan.Field(name='reservations', kw_only=Tr"
        "ue, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='571588aff087d2499ca9b2a48d5254f0219fd6b0',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeInstancesResult'),
    ),
)
def _process_dataclass__571588aff087d2499ca9b2a48d5254f0219fd6b0():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                next_token=self.next_token,
                reservations=self.reservations,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.next_token == other.next_token and
                self.reservations == other.reservations
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'next_token',
            'reservations',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'next_token',
            'reservations',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.next_token,
                self.reservations,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            reservations: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'reservations', reservations)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"reservations={self.reservations!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('k', 'v')), EqPlan(fields=('k', 'v')), FrozenPlan(fields=('k', 'v'), allow_dynamic"
        "_dunder_attrs=False), HashPlan(action='add', fields=('k', 'v'), cache=False), InitPlan(fields=(InitPlan.Field("
        "name='k', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, ov"
        "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='v', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std"
        "_params=('k', 'v'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_"
        "fns=()), ReprPlan(fields=(ReprPlan.Field(name='k', kw_only=False, fn=None), ReprPlan.Field(name='v', kw_only=F"
        "alse, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='578f7d51b95e4fe4ec2ad0437b5688e4ff9ac9e6',
    op_ref_idents=(
        '__dataclass__init__fields__0__annotation',
        '__dataclass__init__fields__1__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'MapValueType'),
    ),
)
def _process_dataclass__578f7d51b95e4fe4ec2ad0437b5688e4ff9ac9e6():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__0__annotation,
        __dataclass__init__fields__1__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                k=self.k,
                v=self.v,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.k == other.k and
                self.v == other.v
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            'k',
            'v',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            'k',
            'v',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.k,
                self.v,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            k: __dataclass__init__fields__0__annotation,
            v: __dataclass__init__fields__1__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'k', k)
            __dataclass__object_setattr(self, 'v', v)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"k={self.k!r}")
            parts.append(f"v={self.v!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('db_instance_identifier', 'force_failover')), EqPlan(fields=('db_instance_identifi"
        "er', 'force_failover')), FrozenPlan(fields=('__shape__', 'db_instance_identifier', 'force_failover'), allow_dy"
        "namic_dunder_attrs=False), HashPlan(action='add', fields=('db_instance_identifier', 'force_failover'), cache=F"
        "alse), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), de"
        "fault=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='db_instance_identifier', annotation=OpRef(name='init.fields."
        "1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
        "coerce=None, validate=None, check_type=None), InitPlan.Field(name='force_failover', annotation=OpRef(name='ini"
        "t.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_"
        "params=(), kw_only_params=('db_instance_identifier', 'force_failover'), frozen=True, slots=False, post_init_pa"
        "rams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db_instance_identifier', kw_on"
        "ly=True, fn=None), ReprPlan.Field(name='force_failover', kw_only=True, fn=None)), id=False, terse=False, defau"
        "lt_fn=None)))"
    ),
    plan_repr_sha1='57df3a0abb409483de9a76ede74c282972bd0875',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'RebootDBInstanceMessage'),
    ),
)
def _process_dataclass__57df3a0abb409483de9a76ede74c282972bd0875():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                db_instance_identifier=self.db_instance_identifier,
                force_failover=self.force_failover,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.db_instance_identifier == other.db_instance_identifier and
                self.force_failover == other.force_failover
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'db_instance_identifier',
            'force_failover',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'db_instance_identifier',
            'force_failover',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.db_instance_identifier,
                self.force_failover,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            db_instance_identifier: __dataclass__init__fields__1__annotation,
            force_failover: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'db_instance_identifier', db_instance_identifier)
            __dataclass__object_setattr(self, 'force_failover', force_failover)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"db_instance_identifier={self.db_instance_identifier!r}")
            parts.append(f"force_failover={self.force_failover!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('route_table', 'client_token')), EqPlan(fields=('route_table', 'client_token')), F"
        "rozenPlan(fields=('__shape__', 'route_table', 'client_token'), allow_dynamic_dunder_attrs=False), HashPlan(act"
        "ion='add', fields=('route_table', 'client_token'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape"
        "__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ro"
        "ute_table', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
        "k_type=None), InitPlan.Field(name='client_token', annotation=OpRef(name='init.fields.2.annotation'), default=O"
        "pRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('route_"
        "table', 'client_token'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
        "lan(fields=(ReprPlan.Field(name='route_table', kw_only=True, fn=None), ReprPlan.Field(name='client_token', kw_"
        "only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='582754ca145127aaf3528d004fb3082a11a878aa',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CreateRouteTableResult'),
    ),
)
def _process_dataclass__582754ca145127aaf3528d004fb3082a11a878aa():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                route_table=self.route_table,
                client_token=self.client_token,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.route_table == other.route_table and
                self.client_token == other.client_token
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'route_table',
            'client_token',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'route_table',
            'client_token',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.route_table,
                self.client_token,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            route_table: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            client_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'route_table', route_table)
            __dataclass__object_setattr(self, 'client_token', client_token)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"route_table={self.route_table!r}")
            parts.append(f"client_token={self.client_token!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('association_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'ipv6_address_attrib"
        "ute', 'ip_source')), EqPlan(fields=('association_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'ipv6_addres"
        "s_attribute', 'ip_source')), FrozenPlan(fields=('__shape__', 'association_id', 'ipv6_cidr_block', 'ipv6_cidr_b"
        "lock_state', 'ipv6_address_attribute', 'ip_source'), allow_dynamic_dunder_attrs=False), HashPlan(action='add',"
        " fields=('association_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'ipv6_address_attribute', 'ip_source'),"
        " cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotati"
        "on'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='association_id', annotation=OpRef(name='init.fields."
        "1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_cidr_bl"
        "ock', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='ipv6_cidr_block_state', annotation=OpRef(name='init.fields.3.annotation'), defaul"
        "t=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
        "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_address_attribute', annotatio"
        "n=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='ip_source', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('association_id', 'ipv6_cidr_bl"
        "ock', 'ipv6_cidr_block_state', 'ipv6_address_attribute', 'ip_source'), frozen=True, slots=False, post_init_par"
        "ams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='association_id', kw_only=True, "
        "fn=None), ReprPlan.Field(name='ipv6_cidr_block', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_cidr_block_"
        "state', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_address_attribute', kw_only=True, fn=None), ReprPlan"
        ".Field(name='ip_source', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='58932d05fd6336438a2ce2e7422de8bf9a7c4aae',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'SubnetIpv6CidrBlockAssociation'),
    ),
)
def _process_dataclass__58932d05fd6336438a2ce2e7422de8bf9a7c4aae():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                association_id=self.association_id,
                ipv6_cidr_block=self.ipv6_cidr_block,
                ipv6_cidr_block_state=self.ipv6_cidr_block_state,
                ipv6_address_attribute=self.ipv6_address_attribute,
                ip_source=self.ip_source,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.association_id == other.association_id and
                self.ipv6_cidr_block == other.ipv6_cidr_block and
                self.ipv6_cidr_block_state == other.ipv6_cidr_block_state and
                self.ipv6_address_attribute == other.ipv6_address_attribute and
                self.ip_source == other.ip_source
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'association_id',
            'ipv6_cidr_block',
            'ipv6_cidr_block_state',
            'ipv6_address_attribute',
            'ip_source',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'association_id',
            'ipv6_cidr_block',
            'ipv6_cidr_block_state',
            'ipv6_address_attribute',
            'ip_source',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.association_id,
                self.ipv6_cidr_block,
                self.ipv6_cidr_block_state,
                self.ipv6_address_attribute,
                self.ip_source,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            association_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            ipv6_cidr_block: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            ipv6_cidr_block_state: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            ipv6_address_attribute: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            ip_source: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'association_id', association_id)
            __dataclass__object_setattr(self, 'ipv6_cidr_block', ipv6_cidr_block)
            __dataclass__object_setattr(self, 'ipv6_cidr_block_state', ipv6_cidr_block_state)
            __dataclass__object_setattr(self, 'ipv6_address_attribute', ipv6_address_attribute)
            __dataclass__object_setattr(self, 'ip_source', ip_source)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"association_id={self.association_id!r}")
            parts.append(f"ipv6_cidr_block={self.ipv6_cidr_block!r}")
            parts.append(f"ipv6_cidr_block_state={self.ipv6_cidr_block_state!r}")
            parts.append(f"ipv6_address_attribute={self.ipv6_address_attribute!r}")
            parts.append(f"ip_source={self.ip_source!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ena_srd_udp_enabled',)), EqPlan(fields=('ena_srd_udp_enabled',)), FrozenPlan(fiel"
        "ds=('__shape__', 'ena_srd_udp_enabled'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('en"
        "a_srd_udp_enabled',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='i"
        "nit.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType"
        ".CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_srd_udp_enabled', annotatio"
        "n=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_p"
        "aram='self', std_params=(), kw_only_params=('ena_srd_udp_enabled',), frozen=True, slots=False, post_init_param"
        "s=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ena_srd_udp_enabled', kw_only=Tru"
        "e, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='5a79dae371ff101fec6f7ecde39b38153b14fcee',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'AttachmentEnaSrdUdpSpecification'),
        ('ominfra.clouds.aws.models.services.ec2', 'EnaSrdUdpSpecificationRequest'),
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceAttachmentEnaSrdUdpSpecification'),
    ),
)
def _process_dataclass__5a79dae371ff101fec6f7ecde39b38153b14fcee():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ena_srd_udp_enabled=self.ena_srd_udp_enabled,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ena_srd_udp_enabled == other.ena_srd_udp_enabled
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ena_srd_udp_enabled',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ena_srd_udp_enabled',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ena_srd_udp_enabled,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ena_srd_udp_enabled: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ena_srd_udp_enabled', ena_srd_udp_enabled)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ena_srd_udp_enabled={self.ena_srd_udp_enabled!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('return_', 'group_id')), EqPlan(fields=('return_', 'group_id')), FrozenPlan(fields"
        "=('__shape__', 'return_', 'group_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('retu"
        "rn_', 'group_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init"
        ".fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CL"
        "ASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='return_', annotation=OpRef(name='i"
        "nit.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='g"
        "roup_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None)), self_param='self', std_params=(), kw_only_params=('return_', 'group_id'), frozen=True, slots=Fals"
        "e, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='return_', kw_on"
        "ly=True, fn=None), ReprPlan.Field(name='group_id', kw_only=True, fn=None)), id=False, terse=False, default_fn="
        "None)))"
    ),
    plan_repr_sha1='5afbe7bbec3a5065ddc8f2d5773563e9771995a3',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DeleteSecurityGroupResult'),
    ),
)
def _process_dataclass__5afbe7bbec3a5065ddc8f2d5773563e9771995a3():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                return_=self.return_,
                group_id=self.group_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.return_ == other.return_ and
                self.group_id == other.group_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'return_',
            'group_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'return_',
            'group_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.return_,
                self.group_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            return_: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            group_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'return_', return_)
            __dataclass__object_setattr(self, 'group_id', group_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"return_={self.return_!r}")
            parts.append(f"group_id={self.group_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('db_security_group_name', 'status')), EqPlan(fields=('db_security_group_name', 'st"
        "atus')), FrozenPlan(fields=('__shape__', 'db_security_group_name', 'status'), allow_dynamic_dunder_attrs=False"
        "), HashPlan(action='add', fields=('db_security_group_name', 'status'), cache=False), InitPlan(fields=(InitPlan"
        ".Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None"
        ", init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='db_security_group_name', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(na"
        "me='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
        "oerce=None, validate=None, check_type=None), InitPlan.Field(name='status', annotation=OpRef(name='init.fields."
        "2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=()"
        ", kw_only_params=('db_security_group_name', 'status'), frozen=True, slots=False, post_init_params=None, init_f"
        "ns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db_security_group_name', kw_only=True, fn=None)"
        ", ReprPlan.Field(name='status', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='5b874daf1f977f07597ba17556eee1fdb7257557',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'DBSecurityGroupMembership'),
    ),
)
def _process_dataclass__5b874daf1f977f07597ba17556eee1fdb7257557():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                db_security_group_name=self.db_security_group_name,
                status=self.status,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.db_security_group_name == other.db_security_group_name and
                self.status == other.status
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'db_security_group_name',
            'status',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'db_security_group_name',
            'status',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.db_security_group_name,
                self.status,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            db_security_group_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            status: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'db_security_group_name', db_security_group_name)
            __dataclass__object_setattr(self, 'status', status)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"db_security_group_name={self.db_security_group_name!r}")
            parts.append(f"status={self.status!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('delete_marker', 'version_id', 'request_charged')), EqPlan(fields=('delete_marker'"
        ", 'version_id', 'request_charged')), FrozenPlan(fields=('__shape__', 'delete_marker', 'version_id', 'request_c"
        "harged'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('delete_marker', 'version_id', 're"
        "quest_charged'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.f"
        "ields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLAS"
        "S_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='delete_marker', annotation=OpRef(nam"
        "e='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='version_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default')"
        ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='request_charged', annotation=OpRef(name='init.fields.3.annotation'), de"
        "fault=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=("
        "'delete_marker', 'version_id', 'request_charged'), frozen=True, slots=False, post_init_params=None, init_fns=("
        "), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='delete_marker', kw_only=True, fn=None), ReprPlan.Fi"
        "eld(name='version_id', kw_only=True, fn=None), ReprPlan.Field(name='request_charged', kw_only=True, fn=None)),"
        " id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='5c39bd4aeaeb4d1400d167fcf34d220b90689df3',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.s3', 'DeleteObjectOutput'),
    ),
)
def _process_dataclass__5c39bd4aeaeb4d1400d167fcf34d220b90689df3():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                delete_marker=self.delete_marker,
                version_id=self.version_id,
                request_charged=self.request_charged,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.delete_marker == other.delete_marker and
                self.version_id == other.version_id and
                self.request_charged == other.request_charged
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'delete_marker',
            'version_id',
            'request_charged',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'delete_marker',
            'version_id',
            'request_charged',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.delete_marker,
                self.version_id,
                self.request_charged,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            delete_marker: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            version_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            request_charged: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'delete_marker', delete_marker)
            __dataclass__object_setattr(self, 'version_id', version_id)
            __dataclass__object_setattr(self, 'request_charged', request_charged)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"delete_marker={self.delete_marker!r}")
            parts.append(f"version_id={self.version_id!r}")
            parts.append(f"request_charged={self.request_charged!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ip_protocol', 'from_port', 'to_port', 'user_id_group_pairs', 'ip_ranges', 'ipv6_r"
        "anges', 'prefix_list_ids')), EqPlan(fields=('ip_protocol', 'from_port', 'to_port', 'user_id_group_pairs', 'ip_"
        "ranges', 'ipv6_ranges', 'prefix_list_ids')), FrozenPlan(fields=('__shape__', 'ip_protocol', 'from_port', 'to_p"
        "ort', 'user_id_group_pairs', 'ip_ranges', 'ipv6_ranges', 'prefix_list_ids'), allow_dynamic_dunder_attrs=False)"
        ", HashPlan(action='add', fields=('ip_protocol', 'from_port', 'to_port', 'user_id_group_pairs', 'ip_ranges', 'i"
        "pv6_ranges', 'prefix_list_ids'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=Op"
        "Ref(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ip_protocol', annota"
        "tion=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='from_port', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.field"
        "s.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='to_port', annotation=OpRef(name='init.fields.3.annotation'"
        "), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='user_id_group_pairs', ann"
        "otation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='ip_ranges', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fi"
        "elds.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='ipv6_ranges', annotation=OpRef(name='init.fields.6.anno"
        "tation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='prefix_list_ids', "
        "annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        "), self_param='self', std_params=(), kw_only_params=('ip_protocol', 'from_port', 'to_port', 'user_id_group_pai"
        "rs', 'ip_ranges', 'ipv6_ranges', 'prefix_list_ids'), frozen=True, slots=False, post_init_params=None, init_fns"
        "=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ip_protocol', kw_only=True, fn=None), ReprPlan.Fi"
        "eld(name='from_port', kw_only=True, fn=None), ReprPlan.Field(name='to_port', kw_only=True, fn=None), ReprPlan."
        "Field(name='user_id_group_pairs', kw_only=True, fn=None), ReprPlan.Field(name='ip_ranges', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='ipv6_ranges', kw_only=True, fn=None), ReprPlan.Field(name='prefix_list_ids', kw_only"
        "=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='5d4d61028876e0a148997dc4f2bdd55c90513310',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'IpPermission'),
    ),
)
def _process_dataclass__5d4d61028876e0a148997dc4f2bdd55c90513310():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ip_protocol=self.ip_protocol,
                from_port=self.from_port,
                to_port=self.to_port,
                user_id_group_pairs=self.user_id_group_pairs,
                ip_ranges=self.ip_ranges,
                ipv6_ranges=self.ipv6_ranges,
                prefix_list_ids=self.prefix_list_ids,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ip_protocol == other.ip_protocol and
                self.from_port == other.from_port and
                self.to_port == other.to_port and
                self.user_id_group_pairs == other.user_id_group_pairs and
                self.ip_ranges == other.ip_ranges and
                self.ipv6_ranges == other.ipv6_ranges and
                self.prefix_list_ids == other.prefix_list_ids
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ip_protocol',
            'from_port',
            'to_port',
            'user_id_group_pairs',
            'ip_ranges',
            'ipv6_ranges',
            'prefix_list_ids',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ip_protocol',
            'from_port',
            'to_port',
            'user_id_group_pairs',
            'ip_ranges',
            'ipv6_ranges',
            'prefix_list_ids',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ip_protocol,
                self.from_port,
                self.to_port,
                self.user_id_group_pairs,
                self.ip_ranges,
                self.ipv6_ranges,
                self.prefix_list_ids,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ip_protocol: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            from_port: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            to_port: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            user_id_group_pairs: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            ip_ranges: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            ipv6_ranges: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            prefix_list_ids: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ip_protocol', ip_protocol)
            __dataclass__object_setattr(self, 'from_port', from_port)
            __dataclass__object_setattr(self, 'to_port', to_port)
            __dataclass__object_setattr(self, 'user_id_group_pairs', user_id_group_pairs)
            __dataclass__object_setattr(self, 'ip_ranges', ip_ranges)
            __dataclass__object_setattr(self, 'ipv6_ranges', ipv6_ranges)
            __dataclass__object_setattr(self, 'prefix_list_ids', prefix_list_ids)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ip_protocol={self.ip_protocol!r}")
            parts.append(f"from_port={self.from_port!r}")
            parts.append(f"to_port={self.to_port!r}")
            parts.append(f"user_id_group_pairs={self.user_id_group_pairs!r}")
            parts.append(f"ip_ranges={self.ip_ranges!r}")
            parts.append(f"ipv6_ranges={self.ipv6_ranges!r}")
            parts.append(f"prefix_list_ids={self.prefix_list_ids!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('next_token', 'max_results', 'dry_run', 'route_table_ids', 'filters')), EqPlan(fie"
        "lds=('next_token', 'max_results', 'dry_run', 'route_table_ids', 'filters')), FrozenPlan(fields=('__shape__', '"
        "next_token', 'max_results', 'dry_run', 'route_table_ids', 'filters'), allow_dynamic_dunder_attrs=False), HashP"
        "lan(action='add', fields=('next_token', 'max_results', 'dry_run', 'route_table_ids', 'filters'), cache=False),"
        " InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default="
        "None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=N"
        "one, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.1.annotation'), de"
        "fault=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_results', annotation=OpRef"
        "(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='dry_run', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='route_table_ids', annotation=OpRef(name='init.fields.4.annotation'), d"
        "efault=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='filters', annotation=OpRef(na"
        "me='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self"
        "', std_params=(), kw_only_params=('next_token', 'max_results', 'dry_run', 'route_table_ids', 'filters'), froze"
        "n=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
        "e='next_token', kw_only=True, fn=None), ReprPlan.Field(name='max_results', kw_only=True, fn=None), ReprPlan.Fi"
        "eld(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='route_table_ids', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='filters', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='60ae60e5642c31ca058ee94cba2574ae2c983166',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeRouteTablesRequest'),
    ),
)
def _process_dataclass__60ae60e5642c31ca058ee94cba2574ae2c983166():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                next_token=self.next_token,
                max_results=self.max_results,
                dry_run=self.dry_run,
                route_table_ids=self.route_table_ids,
                filters=self.filters,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.next_token == other.next_token and
                self.max_results == other.max_results and
                self.dry_run == other.dry_run and
                self.route_table_ids == other.route_table_ids and
                self.filters == other.filters
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'next_token',
            'max_results',
            'dry_run',
            'route_table_ids',
            'filters',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'next_token',
            'max_results',
            'dry_run',
            'route_table_ids',
            'filters',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.next_token,
                self.max_results,
                self.dry_run,
                self.route_table_ids,
                self.filters,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            max_results: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            dry_run: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            route_table_ids: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            filters: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'max_results', max_results)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'route_table_ids', route_table_ids)
            __dataclass__object_setattr(self, 'filters', filters)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"max_results={self.max_results!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"route_table_ids={self.route_table_ids!r}")
            parts.append(f"filters={self.filters!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('license_configuration_arn',)), EqPlan(fields=('license_configuration_arn',)), Fro"
        "zenPlan(fields=('__shape__', 'license_configuration_arn'), allow_dynamic_dunder_attrs=False), HashPlan(action="
        "'add', fields=('license_configuration_arn',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', "
        "annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='license"
        "_configuration_arn', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defa"
        "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
        "one, check_type=None)), self_param='self', std_params=(), kw_only_params=('license_configuration_arn',), froze"
        "n=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
        "e='license_configuration_arn', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='60dc2293079a28718fcee879d22638a00a001c46',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'LicenseConfiguration'),
        ('ominfra.clouds.aws.models.services.ec2', 'LicenseConfigurationRequest'),
    ),
)
def _process_dataclass__60dc2293079a28718fcee879d22638a00a001c46():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                license_configuration_arn=self.license_configuration_arn,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.license_configuration_arn == other.license_configuration_arn
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'license_configuration_arn',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'license_configuration_arn',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.license_configuration_arn,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            license_configuration_arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'license_configuration_arn', license_configuration_arn)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"license_configuration_arn={self.license_configuration_arn!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('next_token', 'security_groups')), EqPlan(fields=('next_token', 'security_groups')"
        "), FrozenPlan(fields=('__shape__', 'next_token', 'security_groups'), allow_dynamic_dunder_attrs=False), HashPl"
        "an(action='add', fields=('next_token', 'security_groups'), cache=False), InitPlan(fields=(InitPlan.Field(name="
        "'__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True,"
        " override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='next_token', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='security_groups', annotation=OpRef(name='init.fields.2.annotation'),"
        " default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_param"
        "s=('next_token', 'security_groups'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fn"
        "s=()), ReprPlan(fields=(ReprPlan.Field(name='next_token', kw_only=True, fn=None), ReprPlan.Field(name='securit"
        "y_groups', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='64bdc1aa50f0496ab696721dd6c679c10dd92687',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeSecurityGroupsResult'),
    ),
)
def _process_dataclass__64bdc1aa50f0496ab696721dd6c679c10dd92687():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                next_token=self.next_token,
                security_groups=self.security_groups,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.next_token == other.next_token and
                self.security_groups == other.security_groups
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'next_token',
            'security_groups',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'next_token',
            'security_groups',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.next_token,
                self.security_groups,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            security_groups: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'security_groups', security_groups)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"security_groups={self.security_groups!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ena_srd_enabled', 'ena_srd_udp_specification')), EqPlan(fields=('ena_srd_enabled'"
        ", 'ena_srd_udp_specification')), FrozenPlan(fields=('__shape__', 'ena_srd_enabled', 'ena_srd_udp_specification"
        "'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ena_srd_enabled', 'ena_srd_udp_specific"
        "ation'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0."
        "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, c"
        "oerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_srd_enabled', annotation=OpRef(name='ini"
        "t.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena"
        "_srd_udp_specification', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('ena_srd_enabled', 'ena_srd_udp_"
        "specification'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fiel"
        "ds=(ReprPlan.Field(name='ena_srd_enabled', kw_only=True, fn=None), ReprPlan.Field(name='ena_srd_udp_specificat"
        "ion', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='665dc09fab514fa0dfe68075b016a3e79a47a7ad',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'AttachmentEnaSrdSpecification'),
        ('ominfra.clouds.aws.models.services.ec2', 'EnaSrdSpecificationRequest'),
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceAttachmentEnaSrdSpecification'),
    ),
)
def _process_dataclass__665dc09fab514fa0dfe68075b016a3e79a47a7ad():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ena_srd_enabled=self.ena_srd_enabled,
                ena_srd_udp_specification=self.ena_srd_udp_specification,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ena_srd_enabled == other.ena_srd_enabled and
                self.ena_srd_udp_specification == other.ena_srd_udp_specification
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ena_srd_enabled',
            'ena_srd_udp_specification',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ena_srd_enabled',
            'ena_srd_udp_specification',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ena_srd_enabled,
                self.ena_srd_udp_specification,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ena_srd_enabled: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            ena_srd_udp_specification: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ena_srd_enabled', ena_srd_enabled)
            __dataclass__object_setattr(self, 'ena_srd_udp_specification', ena_srd_udp_specification)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ena_srd_enabled={self.ena_srd_enabled!r}")
            parts.append(f"ena_srd_udp_specification={self.ena_srd_udp_specification!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('description', 'group_name', 'vpc_id', 'tag_specifications', 'dry_run')), EqPlan(f"
        "ields=('description', 'group_name', 'vpc_id', 'tag_specifications', 'dry_run')), FrozenPlan(fields=('__shape__"
        "', 'description', 'group_name', 'vpc_id', 'tag_specifications', 'dry_run'), allow_dynamic_dunder_attrs=False),"
        " HashPlan(action='add', fields=('description', 'group_name', 'vpc_id', 'tag_specifications', 'dry_run'), cache"
        "=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), "
        "default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='description', annotation=OpRef(name='init.fields.1.annotat"
        "ion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='group_name', annotation=OpRef(name='init.fields.2.an"
        "notation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.3.a"
        "nnotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tag_specificati"
        "ons', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='"
        "init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
        "e=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('description', 'gr"
        "oup_name', 'vpc_id', 'tag_specifications', 'dry_run'), frozen=True, slots=False, post_init_params=None, init_f"
        "ns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='description', kw_only=True, fn=None), ReprPlan."
        "Field(name='group_name', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPla"
        "n.Field(name='tag_specifications', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=Non"
        "e)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='6761001676719ee7d82d5f2ef1929b36fb933be8',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CreateSecurityGroupRequest'),
    ),
)
def _process_dataclass__6761001676719ee7d82d5f2ef1929b36fb933be8():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                description=self.description,
                group_name=self.group_name,
                vpc_id=self.vpc_id,
                tag_specifications=self.tag_specifications,
                dry_run=self.dry_run,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.description == other.description and
                self.group_name == other.group_name and
                self.vpc_id == other.vpc_id and
                self.tag_specifications == other.tag_specifications and
                self.dry_run == other.dry_run
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'description',
            'group_name',
            'vpc_id',
            'tag_specifications',
            'dry_run',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'description',
            'group_name',
            'vpc_id',
            'tag_specifications',
            'dry_run',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.description,
                self.group_name,
                self.vpc_id,
                self.tag_specifications,
                self.dry_run,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            description: __dataclass__init__fields__1__annotation,
            group_name: __dataclass__init__fields__2__annotation,
            vpc_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            tag_specifications: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            dry_run: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'group_name', group_name)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'tag_specifications', tag_specifications)
            __dataclass__object_setattr(self, 'dry_run', dry_run)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"description={self.description!r}")
            parts.append(f"group_name={self.group_name!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"tag_specifications={self.tag_specifications!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('is_restore_in_progress', 'restore_expiry_date')), EqPlan(fields=('is_restore_in_p"
        "rogress', 'restore_expiry_date')), FrozenPlan(fields=('__shape__', 'is_restore_in_progress', 'restore_expiry_d"
        "ate'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('is_restore_in_progress', 'restore_ex"
        "piry_date'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.field"
        "s.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VA"
        "R, coerce=None, validate=None, check_type=None), InitPlan.Field(name='is_restore_in_progress', annotation=OpRe"
        "f(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='restore_expiry_date', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fiel"
        "ds.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('is_restore_in_progress', '"
        "restore_expiry_date'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPla"
        "n(fields=(ReprPlan.Field(name='is_restore_in_progress', kw_only=True, fn=None), ReprPlan.Field(name='restore_e"
        "xpiry_date', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='6806d7dddb4fb9f5936333eb79517dfb8542221e',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.s3', 'RestoreStatus'),
    ),
)
def _process_dataclass__6806d7dddb4fb9f5936333eb79517dfb8542221e():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                is_restore_in_progress=self.is_restore_in_progress,
                restore_expiry_date=self.restore_expiry_date,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.is_restore_in_progress == other.is_restore_in_progress and
                self.restore_expiry_date == other.restore_expiry_date
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'is_restore_in_progress',
            'restore_expiry_date',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'is_restore_in_progress',
            'restore_expiry_date',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.is_restore_in_progress,
                self.restore_expiry_date,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            is_restore_in_progress: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            restore_expiry_date: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'is_restore_in_progress', is_restore_in_progress)
            __dataclass__object_setattr(self, 'restore_expiry_date', restore_expiry_date)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"is_restore_in_progress={self.is_restore_in_progress!r}")
            parts.append(f"restore_expiry_date={self.restore_expiry_date!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ebs', 'no_device', 'device_name', 'virtual_name')), EqPlan(fields=('ebs', 'no_dev"
        "ice', 'device_name', 'virtual_name')), FrozenPlan(fields=('__shape__', 'ebs', 'no_device', 'device_name', 'vir"
        "tual_name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ebs', 'no_device', 'device_nam"
        "e', 'virtual_name'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='in"
        "it.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType."
        "CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ebs', annotation=OpRef(name='ini"
        "t.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='no_"
        "device', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), defau"
        "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
        "ype=None), InitPlan.Field(name='device_name', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef"
        "(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='virtual_name', annotation=OpRef(name='ini"
        "t.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_"
        "params=(), kw_only_params=('ebs', 'no_device', 'device_name', 'virtual_name'), frozen=True, slots=False, post_"
        "init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ebs', kw_only=True, fn="
        "None), ReprPlan.Field(name='no_device', kw_only=True, fn=None), ReprPlan.Field(name='device_name', kw_only=Tru"
        "e, fn=None), ReprPlan.Field(name='virtual_name', kw_only=True, fn=None)), id=False, terse=False, default_fn=No"
        "ne)))"
    ),
    plan_repr_sha1='694128aac38488f2fdd926dd2d61b92a7e4d2fff',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'BlockDeviceMapping'),
    ),
)
def _process_dataclass__694128aac38488f2fdd926dd2d61b92a7e4d2fff():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ebs=self.ebs,
                no_device=self.no_device,
                device_name=self.device_name,
                virtual_name=self.virtual_name,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ebs == other.ebs and
                self.no_device == other.no_device and
                self.device_name == other.device_name and
                self.virtual_name == other.virtual_name
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ebs',
            'no_device',
            'device_name',
            'virtual_name',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ebs',
            'no_device',
            'device_name',
            'virtual_name',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ebs,
                self.no_device,
                self.device_name,
                self.virtual_name,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ebs: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            no_device: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            device_name: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            virtual_name: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ebs', ebs)
            __dataclass__object_setattr(self, 'no_device', no_device)
            __dataclass__object_setattr(self, 'device_name', device_name)
            __dataclass__object_setattr(self, 'virtual_name', virtual_name)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ebs={self.ebs!r}")
            parts.append(f"no_device={self.no_device!r}")
            parts.append(f"device_name={self.device_name!r}")
            parts.append(f"virtual_name={self.virtual_name!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('attachments', 'internet_gateway_id', 'owner_id', 'tags')), EqPlan(fields=('attach"
        "ments', 'internet_gateway_id', 'owner_id', 'tags')), FrozenPlan(fields=('__shape__', 'attachments', 'internet_"
        "gateway_id', 'owner_id', 'tags'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('attachmen"
        "ts', 'internet_gateway_id', 'owner_id', 'tags'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__"
        "', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override="
        "False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='atta"
        "chments', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='internet_gateway_id', annotation=OpRef(name='init.fields.2.annotation'), defa"
        "ult=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='owner_id', annotation=OpRef(name"
        "='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, ov"
        "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='tags', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), defau"
        "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
        "ype=None)), self_param='self', std_params=(), kw_only_params=('attachments', 'internet_gateway_id', 'owner_id'"
        ", 'tags'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Re"
        "prPlan.Field(name='attachments', kw_only=True, fn=None), ReprPlan.Field(name='internet_gateway_id', kw_only=Tr"
        "ue, fn=None), ReprPlan.Field(name='owner_id', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=True"
        ", fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='6a86d2b168af2b5ae6345c6175bf57264a7bf041',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InternetGateway'),
    ),
)
def _process_dataclass__6a86d2b168af2b5ae6345c6175bf57264a7bf041():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                attachments=self.attachments,
                internet_gateway_id=self.internet_gateway_id,
                owner_id=self.owner_id,
                tags=self.tags,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.attachments == other.attachments and
                self.internet_gateway_id == other.internet_gateway_id and
                self.owner_id == other.owner_id and
                self.tags == other.tags
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'attachments',
            'internet_gateway_id',
            'owner_id',
            'tags',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'attachments',
            'internet_gateway_id',
            'owner_id',
            'tags',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.attachments,
                self.internet_gateway_id,
                self.owner_id,
                self.tags,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            attachments: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            internet_gateway_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            owner_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            tags: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'attachments', attachments)
            __dataclass__object_setattr(self, 'internet_gateway_id', internet_gateway_id)
            __dataclass__object_setattr(self, 'owner_id', owner_id)
            __dataclass__object_setattr(self, 'tags', tags)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"attachments={self.attachments!r}")
            parts.append(f"internet_gateway_id={self.internet_gateway_id!r}")
            parts.append(f"owner_id={self.owner_id!r}")
            parts.append(f"tags={self.tags!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('group_id', 'ip_permissions_egress', 'tags', 'vpc_id', 'security_group_arn', 'owne"
        "r_id', 'group_name', 'description', 'ip_permissions')), EqPlan(fields=('group_id', 'ip_permissions_egress', 't"
        "ags', 'vpc_id', 'security_group_arn', 'owner_id', 'group_name', 'description', 'ip_permissions')), FrozenPlan("
        "fields=('__shape__', 'group_id', 'ip_permissions_egress', 'tags', 'vpc_id', 'security_group_arn', 'owner_id', "
        "'group_name', 'description', 'ip_permissions'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fiel"
        "ds=('group_id', 'ip_permissions_egress', 'tags', 'vpc_id', 'security_group_arn', 'owner_id', 'group_name', 'de"
        "scription', 'ip_permissions'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRe"
        "f(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type="
        "FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_id', annotation="
        "OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='ip_permissions_egress', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='ini"
        "t.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
        "one, validate=None, check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='init.fields.3.annotat"
        "ion'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_id', annotation=O"
        "pRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init"
        "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
        "ield(name='security_group_arn', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fi"
        "elds.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='owner_id', annotation=OpRef(name='init.fields.6.annotat"
        "ion'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_name', annotati"
        "on=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='description', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.field"
        "s.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='ip_permissions', annotation=OpRef(name='init.fields.9.anno"
        "tation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_o"
        "nly_params=('group_id', 'ip_permissions_egress', 'tags', 'vpc_id', 'security_group_arn', 'owner_id', 'group_na"
        "me', 'description', 'ip_permissions'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_"
        "fns=()), ReprPlan(fields=(ReprPlan.Field(name='group_id', kw_only=True, fn=None), ReprPlan.Field(name='ip_perm"
        "issions_egress', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=True, fn=None), ReprPlan.Field(na"
        "me='vpc_id', kw_only=True, fn=None), ReprPlan.Field(name='security_group_arn', kw_only=True, fn=None), ReprPla"
        "n.Field(name='owner_id', kw_only=True, fn=None), ReprPlan.Field(name='group_name', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='description', kw_only=True, fn=None), ReprPlan.Field(name='ip_permissions', kw_only=True, fn"
        "=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='6b96e533fe8f8ebd408827622def8123d5c1c9dc',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'SecurityGroup'),
    ),
)
def _process_dataclass__6b96e533fe8f8ebd408827622def8123d5c1c9dc():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                group_id=self.group_id,
                ip_permissions_egress=self.ip_permissions_egress,
                tags=self.tags,
                vpc_id=self.vpc_id,
                security_group_arn=self.security_group_arn,
                owner_id=self.owner_id,
                group_name=self.group_name,
                description=self.description,
                ip_permissions=self.ip_permissions,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.group_id == other.group_id and
                self.ip_permissions_egress == other.ip_permissions_egress and
                self.tags == other.tags and
                self.vpc_id == other.vpc_id and
                self.security_group_arn == other.security_group_arn and
                self.owner_id == other.owner_id and
                self.group_name == other.group_name and
                self.description == other.description and
                self.ip_permissions == other.ip_permissions
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'group_id',
            'ip_permissions_egress',
            'tags',
            'vpc_id',
            'security_group_arn',
            'owner_id',
            'group_name',
            'description',
            'ip_permissions',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'group_id',
            'ip_permissions_egress',
            'tags',
            'vpc_id',
            'security_group_arn',
            'owner_id',
            'group_name',
            'description',
            'ip_permissions',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.group_id,
                self.ip_permissions_egress,
                self.tags,
                self.vpc_id,
                self.security_group_arn,
                self.owner_id,
                self.group_name,
                self.description,
                self.ip_permissions,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            group_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            ip_permissions_egress: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            tags: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            vpc_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            security_group_arn: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            owner_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            group_name: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            description: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            ip_permissions: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'group_id', group_id)
            __dataclass__object_setattr(self, 'ip_permissions_egress', ip_permissions_egress)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'security_group_arn', security_group_arn)
            __dataclass__object_setattr(self, 'owner_id', owner_id)
            __dataclass__object_setattr(self, 'group_name', group_name)
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'ip_permissions', ip_permissions)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"group_id={self.group_id!r}")
            parts.append(f"ip_permissions_egress={self.ip_permissions_egress!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"security_group_arn={self.security_group_arn!r}")
            parts.append(f"owner_id={self.owner_id!r}")
            parts.append(f"group_name={self.group_name!r}")
            parts.append(f"description={self.description!r}")
            parts.append(f"ip_permissions={self.ip_permissions!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('log_types_to_enable', 'log_types_to_disable')), EqPlan(fields=('log_types_to_enab"
        "le', 'log_types_to_disable')), FrozenPlan(fields=('__shape__', 'log_types_to_enable', 'log_types_to_disable'),"
        " allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('log_types_to_enable', 'log_types_to_disabl"
        "e'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.anno"
        "tation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerc"
        "e=None, validate=None, check_type=None), InitPlan.Field(name='log_types_to_enable', annotation=OpRef(name='ini"
        "t.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='log"
        "_types_to_disable', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None)), self_param='self', std_params=(), kw_only_params=('log_types_to_enable', 'log_types_to_"
        "disable'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Re"
        "prPlan.Field(name='log_types_to_enable', kw_only=True, fn=None), ReprPlan.Field(name='log_types_to_disable', k"
        "w_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='6c402681f08e7afb46231052156de336964e583e',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'PendingCloudwatchLogsExports'),
    ),
)
def _process_dataclass__6c402681f08e7afb46231052156de336964e583e():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                log_types_to_enable=self.log_types_to_enable,
                log_types_to_disable=self.log_types_to_disable,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.log_types_to_enable == other.log_types_to_enable and
                self.log_types_to_disable == other.log_types_to_disable
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'log_types_to_enable',
            'log_types_to_disable',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'log_types_to_enable',
            'log_types_to_disable',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.log_types_to_enable,
                self.log_types_to_disable,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            log_types_to_enable: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            log_types_to_disable: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'log_types_to_enable', log_types_to_enable)
            __dataclass__object_setattr(self, 'log_types_to_disable', log_types_to_disable)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"log_types_to_enable={self.log_types_to_enable!r}")
            parts.append(f"log_types_to_disable={self.log_types_to_disable!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('storage_class', 'access_tier')), EqPlan(fields=('storage_class', 'access_tier')),"
        " FrozenPlan(fields=('__shape__', 'storage_class', 'access_tier'), allow_dynamic_dunder_attrs=False), HashPlan("
        "action='add', fields=('storage_class', 'access_tier'), cache=False), InitPlan(fields=(InitPlan.Field(name='__s"
        "hape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='storage_class', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default"
        "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
        ", check_type=None), InitPlan.Field(name='access_tier', annotation=OpRef(name='init.fields.2.annotation'), defa"
        "ult=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('s"
        "torage_class', 'access_tier'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
        " ReprPlan(fields=(ReprPlan.Field(name='storage_class', kw_only=True, fn=None), ReprPlan.Field(name='access_tie"
        "r', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='6e1556eb8f47a5fb63c82d958b0cc397873f9549',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.s3', 'InvalidObjectState'),
    ),
)
def _process_dataclass__6e1556eb8f47a5fb63c82d958b0cc397873f9549():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                storage_class=self.storage_class,
                access_tier=self.access_tier,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.storage_class == other.storage_class and
                self.access_tier == other.access_tier
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'storage_class',
            'access_tier',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'storage_class',
            'access_tier',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.storage_class,
                self.access_tier,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            storage_class: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            access_tier: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'storage_class', storage_class)
            __dataclass__object_setattr(self, 'access_tier', access_tier)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"storage_class={self.storage_class!r}")
            parts.append(f"access_tier={self.access_tier!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('arn',)), EqPlan(fields=('arn',)), FrozenPlan(fields=('__shape__', 'arn'), allow_d"
        "ynamic_dunder_attrs=False), HashPlan(action='add', fields=('arn',), cache=False), InitPlan(fields=(InitPlan.Fi"
        "eld(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='arn', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defa"
        "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
        "one, check_type=None)), self_param='self', std_params=(), kw_only_params=('arn',), frozen=True, slots=False, p"
        "ost_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='arn', kw_only=True,"
        " fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='6eeb5cf87ddee1bcad75c8766a916fd57479a19d',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'Outpost'),
    ),
)
def _process_dataclass__6eeb5cf87ddee1bcad75c8766a916fd57479a19d():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                arn=self.arn,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.arn == other.arn
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'arn',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'arn',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.arn,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'arn', arn)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"arn={self.arn!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('gpus', 'total_gpu_memory_in_mi_b')), EqPlan(fields=('gpus', 'total_gpu_memory_in_"
        "mi_b')), FrozenPlan(fields=('__shape__', 'gpus', 'total_gpu_memory_in_mi_b'), allow_dynamic_dunder_attrs=False"
        "), HashPlan(action='add', fields=('gpus', 'total_gpu_memory_in_mi_b'), cache=False), InitPlan(fields=(InitPlan"
        ".Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None"
        ", init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='gpus', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='total_gpu_memory_in_mi_b', annotation=OpRef(name='init.fields."
        "2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=()"
        ", kw_only_params=('gpus', 'total_gpu_memory_in_mi_b'), frozen=True, slots=False, post_init_params=None, init_f"
        "ns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='gpus', kw_only=True, fn=None), ReprPlan.Field(n"
        "ame='total_gpu_memory_in_mi_b', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='716db2b453a7379781d728ae63db1a6fd30a0069',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'GpuInfo'),
    ),
)
def _process_dataclass__716db2b453a7379781d728ae63db1a6fd30a0069():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                gpus=self.gpus,
                total_gpu_memory_in_mi_b=self.total_gpu_memory_in_mi_b,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.gpus == other.gpus and
                self.total_gpu_memory_in_mi_b == other.total_gpu_memory_in_mi_b
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'gpus',
            'total_gpu_memory_in_mi_b',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'gpus',
            'total_gpu_memory_in_mi_b',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.gpus,
                self.total_gpu_memory_in_mi_b,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            gpus: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            total_gpu_memory_in_mi_b: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'gpus', gpus)
            __dataclass__object_setattr(self, 'total_gpu_memory_in_mi_b', total_gpu_memory_in_mi_b)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"gpus={self.gpus!r}")
            parts.append(f"total_gpu_memory_in_mi_b={self.total_gpu_memory_in_mi_b!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('dry_run', 'route_table_id')), EqPlan(fields=('dry_run', 'route_table_id')), Froze"
        "nPlan(fields=('__shape__', 'dry_run', 'route_table_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='a"
        "dd', fields=('dry_run', 'route_table_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', ann"
        "otation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False,"
        " field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', "
        "annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='route_table_id', annotation=OpRef(name='init.fields.2.annotation'), default=None, defau"
        "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
        "ype=None)), self_param='self', std_params=(), kw_only_params=('dry_run', 'route_table_id'), frozen=True, slots"
        "=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='dry_run', "
        "kw_only=True, fn=None), ReprPlan.Field(name='route_table_id', kw_only=True, fn=None)), id=False, terse=False, "
        "default_fn=None)))"
    ),
    plan_repr_sha1='71e4b4e0f9919133a1bf7f7a493d96671919406d',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DeleteRouteTableRequest'),
    ),
)
def _process_dataclass__71e4b4e0f9919133a1bf7f7a493d96671919406d():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                dry_run=self.dry_run,
                route_table_id=self.route_table_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.dry_run == other.dry_run and
                self.route_table_id == other.route_table_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'dry_run',
            'route_table_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'dry_run',
            'route_table_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.dry_run,
                self.route_table_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            dry_run: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            route_table_id: __dataclass__init__fields__2__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'route_table_id', route_table_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"route_table_id={self.route_table_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('resource_type', 'tags')), EqPlan(fields=('resource_type', 'tags')), FrozenPlan(fi"
        "elds=('__shape__', 'resource_type', 'tags'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields="
        "('resource_type', 'tags'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(na"
        "me='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='resource_type', annotation"
        "=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
        ".Field(name='tags', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None)), self_param='self', std_params=(), kw_only_params=('resource_type', 'tags'), frozen=True"
        ", slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='res"
        "ource_type', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=True, fn=None)), id=False, terse=Fals"
        "e, default_fn=None)))"
    ),
    plan_repr_sha1='72408a250113d7efc0131778f5e6fa438b55e772',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'TagSpecification'),
    ),
)
def _process_dataclass__72408a250113d7efc0131778f5e6fa438b55e772():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                resource_type=self.resource_type,
                tags=self.tags,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.resource_type == other.resource_type and
                self.tags == other.tags
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'resource_type',
            'tags',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'resource_type',
            'tags',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.resource_type,
                self.tags,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            resource_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            tags: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'resource_type', resource_type)
            __dataclass__object_setattr(self, 'tags', tags)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"resource_type={self.resource_type!r}")
            parts.append(f"tags={self.tags!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('function_name', 'function_arn', 'runtime', 'role', 'handler', 'code_size', 'descr"
        "iption', 'timeout', 'memory_size', 'last_modified', 'code_sha256', 'version', 'vpc_config', 'dead_letter_confi"
        "g', 'environment', 'kms_key_arn', 'tracing_config', 'master_arn', 'revision_id', 'layers', 'state', 'state_rea"
        "son', 'state_reason_code', 'last_update_status', 'last_update_status_reason', 'last_update_status_reason_code'"
        ", 'file_system_configs', 'package_type', 'image_config_response', 'signing_profile_version_arn', 'signing_job_"
        "arn', 'architectures', 'ephemeral_storage', 'snap_start', 'runtime_version_config', 'logging_config', 'capacit"
        "y_provider_config', 'config_sha256', 'durable_config', 'tenancy_config')), EqPlan(fields=('function_name', 'fu"
        "nction_arn', 'runtime', 'role', 'handler', 'code_size', 'description', 'timeout', 'memory_size', 'last_modifie"
        "d', 'code_sha256', 'version', 'vpc_config', 'dead_letter_config', 'environment', 'kms_key_arn', 'tracing_confi"
        "g', 'master_arn', 'revision_id', 'layers', 'state', 'state_reason', 'state_reason_code', 'last_update_status',"
        " 'last_update_status_reason', 'last_update_status_reason_code', 'file_system_configs', 'package_type', 'image_"
        "config_response', 'signing_profile_version_arn', 'signing_job_arn', 'architectures', 'ephemeral_storage', 'sna"
        "p_start', 'runtime_version_config', 'logging_config', 'capacity_provider_config', 'config_sha256', 'durable_co"
        "nfig', 'tenancy_config')), FrozenPlan(fields=('__shape__', 'function_name', 'function_arn', 'runtime', 'role',"
        " 'handler', 'code_size', 'description', 'timeout', 'memory_size', 'last_modified', 'code_sha256', 'version', '"
        "vpc_config', 'dead_letter_config', 'environment', 'kms_key_arn', 'tracing_config', 'master_arn', 'revision_id'"
        ", 'layers', 'state', 'state_reason', 'state_reason_code', 'last_update_status', 'last_update_status_reason', '"
        "last_update_status_reason_code', 'file_system_configs', 'package_type', 'image_config_response', 'signing_prof"
        "ile_version_arn', 'signing_job_arn', 'architectures', 'ephemeral_storage', 'snap_start', 'runtime_version_conf"
        "ig', 'logging_config', 'capacity_provider_config', 'config_sha256', 'durable_config', 'tenancy_config'), allow"
        "_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('function_name', 'function_arn', 'runtime', 'role"
        "', 'handler', 'code_size', 'description', 'timeout', 'memory_size', 'last_modified', 'code_sha256', 'version',"
        " 'vpc_config', 'dead_letter_config', 'environment', 'kms_key_arn', 'tracing_config', 'master_arn', 'revision_i"
        "d', 'layers', 'state', 'state_reason', 'state_reason_code', 'last_update_status', 'last_update_status_reason',"
        " 'last_update_status_reason_code', 'file_system_configs', 'package_type', 'image_config_response', 'signing_pr"
        "ofile_version_arn', 'signing_job_arn', 'architectures', 'ephemeral_storage', 'snap_start', 'runtime_version_co"
        "nfig', 'logging_config', 'capacity_provider_config', 'config_sha256', 'durable_config', 'tenancy_config'), cac"
        "he=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation')"
        ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='function_name', annotation=OpRef(name='init.fields.1.ann"
        "otation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='function_arn', an"
        "notation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory="
        "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
        "InitPlan.Field(name='runtime', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fie"
        "lds.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='role', annotation=OpRef(name='init.fields.4.annotation')"
        ", default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=Fie"
        "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='handler', annotation=OpRef"
        "(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='code_size', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='description', annotation=OpRef(name='init.fields.7.annotation'), def"
        "ault=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='timeout', annotation=OpRef(name"
        "='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, ov"
        "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='memory_size', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default')"
        ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='last_modified', annotation=OpRef(name='init.fields.10.annotation'), def"
        "ault=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='code_sha256', annotation=OpRef"
        "(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
        "ld(name='version', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.defa"
        "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
        "one, check_type=None), InitPlan.Field(name='vpc_config', annotation=OpRef(name='init.fields.13.annotation'), d"
        "efault=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dead_letter_config', annotat"
        "ion=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='environment', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.f"
        "ields.15.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
        "e, validate=None, check_type=None), InitPlan.Field(name='kms_key_arn', annotation=OpRef(name='init.fields.16.a"
        "nnotation'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tracing_config"
        "', annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None), InitPlan.Field(name='master_arn', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(nam"
        "e='init.fields.18.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
        "oerce=None, validate=None, check_type=None), InitPlan.Field(name='revision_id', annotation=OpRef(name='init.fi"
        "elds.19.annotation'), default=OpRef(name='init.fields.19.default'), default_factory=None, init=True, override="
        "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='layer"
        "s', annotation=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.fields.20.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='state', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='i"
        "nit.fields.21.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
        "e=None, validate=None, check_type=None), InitPlan.Field(name='state_reason', annotation=OpRef(name='init.field"
        "s.22.annotation'), default=OpRef(name='init.fields.22.default'), default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state_re"
        "ason_code', annotation=OpRef(name='init.fields.23.annotation'), default=OpRef(name='init.fields.23.default'), "
        "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
        "eck_type=None), InitPlan.Field(name='last_update_status', annotation=OpRef(name='init.fields.24.annotation'), "
        "default=OpRef(name='init.fields.24.default'), default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='last_update_status_reason',"
        " annotation=OpRef(name='init.fields.25.annotation'), default=OpRef(name='init.fields.25.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='last_update_status_reason_code', annotation=OpRef(name='init.fields.26.annotation'),"
        " default=OpRef(name='init.fields.26.default'), default_factory=None, init=True, override=False, field_type=Fie"
        "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='file_system_configs', anno"
        "tation=OpRef(name='init.fields.27.annotation'), default=OpRef(name='init.fields.27.default'), default_factory="
        "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
        "InitPlan.Field(name='package_type', annotation=OpRef(name='init.fields.28.annotation'), default=OpRef(name='in"
        "it.fields.28.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='image_config_response', annotation=OpRef(name='in"
        "it.fields.29.annotation'), default=OpRef(name='init.fields.29.default'), default_factory=None, init=True, over"
        "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "signing_profile_version_arn', annotation=OpRef(name='init.fields.30.annotation'), default=OpRef(name='init.fie"
        "lds.30.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='signing_job_arn', annotation=OpRef(name='init.fields.31"
        ".annotation'), default=OpRef(name='init.fields.31.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='architecture"
        "s', annotation=OpRef(name='init.fields.32.annotation'), default=OpRef(name='init.fields.32.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='ephemeral_storage', annotation=OpRef(name='init.fields.33.annotation'), default=O"
        "pRef(name='init.fields.33.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='snap_start', annotation=OpRef(name='"
        "init.fields.34.annotation'), default=OpRef(name='init.fields.34.default'), default_factory=None, init=True, ov"
        "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='runtime_version_config', annotation=OpRef(name='init.fields.35.annotation'), default=OpRef(name='init.fields"
        ".35.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='logging_config', annotation=OpRef(name='init.fields.36.ann"
        "otation'), default=OpRef(name='init.fields.36.default'), default_factory=None, init=True, override=False, fiel"
        "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='capacity_provide"
        "r_config', annotation=OpRef(name='init.fields.37.annotation'), default=OpRef(name='init.fields.37.default'), d"
        "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='config_sha256', annotation=OpRef(name='init.fields.38.annotation'), defaul"
        "t=OpRef(name='init.fields.38.default'), default_factory=None, init=True, override=False, field_type=FieldType."
        "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='durable_config', annotation=OpRef"
        "(name='init.fields.39.annotation'), default=OpRef(name='init.fields.39.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
        "ld(name='tenancy_config', annotation=OpRef(name='init.fields.40.annotation'), default=OpRef(name='init.fields."
        "40.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('function_name', 'function_ar"
        "n', 'runtime', 'role', 'handler', 'code_size', 'description', 'timeout', 'memory_size', 'last_modified', 'code"
        "_sha256', 'version', 'vpc_config', 'dead_letter_config', 'environment', 'kms_key_arn', 'tracing_config', 'mast"
        "er_arn', 'revision_id', 'layers', 'state', 'state_reason', 'state_reason_code', 'last_update_status', 'last_up"
        "date_status_reason', 'last_update_status_reason_code', 'file_system_configs', 'package_type', 'image_config_re"
        "sponse', 'signing_profile_version_arn', 'signing_job_arn', 'architectures', 'ephemeral_storage', 'snap_start',"
        " 'runtime_version_config', 'logging_config', 'capacity_provider_config', 'config_sha256', 'durable_config', 't"
        "enancy_config'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fiel"
        "ds=(ReprPlan.Field(name='function_name', kw_only=True, fn=None), ReprPlan.Field(name='function_arn', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='runtime', kw_only=True, fn=None), ReprPlan.Field(name='role', kw_only=True"
        ", fn=None), ReprPlan.Field(name='handler', kw_only=True, fn=None), ReprPlan.Field(name='code_size', kw_only=Tr"
        "ue, fn=None), ReprPlan.Field(name='description', kw_only=True, fn=None), ReprPlan.Field(name='timeout', kw_onl"
        "y=True, fn=None), ReprPlan.Field(name='memory_size', kw_only=True, fn=None), ReprPlan.Field(name='last_modifie"
        "d', kw_only=True, fn=None), ReprPlan.Field(name='code_sha256', kw_only=True, fn=None), ReprPlan.Field(name='ve"
        "rsion', kw_only=True, fn=None), ReprPlan.Field(name='vpc_config', kw_only=True, fn=None), ReprPlan.Field(name="
        "'dead_letter_config', kw_only=True, fn=None), ReprPlan.Field(name='environment', kw_only=True, fn=None), ReprP"
        "lan.Field(name='kms_key_arn', kw_only=True, fn=None), ReprPlan.Field(name='tracing_config', kw_only=True, fn=N"
        "one), ReprPlan.Field(name='master_arn', kw_only=True, fn=None), ReprPlan.Field(name='revision_id', kw_only=Tru"
        "e, fn=None), ReprPlan.Field(name='layers', kw_only=True, fn=None), ReprPlan.Field(name='state', kw_only=True, "
        "fn=None), ReprPlan.Field(name='state_reason', kw_only=True, fn=None), ReprPlan.Field(name='state_reason_code',"
        " kw_only=True, fn=None), ReprPlan.Field(name='last_update_status', kw_only=True, fn=None), ReprPlan.Field(name"
        "='last_update_status_reason', kw_only=True, fn=None), ReprPlan.Field(name='last_update_status_reason_code', kw"
        "_only=True, fn=None), ReprPlan.Field(name='file_system_configs', kw_only=True, fn=None), ReprPlan.Field(name='"
        "package_type', kw_only=True, fn=None), ReprPlan.Field(name='image_config_response', kw_only=True, fn=None), Re"
        "prPlan.Field(name='signing_profile_version_arn', kw_only=True, fn=None), ReprPlan.Field(name='signing_job_arn'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='architectures', kw_only=True, fn=None), ReprPlan.Field(name='ep"
        "hemeral_storage', kw_only=True, fn=None), ReprPlan.Field(name='snap_start', kw_only=True, fn=None), ReprPlan.F"
        "ield(name='runtime_version_config', kw_only=True, fn=None), ReprPlan.Field(name='logging_config', kw_only=True"
        ", fn=None), ReprPlan.Field(name='capacity_provider_config', kw_only=True, fn=None), ReprPlan.Field(name='confi"
        "g_sha256', kw_only=True, fn=None), ReprPlan.Field(name='durable_config', kw_only=True, fn=None), ReprPlan.Fiel"
        "d(name='tenancy_config', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='73a6aff22feac7761d197b901075deb9184371c9',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__24__annotation',
        '__dataclass__init__fields__24__default',
        '__dataclass__init__fields__25__annotation',
        '__dataclass__init__fields__25__default',
        '__dataclass__init__fields__26__annotation',
        '__dataclass__init__fields__26__default',
        '__dataclass__init__fields__27__annotation',
        '__dataclass__init__fields__27__default',
        '__dataclass__init__fields__28__annotation',
        '__dataclass__init__fields__28__default',
        '__dataclass__init__fields__29__annotation',
        '__dataclass__init__fields__29__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__30__annotation',
        '__dataclass__init__fields__30__default',
        '__dataclass__init__fields__31__annotation',
        '__dataclass__init__fields__31__default',
        '__dataclass__init__fields__32__annotation',
        '__dataclass__init__fields__32__default',
        '__dataclass__init__fields__33__annotation',
        '__dataclass__init__fields__33__default',
        '__dataclass__init__fields__34__annotation',
        '__dataclass__init__fields__34__default',
        '__dataclass__init__fields__35__annotation',
        '__dataclass__init__fields__35__default',
        '__dataclass__init__fields__36__annotation',
        '__dataclass__init__fields__36__default',
        '__dataclass__init__fields__37__annotation',
        '__dataclass__init__fields__37__default',
        '__dataclass__init__fields__38__annotation',
        '__dataclass__init__fields__38__default',
        '__dataclass__init__fields__39__annotation',
        '__dataclass__init__fields__39__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__40__annotation',
        '__dataclass__init__fields__40__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'FunctionConfiguration'),
    ),
)
def _process_dataclass__73a6aff22feac7761d197b901075deb9184371c9():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__24__annotation,
        __dataclass__init__fields__24__default,
        __dataclass__init__fields__25__annotation,
        __dataclass__init__fields__25__default,
        __dataclass__init__fields__26__annotation,
        __dataclass__init__fields__26__default,
        __dataclass__init__fields__27__annotation,
        __dataclass__init__fields__27__default,
        __dataclass__init__fields__28__annotation,
        __dataclass__init__fields__28__default,
        __dataclass__init__fields__29__annotation,
        __dataclass__init__fields__29__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__30__annotation,
        __dataclass__init__fields__30__default,
        __dataclass__init__fields__31__annotation,
        __dataclass__init__fields__31__default,
        __dataclass__init__fields__32__annotation,
        __dataclass__init__fields__32__default,
        __dataclass__init__fields__33__annotation,
        __dataclass__init__fields__33__default,
        __dataclass__init__fields__34__annotation,
        __dataclass__init__fields__34__default,
        __dataclass__init__fields__35__annotation,
        __dataclass__init__fields__35__default,
        __dataclass__init__fields__36__annotation,
        __dataclass__init__fields__36__default,
        __dataclass__init__fields__37__annotation,
        __dataclass__init__fields__37__default,
        __dataclass__init__fields__38__annotation,
        __dataclass__init__fields__38__default,
        __dataclass__init__fields__39__annotation,
        __dataclass__init__fields__39__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__40__annotation,
        __dataclass__init__fields__40__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                function_name=self.function_name,
                function_arn=self.function_arn,
                runtime=self.runtime,
                role=self.role,
                handler=self.handler,
                code_size=self.code_size,
                description=self.description,
                timeout=self.timeout,
                memory_size=self.memory_size,
                last_modified=self.last_modified,
                code_sha256=self.code_sha256,
                version=self.version,
                vpc_config=self.vpc_config,
                dead_letter_config=self.dead_letter_config,
                environment=self.environment,
                kms_key_arn=self.kms_key_arn,
                tracing_config=self.tracing_config,
                master_arn=self.master_arn,
                revision_id=self.revision_id,
                layers=self.layers,
                state=self.state,
                state_reason=self.state_reason,
                state_reason_code=self.state_reason_code,
                last_update_status=self.last_update_status,
                last_update_status_reason=self.last_update_status_reason,
                last_update_status_reason_code=self.last_update_status_reason_code,
                file_system_configs=self.file_system_configs,
                package_type=self.package_type,
                image_config_response=self.image_config_response,
                signing_profile_version_arn=self.signing_profile_version_arn,
                signing_job_arn=self.signing_job_arn,
                architectures=self.architectures,
                ephemeral_storage=self.ephemeral_storage,
                snap_start=self.snap_start,
                runtime_version_config=self.runtime_version_config,
                logging_config=self.logging_config,
                capacity_provider_config=self.capacity_provider_config,
                config_sha256=self.config_sha256,
                durable_config=self.durable_config,
                tenancy_config=self.tenancy_config,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.function_name == other.function_name and
                self.function_arn == other.function_arn and
                self.runtime == other.runtime and
                self.role == other.role and
                self.handler == other.handler and
                self.code_size == other.code_size and
                self.description == other.description and
                self.timeout == other.timeout and
                self.memory_size == other.memory_size and
                self.last_modified == other.last_modified and
                self.code_sha256 == other.code_sha256 and
                self.version == other.version and
                self.vpc_config == other.vpc_config and
                self.dead_letter_config == other.dead_letter_config and
                self.environment == other.environment and
                self.kms_key_arn == other.kms_key_arn and
                self.tracing_config == other.tracing_config and
                self.master_arn == other.master_arn and
                self.revision_id == other.revision_id and
                self.layers == other.layers and
                self.state == other.state and
                self.state_reason == other.state_reason and
                self.state_reason_code == other.state_reason_code and
                self.last_update_status == other.last_update_status and
                self.last_update_status_reason == other.last_update_status_reason and
                self.last_update_status_reason_code == other.last_update_status_reason_code and
                self.file_system_configs == other.file_system_configs and
                self.package_type == other.package_type and
                self.image_config_response == other.image_config_response and
                self.signing_profile_version_arn == other.signing_profile_version_arn and
                self.signing_job_arn == other.signing_job_arn and
                self.architectures == other.architectures and
                self.ephemeral_storage == other.ephemeral_storage and
                self.snap_start == other.snap_start and
                self.runtime_version_config == other.runtime_version_config and
                self.logging_config == other.logging_config and
                self.capacity_provider_config == other.capacity_provider_config and
                self.config_sha256 == other.config_sha256 and
                self.durable_config == other.durable_config and
                self.tenancy_config == other.tenancy_config
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'function_name',
            'function_arn',
            'runtime',
            'role',
            'handler',
            'code_size',
            'description',
            'timeout',
            'memory_size',
            'last_modified',
            'code_sha256',
            'version',
            'vpc_config',
            'dead_letter_config',
            'environment',
            'kms_key_arn',
            'tracing_config',
            'master_arn',
            'revision_id',
            'layers',
            'state',
            'state_reason',
            'state_reason_code',
            'last_update_status',
            'last_update_status_reason',
            'last_update_status_reason_code',
            'file_system_configs',
            'package_type',
            'image_config_response',
            'signing_profile_version_arn',
            'signing_job_arn',
            'architectures',
            'ephemeral_storage',
            'snap_start',
            'runtime_version_config',
            'logging_config',
            'capacity_provider_config',
            'config_sha256',
            'durable_config',
            'tenancy_config',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'function_name',
            'function_arn',
            'runtime',
            'role',
            'handler',
            'code_size',
            'description',
            'timeout',
            'memory_size',
            'last_modified',
            'code_sha256',
            'version',
            'vpc_config',
            'dead_letter_config',
            'environment',
            'kms_key_arn',
            'tracing_config',
            'master_arn',
            'revision_id',
            'layers',
            'state',
            'state_reason',
            'state_reason_code',
            'last_update_status',
            'last_update_status_reason',
            'last_update_status_reason_code',
            'file_system_configs',
            'package_type',
            'image_config_response',
            'signing_profile_version_arn',
            'signing_job_arn',
            'architectures',
            'ephemeral_storage',
            'snap_start',
            'runtime_version_config',
            'logging_config',
            'capacity_provider_config',
            'config_sha256',
            'durable_config',
            'tenancy_config',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.function_name,
                self.function_arn,
                self.runtime,
                self.role,
                self.handler,
                self.code_size,
                self.description,
                self.timeout,
                self.memory_size,
                self.last_modified,
                self.code_sha256,
                self.version,
                self.vpc_config,
                self.dead_letter_config,
                self.environment,
                self.kms_key_arn,
                self.tracing_config,
                self.master_arn,
                self.revision_id,
                self.layers,
                self.state,
                self.state_reason,
                self.state_reason_code,
                self.last_update_status,
                self.last_update_status_reason,
                self.last_update_status_reason_code,
                self.file_system_configs,
                self.package_type,
                self.image_config_response,
                self.signing_profile_version_arn,
                self.signing_job_arn,
                self.architectures,
                self.ephemeral_storage,
                self.snap_start,
                self.runtime_version_config,
                self.logging_config,
                self.capacity_provider_config,
                self.config_sha256,
                self.durable_config,
                self.tenancy_config,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            function_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            function_arn: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            runtime: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            role: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            handler: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            code_size: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            description: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            timeout: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            memory_size: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            last_modified: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            code_sha256: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            version: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            vpc_config: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            dead_letter_config: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            environment: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            kms_key_arn: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            tracing_config: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            master_arn: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            revision_id: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            layers: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            state: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            state_reason: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            state_reason_code: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
            last_update_status: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
            last_update_status_reason: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
            last_update_status_reason_code: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
            file_system_configs: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
            package_type: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
            image_config_response: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
            signing_profile_version_arn: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
            signing_job_arn: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
            architectures: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
            ephemeral_storage: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
            snap_start: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
            runtime_version_config: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
            logging_config: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
            capacity_provider_config: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
            config_sha256: __dataclass__init__fields__38__annotation = __dataclass__init__fields__38__default,
            durable_config: __dataclass__init__fields__39__annotation = __dataclass__init__fields__39__default,
            tenancy_config: __dataclass__init__fields__40__annotation = __dataclass__init__fields__40__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'function_name', function_name)
            __dataclass__object_setattr(self, 'function_arn', function_arn)
            __dataclass__object_setattr(self, 'runtime', runtime)
            __dataclass__object_setattr(self, 'role', role)
            __dataclass__object_setattr(self, 'handler', handler)
            __dataclass__object_setattr(self, 'code_size', code_size)
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'timeout', timeout)
            __dataclass__object_setattr(self, 'memory_size', memory_size)
            __dataclass__object_setattr(self, 'last_modified', last_modified)
            __dataclass__object_setattr(self, 'code_sha256', code_sha256)
            __dataclass__object_setattr(self, 'version', version)
            __dataclass__object_setattr(self, 'vpc_config', vpc_config)
            __dataclass__object_setattr(self, 'dead_letter_config', dead_letter_config)
            __dataclass__object_setattr(self, 'environment', environment)
            __dataclass__object_setattr(self, 'kms_key_arn', kms_key_arn)
            __dataclass__object_setattr(self, 'tracing_config', tracing_config)
            __dataclass__object_setattr(self, 'master_arn', master_arn)
            __dataclass__object_setattr(self, 'revision_id', revision_id)
            __dataclass__object_setattr(self, 'layers', layers)
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'state_reason', state_reason)
            __dataclass__object_setattr(self, 'state_reason_code', state_reason_code)
            __dataclass__object_setattr(self, 'last_update_status', last_update_status)
            __dataclass__object_setattr(self, 'last_update_status_reason', last_update_status_reason)
            __dataclass__object_setattr(self, 'last_update_status_reason_code', last_update_status_reason_code)
            __dataclass__object_setattr(self, 'file_system_configs', file_system_configs)
            __dataclass__object_setattr(self, 'package_type', package_type)
            __dataclass__object_setattr(self, 'image_config_response', image_config_response)
            __dataclass__object_setattr(self, 'signing_profile_version_arn', signing_profile_version_arn)
            __dataclass__object_setattr(self, 'signing_job_arn', signing_job_arn)
            __dataclass__object_setattr(self, 'architectures', architectures)
            __dataclass__object_setattr(self, 'ephemeral_storage', ephemeral_storage)
            __dataclass__object_setattr(self, 'snap_start', snap_start)
            __dataclass__object_setattr(self, 'runtime_version_config', runtime_version_config)
            __dataclass__object_setattr(self, 'logging_config', logging_config)
            __dataclass__object_setattr(self, 'capacity_provider_config', capacity_provider_config)
            __dataclass__object_setattr(self, 'config_sha256', config_sha256)
            __dataclass__object_setattr(self, 'durable_config', durable_config)
            __dataclass__object_setattr(self, 'tenancy_config', tenancy_config)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"function_name={self.function_name!r}")
            parts.append(f"function_arn={self.function_arn!r}")
            parts.append(f"runtime={self.runtime!r}")
            parts.append(f"role={self.role!r}")
            parts.append(f"handler={self.handler!r}")
            parts.append(f"code_size={self.code_size!r}")
            parts.append(f"description={self.description!r}")
            parts.append(f"timeout={self.timeout!r}")
            parts.append(f"memory_size={self.memory_size!r}")
            parts.append(f"last_modified={self.last_modified!r}")
            parts.append(f"code_sha256={self.code_sha256!r}")
            parts.append(f"version={self.version!r}")
            parts.append(f"vpc_config={self.vpc_config!r}")
            parts.append(f"dead_letter_config={self.dead_letter_config!r}")
            parts.append(f"environment={self.environment!r}")
            parts.append(f"kms_key_arn={self.kms_key_arn!r}")
            parts.append(f"tracing_config={self.tracing_config!r}")
            parts.append(f"master_arn={self.master_arn!r}")
            parts.append(f"revision_id={self.revision_id!r}")
            parts.append(f"layers={self.layers!r}")
            parts.append(f"state={self.state!r}")
            parts.append(f"state_reason={self.state_reason!r}")
            parts.append(f"state_reason_code={self.state_reason_code!r}")
            parts.append(f"last_update_status={self.last_update_status!r}")
            parts.append(f"last_update_status_reason={self.last_update_status_reason!r}")
            parts.append(f"last_update_status_reason_code={self.last_update_status_reason_code!r}")
            parts.append(f"file_system_configs={self.file_system_configs!r}")
            parts.append(f"package_type={self.package_type!r}")
            parts.append(f"image_config_response={self.image_config_response!r}")
            parts.append(f"signing_profile_version_arn={self.signing_profile_version_arn!r}")
            parts.append(f"signing_job_arn={self.signing_job_arn!r}")
            parts.append(f"architectures={self.architectures!r}")
            parts.append(f"ephemeral_storage={self.ephemeral_storage!r}")
            parts.append(f"snap_start={self.snap_start!r}")
            parts.append(f"runtime_version_config={self.runtime_version_config!r}")
            parts.append(f"logging_config={self.logging_config!r}")
            parts.append(f"capacity_provider_config={self.capacity_provider_config!r}")
            parts.append(f"config_sha256={self.config_sha256!r}")
            parts.append(f"durable_config={self.durable_config!r}")
            parts.append(f"tenancy_config={self.tenancy_config!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('marker', 'db_instances')), EqPlan(fields=('marker', 'db_instances')), FrozenPlan("
        "fields=('__shape__', 'marker', 'db_instances'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fiel"
        "ds=('marker', 'db_instances'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRe"
        "f(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type="
        "FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='marker', annotation=Op"
        "Ref(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init="
        "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
        "eld(name='db_instances', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('marker', 'db_instances'), froze"
        "n=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
        "e='marker', kw_only=True, fn=None), ReprPlan.Field(name='db_instances', kw_only=True, fn=None)), id=False, ter"
        "se=False, default_fn=None)))"
    ),
    plan_repr_sha1='73f8c682b7489fa5d592e53237f171acb7a40089',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'DBInstanceMessage'),
    ),
)
def _process_dataclass__73f8c682b7489fa5d592e53237f171acb7a40089():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                marker=self.marker,
                db_instances=self.db_instances,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.marker == other.marker and
                self.db_instances == other.db_instances
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'marker',
            'db_instances',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'marker',
            'db_instances',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.marker,
                self.db_instances,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            marker: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            db_instances: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'marker', marker)
            __dataclass__object_setattr(self, 'db_instances', db_instances)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"marker={self.marker!r}")
            parts.append(f"db_instances={self.db_instances!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('associations', 'propagating_vgws', 'route_table_id', 'routes', 'tags', 'vpc_id', "
        "'owner_id')), EqPlan(fields=('associations', 'propagating_vgws', 'route_table_id', 'routes', 'tags', 'vpc_id',"
        " 'owner_id')), FrozenPlan(fields=('__shape__', 'associations', 'propagating_vgws', 'route_table_id', 'routes',"
        " 'tags', 'vpc_id', 'owner_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('association"
        "s', 'propagating_vgws', 'route_table_id', 'routes', 'tags', 'vpc_id', 'owner_id'), cache=False), InitPlan(fiel"
        "ds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_"
        "factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='associations', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef("
        "name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
        " coerce=None, validate=None, check_type=None), InitPlan.Field(name='propagating_vgws', annotation=OpRef(name='"
        "init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, over"
        "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "route_table_id', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='routes', annotation=OpRef(name='init.fields.4.annotation'), default=Op"
        "Ref(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
        "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='init.fie"
        "lds.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_id',"
        " annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_facto"
        "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
        "), InitPlan.Field(name='owner_id', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init"
        ".fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('associations', 'propa"
        "gating_vgws', 'route_table_id', 'routes', 'tags', 'vpc_id', 'owner_id'), frozen=True, slots=False, post_init_p"
        "arams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='associations', kw_only=True, "
        "fn=None), ReprPlan.Field(name='propagating_vgws', kw_only=True, fn=None), ReprPlan.Field(name='route_table_id'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='routes', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw"
        "_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPlan.Field(name='owner_id', kw"
        "_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='743790e42a33fe8d52a44a740e180dc180d5d330',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'RouteTable'),
    ),
)
def _process_dataclass__743790e42a33fe8d52a44a740e180dc180d5d330():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                associations=self.associations,
                propagating_vgws=self.propagating_vgws,
                route_table_id=self.route_table_id,
                routes=self.routes,
                tags=self.tags,
                vpc_id=self.vpc_id,
                owner_id=self.owner_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.associations == other.associations and
                self.propagating_vgws == other.propagating_vgws and
                self.route_table_id == other.route_table_id and
                self.routes == other.routes and
                self.tags == other.tags and
                self.vpc_id == other.vpc_id and
                self.owner_id == other.owner_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'associations',
            'propagating_vgws',
            'route_table_id',
            'routes',
            'tags',
            'vpc_id',
            'owner_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'associations',
            'propagating_vgws',
            'route_table_id',
            'routes',
            'tags',
            'vpc_id',
            'owner_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.associations,
                self.propagating_vgws,
                self.route_table_id,
                self.routes,
                self.tags,
                self.vpc_id,
                self.owner_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            associations: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            propagating_vgws: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            route_table_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            routes: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            tags: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            vpc_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            owner_id: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'associations', associations)
            __dataclass__object_setattr(self, 'propagating_vgws', propagating_vgws)
            __dataclass__object_setattr(self, 'route_table_id', route_table_id)
            __dataclass__object_setattr(self, 'routes', routes)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'owner_id', owner_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"associations={self.associations!r}")
            parts.append(f"propagating_vgws={self.propagating_vgws!r}")
            parts.append(f"route_table_id={self.route_table_id!r}")
            parts.append(f"routes={self.routes!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"owner_id={self.owner_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('bandwidth_weighting',)), EqPlan(fields=('bandwidth_weighting',)), FrozenPlan(fiel"
        "ds=('__shape__', 'bandwidth_weighting'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ba"
        "ndwidth_weighting',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='i"
        "nit.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType"
        ".CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='bandwidth_weighting', annotatio"
        "n=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_p"
        "aram='self', std_params=(), kw_only_params=('bandwidth_weighting',), frozen=True, slots=False, post_init_param"
        "s=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='bandwidth_weighting', kw_only=Tru"
        "e, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='74995e6dde021b73d230df53469d42118e72a658',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceNetworkPerformanceOptions'),
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceNetworkPerformanceOptionsRequest'),
    ),
)
def _process_dataclass__74995e6dde021b73d230df53469d42118e72a658():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                bandwidth_weighting=self.bandwidth_weighting,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.bandwidth_weighting == other.bandwidth_weighting
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'bandwidth_weighting',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'bandwidth_weighting',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.bandwidth_weighting,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            bandwidth_weighting: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'bandwidth_weighting', bandwidth_weighting)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"bandwidth_weighting={self.bandwidth_weighting!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('availability_zone_id', 'enable_lni_at_device_index', 'map_customer_owned_ip_on_la"
        "unch', 'customer_owned_ipv4_pool', 'owner_id', 'assign_ipv6_address_on_creation', 'ipv6_cidr_block_association"
        "_set', 'tags', 'subnet_arn', 'outpost_arn', 'enable_dns64', 'ipv6_native', 'private_dns_name_options_on_launch"
        "', 'block_public_access_states', 'type', 'subnet_id', 'state', 'vpc_id', 'cidr_block', 'available_ip_address_c"
        "ount', 'availability_zone', 'default_for_az', 'map_public_ip_on_launch')), EqPlan(fields=('availability_zone_i"
        "d', 'enable_lni_at_device_index', 'map_customer_owned_ip_on_launch', 'customer_owned_ipv4_pool', 'owner_id', '"
        "assign_ipv6_address_on_creation', 'ipv6_cidr_block_association_set', 'tags', 'subnet_arn', 'outpost_arn', 'ena"
        "ble_dns64', 'ipv6_native', 'private_dns_name_options_on_launch', 'block_public_access_states', 'type', 'subnet"
        "_id', 'state', 'vpc_id', 'cidr_block', 'available_ip_address_count', 'availability_zone', 'default_for_az', 'm"
        "ap_public_ip_on_launch')), FrozenPlan(fields=('__shape__', 'availability_zone_id', 'enable_lni_at_device_index"
        "', 'map_customer_owned_ip_on_launch', 'customer_owned_ipv4_pool', 'owner_id', 'assign_ipv6_address_on_creation"
        "', 'ipv6_cidr_block_association_set', 'tags', 'subnet_arn', 'outpost_arn', 'enable_dns64', 'ipv6_native', 'pri"
        "vate_dns_name_options_on_launch', 'block_public_access_states', 'type', 'subnet_id', 'state', 'vpc_id', 'cidr_"
        "block', 'available_ip_address_count', 'availability_zone', 'default_for_az', 'map_public_ip_on_launch'), allow"
        "_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('availability_zone_id', 'enable_lni_at_device_ind"
        "ex', 'map_customer_owned_ip_on_launch', 'customer_owned_ipv4_pool', 'owner_id', 'assign_ipv6_address_on_creati"
        "on', 'ipv6_cidr_block_association_set', 'tags', 'subnet_arn', 'outpost_arn', 'enable_dns64', 'ipv6_native', 'p"
        "rivate_dns_name_options_on_launch', 'block_public_access_states', 'type', 'subnet_id', 'state', 'vpc_id', 'cid"
        "r_block', 'available_ip_address_count', 'availability_zone', 'default_for_az', 'map_public_ip_on_launch'), cac"
        "he=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation')"
        ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='availability_zone_id', annotation=OpRef(name='init.field"
        "s.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False"
        ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='enable_lni"
        "_at_device_index', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='map_customer_owned_ip_on_launch', annotation=OpRef(name='init.fields"
        ".3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='customer_ow"
        "ned_ipv4_pool', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default')"
        ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='owner_id', annotation=OpRef(name='init.fields.5.annotation'), default=O"
        "pRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='assign_ipv6_address_on_creation', ann"
        "otation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='ipv6_cidr_block_association_set', annotation=OpRef(name='init.fields.7.annotation'), defau"
        "lt=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType."
        "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='ini"
        "t.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='sub"
        "net_arn', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='outpost_arn', annotation=OpRef(name='init.fields.10.annotation'), default=OpR"
        "ef(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
        "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='enable_dns64', annotation=OpRef(name='"
        "init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True, ov"
        "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='ipv6_native', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default"
        "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
        ", check_type=None), InitPlan.Field(name='private_dns_name_options_on_launch', annotation=OpRef(name='init.fiel"
        "ds.13.annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='block_p"
        "ublic_access_states', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.15.annotation'), defa"
        "ult=OpRef(name='init.fields.15.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnet_id', annotation=OpRef(na"
        "me='init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='state', annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default')"
        ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.18.annotation'), default=Op"
        "Ref(name='init.fields.18.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cidr_block', annotation=OpRef(name='i"
        "nit.fields.19.annotation'), default=OpRef(name='init.fields.19.default'), default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
        "'available_ip_address_count', annotation=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.fie"
        "lds.20.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='availability_zone', annotation=OpRef(name='init.fields."
        "21.annotation'), default=OpRef(name='init.fields.21.default'), default_factory=None, init=True, override=False"
        ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='default_fo"
        "r_az', annotation=OpRef(name='init.fields.22.annotation'), default=OpRef(name='init.fields.22.default'), defau"
        "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
        "ype=None), InitPlan.Field(name='map_public_ip_on_launch', annotation=OpRef(name='init.fields.23.annotation'), "
        "default=OpRef(name='init.fields.23.default'), default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_param"
        "s=('availability_zone_id', 'enable_lni_at_device_index', 'map_customer_owned_ip_on_launch', 'customer_owned_ip"
        "v4_pool', 'owner_id', 'assign_ipv6_address_on_creation', 'ipv6_cidr_block_association_set', 'tags', 'subnet_ar"
        "n', 'outpost_arn', 'enable_dns64', 'ipv6_native', 'private_dns_name_options_on_launch', 'block_public_access_s"
        "tates', 'type', 'subnet_id', 'state', 'vpc_id', 'cidr_block', 'available_ip_address_count', 'availability_zone"
        "', 'default_for_az', 'map_public_ip_on_launch'), frozen=True, slots=False, post_init_params=None, init_fns=(),"
        " validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='availability_zone_id', kw_only=True, fn=None), ReprPl"
        "an.Field(name='enable_lni_at_device_index', kw_only=True, fn=None), ReprPlan.Field(name='map_customer_owned_ip"
        "_on_launch', kw_only=True, fn=None), ReprPlan.Field(name='customer_owned_ipv4_pool', kw_only=True, fn=None), R"
        "eprPlan.Field(name='owner_id', kw_only=True, fn=None), ReprPlan.Field(name='assign_ipv6_address_on_creation', "
        "kw_only=True, fn=None), ReprPlan.Field(name='ipv6_cidr_block_association_set', kw_only=True, fn=None), ReprPla"
        "n.Field(name='tags', kw_only=True, fn=None), ReprPlan.Field(name='subnet_arn', kw_only=True, fn=None), ReprPla"
        "n.Field(name='outpost_arn', kw_only=True, fn=None), ReprPlan.Field(name='enable_dns64', kw_only=True, fn=None)"
        ", ReprPlan.Field(name='ipv6_native', kw_only=True, fn=None), ReprPlan.Field(name='private_dns_name_options_on_"
        "launch', kw_only=True, fn=None), ReprPlan.Field(name='block_public_access_states', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='type', kw_only=True, fn=None), ReprPlan.Field(name='subnet_id', kw_only=True, fn=None), Repr"
        "Plan.Field(name='state', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPla"
        "n.Field(name='cidr_block', kw_only=True, fn=None), ReprPlan.Field(name='available_ip_address_count', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='availability_zone', kw_only=True, fn=None), ReprPlan.Field(name='default_f"
        "or_az', kw_only=True, fn=None), ReprPlan.Field(name='map_public_ip_on_launch', kw_only=True, fn=None)), id=Fal"
        "se, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='75f7e362ffb3e14e0ae63b7138f52a6d7cd258c5',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Subnet'),
    ),
)
def _process_dataclass__75f7e362ffb3e14e0ae63b7138f52a6d7cd258c5():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                availability_zone_id=self.availability_zone_id,
                enable_lni_at_device_index=self.enable_lni_at_device_index,
                map_customer_owned_ip_on_launch=self.map_customer_owned_ip_on_launch,
                customer_owned_ipv4_pool=self.customer_owned_ipv4_pool,
                owner_id=self.owner_id,
                assign_ipv6_address_on_creation=self.assign_ipv6_address_on_creation,
                ipv6_cidr_block_association_set=self.ipv6_cidr_block_association_set,
                tags=self.tags,
                subnet_arn=self.subnet_arn,
                outpost_arn=self.outpost_arn,
                enable_dns64=self.enable_dns64,
                ipv6_native=self.ipv6_native,
                private_dns_name_options_on_launch=self.private_dns_name_options_on_launch,
                block_public_access_states=self.block_public_access_states,
                type=self.type,
                subnet_id=self.subnet_id,
                state=self.state,
                vpc_id=self.vpc_id,
                cidr_block=self.cidr_block,
                available_ip_address_count=self.available_ip_address_count,
                availability_zone=self.availability_zone,
                default_for_az=self.default_for_az,
                map_public_ip_on_launch=self.map_public_ip_on_launch,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.availability_zone_id == other.availability_zone_id and
                self.enable_lni_at_device_index == other.enable_lni_at_device_index and
                self.map_customer_owned_ip_on_launch == other.map_customer_owned_ip_on_launch and
                self.customer_owned_ipv4_pool == other.customer_owned_ipv4_pool and
                self.owner_id == other.owner_id and
                self.assign_ipv6_address_on_creation == other.assign_ipv6_address_on_creation and
                self.ipv6_cidr_block_association_set == other.ipv6_cidr_block_association_set and
                self.tags == other.tags and
                self.subnet_arn == other.subnet_arn and
                self.outpost_arn == other.outpost_arn and
                self.enable_dns64 == other.enable_dns64 and
                self.ipv6_native == other.ipv6_native and
                self.private_dns_name_options_on_launch == other.private_dns_name_options_on_launch and
                self.block_public_access_states == other.block_public_access_states and
                self.type == other.type and
                self.subnet_id == other.subnet_id and
                self.state == other.state and
                self.vpc_id == other.vpc_id and
                self.cidr_block == other.cidr_block and
                self.available_ip_address_count == other.available_ip_address_count and
                self.availability_zone == other.availability_zone and
                self.default_for_az == other.default_for_az and
                self.map_public_ip_on_launch == other.map_public_ip_on_launch
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'availability_zone_id',
            'enable_lni_at_device_index',
            'map_customer_owned_ip_on_launch',
            'customer_owned_ipv4_pool',
            'owner_id',
            'assign_ipv6_address_on_creation',
            'ipv6_cidr_block_association_set',
            'tags',
            'subnet_arn',
            'outpost_arn',
            'enable_dns64',
            'ipv6_native',
            'private_dns_name_options_on_launch',
            'block_public_access_states',
            'type',
            'subnet_id',
            'state',
            'vpc_id',
            'cidr_block',
            'available_ip_address_count',
            'availability_zone',
            'default_for_az',
            'map_public_ip_on_launch',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'availability_zone_id',
            'enable_lni_at_device_index',
            'map_customer_owned_ip_on_launch',
            'customer_owned_ipv4_pool',
            'owner_id',
            'assign_ipv6_address_on_creation',
            'ipv6_cidr_block_association_set',
            'tags',
            'subnet_arn',
            'outpost_arn',
            'enable_dns64',
            'ipv6_native',
            'private_dns_name_options_on_launch',
            'block_public_access_states',
            'type',
            'subnet_id',
            'state',
            'vpc_id',
            'cidr_block',
            'available_ip_address_count',
            'availability_zone',
            'default_for_az',
            'map_public_ip_on_launch',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.availability_zone_id,
                self.enable_lni_at_device_index,
                self.map_customer_owned_ip_on_launch,
                self.customer_owned_ipv4_pool,
                self.owner_id,
                self.assign_ipv6_address_on_creation,
                self.ipv6_cidr_block_association_set,
                self.tags,
                self.subnet_arn,
                self.outpost_arn,
                self.enable_dns64,
                self.ipv6_native,
                self.private_dns_name_options_on_launch,
                self.block_public_access_states,
                self.type,
                self.subnet_id,
                self.state,
                self.vpc_id,
                self.cidr_block,
                self.available_ip_address_count,
                self.availability_zone,
                self.default_for_az,
                self.map_public_ip_on_launch,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            availability_zone_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            enable_lni_at_device_index: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            map_customer_owned_ip_on_launch: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            customer_owned_ipv4_pool: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            owner_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            assign_ipv6_address_on_creation: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            ipv6_cidr_block_association_set: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            tags: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            subnet_arn: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            outpost_arn: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            enable_dns64: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            ipv6_native: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            private_dns_name_options_on_launch: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            block_public_access_states: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            type: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            subnet_id: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            state: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            vpc_id: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            cidr_block: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            available_ip_address_count: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            availability_zone: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            default_for_az: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            map_public_ip_on_launch: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'availability_zone_id', availability_zone_id)
            __dataclass__object_setattr(self, 'enable_lni_at_device_index', enable_lni_at_device_index)
            __dataclass__object_setattr(self, 'map_customer_owned_ip_on_launch', map_customer_owned_ip_on_launch)
            __dataclass__object_setattr(self, 'customer_owned_ipv4_pool', customer_owned_ipv4_pool)
            __dataclass__object_setattr(self, 'owner_id', owner_id)
            __dataclass__object_setattr(self, 'assign_ipv6_address_on_creation', assign_ipv6_address_on_creation)
            __dataclass__object_setattr(self, 'ipv6_cidr_block_association_set', ipv6_cidr_block_association_set)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'subnet_arn', subnet_arn)
            __dataclass__object_setattr(self, 'outpost_arn', outpost_arn)
            __dataclass__object_setattr(self, 'enable_dns64', enable_dns64)
            __dataclass__object_setattr(self, 'ipv6_native', ipv6_native)
            __dataclass__object_setattr(self, 'private_dns_name_options_on_launch', private_dns_name_options_on_launch)
            __dataclass__object_setattr(self, 'block_public_access_states', block_public_access_states)
            __dataclass__object_setattr(self, 'type', type)
            __dataclass__object_setattr(self, 'subnet_id', subnet_id)
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'cidr_block', cidr_block)
            __dataclass__object_setattr(self, 'available_ip_address_count', available_ip_address_count)
            __dataclass__object_setattr(self, 'availability_zone', availability_zone)
            __dataclass__object_setattr(self, 'default_for_az', default_for_az)
            __dataclass__object_setattr(self, 'map_public_ip_on_launch', map_public_ip_on_launch)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"availability_zone_id={self.availability_zone_id!r}")
            parts.append(f"enable_lni_at_device_index={self.enable_lni_at_device_index!r}")
            parts.append(f"map_customer_owned_ip_on_launch={self.map_customer_owned_ip_on_launch!r}")
            parts.append(f"customer_owned_ipv4_pool={self.customer_owned_ipv4_pool!r}")
            parts.append(f"owner_id={self.owner_id!r}")
            parts.append(f"assign_ipv6_address_on_creation={self.assign_ipv6_address_on_creation!r}")
            parts.append(f"ipv6_cidr_block_association_set={self.ipv6_cidr_block_association_set!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"subnet_arn={self.subnet_arn!r}")
            parts.append(f"outpost_arn={self.outpost_arn!r}")
            parts.append(f"enable_dns64={self.enable_dns64!r}")
            parts.append(f"ipv6_native={self.ipv6_native!r}")
            parts.append(f"private_dns_name_options_on_launch={self.private_dns_name_options_on_launch!r}")
            parts.append(f"block_public_access_states={self.block_public_access_states!r}")
            parts.append(f"type={self.type!r}")
            parts.append(f"subnet_id={self.subnet_id!r}")
            parts.append(f"state={self.state!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"cidr_block={self.cidr_block!r}")
            parts.append(f"available_ip_address_count={self.available_ip_address_count!r}")
            parts.append(f"availability_zone={self.availability_zone!r}")
            parts.append(f"default_for_az={self.default_for_az!r}")
            parts.append(f"map_public_ip_on_launch={self.map_public_ip_on_launch!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('arn', 'local_mount_path')), EqPlan(fields=('arn', 'local_mount_path')), FrozenPla"
        "n(fields=('__shape__', 'arn', 'local_mount_path'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', f"
        "ields=('arn', 'local_mount_path'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation="
        "OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='arn', annotation=O"
        "pRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='local_mount_path', a"
        "nnotation=OpRef(name='init.fields.2.annotation'), default=None, default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params"
        "=(), kw_only_params=('arn', 'local_mount_path'), frozen=True, slots=False, post_init_params=None, init_fns=(),"
        " validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='arn', kw_only=True, fn=None), ReprPlan.Field(name='lo"
        "cal_mount_path', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='782e9b5d3cf1915925c20121ed1c830c7d6ccaf2',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'FileSystemConfig'),
    ),
)
def _process_dataclass__782e9b5d3cf1915925c20121ed1c830c7d6ccaf2():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                arn=self.arn,
                local_mount_path=self.local_mount_path,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.arn == other.arn and
                self.local_mount_path == other.local_mount_path
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'arn',
            'local_mount_path',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'arn',
            'local_mount_path',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.arn,
                self.local_mount_path,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            arn: __dataclass__init__fields__1__annotation,
            local_mount_path: __dataclass__init__fields__2__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'arn', arn)
            __dataclass__object_setattr(self, 'local_mount_path', local_mount_path)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"arn={self.arn!r}")
            parts.append(f"local_mount_path={self.local_mount_path!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('tcp_established_timeout', 'udp_stream_timeout', 'udp_timeout')), EqPlan(fields=('"
        "tcp_established_timeout', 'udp_stream_timeout', 'udp_timeout')), FrozenPlan(fields=('__shape__', 'tcp_establis"
        "hed_timeout', 'udp_stream_timeout', 'udp_timeout'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', "
        "fields=('tcp_established_timeout', 'udp_stream_timeout', 'udp_timeout'), cache=False), InitPlan(fields=(InitPl"
        "an.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='tcp_established_timeout', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef"
        "(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='udp_stream_timeout', annotation=OpRef(nam"
        "e='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='udp_timeout', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None)), self_param='self', std_params=(), kw_only_params=('tcp_established_timeout', 'udp_stream_t"
        "imeout', 'udp_timeout'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
        "lan(fields=(ReprPlan.Field(name='tcp_established_timeout', kw_only=True, fn=None), ReprPlan.Field(name='udp_st"
        "ream_timeout', kw_only=True, fn=None), ReprPlan.Field(name='udp_timeout', kw_only=True, fn=None)), id=False, t"
        "erse=False, default_fn=None)))"
    ),
    plan_repr_sha1='7966b5342926406c3075c21a6670466e44b592e4',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'ConnectionTrackingConfiguration'),
        ('ominfra.clouds.aws.models.services.ec2', 'ConnectionTrackingSpecificationRequest'),
        ('ominfra.clouds.aws.models.services.ec2', 'ConnectionTrackingSpecificationResponse'),
    ),
)
def _process_dataclass__7966b5342926406c3075c21a6670466e44b592e4():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                tcp_established_timeout=self.tcp_established_timeout,
                udp_stream_timeout=self.udp_stream_timeout,
                udp_timeout=self.udp_timeout,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.tcp_established_timeout == other.tcp_established_timeout and
                self.udp_stream_timeout == other.udp_stream_timeout and
                self.udp_timeout == other.udp_timeout
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'tcp_established_timeout',
            'udp_stream_timeout',
            'udp_timeout',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'tcp_established_timeout',
            'udp_stream_timeout',
            'udp_timeout',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.tcp_established_timeout,
                self.udp_stream_timeout,
                self.udp_timeout,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            tcp_established_timeout: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            udp_stream_timeout: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            udp_timeout: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'tcp_established_timeout', tcp_established_timeout)
            __dataclass__object_setattr(self, 'udp_stream_timeout', udp_stream_timeout)
            __dataclass__object_setattr(self, 'udp_timeout', udp_timeout)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"tcp_established_timeout={self.tcp_established_timeout!r}")
            parts.append(f"udp_stream_timeout={self.udp_stream_timeout!r}")
            parts.append(f"udp_timeout={self.udp_timeout!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('retry_after_seconds', 'type', 'message', 'reason')), EqPlan(fields=('retry_after_"
        "seconds', 'type', 'message', 'reason')), FrozenPlan(fields=('__shape__', 'retry_after_seconds', 'type', 'messa"
        "ge', 'reason'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('retry_after_seconds', 'type"
        "', 'message', 'reason'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name"
        "='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='retry_after_seconds', annota"
        "tion=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='type', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='message', annotation=OpRef(name='init.fields.3.annotation'), de"
        "fault=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='reason', annotation=OpRef(name"
        "='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, ov"
        "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self',"
        " std_params=(), kw_only_params=('retry_after_seconds', 'type', 'message', 'reason'), frozen=True, slots=False,"
        " post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='retry_after_secon"
        "ds', kw_only=True, fn=None), ReprPlan.Field(name='type', kw_only=True, fn=None), ReprPlan.Field(name='message'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='reason', kw_only=True, fn=None)), id=False, terse=False, defaul"
        "t_fn=None)))"
    ),
    plan_repr_sha1='79dadd11fd00d21c8fe99901d2f1bb38785142ff',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'TooManyRequestsException'),
    ),
)
def _process_dataclass__79dadd11fd00d21c8fe99901d2f1bb38785142ff():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                retry_after_seconds=self.retry_after_seconds,
                type=self.type,
                message=self.message,
                reason=self.reason,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.retry_after_seconds == other.retry_after_seconds and
                self.type == other.type and
                self.message == other.message and
                self.reason == other.reason
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'retry_after_seconds',
            'type',
            'message',
            'reason',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'retry_after_seconds',
            'type',
            'message',
            'reason',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.retry_after_seconds,
                self.type,
                self.message,
                self.reason,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            retry_after_seconds: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            type: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            message: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            reason: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'retry_after_seconds', retry_after_seconds)
            __dataclass__object_setattr(self, 'type', type)
            __dataclass__object_setattr(self, 'message', message)
            __dataclass__object_setattr(self, 'reason', reason)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"retry_after_seconds={self.retry_after_seconds!r}")
            parts.append(f"type={self.type!r}")
            parts.append(f"message={self.message!r}")
            parts.append(f"reason={self.reason!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('hostname_type', 'enable_resource_name_dns_a_record', 'enable_resource_name_dns_aa"
        "aa_record')), EqPlan(fields=('hostname_type', 'enable_resource_name_dns_a_record', 'enable_resource_name_dns_a"
        "aaa_record')), FrozenPlan(fields=('__shape__', 'hostname_type', 'enable_resource_name_dns_a_record', 'enable_r"
        "esource_name_dns_aaaa_record'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('hostname_ty"
        "pe', 'enable_resource_name_dns_a_record', 'enable_resource_name_dns_aaaa_record'), cache=False), InitPlan(fiel"
        "ds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_"
        "factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='hostname_type', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef"
        "(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='enable_resource_name_dns_a_record', annot"
        "ation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='enable_resource_name_dns_aaaa_record', annotation=OpRef(name='init.fields.3.annotation'), de"
        "fault=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=("
        "'hostname_type', 'enable_resource_name_dns_a_record', 'enable_resource_name_dns_aaaa_record'), frozen=True, sl"
        "ots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='hostnam"
        "e_type', kw_only=True, fn=None), ReprPlan.Field(name='enable_resource_name_dns_a_record', kw_only=True, fn=Non"
        "e), ReprPlan.Field(name='enable_resource_name_dns_aaaa_record', kw_only=True, fn=None)), id=False, terse=False"
        ", default_fn=None)))"
    ),
    plan_repr_sha1='7e027928b04e3415eab0806728312f23ccdfd8a2',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'PrivateDnsNameOptionsOnLaunch'),
        ('ominfra.clouds.aws.models.services.ec2', 'PrivateDnsNameOptionsRequest'),
        ('ominfra.clouds.aws.models.services.ec2', 'PrivateDnsNameOptionsResponse'),
    ),
)
def _process_dataclass__7e027928b04e3415eab0806728312f23ccdfd8a2():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                hostname_type=self.hostname_type,
                enable_resource_name_dns_a_record=self.enable_resource_name_dns_a_record,
                enable_resource_name_dns_aaaa_record=self.enable_resource_name_dns_aaaa_record,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.hostname_type == other.hostname_type and
                self.enable_resource_name_dns_a_record == other.enable_resource_name_dns_a_record and
                self.enable_resource_name_dns_aaaa_record == other.enable_resource_name_dns_aaaa_record
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'hostname_type',
            'enable_resource_name_dns_a_record',
            'enable_resource_name_dns_aaaa_record',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'hostname_type',
            'enable_resource_name_dns_a_record',
            'enable_resource_name_dns_aaaa_record',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.hostname_type,
                self.enable_resource_name_dns_a_record,
                self.enable_resource_name_dns_aaaa_record,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            hostname_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            enable_resource_name_dns_a_record: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            enable_resource_name_dns_aaaa_record: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'hostname_type', hostname_type)
            __dataclass__object_setattr(self, 'enable_resource_name_dns_a_record', enable_resource_name_dns_a_record)
            __dataclass__object_setattr(self, 'enable_resource_name_dns_aaaa_record', enable_resource_name_dns_aaaa_record)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"hostname_type={self.hostname_type!r}")
            parts.append(f"enable_resource_name_dns_a_record={self.enable_resource_name_dns_a_record!r}")
            parts.append(f"enable_resource_name_dns_aaaa_record={self.enable_resource_name_dns_aaaa_record!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('description', 'cidr_ipv6')), EqPlan(fields=('description', 'cidr_ipv6')), FrozenP"
        "lan(fields=('__shape__', 'description', 'cidr_ipv6'), allow_dynamic_dunder_attrs=False), HashPlan(action='add'"
        ", fields=('description', 'cidr_ipv6'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotat"
        "ion=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='description', "
        "annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='cidr_ipv6', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init"
        ".fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('description', 'cidr_i"
        "pv6'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPl"
        "an.Field(name='description', kw_only=True, fn=None), ReprPlan.Field(name='cidr_ipv6', kw_only=True, fn=None)),"
        " id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='7f5ef993e295e5e96fdb6ca03b3accafdafaf592',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Ipv6Range'),
    ),
)
def _process_dataclass__7f5ef993e295e5e96fdb6ca03b3accafdafaf592():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                description=self.description,
                cidr_ipv6=self.cidr_ipv6,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.description == other.description and
                self.cidr_ipv6 == other.cidr_ipv6
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'description',
            'cidr_ipv6',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'description',
            'cidr_ipv6',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.description,
                self.cidr_ipv6,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            description: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            cidr_ipv6: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'cidr_ipv6', cidr_ipv6)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"description={self.description!r}")
            parts.append(f"cidr_ipv6={self.cidr_ipv6!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('state', 'http_tokens', 'http_put_response_hop_limit', 'http_endpoint', 'http_prot"
        "ocol_ipv6', 'instance_metadata_tags')), EqPlan(fields=('state', 'http_tokens', 'http_put_response_hop_limit', "
        "'http_endpoint', 'http_protocol_ipv6', 'instance_metadata_tags')), FrozenPlan(fields=('__shape__', 'state', 'h"
        "ttp_tokens', 'http_put_response_hop_limit', 'http_endpoint', 'http_protocol_ipv6', 'instance_metadata_tags'), "
        "allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('state', 'http_tokens', 'http_put_response_h"
        "op_limit', 'http_endpoint', 'http_protocol_ipv6', 'instance_metadata_tags'), cache=False), InitPlan(fields=(In"
        "itPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factor"
        "y=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None"
        "), InitPlan.Field(name='state', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fi"
        "elds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='http_tokens', annotation=OpRef(name='init.fields.2.anno"
        "tation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='http_put_response_"
        "hop_limit', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
        "k_type=None), InitPlan.Field(name='http_endpoint', annotation=OpRef(name='init.fields.4.annotation'), default="
        "OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='http_protocol_ipv6', annotation=OpRe"
        "f(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='instance_metadata_tags', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.f"
        "ields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
        ", validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('state', 'http_tokens', "
        "'http_put_response_hop_limit', 'http_endpoint', 'http_protocol_ipv6', 'instance_metadata_tags'), frozen=True, "
        "slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='state"
        "', kw_only=True, fn=None), ReprPlan.Field(name='http_tokens', kw_only=True, fn=None), ReprPlan.Field(name='htt"
        "p_put_response_hop_limit', kw_only=True, fn=None), ReprPlan.Field(name='http_endpoint', kw_only=True, fn=None)"
        ", ReprPlan.Field(name='http_protocol_ipv6', kw_only=True, fn=None), ReprPlan.Field(name='instance_metadata_tag"
        "s', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='7fe2772dae2af5a3470bca87c58b0fc1e277591f',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceMetadataOptionsResponse'),
    ),
)
def _process_dataclass__7fe2772dae2af5a3470bca87c58b0fc1e277591f():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                state=self.state,
                http_tokens=self.http_tokens,
                http_put_response_hop_limit=self.http_put_response_hop_limit,
                http_endpoint=self.http_endpoint,
                http_protocol_ipv6=self.http_protocol_ipv6,
                instance_metadata_tags=self.instance_metadata_tags,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.state == other.state and
                self.http_tokens == other.http_tokens and
                self.http_put_response_hop_limit == other.http_put_response_hop_limit and
                self.http_endpoint == other.http_endpoint and
                self.http_protocol_ipv6 == other.http_protocol_ipv6 and
                self.instance_metadata_tags == other.instance_metadata_tags
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'state',
            'http_tokens',
            'http_put_response_hop_limit',
            'http_endpoint',
            'http_protocol_ipv6',
            'instance_metadata_tags',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'state',
            'http_tokens',
            'http_put_response_hop_limit',
            'http_endpoint',
            'http_protocol_ipv6',
            'instance_metadata_tags',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.state,
                self.http_tokens,
                self.http_put_response_hop_limit,
                self.http_endpoint,
                self.http_protocol_ipv6,
                self.instance_metadata_tags,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            state: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            http_tokens: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            http_put_response_hop_limit: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            http_endpoint: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            http_protocol_ipv6: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            instance_metadata_tags: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'http_tokens', http_tokens)
            __dataclass__object_setattr(self, 'http_put_response_hop_limit', http_put_response_hop_limit)
            __dataclass__object_setattr(self, 'http_endpoint', http_endpoint)
            __dataclass__object_setattr(self, 'http_protocol_ipv6', http_protocol_ipv6)
            __dataclass__object_setattr(self, 'instance_metadata_tags', instance_metadata_tags)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"state={self.state!r}")
            parts.append(f"http_tokens={self.http_tokens!r}")
            parts.append(f"http_put_response_hop_limit={self.http_put_response_hop_limit!r}")
            parts.append(f"http_endpoint={self.http_endpoint!r}")
            parts.append(f"http_protocol_ipv6={self.http_protocol_ipv6!r}")
            parts.append(f"instance_metadata_tags={self.instance_metadata_tags!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('max_buckets', 'continuation_token', 'prefix', 'bucket_region')), EqPlan(fields=('"
        "max_buckets', 'continuation_token', 'prefix', 'bucket_region')), FrozenPlan(fields=('__shape__', 'max_buckets'"
        ", 'continuation_token', 'prefix', 'bucket_region'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', "
        "fields=('max_buckets', 'continuation_token', 'prefix', 'bucket_region'), cache=False), InitPlan(fields=(InitPl"
        "an.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='max_buckets', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init."
        "fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
        "e, validate=None, check_type=None), InitPlan.Field(name='continuation_token', annotation=OpRef(name='init.fiel"
        "ds.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='prefix', "
        "annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='bucket_region', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='"
        "init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
        "e=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('max_buckets', 'co"
        "ntinuation_token', 'prefix', 'bucket_region'), frozen=True, slots=False, post_init_params=None, init_fns=(), v"
        "alidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='max_buckets', kw_only=True, fn=None), ReprPlan.Field(na"
        "me='continuation_token', kw_only=True, fn=None), ReprPlan.Field(name='prefix', kw_only=True, fn=None), ReprPla"
        "n.Field(name='bucket_region', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='827685e3cb57e47f66486205586cef97c9a0dd1a',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.s3', 'ListBucketsRequest'),
    ),
)
def _process_dataclass__827685e3cb57e47f66486205586cef97c9a0dd1a():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                max_buckets=self.max_buckets,
                continuation_token=self.continuation_token,
                prefix=self.prefix,
                bucket_region=self.bucket_region,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.max_buckets == other.max_buckets and
                self.continuation_token == other.continuation_token and
                self.prefix == other.prefix and
                self.bucket_region == other.bucket_region
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'max_buckets',
            'continuation_token',
            'prefix',
            'bucket_region',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'max_buckets',
            'continuation_token',
            'prefix',
            'bucket_region',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.max_buckets,
                self.continuation_token,
                self.prefix,
                self.bucket_region,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            max_buckets: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            continuation_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            prefix: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            bucket_region: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'max_buckets', max_buckets)
            __dataclass__object_setattr(self, 'continuation_token', continuation_token)
            __dataclass__object_setattr(self, 'prefix', prefix)
            __dataclass__object_setattr(self, 'bucket_region', bucket_region)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"max_buckets={self.max_buckets!r}")
            parts.append(f"continuation_token={self.continuation_token!r}")
            parts.append(f"prefix={self.prefix!r}")
            parts.append(f"bucket_region={self.bucket_region!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('is_truncated', 'contents', 'name', 'prefix', 'delimiter', 'max_keys', 'common_pre"
        "fixes', 'encoding_type', 'key_count', 'continuation_token', 'next_continuation_token', 'start_after', 'request"
        "_charged')), EqPlan(fields=('is_truncated', 'contents', 'name', 'prefix', 'delimiter', 'max_keys', 'common_pre"
        "fixes', 'encoding_type', 'key_count', 'continuation_token', 'next_continuation_token', 'start_after', 'request"
        "_charged')), FrozenPlan(fields=('__shape__', 'is_truncated', 'contents', 'name', 'prefix', 'delimiter', 'max_k"
        "eys', 'common_prefixes', 'encoding_type', 'key_count', 'continuation_token', 'next_continuation_token', 'start"
        "_after', 'request_charged'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('is_truncated',"
        " 'contents', 'name', 'prefix', 'delimiter', 'max_keys', 'common_prefixes', 'encoding_type', 'key_count', 'cont"
        "inuation_token', 'next_continuation_token', 'start_after', 'request_charged'), cache=False), InitPlan(fields=("
        "InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='is_truncated', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name"
        "='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='contents', annotation=OpRef(name='init.fields."
        "2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annot"
        "ation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='prefix', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields."
        "4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='delimiter', annotation=OpRef(name='init.fields.5.annotation'"
        "), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_keys', annotation=OpR"
        "ef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
        "ld(name='common_prefixes', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields."
        "7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='encoding_type', annotation=OpRef(name='init.fields.8.annotat"
        "ion'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='key_count', annotatio"
        "n=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='continuation_token', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='ini"
        "t.fields.10.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='next_continuation_token', annotation=OpRef(name='i"
        "nit.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
        "'start_after', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='request_charged', annotation=OpRef(name='init.fields.13.annotation'), "
        "default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_param"
        "s=('is_truncated', 'contents', 'name', 'prefix', 'delimiter', 'max_keys', 'common_prefixes', 'encoding_type', "
        "'key_count', 'continuation_token', 'next_continuation_token', 'start_after', 'request_charged'), frozen=True, "
        "slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='is_tr"
        "uncated', kw_only=True, fn=None), ReprPlan.Field(name='contents', kw_only=True, fn=None), ReprPlan.Field(name="
        "'name', kw_only=True, fn=None), ReprPlan.Field(name='prefix', kw_only=True, fn=None), ReprPlan.Field(name='del"
        "imiter', kw_only=True, fn=None), ReprPlan.Field(name='max_keys', kw_only=True, fn=None), ReprPlan.Field(name='"
        "common_prefixes', kw_only=True, fn=None), ReprPlan.Field(name='encoding_type', kw_only=True, fn=None), ReprPla"
        "n.Field(name='key_count', kw_only=True, fn=None), ReprPlan.Field(name='continuation_token', kw_only=True, fn=N"
        "one), ReprPlan.Field(name='next_continuation_token', kw_only=True, fn=None), ReprPlan.Field(name='start_after'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='request_charged', kw_only=True, fn=None)), id=False, terse=Fals"
        "e, default_fn=None)))"
    ),
    plan_repr_sha1='82e4be8df7be1ffddf9b1db833783106a9774a76',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.s3', 'ListObjectsV2Output'),
    ),
)
def _process_dataclass__82e4be8df7be1ffddf9b1db833783106a9774a76():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                is_truncated=self.is_truncated,
                contents=self.contents,
                name=self.name,
                prefix=self.prefix,
                delimiter=self.delimiter,
                max_keys=self.max_keys,
                common_prefixes=self.common_prefixes,
                encoding_type=self.encoding_type,
                key_count=self.key_count,
                continuation_token=self.continuation_token,
                next_continuation_token=self.next_continuation_token,
                start_after=self.start_after,
                request_charged=self.request_charged,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.is_truncated == other.is_truncated and
                self.contents == other.contents and
                self.name == other.name and
                self.prefix == other.prefix and
                self.delimiter == other.delimiter and
                self.max_keys == other.max_keys and
                self.common_prefixes == other.common_prefixes and
                self.encoding_type == other.encoding_type and
                self.key_count == other.key_count and
                self.continuation_token == other.continuation_token and
                self.next_continuation_token == other.next_continuation_token and
                self.start_after == other.start_after and
                self.request_charged == other.request_charged
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'is_truncated',
            'contents',
            'name',
            'prefix',
            'delimiter',
            'max_keys',
            'common_prefixes',
            'encoding_type',
            'key_count',
            'continuation_token',
            'next_continuation_token',
            'start_after',
            'request_charged',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'is_truncated',
            'contents',
            'name',
            'prefix',
            'delimiter',
            'max_keys',
            'common_prefixes',
            'encoding_type',
            'key_count',
            'continuation_token',
            'next_continuation_token',
            'start_after',
            'request_charged',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.is_truncated,
                self.contents,
                self.name,
                self.prefix,
                self.delimiter,
                self.max_keys,
                self.common_prefixes,
                self.encoding_type,
                self.key_count,
                self.continuation_token,
                self.next_continuation_token,
                self.start_after,
                self.request_charged,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            is_truncated: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            contents: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            name: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            prefix: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            delimiter: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            max_keys: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            common_prefixes: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            encoding_type: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            key_count: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            continuation_token: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            next_continuation_token: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            start_after: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            request_charged: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'is_truncated', is_truncated)
            __dataclass__object_setattr(self, 'contents', contents)
            __dataclass__object_setattr(self, 'name', name)
            __dataclass__object_setattr(self, 'prefix', prefix)
            __dataclass__object_setattr(self, 'delimiter', delimiter)
            __dataclass__object_setattr(self, 'max_keys', max_keys)
            __dataclass__object_setattr(self, 'common_prefixes', common_prefixes)
            __dataclass__object_setattr(self, 'encoding_type', encoding_type)
            __dataclass__object_setattr(self, 'key_count', key_count)
            __dataclass__object_setattr(self, 'continuation_token', continuation_token)
            __dataclass__object_setattr(self, 'next_continuation_token', next_continuation_token)
            __dataclass__object_setattr(self, 'start_after', start_after)
            __dataclass__object_setattr(self, 'request_charged', request_charged)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"is_truncated={self.is_truncated!r}")
            parts.append(f"contents={self.contents!r}")
            parts.append(f"name={self.name!r}")
            parts.append(f"prefix={self.prefix!r}")
            parts.append(f"delimiter={self.delimiter!r}")
            parts.append(f"max_keys={self.max_keys!r}")
            parts.append(f"common_prefixes={self.common_prefixes!r}")
            parts.append(f"encoding_type={self.encoding_type!r}")
            parts.append(f"key_count={self.key_count!r}")
            parts.append(f"continuation_token={self.continuation_token!r}")
            parts.append(f"next_continuation_token={self.next_continuation_token!r}")
            parts.append(f"start_after={self.start_after!r}")
            parts.append(f"request_charged={self.request_charged!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('bucket', 'if_match', 'if_modified_since', 'if_none_match', 'if_unmodified_since',"
        " 'key', 'range', 'response_cache_control', 'response_content_disposition', 'response_content_encoding', 'respo"
        "nse_content_language', 'response_content_type', 'response_expires', 'version_id', 'sse_customer_algorithm', 's"
        "se_customer_key', 'sse_customer_key_md5', 'request_payer', 'part_number', 'expected_bucket_owner', 'checksum_m"
        "ode')), EqPlan(fields=('bucket', 'if_match', 'if_modified_since', 'if_none_match', 'if_unmodified_since', 'key"
        "', 'range', 'response_cache_control', 'response_content_disposition', 'response_content_encoding', 'response_c"
        "ontent_language', 'response_content_type', 'response_expires', 'version_id', 'sse_customer_algorithm', 'sse_cu"
        "stomer_key', 'sse_customer_key_md5', 'request_payer', 'part_number', 'expected_bucket_owner', 'checksum_mode')"
        "), FrozenPlan(fields=('__shape__', 'bucket', 'if_match', 'if_modified_since', 'if_none_match', 'if_unmodified_"
        "since', 'key', 'range', 'response_cache_control', 'response_content_disposition', 'response_content_encoding',"
        " 'response_content_language', 'response_content_type', 'response_expires', 'version_id', 'sse_customer_algorit"
        "hm', 'sse_customer_key', 'sse_customer_key_md5', 'request_payer', 'part_number', 'expected_bucket_owner', 'che"
        "cksum_mode'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('bucket', 'if_match', 'if_modi"
        "fied_since', 'if_none_match', 'if_unmodified_since', 'key', 'range', 'response_cache_control', 'response_conte"
        "nt_disposition', 'response_content_encoding', 'response_content_language', 'response_content_type', 'response_"
        "expires', 'version_id', 'sse_customer_algorithm', 'sse_customer_key', 'sse_customer_key_md5', 'request_payer',"
        " 'part_number', 'expected_bucket_owner', 'checksum_mode'), cache=False), InitPlan(fields=(InitPlan.Field(name="
        "'__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True,"
        " override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='bucket', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='if_match', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default"
        "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
        ", check_type=None), InitPlan.Field(name='if_modified_since', annotation=OpRef(name='init.fields.3.annotation')"
        ", default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=Fie"
        "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='if_none_match', annotation"
        "=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
        ".Field(name='if_unmodified_since', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init"
        ".fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='key', annotation=OpRef(name='init.fields.6.annotatio"
        "n'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='range', annotation=OpRef(name='init.fields.7.annotatio"
        "n'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type="
        "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='response_cache_control'"
        ", annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='response_content_disposition', annotation=OpRef(name='init.fields.9.annotation'), def"
        "ault=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='response_content_encoding', ann"
        "otation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_factory"
        "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
        " InitPlan.Field(name='response_content_language', annotation=OpRef(name='init.fields.11.annotation'), default="
        "OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
        "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='response_content_type', annotation="
        "OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='response_expires', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init."
        "fields.13.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='version_id', annotation=OpRef(name='init.fields.14.a"
        "nnotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='sse_customer_a"
        "lgorithm', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), d"
        "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='sse_customer_key', annotation=OpRef(name='init.fields.16.annotation'), def"
        "ault=OpRef(name='init.fields.16.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='sse_customer_key_md5', annotat"
        "ion=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='request_payer', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init"
        ".fields.18.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
        "one, validate=None, check_type=None), InitPlan.Field(name='part_number', annotation=OpRef(name='init.fields.19"
        ".annotation'), default=OpRef(name='init.fields.19.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='expected_buc"
        "ket_owner', annotation=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.fields.20.default'), "
        "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
        "eck_type=None), InitPlan.Field(name='checksum_mode', annotation=OpRef(name='init.fields.21.annotation'), defau"
        "lt=OpRef(name='init.fields.21.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('b"
        "ucket', 'if_match', 'if_modified_since', 'if_none_match', 'if_unmodified_since', 'key', 'range', 'response_cac"
        "he_control', 'response_content_disposition', 'response_content_encoding', 'response_content_language', 'respon"
        "se_content_type', 'response_expires', 'version_id', 'sse_customer_algorithm', 'sse_customer_key', 'sse_custome"
        "r_key_md5', 'request_payer', 'part_number', 'expected_bucket_owner', 'checksum_mode'), frozen=True, slots=Fals"
        "e, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='bucket', kw_onl"
        "y=True, fn=None), ReprPlan.Field(name='if_match', kw_only=True, fn=None), ReprPlan.Field(name='if_modified_sin"
        "ce', kw_only=True, fn=None), ReprPlan.Field(name='if_none_match', kw_only=True, fn=None), ReprPlan.Field(name="
        "'if_unmodified_since', kw_only=True, fn=None), ReprPlan.Field(name='key', kw_only=True, fn=None), ReprPlan.Fie"
        "ld(name='range', kw_only=True, fn=None), ReprPlan.Field(name='response_cache_control', kw_only=True, fn=None),"
        " ReprPlan.Field(name='response_content_disposition', kw_only=True, fn=None), ReprPlan.Field(name='response_con"
        "tent_encoding', kw_only=True, fn=None), ReprPlan.Field(name='response_content_language', kw_only=True, fn=None"
        "), ReprPlan.Field(name='response_content_type', kw_only=True, fn=None), ReprPlan.Field(name='response_expires'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='version_id', kw_only=True, fn=None), ReprPlan.Field(name='sse_c"
        "ustomer_algorithm', kw_only=True, fn=None), ReprPlan.Field(name='sse_customer_key', kw_only=True, fn=None), Re"
        "prPlan.Field(name='sse_customer_key_md5', kw_only=True, fn=None), ReprPlan.Field(name='request_payer', kw_only"
        "=True, fn=None), ReprPlan.Field(name='part_number', kw_only=True, fn=None), ReprPlan.Field(name='expected_buck"
        "et_owner', kw_only=True, fn=None), ReprPlan.Field(name='checksum_mode', kw_only=True, fn=None)), id=False, ter"
        "se=False, default_fn=None)))"
    ),
    plan_repr_sha1='83168d569e50776814bc06237a3fe741d44d3b9f',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.s3', 'GetObjectRequest'),
    ),
)
def _process_dataclass__83168d569e50776814bc06237a3fe741d44d3b9f():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                bucket=self.bucket,
                if_match=self.if_match,
                if_modified_since=self.if_modified_since,
                if_none_match=self.if_none_match,
                if_unmodified_since=self.if_unmodified_since,
                key=self.key,
                range=self.range,
                response_cache_control=self.response_cache_control,
                response_content_disposition=self.response_content_disposition,
                response_content_encoding=self.response_content_encoding,
                response_content_language=self.response_content_language,
                response_content_type=self.response_content_type,
                response_expires=self.response_expires,
                version_id=self.version_id,
                sse_customer_algorithm=self.sse_customer_algorithm,
                sse_customer_key=self.sse_customer_key,
                sse_customer_key_md5=self.sse_customer_key_md5,
                request_payer=self.request_payer,
                part_number=self.part_number,
                expected_bucket_owner=self.expected_bucket_owner,
                checksum_mode=self.checksum_mode,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.bucket == other.bucket and
                self.if_match == other.if_match and
                self.if_modified_since == other.if_modified_since and
                self.if_none_match == other.if_none_match and
                self.if_unmodified_since == other.if_unmodified_since and
                self.key == other.key and
                self.range == other.range and
                self.response_cache_control == other.response_cache_control and
                self.response_content_disposition == other.response_content_disposition and
                self.response_content_encoding == other.response_content_encoding and
                self.response_content_language == other.response_content_language and
                self.response_content_type == other.response_content_type and
                self.response_expires == other.response_expires and
                self.version_id == other.version_id and
                self.sse_customer_algorithm == other.sse_customer_algorithm and
                self.sse_customer_key == other.sse_customer_key and
                self.sse_customer_key_md5 == other.sse_customer_key_md5 and
                self.request_payer == other.request_payer and
                self.part_number == other.part_number and
                self.expected_bucket_owner == other.expected_bucket_owner and
                self.checksum_mode == other.checksum_mode
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'bucket',
            'if_match',
            'if_modified_since',
            'if_none_match',
            'if_unmodified_since',
            'key',
            'range',
            'response_cache_control',
            'response_content_disposition',
            'response_content_encoding',
            'response_content_language',
            'response_content_type',
            'response_expires',
            'version_id',
            'sse_customer_algorithm',
            'sse_customer_key',
            'sse_customer_key_md5',
            'request_payer',
            'part_number',
            'expected_bucket_owner',
            'checksum_mode',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'bucket',
            'if_match',
            'if_modified_since',
            'if_none_match',
            'if_unmodified_since',
            'key',
            'range',
            'response_cache_control',
            'response_content_disposition',
            'response_content_encoding',
            'response_content_language',
            'response_content_type',
            'response_expires',
            'version_id',
            'sse_customer_algorithm',
            'sse_customer_key',
            'sse_customer_key_md5',
            'request_payer',
            'part_number',
            'expected_bucket_owner',
            'checksum_mode',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.bucket,
                self.if_match,
                self.if_modified_since,
                self.if_none_match,
                self.if_unmodified_since,
                self.key,
                self.range,
                self.response_cache_control,
                self.response_content_disposition,
                self.response_content_encoding,
                self.response_content_language,
                self.response_content_type,
                self.response_expires,
                self.version_id,
                self.sse_customer_algorithm,
                self.sse_customer_key,
                self.sse_customer_key_md5,
                self.request_payer,
                self.part_number,
                self.expected_bucket_owner,
                self.checksum_mode,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            bucket: __dataclass__init__fields__1__annotation,
            if_match: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            if_modified_since: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            if_none_match: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            if_unmodified_since: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            key: __dataclass__init__fields__6__annotation,
            range: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            response_cache_control: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            response_content_disposition: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            response_content_encoding: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            response_content_language: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            response_content_type: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            response_expires: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            version_id: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            sse_customer_algorithm: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            sse_customer_key: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            sse_customer_key_md5: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            request_payer: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            part_number: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            expected_bucket_owner: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            checksum_mode: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'bucket', bucket)
            __dataclass__object_setattr(self, 'if_match', if_match)
            __dataclass__object_setattr(self, 'if_modified_since', if_modified_since)
            __dataclass__object_setattr(self, 'if_none_match', if_none_match)
            __dataclass__object_setattr(self, 'if_unmodified_since', if_unmodified_since)
            __dataclass__object_setattr(self, 'key', key)
            __dataclass__object_setattr(self, 'range', range)
            __dataclass__object_setattr(self, 'response_cache_control', response_cache_control)
            __dataclass__object_setattr(self, 'response_content_disposition', response_content_disposition)
            __dataclass__object_setattr(self, 'response_content_encoding', response_content_encoding)
            __dataclass__object_setattr(self, 'response_content_language', response_content_language)
            __dataclass__object_setattr(self, 'response_content_type', response_content_type)
            __dataclass__object_setattr(self, 'response_expires', response_expires)
            __dataclass__object_setattr(self, 'version_id', version_id)
            __dataclass__object_setattr(self, 'sse_customer_algorithm', sse_customer_algorithm)
            __dataclass__object_setattr(self, 'sse_customer_key', sse_customer_key)
            __dataclass__object_setattr(self, 'sse_customer_key_md5', sse_customer_key_md5)
            __dataclass__object_setattr(self, 'request_payer', request_payer)
            __dataclass__object_setattr(self, 'part_number', part_number)
            __dataclass__object_setattr(self, 'expected_bucket_owner', expected_bucket_owner)
            __dataclass__object_setattr(self, 'checksum_mode', checksum_mode)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"bucket={self.bucket!r}")
            parts.append(f"if_match={self.if_match!r}")
            parts.append(f"if_modified_since={self.if_modified_since!r}")
            parts.append(f"if_none_match={self.if_none_match!r}")
            parts.append(f"if_unmodified_since={self.if_unmodified_since!r}")
            parts.append(f"key={self.key!r}")
            parts.append(f"range={self.range!r}")
            parts.append(f"response_cache_control={self.response_cache_control!r}")
            parts.append(f"response_content_disposition={self.response_content_disposition!r}")
            parts.append(f"response_content_encoding={self.response_content_encoding!r}")
            parts.append(f"response_content_language={self.response_content_language!r}")
            parts.append(f"response_content_type={self.response_content_type!r}")
            parts.append(f"response_expires={self.response_expires!r}")
            parts.append(f"version_id={self.version_id!r}")
            parts.append(f"sse_customer_algorithm={self.sse_customer_algorithm!r}")
            parts.append(f"sse_customer_key={self.sse_customer_key!r}")
            parts.append(f"sse_customer_key_md5={self.sse_customer_key_md5!r}")
            parts.append(f"request_payer={self.request_payer!r}")
            parts.append(f"part_number={self.part_number!r}")
            parts.append(f"expected_bucket_owner={self.expected_bucket_owner!r}")
            parts.append(f"checksum_mode={self.checksum_mode!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('executable_users', 'image_ids', 'owners', 'include_deprecated', 'include_disabled"
        "', 'max_results', 'next_token', 'dry_run', 'filters')), EqPlan(fields=('executable_users', 'image_ids', 'owner"
        "s', 'include_deprecated', 'include_disabled', 'max_results', 'next_token', 'dry_run', 'filters')), FrozenPlan("
        "fields=('__shape__', 'executable_users', 'image_ids', 'owners', 'include_deprecated', 'include_disabled', 'max"
        "_results', 'next_token', 'dry_run', 'filters'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fiel"
        "ds=('executable_users', 'image_ids', 'owners', 'include_deprecated', 'include_disabled', 'max_results', 'next_"
        "token', 'dry_run', 'filters'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRe"
        "f(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type="
        "FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='executable_users', ann"
        "otation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='image_ids', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fi"
        "elds.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='owners', annotation=OpRef(name='init.fields.3.annotatio"
        "n'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type="
        "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='include_deprecated', an"
        "notation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory="
        "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
        "InitPlan.Field(name='include_disabled', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name="
        "'init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None), InitPlan.Field(name='max_results', annotation=OpRef(name='init.field"
        "s.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False"
        ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token"
        "', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='ini"
        "t.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
        "one, validate=None, check_type=None), InitPlan.Field(name='filters', annotation=OpRef(name='init.fields.9.anno"
        "tation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_o"
        "nly_params=('executable_users', 'image_ids', 'owners', 'include_deprecated', 'include_disabled', 'max_results'"
        ", 'next_token', 'dry_run', 'filters'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_"
        "fns=()), ReprPlan(fields=(ReprPlan.Field(name='executable_users', kw_only=True, fn=None), ReprPlan.Field(name="
        "'image_ids', kw_only=True, fn=None), ReprPlan.Field(name='owners', kw_only=True, fn=None), ReprPlan.Field(name"
        "='include_deprecated', kw_only=True, fn=None), ReprPlan.Field(name='include_disabled', kw_only=True, fn=None),"
        " ReprPlan.Field(name='max_results', kw_only=True, fn=None), ReprPlan.Field(name='next_token', kw_only=True, fn"
        "=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn"
        "=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='888cdb8e577e74f9db2d2232e85293bb88592258',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeImagesRequest'),
    ),
)
def _process_dataclass__888cdb8e577e74f9db2d2232e85293bb88592258():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                executable_users=self.executable_users,
                image_ids=self.image_ids,
                owners=self.owners,
                include_deprecated=self.include_deprecated,
                include_disabled=self.include_disabled,
                max_results=self.max_results,
                next_token=self.next_token,
                dry_run=self.dry_run,
                filters=self.filters,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.executable_users == other.executable_users and
                self.image_ids == other.image_ids and
                self.owners == other.owners and
                self.include_deprecated == other.include_deprecated and
                self.include_disabled == other.include_disabled and
                self.max_results == other.max_results and
                self.next_token == other.next_token and
                self.dry_run == other.dry_run and
                self.filters == other.filters
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'executable_users',
            'image_ids',
            'owners',
            'include_deprecated',
            'include_disabled',
            'max_results',
            'next_token',
            'dry_run',
            'filters',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'executable_users',
            'image_ids',
            'owners',
            'include_deprecated',
            'include_disabled',
            'max_results',
            'next_token',
            'dry_run',
            'filters',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.executable_users,
                self.image_ids,
                self.owners,
                self.include_deprecated,
                self.include_disabled,
                self.max_results,
                self.next_token,
                self.dry_run,
                self.filters,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            executable_users: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            image_ids: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            owners: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            include_deprecated: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            include_disabled: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            max_results: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            next_token: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            dry_run: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            filters: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'executable_users', executable_users)
            __dataclass__object_setattr(self, 'image_ids', image_ids)
            __dataclass__object_setattr(self, 'owners', owners)
            __dataclass__object_setattr(self, 'include_deprecated', include_deprecated)
            __dataclass__object_setattr(self, 'include_disabled', include_disabled)
            __dataclass__object_setattr(self, 'max_results', max_results)
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'filters', filters)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"executable_users={self.executable_users!r}")
            parts.append(f"image_ids={self.image_ids!r}")
            parts.append(f"owners={self.owners!r}")
            parts.append(f"include_deprecated={self.include_deprecated!r}")
            parts.append(f"include_disabled={self.include_disabled!r}")
            parts.append(f"max_results={self.max_results!r}")
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"filters={self.filters!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('name', 'value')), EqPlan(fields=('name', 'value')), FrozenPlan(fields=('__shape__"
        "', 'name', 'value'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'value'), cache"
        "=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), "
        "default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation'), "
        "default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='value', annotation=OpRef(nam"
        "e='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self'"
        ", std_params=(), kw_only_params=('name', 'value'), frozen=True, slots=False, post_init_params=None, init_fns=("
        "), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name="
        "'value', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='895749f2203fe95718692e36384965b13d7c3e70',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'ProcessorFeature'),
    ),
)
def _process_dataclass__895749f2203fe95718692e36384965b13d7c3e70():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                name=self.name,
                value=self.value,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.name == other.name and
                self.value == other.value
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'name',
            'value',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'name',
            'value',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.name,
                self.value,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            value: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'name', name)
            __dataclass__object_setattr(self, 'value', value)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"name={self.name!r}")
            parts.append(f"value={self.value!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('association', 'primary', 'private_dns_name', 'private_ip_address')), EqPlan(field"
        "s=('association', 'primary', 'private_dns_name', 'private_ip_address')), FrozenPlan(fields=('__shape__', 'asso"
        "ciation', 'primary', 'private_dns_name', 'private_ip_address'), allow_dynamic_dunder_attrs=False), HashPlan(ac"
        "tion='add', fields=('association', 'primary', 'private_dns_name', 'private_ip_address'), cache=False), InitPla"
        "n(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='association', annotation=OpRef(name='init.fields.1.annotation'), default=O"
        "pRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='primary', annotation=OpRef(name='init"
        ".fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override"
        "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='priv"
        "ate_dns_name', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None), InitPlan.Field(name='private_ip_address', annotation=OpRef(name='init.fields.4.annotation'), "
        "default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params"
        "=('association', 'primary', 'private_dns_name', 'private_ip_address'), frozen=True, slots=False, post_init_par"
        "ams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='association', kw_only=True, fn="
        "None), ReprPlan.Field(name='primary', kw_only=True, fn=None), ReprPlan.Field(name='private_dns_name', kw_only="
        "True, fn=None), ReprPlan.Field(name='private_ip_address', kw_only=True, fn=None)), id=False, terse=False, defa"
        "ult_fn=None)))"
    ),
    plan_repr_sha1='8b22e4f30c55342a1e67e0793e5d4a8aabf425d6',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstancePrivateIpAddress'),
        ('ominfra.clouds.aws.models.services.ec2', 'NetworkInterfacePrivateIpAddress'),
    ),
)
def _process_dataclass__8b22e4f30c55342a1e67e0793e5d4a8aabf425d6():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                association=self.association,
                primary=self.primary,
                private_dns_name=self.private_dns_name,
                private_ip_address=self.private_ip_address,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.association == other.association and
                self.primary == other.primary and
                self.private_dns_name == other.private_dns_name and
                self.private_ip_address == other.private_ip_address
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'association',
            'primary',
            'private_dns_name',
            'private_ip_address',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'association',
            'primary',
            'private_dns_name',
            'private_ip_address',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.association,
                self.primary,
                self.private_dns_name,
                self.private_ip_address,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            association: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            primary: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            private_dns_name: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            private_ip_address: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'association', association)
            __dataclass__object_setattr(self, 'primary', primary)
            __dataclass__object_setattr(self, 'private_dns_name', private_dns_name)
            __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"association={self.association!r}")
            parts.append(f"primary={self.primary!r}")
            parts.append(f"private_dns_name={self.private_dns_name!r}")
            parts.append(f"private_ip_address={self.private_ip_address!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('addresses',)), EqPlan(fields=('addresses',)), FrozenPlan(fields=('__shape__', 'ad"
        "dresses'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('addresses',), cache=False), Init"
        "Plan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None,"
        " default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='addresses', annotation=OpRef(name='init.fields.1.annotation'), default="
        "OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('addre"
        "sses',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Repr"
        "Plan.Field(name='addresses', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='8bd2366327ae9973345c3c715d2d93e36ac27f11',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeAddressesResult'),
    ),
)
def _process_dataclass__8bd2366327ae9973345c3c715d2d93e36ac27f11():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                addresses=self.addresses,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.addresses == other.addresses
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'addresses',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'addresses',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.addresses,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            addresses: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'addresses', addresses)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"addresses={self.addresses!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('group_id', 'group_name', 'dry_run')), EqPlan(fields=('group_id', 'group_name', 'd"
        "ry_run')), FrozenPlan(fields=('__shape__', 'group_id', 'group_name', 'dry_run'), allow_dynamic_dunder_attrs=Fa"
        "lse), HashPlan(action='add', fields=('group_id', 'group_name', 'dry_run'), cache=False), InitPlan(fields=(Init"
        "Plan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory="
        "None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),"
        " InitPlan.Field(name='group_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.f"
        "ields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='group_name', annotation=OpRef(name='init.fields.2.anno"
        "tation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotati"
        "on=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_"
        "param='self', std_params=(), kw_only_params=('group_id', 'group_name', 'dry_run'), frozen=True, slots=False, p"
        "ost_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='group_id', kw_only="
        "True, fn=None), ReprPlan.Field(name='group_name', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_on"
        "ly=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='8dce2cc8aa2d92ebd569fffa8ed82a243f1a1bc2',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DeleteSecurityGroupRequest'),
    ),
)
def _process_dataclass__8dce2cc8aa2d92ebd569fffa8ed82a243f1a1bc2():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                group_id=self.group_id,
                group_name=self.group_name,
                dry_run=self.dry_run,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.group_id == other.group_id and
                self.group_name == other.group_name and
                self.dry_run == other.dry_run
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'group_id',
            'group_name',
            'dry_run',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'group_id',
            'group_name',
            'dry_run',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.group_id,
                self.group_name,
                self.dry_run,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            group_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            group_name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            dry_run: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'group_id', group_id)
            __dataclass__object_setattr(self, 'group_name', group_name)
            __dataclass__object_setattr(self, 'dry_run', dry_run)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"group_id={self.group_id!r}")
            parts.append(f"group_name={self.group_name!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('state', 'state_message')), EqPlan(fields=('state', 'state_message')), FrozenPlan("
        "fields=('__shape__', 'state', 'state_message'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fiel"
        "ds=('state', 'state_message'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRe"
        "f(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type="
        "FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state', annotation=OpR"
        "ef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
        "ld(name='state_message', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('state', 'state_message'), froze"
        "n=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
        "e='state', kw_only=True, fn=None), ReprPlan.Field(name='state_message', kw_only=True, fn=None)), id=False, ter"
        "se=False, default_fn=None)))"
    ),
    plan_repr_sha1='8e0c14bba9e8983bf6d4f25359bf99c8ca9c423a',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'VpcEncryptionControlExclusion'),
    ),
)
def _process_dataclass__8e0c14bba9e8983bf6d4f25359bf99c8ca9c423a():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                state=self.state,
                state_message=self.state_message,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.state == other.state and
                self.state_message == other.state_message
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'state',
            'state_message',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'state',
            'state_message',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.state,
                self.state_message,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            state: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            state_message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'state_message', state_message)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"state={self.state!r}")
            parts.append(f"state_message={self.state_message!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('internet_gateway', 'egress_only_internet_gateway', 'nat_gateway', 'virtual_privat"
        "e_gateway', 'vpc_peering', 'lambda_', 'vpc_lattice', 'elastic_file_system')), EqPlan(fields=('internet_gateway"
        "', 'egress_only_internet_gateway', 'nat_gateway', 'virtual_private_gateway', 'vpc_peering', 'lambda_', 'vpc_la"
        "ttice', 'elastic_file_system')), FrozenPlan(fields=('__shape__', 'internet_gateway', 'egress_only_internet_gat"
        "eway', 'nat_gateway', 'virtual_private_gateway', 'vpc_peering', 'lambda_', 'vpc_lattice', 'elastic_file_system"
        "'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('internet_gateway', 'egress_only_interne"
        "t_gateway', 'nat_gateway', 'virtual_private_gateway', 'vpc_peering', 'lambda_', 'vpc_lattice', 'elastic_file_s"
        "ystem'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0."
        "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, c"
        "oerce=None, validate=None, check_type=None), InitPlan.Field(name='internet_gateway', annotation=OpRef(name='in"
        "it.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='eg"
        "ress_only_internet_gateway', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.field"
        "s.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='nat_gateway', annotation=OpRef(name='init.fields.3.annotat"
        "ion'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='virtual_private_gatew"
        "ay', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None), InitPlan.Field(name='vpc_peering', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(nam"
        "e='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='lambda_', annotation=OpRef(name='init.fields."
        "6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_lattice'"
        ", annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='elastic_file_system', annotation=OpRef(name='init.fields.8.annotation'), default=OpRe"
        "f(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
        "E, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('internet_"
        "gateway', 'egress_only_internet_gateway', 'nat_gateway', 'virtual_private_gateway', 'vpc_peering', 'lambda_', "
        "'vpc_lattice', 'elastic_file_system'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_"
        "fns=()), ReprPlan(fields=(ReprPlan.Field(name='internet_gateway', kw_only=True, fn=None), ReprPlan.Field(name="
        "'egress_only_internet_gateway', kw_only=True, fn=None), ReprPlan.Field(name='nat_gateway', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='virtual_private_gateway', kw_only=True, fn=None), ReprPlan.Field(name='vpc_peering',"
        " kw_only=True, fn=None), ReprPlan.Field(name='lambda_', kw_only=True, fn=None), ReprPlan.Field(name='vpc_latti"
        "ce', kw_only=True, fn=None), ReprPlan.Field(name='elastic_file_system', kw_only=True, fn=None)), id=False, ter"
        "se=False, default_fn=None)))"
    ),
    plan_repr_sha1='8e5a61cba55eff4b4b1cbaafcda7e5d75c135da6',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'VpcEncryptionControlExclusions'),
    ),
)
def _process_dataclass__8e5a61cba55eff4b4b1cbaafcda7e5d75c135da6():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                internet_gateway=self.internet_gateway,
                egress_only_internet_gateway=self.egress_only_internet_gateway,
                nat_gateway=self.nat_gateway,
                virtual_private_gateway=self.virtual_private_gateway,
                vpc_peering=self.vpc_peering,
                lambda_=self.lambda_,
                vpc_lattice=self.vpc_lattice,
                elastic_file_system=self.elastic_file_system,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.internet_gateway == other.internet_gateway and
                self.egress_only_internet_gateway == other.egress_only_internet_gateway and
                self.nat_gateway == other.nat_gateway and
                self.virtual_private_gateway == other.virtual_private_gateway and
                self.vpc_peering == other.vpc_peering and
                self.lambda_ == other.lambda_ and
                self.vpc_lattice == other.vpc_lattice and
                self.elastic_file_system == other.elastic_file_system
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'internet_gateway',
            'egress_only_internet_gateway',
            'nat_gateway',
            'virtual_private_gateway',
            'vpc_peering',
            'lambda_',
            'vpc_lattice',
            'elastic_file_system',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'internet_gateway',
            'egress_only_internet_gateway',
            'nat_gateway',
            'virtual_private_gateway',
            'vpc_peering',
            'lambda_',
            'vpc_lattice',
            'elastic_file_system',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.internet_gateway,
                self.egress_only_internet_gateway,
                self.nat_gateway,
                self.virtual_private_gateway,
                self.vpc_peering,
                self.lambda_,
                self.vpc_lattice,
                self.elastic_file_system,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            internet_gateway: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            egress_only_internet_gateway: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            nat_gateway: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            virtual_private_gateway: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            vpc_peering: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            lambda_: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            vpc_lattice: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            elastic_file_system: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'internet_gateway', internet_gateway)
            __dataclass__object_setattr(self, 'egress_only_internet_gateway', egress_only_internet_gateway)
            __dataclass__object_setattr(self, 'nat_gateway', nat_gateway)
            __dataclass__object_setattr(self, 'virtual_private_gateway', virtual_private_gateway)
            __dataclass__object_setattr(self, 'vpc_peering', vpc_peering)
            __dataclass__object_setattr(self, 'lambda_', lambda_)
            __dataclass__object_setattr(self, 'vpc_lattice', vpc_lattice)
            __dataclass__object_setattr(self, 'elastic_file_system', elastic_file_system)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"internet_gateway={self.internet_gateway!r}")
            parts.append(f"egress_only_internet_gateway={self.egress_only_internet_gateway!r}")
            parts.append(f"nat_gateway={self.nat_gateway!r}")
            parts.append(f"virtual_private_gateway={self.virtual_private_gateway!r}")
            parts.append(f"vpc_peering={self.vpc_peering!r}")
            parts.append(f"lambda_={self.lambda_!r}")
            parts.append(f"vpc_lattice={self.vpc_lattice!r}")
            parts.append(f"elastic_file_system={self.elastic_file_system!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('expiration', 'etag', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc64_nvme', "
        "'checksum_sha1', 'checksum_sha256', 'checksum_type', 'server_side_encryption', 'version_id', 'sse_customer_alg"
        "orithm', 'sse_customer_key_md5', 'sse_kms_key_id', 'sse_kms_encryption_context', 'bucket_key_enabled', 'size',"
        " 'request_charged')), EqPlan(fields=('expiration', 'etag', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc6"
        "4_nvme', 'checksum_sha1', 'checksum_sha256', 'checksum_type', 'server_side_encryption', 'version_id', 'sse_cus"
        "tomer_algorithm', 'sse_customer_key_md5', 'sse_kms_key_id', 'sse_kms_encryption_context', 'bucket_key_enabled'"
        ", 'size', 'request_charged')), FrozenPlan(fields=('__shape__', 'expiration', 'etag', 'checksum_crc32', 'checks"
        "um_crc32c', 'checksum_crc64_nvme', 'checksum_sha1', 'checksum_sha256', 'checksum_type', 'server_side_encryptio"
        "n', 'version_id', 'sse_customer_algorithm', 'sse_customer_key_md5', 'sse_kms_key_id', 'sse_kms_encryption_cont"
        "ext', 'bucket_key_enabled', 'size', 'request_charged'), allow_dynamic_dunder_attrs=False), HashPlan(action='ad"
        "d', fields=('expiration', 'etag', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc64_nvme', 'checksum_sha1',"
        " 'checksum_sha256', 'checksum_type', 'server_side_encryption', 'version_id', 'sse_customer_algorithm', 'sse_cu"
        "stomer_key_md5', 'sse_kms_key_id', 'sse_kms_encryption_context', 'bucket_key_enabled', 'size', 'request_charge"
        "d'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.anno"
        "tation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerc"
        "e=None, validate=None, check_type=None), InitPlan.Field(name='expiration', annotation=OpRef(name='init.fields."
        "1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='etag', annot"
        "ation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='checksum_crc32', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init"
        ".fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='checksum_crc32c', annotation=OpRef(name='init.fields"
        ".4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='checksum_cr"
        "c64_nvme', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), def"
        "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
        "_type=None), InitPlan.Field(name='checksum_sha1', annotation=OpRef(name='init.fields.6.annotation'), default=O"
        "pRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='checksum_sha256', annotation=OpRef(na"
        "me='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='checksum_type', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='server_side_encryption', annotation=OpRef(name='init.fields.9.annot"
        "ation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='version_id', annota"
        "tion=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='sse_customer_algorithm', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef("
        "name='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='sse_customer_key_md5', annotation=OpRef(n"
        "ame='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='sse_kms_key_id', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None), InitPlan.Field(name='sse_kms_encryption_context', annotation=OpRef(name='init.fiel"
        "ds.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='bucket_"
        "key_enabled', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default')"
        ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='size', annotation=OpRef(name='init.fields.16.annotation'), default=OpRe"
        "f(name='init.fields.16.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='request_charged', annotation=OpRef(name"
        "='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self"
        "', std_params=(), kw_only_params=('expiration', 'etag', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc64_n"
        "vme', 'checksum_sha1', 'checksum_sha256', 'checksum_type', 'server_side_encryption', 'version_id', 'sse_custom"
        "er_algorithm', 'sse_customer_key_md5', 'sse_kms_key_id', 'sse_kms_encryption_context', 'bucket_key_enabled', '"
        "size', 'request_charged'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Rep"
        "rPlan(fields=(ReprPlan.Field(name='expiration', kw_only=True, fn=None), ReprPlan.Field(name='etag', kw_only=Tr"
        "ue, fn=None), ReprPlan.Field(name='checksum_crc32', kw_only=True, fn=None), ReprPlan.Field(name='checksum_crc3"
        "2c', kw_only=True, fn=None), ReprPlan.Field(name='checksum_crc64_nvme', kw_only=True, fn=None), ReprPlan.Field"
        "(name='checksum_sha1', kw_only=True, fn=None), ReprPlan.Field(name='checksum_sha256', kw_only=True, fn=None), "
        "ReprPlan.Field(name='checksum_type', kw_only=True, fn=None), ReprPlan.Field(name='server_side_encryption', kw_"
        "only=True, fn=None), ReprPlan.Field(name='version_id', kw_only=True, fn=None), ReprPlan.Field(name='sse_custom"
        "er_algorithm', kw_only=True, fn=None), ReprPlan.Field(name='sse_customer_key_md5', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='sse_kms_key_id', kw_only=True, fn=None), ReprPlan.Field(name='sse_kms_encryption_context', k"
        "w_only=True, fn=None), ReprPlan.Field(name='bucket_key_enabled', kw_only=True, fn=None), ReprPlan.Field(name='"
        "size', kw_only=True, fn=None), ReprPlan.Field(name='request_charged', kw_only=True, fn=None)), id=False, terse"
        "=False, default_fn=None)))"
    ),
    plan_repr_sha1='8fdebf05eeb23c866f3ff41d170ac9d6404c9f97',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.s3', 'PutObjectOutput'),
    ),
)
def _process_dataclass__8fdebf05eeb23c866f3ff41d170ac9d6404c9f97():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                expiration=self.expiration,
                etag=self.etag,
                checksum_crc32=self.checksum_crc32,
                checksum_crc32c=self.checksum_crc32c,
                checksum_crc64_nvme=self.checksum_crc64_nvme,
                checksum_sha1=self.checksum_sha1,
                checksum_sha256=self.checksum_sha256,
                checksum_type=self.checksum_type,
                server_side_encryption=self.server_side_encryption,
                version_id=self.version_id,
                sse_customer_algorithm=self.sse_customer_algorithm,
                sse_customer_key_md5=self.sse_customer_key_md5,
                sse_kms_key_id=self.sse_kms_key_id,
                sse_kms_encryption_context=self.sse_kms_encryption_context,
                bucket_key_enabled=self.bucket_key_enabled,
                size=self.size,
                request_charged=self.request_charged,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.expiration == other.expiration and
                self.etag == other.etag and
                self.checksum_crc32 == other.checksum_crc32 and
                self.checksum_crc32c == other.checksum_crc32c and
                self.checksum_crc64_nvme == other.checksum_crc64_nvme and
                self.checksum_sha1 == other.checksum_sha1 and
                self.checksum_sha256 == other.checksum_sha256 and
                self.checksum_type == other.checksum_type and
                self.server_side_encryption == other.server_side_encryption and
                self.version_id == other.version_id and
                self.sse_customer_algorithm == other.sse_customer_algorithm and
                self.sse_customer_key_md5 == other.sse_customer_key_md5 and
                self.sse_kms_key_id == other.sse_kms_key_id and
                self.sse_kms_encryption_context == other.sse_kms_encryption_context and
                self.bucket_key_enabled == other.bucket_key_enabled and
                self.size == other.size and
                self.request_charged == other.request_charged
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'expiration',
            'etag',
            'checksum_crc32',
            'checksum_crc32c',
            'checksum_crc64_nvme',
            'checksum_sha1',
            'checksum_sha256',
            'checksum_type',
            'server_side_encryption',
            'version_id',
            'sse_customer_algorithm',
            'sse_customer_key_md5',
            'sse_kms_key_id',
            'sse_kms_encryption_context',
            'bucket_key_enabled',
            'size',
            'request_charged',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'expiration',
            'etag',
            'checksum_crc32',
            'checksum_crc32c',
            'checksum_crc64_nvme',
            'checksum_sha1',
            'checksum_sha256',
            'checksum_type',
            'server_side_encryption',
            'version_id',
            'sse_customer_algorithm',
            'sse_customer_key_md5',
            'sse_kms_key_id',
            'sse_kms_encryption_context',
            'bucket_key_enabled',
            'size',
            'request_charged',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.expiration,
                self.etag,
                self.checksum_crc32,
                self.checksum_crc32c,
                self.checksum_crc64_nvme,
                self.checksum_sha1,
                self.checksum_sha256,
                self.checksum_type,
                self.server_side_encryption,
                self.version_id,
                self.sse_customer_algorithm,
                self.sse_customer_key_md5,
                self.sse_kms_key_id,
                self.sse_kms_encryption_context,
                self.bucket_key_enabled,
                self.size,
                self.request_charged,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            expiration: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            etag: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            checksum_crc32: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            checksum_crc32c: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            checksum_crc64_nvme: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            checksum_sha1: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            checksum_sha256: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            checksum_type: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            server_side_encryption: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            version_id: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            sse_customer_algorithm: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            sse_customer_key_md5: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            sse_kms_key_id: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            sse_kms_encryption_context: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            bucket_key_enabled: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            size: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            request_charged: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'expiration', expiration)
            __dataclass__object_setattr(self, 'etag', etag)
            __dataclass__object_setattr(self, 'checksum_crc32', checksum_crc32)
            __dataclass__object_setattr(self, 'checksum_crc32c', checksum_crc32c)
            __dataclass__object_setattr(self, 'checksum_crc64_nvme', checksum_crc64_nvme)
            __dataclass__object_setattr(self, 'checksum_sha1', checksum_sha1)
            __dataclass__object_setattr(self, 'checksum_sha256', checksum_sha256)
            __dataclass__object_setattr(self, 'checksum_type', checksum_type)
            __dataclass__object_setattr(self, 'server_side_encryption', server_side_encryption)
            __dataclass__object_setattr(self, 'version_id', version_id)
            __dataclass__object_setattr(self, 'sse_customer_algorithm', sse_customer_algorithm)
            __dataclass__object_setattr(self, 'sse_customer_key_md5', sse_customer_key_md5)
            __dataclass__object_setattr(self, 'sse_kms_key_id', sse_kms_key_id)
            __dataclass__object_setattr(self, 'sse_kms_encryption_context', sse_kms_encryption_context)
            __dataclass__object_setattr(self, 'bucket_key_enabled', bucket_key_enabled)
            __dataclass__object_setattr(self, 'size', size)
            __dataclass__object_setattr(self, 'request_charged', request_charged)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"expiration={self.expiration!r}")
            parts.append(f"etag={self.etag!r}")
            parts.append(f"checksum_crc32={self.checksum_crc32!r}")
            parts.append(f"checksum_crc32c={self.checksum_crc32c!r}")
            parts.append(f"checksum_crc64_nvme={self.checksum_crc64_nvme!r}")
            parts.append(f"checksum_sha1={self.checksum_sha1!r}")
            parts.append(f"checksum_sha256={self.checksum_sha256!r}")
            parts.append(f"checksum_type={self.checksum_type!r}")
            parts.append(f"server_side_encryption={self.server_side_encryption!r}")
            parts.append(f"version_id={self.version_id!r}")
            parts.append(f"sse_customer_algorithm={self.sse_customer_algorithm!r}")
            parts.append(f"sse_customer_key_md5={self.sse_customer_key_md5!r}")
            parts.append(f"sse_kms_key_id={self.sse_kms_key_id!r}")
            parts.append(f"sse_kms_encryption_context={self.sse_kms_encryption_context!r}")
            parts.append(f"bucket_key_enabled={self.bucket_key_enabled!r}")
            parts.append(f"size={self.size!r}")
            parts.append(f"request_charged={self.request_charged!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('availability_zone_id', 'affinity', 'group_name', 'partition_number', 'host_id', '"
        "tenancy', 'spread_domain', 'host_resource_group_arn', 'group_id', 'availability_zone')), EqPlan(fields=('avail"
        "ability_zone_id', 'affinity', 'group_name', 'partition_number', 'host_id', 'tenancy', 'spread_domain', 'host_r"
        "esource_group_arn', 'group_id', 'availability_zone')), FrozenPlan(fields=('__shape__', 'availability_zone_id',"
        " 'affinity', 'group_name', 'partition_number', 'host_id', 'tenancy', 'spread_domain', 'host_resource_group_arn"
        "', 'group_id', 'availability_zone'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('availa"
        "bility_zone_id', 'affinity', 'group_name', 'partition_number', 'host_id', 'tenancy', 'spread_domain', 'host_re"
        "source_group_arn', 'group_id', 'availability_zone'), cache=False), InitPlan(fields=(InitPlan.Field(name='__sha"
        "pe__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "availability_zone_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.de"
        "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
        "=None, check_type=None), InitPlan.Field(name='affinity', annotation=OpRef(name='init.fields.2.annotation'), de"
        "fault=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_name', annotation=OpRef("
        "name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='partition_number', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='host_id', annotation=OpRef(name='init.fields.5.annotation'), d"
        "efault=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tenancy', annotation=OpRef(na"
        "me='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='spread_domain', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='host_resource_group_arn', annotation=OpRef(name='init.fields.8.anno"
        "tation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_id', annotat"
        "ion=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None,"
        " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
        "lan.Field(name='availability_zone', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='in"
        "it.fields.10.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('availability_zone_"
        "id', 'affinity', 'group_name', 'partition_number', 'host_id', 'tenancy', 'spread_domain', 'host_resource_group"
        "_arn', 'group_id', 'availability_zone'), frozen=True, slots=False, post_init_params=None, init_fns=(), validat"
        "e_fns=()), ReprPlan(fields=(ReprPlan.Field(name='availability_zone_id', kw_only=True, fn=None), ReprPlan.Field"
        "(name='affinity', kw_only=True, fn=None), ReprPlan.Field(name='group_name', kw_only=True, fn=None), ReprPlan.F"
        "ield(name='partition_number', kw_only=True, fn=None), ReprPlan.Field(name='host_id', kw_only=True, fn=None), R"
        "eprPlan.Field(name='tenancy', kw_only=True, fn=None), ReprPlan.Field(name='spread_domain', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='host_resource_group_arn', kw_only=True, fn=None), ReprPlan.Field(name='group_id', kw"
        "_only=True, fn=None), ReprPlan.Field(name='availability_zone', kw_only=True, fn=None)), id=False, terse=False,"
        " default_fn=None)))"
    ),
    plan_repr_sha1='9056bbd7f356d0e4a2386c0252f0b94cc7bd0de0',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Placement'),
    ),
)
def _process_dataclass__9056bbd7f356d0e4a2386c0252f0b94cc7bd0de0():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                availability_zone_id=self.availability_zone_id,
                affinity=self.affinity,
                group_name=self.group_name,
                partition_number=self.partition_number,
                host_id=self.host_id,
                tenancy=self.tenancy,
                spread_domain=self.spread_domain,
                host_resource_group_arn=self.host_resource_group_arn,
                group_id=self.group_id,
                availability_zone=self.availability_zone,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.availability_zone_id == other.availability_zone_id and
                self.affinity == other.affinity and
                self.group_name == other.group_name and
                self.partition_number == other.partition_number and
                self.host_id == other.host_id and
                self.tenancy == other.tenancy and
                self.spread_domain == other.spread_domain and
                self.host_resource_group_arn == other.host_resource_group_arn and
                self.group_id == other.group_id and
                self.availability_zone == other.availability_zone
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'availability_zone_id',
            'affinity',
            'group_name',
            'partition_number',
            'host_id',
            'tenancy',
            'spread_domain',
            'host_resource_group_arn',
            'group_id',
            'availability_zone',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'availability_zone_id',
            'affinity',
            'group_name',
            'partition_number',
            'host_id',
            'tenancy',
            'spread_domain',
            'host_resource_group_arn',
            'group_id',
            'availability_zone',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.availability_zone_id,
                self.affinity,
                self.group_name,
                self.partition_number,
                self.host_id,
                self.tenancy,
                self.spread_domain,
                self.host_resource_group_arn,
                self.group_id,
                self.availability_zone,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            availability_zone_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            affinity: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            group_name: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            partition_number: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            host_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            tenancy: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            spread_domain: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            host_resource_group_arn: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            group_id: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            availability_zone: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'availability_zone_id', availability_zone_id)
            __dataclass__object_setattr(self, 'affinity', affinity)
            __dataclass__object_setattr(self, 'group_name', group_name)
            __dataclass__object_setattr(self, 'partition_number', partition_number)
            __dataclass__object_setattr(self, 'host_id', host_id)
            __dataclass__object_setattr(self, 'tenancy', tenancy)
            __dataclass__object_setattr(self, 'spread_domain', spread_domain)
            __dataclass__object_setattr(self, 'host_resource_group_arn', host_resource_group_arn)
            __dataclass__object_setattr(self, 'group_id', group_id)
            __dataclass__object_setattr(self, 'availability_zone', availability_zone)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"availability_zone_id={self.availability_zone_id!r}")
            parts.append(f"affinity={self.affinity!r}")
            parts.append(f"group_name={self.group_name!r}")
            parts.append(f"partition_number={self.partition_number!r}")
            parts.append(f"host_id={self.host_id!r}")
            parts.append(f"tenancy={self.tenancy!r}")
            parts.append(f"spread_domain={self.spread_domain!r}")
            parts.append(f"host_resource_group_arn={self.host_resource_group_arn!r}")
            parts.append(f"group_id={self.group_id!r}")
            parts.append(f"availability_zone={self.availability_zone!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('capacity_reservation_preference', 'capacity_reservation_target')), EqPlan(fields="
        "('capacity_reservation_preference', 'capacity_reservation_target')), FrozenPlan(fields=('__shape__', 'capacity"
        "_reservation_preference', 'capacity_reservation_target'), allow_dynamic_dunder_attrs=False), HashPlan(action='"
        "add', fields=('capacity_reservation_preference', 'capacity_reservation_target'), cache=False), InitPlan(fields"
        "=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fa"
        "ctory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type="
        "None), InitPlan.Field(name='capacity_reservation_preference', annotation=OpRef(name='init.fields.1.annotation'"
        "), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='capacity_reservation_targ"
        "et', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None)), self_param='self', std_params=(), kw_only_params=('capacity_reservation_preference', 'capacity_reserva"
        "tion_target'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields"
        "=(ReprPlan.Field(name='capacity_reservation_preference', kw_only=True, fn=None), ReprPlan.Field(name='capacity"
        "_reservation_target', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='917bc38bfc6f2d040d348ed036cdd76106ba7d55',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CapacityReservationSpecification'),
        ('ominfra.clouds.aws.models.services.ec2', 'CapacityReservationSpecificationResponse'),
    ),
)
def _process_dataclass__917bc38bfc6f2d040d348ed036cdd76106ba7d55():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                capacity_reservation_preference=self.capacity_reservation_preference,
                capacity_reservation_target=self.capacity_reservation_target,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.capacity_reservation_preference == other.capacity_reservation_preference and
                self.capacity_reservation_target == other.capacity_reservation_target
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'capacity_reservation_preference',
            'capacity_reservation_target',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'capacity_reservation_preference',
            'capacity_reservation_target',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.capacity_reservation_preference,
                self.capacity_reservation_target,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            capacity_reservation_preference: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            capacity_reservation_target: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'capacity_reservation_preference', capacity_reservation_preference)
            __dataclass__object_setattr(self, 'capacity_reservation_target', capacity_reservation_target)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"capacity_reservation_preference={self.capacity_reservation_preference!r}")
            parts.append(f"capacity_reservation_target={self.capacity_reservation_target!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('name', 'manufacturer', 'count', 'memory_info')), EqPlan(fields=('name', 'manufact"
        "urer', 'count', 'memory_info')), FrozenPlan(fields=('__shape__', 'name', 'manufacturer', 'count', 'memory_info"
        "'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'manufacturer', 'count', 'memory"
        "_info'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0."
        "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, c"
        "oerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1."
        "annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='manufacturer',"
        " annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_facto"
        "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
        "), InitPlan.Field(name='count', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fi"
        "elds.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='memory_info', annotation=OpRef(name='init.fields.4.anno"
        "tation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_o"
        "nly_params=('name', 'manufacturer', 'count', 'memory_info'), frozen=True, slots=False, post_init_params=None, "
        "init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.F"
        "ield(name='manufacturer', kw_only=True, fn=None), ReprPlan.Field(name='count', kw_only=True, fn=None), ReprPla"
        "n.Field(name='memory_info', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='918337ad51941fcd8bd3f26ae88abd374c057231',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'FpgaDeviceInfo'),
        ('ominfra.clouds.aws.models.services.ec2', 'GpuDeviceInfo'),
    ),
)
def _process_dataclass__918337ad51941fcd8bd3f26ae88abd374c057231():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                name=self.name,
                manufacturer=self.manufacturer,
                count=self.count,
                memory_info=self.memory_info,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.name == other.name and
                self.manufacturer == other.manufacturer and
                self.count == other.count and
                self.memory_info == other.memory_info
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'name',
            'manufacturer',
            'count',
            'memory_info',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'name',
            'manufacturer',
            'count',
            'memory_info',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.name,
                self.manufacturer,
                self.count,
                self.memory_info,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            manufacturer: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            count: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            memory_info: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'name', name)
            __dataclass__object_setattr(self, 'manufacturer', manufacturer)
            __dataclass__object_setattr(self, 'count', count)
            __dataclass__object_setattr(self, 'memory_info', memory_info)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"name={self.name!r}")
            parts.append(f"manufacturer={self.manufacturer!r}")
            parts.append(f"count={self.count!r}")
            parts.append(f"memory_info={self.memory_info!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('instance_ids', 'force', 'skip_os_shutdown', 'dry_run')), EqPlan(fields=('instance"
        "_ids', 'force', 'skip_os_shutdown', 'dry_run')), FrozenPlan(fields=('__shape__', 'instance_ids', 'force', 'ski"
        "p_os_shutdown', 'dry_run'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('instance_ids', "
        "'force', 'skip_os_shutdown', 'dry_run'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annot"
        "ation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_ids"
        "', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override="
        "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='force"
        "', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='skip_os_shutdown', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef("
        "name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
        " coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fiel"
        "ds.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params"
        "=(), kw_only_params=('instance_ids', 'force', 'skip_os_shutdown', 'dry_run'), frozen=True, slots=False, post_i"
        "nit_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='instance_ids', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='force', kw_only=True, fn=None), ReprPlan.Field(name='skip_os_shutdown', kw"
        "_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None)), id=False, terse=False, default_f"
        "n=None)))"
    ),
    plan_repr_sha1='91c5afb6e2c6cf1902cb47c9479b535857ed2830',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'TerminateInstancesRequest'),
    ),
)
def _process_dataclass__91c5afb6e2c6cf1902cb47c9479b535857ed2830():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                instance_ids=self.instance_ids,
                force=self.force,
                skip_os_shutdown=self.skip_os_shutdown,
                dry_run=self.dry_run,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.instance_ids == other.instance_ids and
                self.force == other.force and
                self.skip_os_shutdown == other.skip_os_shutdown and
                self.dry_run == other.dry_run
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'force',
            'skip_os_shutdown',
            'dry_run',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'force',
            'skip_os_shutdown',
            'dry_run',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.instance_ids,
                self.force,
                self.skip_os_shutdown,
                self.dry_run,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            instance_ids: __dataclass__init__fields__1__annotation,
            force: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            skip_os_shutdown: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            dry_run: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'instance_ids', instance_ids)
            __dataclass__object_setattr(self, 'force', force)
            __dataclass__object_setattr(self, 'skip_os_shutdown', skip_os_shutdown)
            __dataclass__object_setattr(self, 'dry_run', dry_run)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"instance_ids={self.instance_ids!r}")
            parts.append(f"force={self.force!r}")
            parts.append(f"skip_os_shutdown={self.skip_os_shutdown!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('bucket', 'delimiter', 'encoding_type', 'max_keys', 'prefix', 'continuation_token'"
        ", 'fetch_owner', 'start_after', 'request_payer', 'expected_bucket_owner', 'optional_object_attributes')), EqPl"
        "an(fields=('bucket', 'delimiter', 'encoding_type', 'max_keys', 'prefix', 'continuation_token', 'fetch_owner', "
        "'start_after', 'request_payer', 'expected_bucket_owner', 'optional_object_attributes')), FrozenPlan(fields=('_"
        "_shape__', 'bucket', 'delimiter', 'encoding_type', 'max_keys', 'prefix', 'continuation_token', 'fetch_owner', "
        "'start_after', 'request_payer', 'expected_bucket_owner', 'optional_object_attributes'), allow_dynamic_dunder_a"
        "ttrs=False), HashPlan(action='add', fields=('bucket', 'delimiter', 'encoding_type', 'max_keys', 'prefix', 'con"
        "tinuation_token', 'fetch_owner', 'start_after', 'request_payer', 'expected_bucket_owner', 'optional_object_att"
        "ributes'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields."
        "0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR,"
        " coerce=None, validate=None, check_type=None), InitPlan.Field(name='bucket', annotation=OpRef(name='init.field"
        "s.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='delimiter', annotation=OpRef(name='init.f"
        "ields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=F"
        "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='encodi"
        "ng_type', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='max_keys', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(n"
        "ame='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
        "coerce=None, validate=None, check_type=None), InitPlan.Field(name='prefix', annotation=OpRef(name='init.fields"
        ".5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='continuatio"
        "n_token', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='fetch_owner', annotation=OpRef(name='init.fields.7.annotation'), default=OpRe"
        "f(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
        "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='start_after', annotation=OpRef(name='ini"
        "t.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='req"
        "uest_payer', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), d"
        "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='expected_bucket_owner', annotation=OpRef(name='init.fields.10.annotation')"
        ", default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='optional_object_attribute"
        "s', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None)), self_param='self', std_params=(), kw_only_params=('bucket', 'delimiter', 'encoding_type', 'max_keys',"
        " 'prefix', 'continuation_token', 'fetch_owner', 'start_after', 'request_payer', 'expected_bucket_owner', 'opti"
        "onal_object_attributes'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Repr"
        "Plan(fields=(ReprPlan.Field(name='bucket', kw_only=True, fn=None), ReprPlan.Field(name='delimiter', kw_only=Tr"
        "ue, fn=None), ReprPlan.Field(name='encoding_type', kw_only=True, fn=None), ReprPlan.Field(name='max_keys', kw_"
        "only=True, fn=None), ReprPlan.Field(name='prefix', kw_only=True, fn=None), ReprPlan.Field(name='continuation_t"
        "oken', kw_only=True, fn=None), ReprPlan.Field(name='fetch_owner', kw_only=True, fn=None), ReprPlan.Field(name="
        "'start_after', kw_only=True, fn=None), ReprPlan.Field(name='request_payer', kw_only=True, fn=None), ReprPlan.F"
        "ield(name='expected_bucket_owner', kw_only=True, fn=None), ReprPlan.Field(name='optional_object_attributes', k"
        "w_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='951540b8bed14a80225187af35957c88bc0978b1',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.s3', 'ListObjectsV2Request'),
    ),
)
def _process_dataclass__951540b8bed14a80225187af35957c88bc0978b1():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                bucket=self.bucket,
                delimiter=self.delimiter,
                encoding_type=self.encoding_type,
                max_keys=self.max_keys,
                prefix=self.prefix,
                continuation_token=self.continuation_token,
                fetch_owner=self.fetch_owner,
                start_after=self.start_after,
                request_payer=self.request_payer,
                expected_bucket_owner=self.expected_bucket_owner,
                optional_object_attributes=self.optional_object_attributes,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.bucket == other.bucket and
                self.delimiter == other.delimiter and
                self.encoding_type == other.encoding_type and
                self.max_keys == other.max_keys and
                self.prefix == other.prefix and
                self.continuation_token == other.continuation_token and
                self.fetch_owner == other.fetch_owner and
                self.start_after == other.start_after and
                self.request_payer == other.request_payer and
                self.expected_bucket_owner == other.expected_bucket_owner and
                self.optional_object_attributes == other.optional_object_attributes
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'bucket',
            'delimiter',
            'encoding_type',
            'max_keys',
            'prefix',
            'continuation_token',
            'fetch_owner',
            'start_after',
            'request_payer',
            'expected_bucket_owner',
            'optional_object_attributes',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'bucket',
            'delimiter',
            'encoding_type',
            'max_keys',
            'prefix',
            'continuation_token',
            'fetch_owner',
            'start_after',
            'request_payer',
            'expected_bucket_owner',
            'optional_object_attributes',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.bucket,
                self.delimiter,
                self.encoding_type,
                self.max_keys,
                self.prefix,
                self.continuation_token,
                self.fetch_owner,
                self.start_after,
                self.request_payer,
                self.expected_bucket_owner,
                self.optional_object_attributes,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            bucket: __dataclass__init__fields__1__annotation,
            delimiter: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            encoding_type: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            max_keys: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            prefix: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            continuation_token: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            fetch_owner: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            start_after: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            request_payer: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            expected_bucket_owner: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            optional_object_attributes: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'bucket', bucket)
            __dataclass__object_setattr(self, 'delimiter', delimiter)
            __dataclass__object_setattr(self, 'encoding_type', encoding_type)
            __dataclass__object_setattr(self, 'max_keys', max_keys)
            __dataclass__object_setattr(self, 'prefix', prefix)
            __dataclass__object_setattr(self, 'continuation_token', continuation_token)
            __dataclass__object_setattr(self, 'fetch_owner', fetch_owner)
            __dataclass__object_setattr(self, 'start_after', start_after)
            __dataclass__object_setattr(self, 'request_payer', request_payer)
            __dataclass__object_setattr(self, 'expected_bucket_owner', expected_bucket_owner)
            __dataclass__object_setattr(self, 'optional_object_attributes', optional_object_attributes)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"bucket={self.bucket!r}")
            parts.append(f"delimiter={self.delimiter!r}")
            parts.append(f"encoding_type={self.encoding_type!r}")
            parts.append(f"max_keys={self.max_keys!r}")
            parts.append(f"prefix={self.prefix!r}")
            parts.append(f"continuation_token={self.continuation_token!r}")
            parts.append(f"fetch_owner={self.fetch_owner!r}")
            parts.append(f"start_after={self.start_after!r}")
            parts.append(f"request_payer={self.request_payer!r}")
            parts.append(f"expected_bucket_owner={self.expected_bucket_owner!r}")
            parts.append(f"optional_object_attributes={self.optional_object_attributes!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('network_interfaces', 'next_token')), EqPlan(fields=('network_interfaces', 'next_t"
        "oken')), FrozenPlan(fields=('__shape__', 'network_interfaces', 'next_token'), allow_dynamic_dunder_attrs=False"
        "), HashPlan(action='add', fields=('network_interfaces', 'next_token'), cache=False), InitPlan(fields=(InitPlan"
        ".Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None"
        ", init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='network_interfaces', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='"
        "init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
        "e=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields."
        "2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=()"
        ", kw_only_params=('network_interfaces', 'next_token'), frozen=True, slots=False, post_init_params=None, init_f"
        "ns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='network_interfaces', kw_only=True, fn=None), Re"
        "prPlan.Field(name='next_token', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='96615f8e1de0943f167f88126f4035d2d2ddb900',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeNetworkInterfacesResult'),
    ),
)
def _process_dataclass__96615f8e1de0943f167f88126f4035d2d2ddb900():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                network_interfaces=self.network_interfaces,
                next_token=self.next_token,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.network_interfaces == other.network_interfaces and
                self.next_token == other.next_token
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'network_interfaces',
            'next_token',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'network_interfaces',
            'next_token',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.network_interfaces,
                self.next_token,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            network_interfaces: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            next_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'network_interfaces', network_interfaces)
            __dataclass__object_setattr(self, 'next_token', next_token)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"network_interfaces={self.network_interfaces!r}")
            parts.append(f"next_token={self.next_token!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('destination_prefix_list_id', 'dry_run', 'route_table_id', 'destination_cidr_block"
        "', 'destination_ipv6_cidr_block')), EqPlan(fields=('destination_prefix_list_id', 'dry_run', 'route_table_id', "
        "'destination_cidr_block', 'destination_ipv6_cidr_block')), FrozenPlan(fields=('__shape__', 'destination_prefix"
        "_list_id', 'dry_run', 'route_table_id', 'destination_cidr_block', 'destination_ipv6_cidr_block'), allow_dynami"
        "c_dunder_attrs=False), HashPlan(action='add', fields=('destination_prefix_list_id', 'dry_run', 'route_table_id"
        "', 'destination_cidr_block', 'destination_ipv6_cidr_block'), cache=False), InitPlan(fields=(InitPlan.Field(nam"
        "e='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='destination_prefix_list_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='in"
        "it.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.2.ann"
        "otation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='route_table_id', "
        "annotation=OpRef(name='init.fields.3.annotation'), default=None, default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='destinat"
        "ion_cidr_block', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='destination_ipv6_cidr_block', annotation=OpRef(name='init.fields.5.ann"
        "otation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_"
        "only_params=('destination_prefix_list_id', 'dry_run', 'route_table_id', 'destination_cidr_block', 'destination"
        "_ipv6_cidr_block'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(f"
        "ields=(ReprPlan.Field(name='destination_prefix_list_id', kw_only=True, fn=None), ReprPlan.Field(name='dry_run'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='route_table_id', kw_only=True, fn=None), ReprPlan.Field(name='d"
        "estination_cidr_block', kw_only=True, fn=None), ReprPlan.Field(name='destination_ipv6_cidr_block', kw_only=Tru"
        "e, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='96794c88f56323f67ace2ae29045cc03327d5c41',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DeleteRouteRequest'),
    ),
)
def _process_dataclass__96794c88f56323f67ace2ae29045cc03327d5c41():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                destination_prefix_list_id=self.destination_prefix_list_id,
                dry_run=self.dry_run,
                route_table_id=self.route_table_id,
                destination_cidr_block=self.destination_cidr_block,
                destination_ipv6_cidr_block=self.destination_ipv6_cidr_block,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.destination_prefix_list_id == other.destination_prefix_list_id and
                self.dry_run == other.dry_run and
                self.route_table_id == other.route_table_id and
                self.destination_cidr_block == other.destination_cidr_block and
                self.destination_ipv6_cidr_block == other.destination_ipv6_cidr_block
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'destination_prefix_list_id',
            'dry_run',
            'route_table_id',
            'destination_cidr_block',
            'destination_ipv6_cidr_block',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'destination_prefix_list_id',
            'dry_run',
            'route_table_id',
            'destination_cidr_block',
            'destination_ipv6_cidr_block',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.destination_prefix_list_id,
                self.dry_run,
                self.route_table_id,
                self.destination_cidr_block,
                self.destination_ipv6_cidr_block,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            destination_prefix_list_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            dry_run: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            route_table_id: __dataclass__init__fields__3__annotation,
            destination_cidr_block: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            destination_ipv6_cidr_block: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'destination_prefix_list_id', destination_prefix_list_id)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'route_table_id', route_table_id)
            __dataclass__object_setattr(self, 'destination_cidr_block', destination_cidr_block)
            __dataclass__object_setattr(self, 'destination_ipv6_cidr_block', destination_ipv6_cidr_block)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"destination_prefix_list_id={self.destination_prefix_list_id!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"route_table_id={self.route_table_id!r}")
            parts.append(f"destination_cidr_block={self.destination_cidr_block!r}")
            parts.append(f"destination_ipv6_cidr_block={self.destination_ipv6_cidr_block!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('size_in_mi_b',)), EqPlan(fields=('size_in_mi_b',)), FrozenPlan(fields=('__shape__"
        "', 'size_in_mi_b'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('size_in_mi_b',), cache="
        "False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), d"
        "efault=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='size_in_mi_b', annotation=OpRef(name='init.fields.1.annotat"
        "ion'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only"
        "_params=('size_in_mi_b',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Rep"
        "rPlan(fields=(ReprPlan.Field(name='size_in_mi_b', kw_only=True, fn=None),), id=False, terse=False, default_fn="
        "None)))"
    ),
    plan_repr_sha1='9a0c4e3e2d7a9d7db1c242fbe40ecb8b8b1d2361',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'FpgaDeviceMemoryInfo'),
        ('ominfra.clouds.aws.models.services.ec2', 'GpuDeviceMemoryInfo'),
        ('ominfra.clouds.aws.models.services.ec2', 'InferenceDeviceMemoryInfo'),
        ('ominfra.clouds.aws.models.services.ec2', 'MediaDeviceMemoryInfo'),
        ('ominfra.clouds.aws.models.services.ec2', 'MemoryInfo'),
        ('ominfra.clouds.aws.models.services.ec2', 'NeuronDeviceMemoryInfo'),
    ),
)
def _process_dataclass__9a0c4e3e2d7a9d7db1c242fbe40ecb8b8b1d2361():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                size_in_mi_b=self.size_in_mi_b,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.size_in_mi_b == other.size_in_mi_b
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'size_in_mi_b',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'size_in_mi_b',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.size_in_mi_b,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            size_in_mi_b: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'size_in_mi_b', size_in_mi_b)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"size_in_mi_b={self.size_in_mi_b!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('return_',)), EqPlan(fields=('return_',)), FrozenPlan(fields=('__shape__', 'return"
        "_'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('return_',), cache=False), InitPlan(fie"
        "lds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default"
        "_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_ty"
        "pe=None), InitPlan.Field(name='return_', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name"
        "='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('return_',), fro"
        "zen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(n"
        "ame='return_', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='9aa5b3dde66636e77903283ad91eb34d6cb27b20',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CreateRouteResult'),
    ),
)
def _process_dataclass__9aa5b3dde66636e77903283ad91eb34d6cb27b20():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                return_=self.return_,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.return_ == other.return_
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'return_',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'return_',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.return_,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            return_: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'return_', return_)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"return_={self.return_!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('next_token', 'images')), EqPlan(fields=('next_token', 'images')), FrozenPlan(fiel"
        "ds=('__shape__', 'next_token', 'images'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('n"
        "ext_token', 'images'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='"
        "init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef("
        "name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='images', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None)), self_param='self', std_params=(), kw_only_params=('next_token', 'images'), frozen=True, slot"
        "s=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='next_toke"
        "n', kw_only=True, fn=None), ReprPlan.Field(name='images', kw_only=True, fn=None)), id=False, terse=False, defa"
        "ult_fn=None)))"
    ),
    plan_repr_sha1='9e25e98278bf5baa0fa863c9a231781780c532e1',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeImagesResult'),
    ),
)
def _process_dataclass__9e25e98278bf5baa0fa863c9a231781780c532e1():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                next_token=self.next_token,
                images=self.images,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.next_token == other.next_token and
                self.images == other.images
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'next_token',
            'images',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'next_token',
            'images',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.next_token,
                self.images,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            images: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'images', images)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"images={self.images!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('state',)), EqPlan(fields=('state',)), FrozenPlan(fields=('__shape__', 'state'), a"
        "llow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('state',), cache=False), InitPlan(fields=(Ini"
        "tPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory"
        "=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='state', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fie"
        "lds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('state',), frozen=True, sl"
        "ots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='state',"
        " kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='a2a4416e2af8714bacfde725575818993950dd57',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Monitoring'),
    ),
)
def _process_dataclass__a2a4416e2af8714bacfde725575818993950dd57():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                state=self.state,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.state == other.state
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'state',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'state',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.state,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            state: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'state', state)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"state={self.state!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('state', 'vpc_id')), EqPlan(fields=('state', 'vpc_id')), FrozenPlan(fields=('__sha"
        "pe__', 'state', 'vpc_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('state', 'vpc_id'"
        "), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annota"
        "tion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='state', annotation=OpRef(name='init.fields.1.annot"
        "ation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_id', annotation"
        "=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_pa"
        "ram='self', std_params=(), kw_only_params=('state', 'vpc_id'), frozen=True, slots=False, post_init_params=None"
        ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='state', kw_only=True, fn=None), ReprPla"
        "n.Field(name='vpc_id', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='a446d5c3e2a71716b2a1d9876adc8b92652a2148',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InternetGatewayAttachment'),
    ),
)
def _process_dataclass__a446d5c3e2a71716b2a1d9876adc8b92652a2148():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                state=self.state,
                vpc_id=self.vpc_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.state == other.state and
                self.vpc_id == other.vpc_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'state',
            'vpc_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'state',
            'vpc_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.state,
                self.vpc_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            state: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            vpc_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"state={self.state!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('starting_instances',)), EqPlan(fields=('starting_instances',)), FrozenPlan(fields"
        "=('__shape__', 'starting_instances'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('start"
        "ing_instances',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init."
        "fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLA"
        "SS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='starting_instances', annotation=OpR"
        "ef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param="
        "'self', std_params=(), kw_only_params=('starting_instances',), frozen=True, slots=False, post_init_params=None"
        ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='starting_instances', kw_only=True, fn=N"
        "one),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='a4a751ef703aea92c31990370bde756df31b62dc',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'StartInstancesResult'),
    ),
)
def _process_dataclass__a4a751ef703aea92c31990370bde756df31b62dc():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                starting_instances=self.starting_instances,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.starting_instances == other.starting_instances
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'starting_instances',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'starting_instances',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.starting_instances,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            starting_instances: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'starting_instances', starting_instances)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"starting_instances={self.starting_instances!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('db_parameter_group_name', 'parameter_apply_status')), EqPlan(fields=('db_paramete"
        "r_group_name', 'parameter_apply_status')), FrozenPlan(fields=('__shape__', 'db_parameter_group_name', 'paramet"
        "er_apply_status'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('db_parameter_group_name'"
        ", 'parameter_apply_status'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef("
        "name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_parameter_group_name'"
        ", annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='parameter_apply_status', annotation=OpRef(name='init.fields.2.annotation'), default=O"
        "pRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('db_par"
        "ameter_group_name', 'parameter_apply_status'), frozen=True, slots=False, post_init_params=None, init_fns=(), v"
        "alidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db_parameter_group_name', kw_only=True, fn=None), ReprP"
        "lan.Field(name='parameter_apply_status', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='a51c3ef9cca312b56d9868235ef7bc299c4a9d57',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'DBParameterGroupStatus'),
    ),
)
def _process_dataclass__a51c3ef9cca312b56d9868235ef7bc299c4a9d57():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                db_parameter_group_name=self.db_parameter_group_name,
                parameter_apply_status=self.parameter_apply_status,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.db_parameter_group_name == other.db_parameter_group_name and
                self.parameter_apply_status == other.parameter_apply_status
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'db_parameter_group_name',
            'parameter_apply_status',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'db_parameter_group_name',
            'parameter_apply_status',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.db_parameter_group_name,
                self.parameter_apply_status,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            db_parameter_group_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            parameter_apply_status: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'db_parameter_group_name', db_parameter_group_name)
            __dataclass__object_setattr(self, 'parameter_apply_status', parameter_apply_status)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"db_parameter_group_name={self.db_parameter_group_name!r}")
            parts.append(f"parameter_apply_status={self.parameter_apply_status!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('target_arn',)), EqPlan(fields=('target_arn',)), FrozenPlan(fields=('__shape__', '"
        "target_arn'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('target_arn',), cache=False), "
        "InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=N"
        "one, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='target_arn', annotation=OpRef(name='init.fields.1.annotation'), def"
        "ault=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('"
        "target_arn',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields"
        "=(ReprPlan.Field(name='target_arn', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='a668802e6cc60181d0d91b2bd31db6e6a3724a65',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'DeadLetterConfig'),
    ),
)
def _process_dataclass__a668802e6cc60181d0d91b2bd31db6e6a3724a65():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                target_arn=self.target_arn,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.target_arn == other.target_arn
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'target_arn',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'target_arn',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.target_arn,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            target_arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'target_arn', target_arn)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"target_arn={self.target_arn!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('association', 'attachment', 'description', 'groups', 'ipv6_addresses', 'mac_addre"
        "ss', 'network_interface_id', 'owner_id', 'private_dns_name', 'private_ip_address', 'private_ip_addresses', 'so"
        "urce_dest_check', 'status', 'subnet_id', 'vpc_id', 'interface_type', 'ipv4_prefixes', 'ipv6_prefixes', 'connec"
        "tion_tracking_configuration', 'operator')), EqPlan(fields=('association', 'attachment', 'description', 'groups"
        "', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'owner_id', 'private_dns_name', 'private_ip_addres"
        "s', 'private_ip_addresses', 'source_dest_check', 'status', 'subnet_id', 'vpc_id', 'interface_type', 'ipv4_pref"
        "ixes', 'ipv6_prefixes', 'connection_tracking_configuration', 'operator')), FrozenPlan(fields=('__shape__', 'as"
        "sociation', 'attachment', 'description', 'groups', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'o"
        "wner_id', 'private_dns_name', 'private_ip_address', 'private_ip_addresses', 'source_dest_check', 'status', 'su"
        "bnet_id', 'vpc_id', 'interface_type', 'ipv4_prefixes', 'ipv6_prefixes', 'connection_tracking_configuration', '"
        "operator'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('association', 'attachment', 'de"
        "scription', 'groups', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'owner_id', 'private_dns_name',"
        " 'private_ip_address', 'private_ip_addresses', 'source_dest_check', 'status', 'subnet_id', 'vpc_id', 'interfac"
        "e_type', 'ipv4_prefixes', 'ipv6_prefixes', 'connection_tracking_configuration', 'operator'), cache=False), Ini"
        "tPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None"
        ", default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='association', annotation=OpRef(name='init.fields.1.annotation'), defau"
        "lt=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType."
        "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='attachment', annotation=OpRef(nam"
        "e='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='description', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='groups', annotation=OpRef(name='init.fields.4.annotation'), default=Op"
        "Ref(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
        "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_addresses', annotation=OpRef(name"
        "='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, ov"
        "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='mac_address', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default')"
        ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='network_interface_id', annotation=OpRef(name='init.fields.7.annotation'"
        "), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='owner_id', annotation=OpR"
        "ef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
        "ld(name='private_dns_name', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields"
        ".9.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='private_ip_address', annotation=OpRef(name='init.fields.10."
        "annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='private_ip_ad"
        "dresses', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
        "k_type=None), InitPlan.Field(name='source_dest_check', annotation=OpRef(name='init.fields.12.annotation'), def"
        "ault=OpRef(name='init.fields.12.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='status', annotation=OpRef(name"
        "='init.fields.13.annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='subnet_id', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default"
        "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
        ", check_type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.15.annotation'), default="
        "OpRef(name='init.fields.15.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
        "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='interface_type', annotation=OpRef(n"
        "ame='init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='ipv4_prefixes', annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='ipv6_prefixes', annotation=OpRef(name='init.fields.18.annotati"
        "on'), default=OpRef(name='init.fields.18.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='connection_tracking_c"
        "onfiguration', annotation=OpRef(name='init.fields.19.annotation'), default=OpRef(name='init.fields.19.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='operator', annotation=OpRef(name='init.fields.20.annotation'), default"
        "=OpRef(name='init.fields.20.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
        "NSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('ass"
        "ociation', 'attachment', 'description', 'groups', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'ow"
        "ner_id', 'private_dns_name', 'private_ip_address', 'private_ip_addresses', 'source_dest_check', 'status', 'sub"
        "net_id', 'vpc_id', 'interface_type', 'ipv4_prefixes', 'ipv6_prefixes', 'connection_tracking_configuration', 'o"
        "perator'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Re"
        "prPlan.Field(name='association', kw_only=True, fn=None), ReprPlan.Field(name='attachment', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='description', kw_only=True, fn=None), ReprPlan.Field(name='groups', kw_only=True, fn"
        "=None), ReprPlan.Field(name='ipv6_addresses', kw_only=True, fn=None), ReprPlan.Field(name='mac_address', kw_on"
        "ly=True, fn=None), ReprPlan.Field(name='network_interface_id', kw_only=True, fn=None), ReprPlan.Field(name='ow"
        "ner_id', kw_only=True, fn=None), ReprPlan.Field(name='private_dns_name', kw_only=True, fn=None), ReprPlan.Fiel"
        "d(name='private_ip_address', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_addresses', kw_only=True,"
        " fn=None), ReprPlan.Field(name='source_dest_check', kw_only=True, fn=None), ReprPlan.Field(name='status', kw_o"
        "nly=True, fn=None), ReprPlan.Field(name='subnet_id', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_"
        "only=True, fn=None), ReprPlan.Field(name='interface_type', kw_only=True, fn=None), ReprPlan.Field(name='ipv4_p"
        "refixes', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_prefixes', kw_only=True, fn=None), ReprPlan.Field("
        "name='connection_tracking_configuration', kw_only=True, fn=None), ReprPlan.Field(name='operator', kw_only=True"
        ", fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='a70987d10ed61c28e98fe9fa21edba13d707ac39',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceNetworkInterface'),
    ),
)
def _process_dataclass__a70987d10ed61c28e98fe9fa21edba13d707ac39():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                association=self.association,
                attachment=self.attachment,
                description=self.description,
                groups=self.groups,
                ipv6_addresses=self.ipv6_addresses,
                mac_address=self.mac_address,
                network_interface_id=self.network_interface_id,
                owner_id=self.owner_id,
                private_dns_name=self.private_dns_name,
                private_ip_address=self.private_ip_address,
                private_ip_addresses=self.private_ip_addresses,
                source_dest_check=self.source_dest_check,
                status=self.status,
                subnet_id=self.subnet_id,
                vpc_id=self.vpc_id,
                interface_type=self.interface_type,
                ipv4_prefixes=self.ipv4_prefixes,
                ipv6_prefixes=self.ipv6_prefixes,
                connection_tracking_configuration=self.connection_tracking_configuration,
                operator=self.operator,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.association == other.association and
                self.attachment == other.attachment and
                self.description == other.description and
                self.groups == other.groups and
                self.ipv6_addresses == other.ipv6_addresses and
                self.mac_address == other.mac_address and
                self.network_interface_id == other.network_interface_id and
                self.owner_id == other.owner_id and
                self.private_dns_name == other.private_dns_name and
                self.private_ip_address == other.private_ip_address and
                self.private_ip_addresses == other.private_ip_addresses and
                self.source_dest_check == other.source_dest_check and
                self.status == other.status and
                self.subnet_id == other.subnet_id and
                self.vpc_id == other.vpc_id and
                self.interface_type == other.interface_type and
                self.ipv4_prefixes == other.ipv4_prefixes and
                self.ipv6_prefixes == other.ipv6_prefixes and
                self.connection_tracking_configuration == other.connection_tracking_configuration and
                self.operator == other.operator
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'association',
            'attachment',
            'description',
            'groups',
            'ipv6_addresses',
            'mac_address',
            'network_interface_id',
            'owner_id',
            'private_dns_name',
            'private_ip_address',
            'private_ip_addresses',
            'source_dest_check',
            'status',
            'subnet_id',
            'vpc_id',
            'interface_type',
            'ipv4_prefixes',
            'ipv6_prefixes',
            'connection_tracking_configuration',
            'operator',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'association',
            'attachment',
            'description',
            'groups',
            'ipv6_addresses',
            'mac_address',
            'network_interface_id',
            'owner_id',
            'private_dns_name',
            'private_ip_address',
            'private_ip_addresses',
            'source_dest_check',
            'status',
            'subnet_id',
            'vpc_id',
            'interface_type',
            'ipv4_prefixes',
            'ipv6_prefixes',
            'connection_tracking_configuration',
            'operator',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.association,
                self.attachment,
                self.description,
                self.groups,
                self.ipv6_addresses,
                self.mac_address,
                self.network_interface_id,
                self.owner_id,
                self.private_dns_name,
                self.private_ip_address,
                self.private_ip_addresses,
                self.source_dest_check,
                self.status,
                self.subnet_id,
                self.vpc_id,
                self.interface_type,
                self.ipv4_prefixes,
                self.ipv6_prefixes,
                self.connection_tracking_configuration,
                self.operator,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            association: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            attachment: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            description: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            groups: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            ipv6_addresses: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            mac_address: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            network_interface_id: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            owner_id: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            private_dns_name: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            private_ip_address: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            private_ip_addresses: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            source_dest_check: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            status: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            subnet_id: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            vpc_id: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            interface_type: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            ipv4_prefixes: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            ipv6_prefixes: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            connection_tracking_configuration: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            operator: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'association', association)
            __dataclass__object_setattr(self, 'attachment', attachment)
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'groups', groups)
            __dataclass__object_setattr(self, 'ipv6_addresses', ipv6_addresses)
            __dataclass__object_setattr(self, 'mac_address', mac_address)
            __dataclass__object_setattr(self, 'network_interface_id', network_interface_id)
            __dataclass__object_setattr(self, 'owner_id', owner_id)
            __dataclass__object_setattr(self, 'private_dns_name', private_dns_name)
            __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)
            __dataclass__object_setattr(self, 'private_ip_addresses', private_ip_addresses)
            __dataclass__object_setattr(self, 'source_dest_check', source_dest_check)
            __dataclass__object_setattr(self, 'status', status)
            __dataclass__object_setattr(self, 'subnet_id', subnet_id)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'interface_type', interface_type)
            __dataclass__object_setattr(self, 'ipv4_prefixes', ipv4_prefixes)
            __dataclass__object_setattr(self, 'ipv6_prefixes', ipv6_prefixes)
            __dataclass__object_setattr(self, 'connection_tracking_configuration', connection_tracking_configuration)
            __dataclass__object_setattr(self, 'operator', operator)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"association={self.association!r}")
            parts.append(f"attachment={self.attachment!r}")
            parts.append(f"description={self.description!r}")
            parts.append(f"groups={self.groups!r}")
            parts.append(f"ipv6_addresses={self.ipv6_addresses!r}")
            parts.append(f"mac_address={self.mac_address!r}")
            parts.append(f"network_interface_id={self.network_interface_id!r}")
            parts.append(f"owner_id={self.owner_id!r}")
            parts.append(f"private_dns_name={self.private_dns_name!r}")
            parts.append(f"private_ip_address={self.private_ip_address!r}")
            parts.append(f"private_ip_addresses={self.private_ip_addresses!r}")
            parts.append(f"source_dest_check={self.source_dest_check!r}")
            parts.append(f"status={self.status!r}")
            parts.append(f"subnet_id={self.subnet_id!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"interface_type={self.interface_type!r}")
            parts.append(f"ipv4_prefixes={self.ipv4_prefixes!r}")
            parts.append(f"ipv6_prefixes={self.ipv6_prefixes!r}")
            parts.append(f"connection_tracking_configuration={self.connection_tracking_configuration!r}")
            parts.append(f"operator={self.operator!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ipv4_prefix',)), EqPlan(fields=('ipv4_prefix',)), FrozenPlan(fields=('__shape__',"
        " 'ipv4_prefix'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ipv4_prefix',), cache=Fals"
        "e), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defau"
        "lt=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='ipv4_prefix', annotation=OpRef(name='init.fields.1.annotation')"
        ", default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fie"
        "ldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_para"
        "ms=('ipv4_prefix',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan("
        "fields=(ReprPlan.Field(name='ipv4_prefix', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='ab20a40c4e4ec96dead82de9d24b8b611ba8974c',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceIpv4Prefix'),
        ('ominfra.clouds.aws.models.services.ec2', 'Ipv4PrefixSpecification'),
        ('ominfra.clouds.aws.models.services.ec2', 'Ipv4PrefixSpecificationRequest'),
    ),
)
def _process_dataclass__ab20a40c4e4ec96dead82de9d24b8b611ba8974c():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ipv4_prefix=self.ipv4_prefix,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ipv4_prefix == other.ipv4_prefix
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ipv4_prefix',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ipv4_prefix',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ipv4_prefix,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ipv4_prefix: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ipv4_prefix', ipv4_prefix)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ipv4_prefix={self.ipv4_prefix!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('tenant_isolation_mode',)), EqPlan(fields=('tenant_isolation_mode',)), FrozenPlan("
        "fields=('__shape__', 'tenant_isolation_mode'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', field"
        "s=('tenant_isolation_mode',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef"
        "(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=F"
        "ieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tenant_isolation_mode',"
        " annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_para"
        "ms=(), kw_only_params=('tenant_isolation_mode',), frozen=True, slots=False, post_init_params=None, init_fns=()"
        ", validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='tenant_isolation_mode', kw_only=True, fn=None),), id"
        "=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='acba8e67f2ea6e7d9058cd7cead360bc0a73cf1a',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'TenancyConfig'),
    ),
)
def _process_dataclass__acba8e67f2ea6e7d9058cd7cead360bc0a73cf1a():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                tenant_isolation_mode=self.tenant_isolation_mode,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.tenant_isolation_mode == other.tenant_isolation_mode
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'tenant_isolation_mode',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'tenant_isolation_mode',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.tenant_isolation_mode,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            tenant_isolation_mode: __dataclass__init__fields__1__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'tenant_isolation_mode', tenant_isolation_mode)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"tenant_isolation_mode={self.tenant_isolation_mode!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('instance_types', 'next_token')), EqPlan(fields=('instance_types', 'next_token')),"
        " FrozenPlan(fields=('__shape__', 'instance_types', 'next_token'), allow_dynamic_dunder_attrs=False), HashPlan("
        "action='add', fields=('instance_types', 'next_token'), cache=False), InitPlan(fields=(InitPlan.Field(name='__s"
        "hape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='instance_types', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.2.annotation'), defa"
        "ult=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('i"
        "nstance_types', 'next_token'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
        " ReprPlan(fields=(ReprPlan.Field(name='instance_types', kw_only=True, fn=None), ReprPlan.Field(name='next_toke"
        "n', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='ad278adb314f3f74b95f1b0515ed1bb994d5624e',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeInstanceTypesResult'),
    ),
)
def _process_dataclass__ad278adb314f3f74b95f1b0515ed1bb994d5624e():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                instance_types=self.instance_types,
                next_token=self.next_token,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.instance_types == other.instance_types and
                self.next_token == other.next_token
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'instance_types',
            'next_token',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'instance_types',
            'next_token',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.instance_types,
                self.next_token,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            instance_types: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            next_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'instance_types', instance_types)
            __dataclass__object_setattr(self, 'next_token', next_token)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"instance_types={self.instance_types!r}")
            parts.append(f"next_token={self.next_token!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('subnet_ids', 'security_group_ids', 'vpc_id', 'ipv6_allowed_for_dual_stack')), EqP"
        "lan(fields=('subnet_ids', 'security_group_ids', 'vpc_id', 'ipv6_allowed_for_dual_stack')), FrozenPlan(fields=("
        "'__shape__', 'subnet_ids', 'security_group_ids', 'vpc_id', 'ipv6_allowed_for_dual_stack'), allow_dynamic_dunde"
        "r_attrs=False), HashPlan(action='add', fields=('subnet_ids', 'security_group_ids', 'vpc_id', 'ipv6_allowed_for"
        "_dual_stack'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fie"
        "lds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_"
        "VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnet_ids', annotation=OpRef(name='in"
        "it.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='se"
        "curity_group_ids', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.3.annotation'), default="
        "OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_allowed_for_dual_stack', annota"
        "tion=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), sel"
        "f_param='self', std_params=(), kw_only_params=('subnet_ids', 'security_group_ids', 'vpc_id', 'ipv6_allowed_for"
        "_dual_stack'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields"
        "=(ReprPlan.Field(name='subnet_ids', kw_only=True, fn=None), ReprPlan.Field(name='security_group_ids', kw_only="
        "True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_allowed_for_du"
        "al_stack', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='adc0193a1c11249e7e0ecd78b9755bc5f0aaada7',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'VpcConfigResponse'),
    ),
)
def _process_dataclass__adc0193a1c11249e7e0ecd78b9755bc5f0aaada7():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                subnet_ids=self.subnet_ids,
                security_group_ids=self.security_group_ids,
                vpc_id=self.vpc_id,
                ipv6_allowed_for_dual_stack=self.ipv6_allowed_for_dual_stack,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.subnet_ids == other.subnet_ids and
                self.security_group_ids == other.security_group_ids and
                self.vpc_id == other.vpc_id and
                self.ipv6_allowed_for_dual_stack == other.ipv6_allowed_for_dual_stack
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'subnet_ids',
            'security_group_ids',
            'vpc_id',
            'ipv6_allowed_for_dual_stack',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'subnet_ids',
            'security_group_ids',
            'vpc_id',
            'ipv6_allowed_for_dual_stack',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.subnet_ids,
                self.security_group_ids,
                self.vpc_id,
                self.ipv6_allowed_for_dual_stack,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            subnet_ids: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            security_group_ids: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            vpc_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            ipv6_allowed_for_dual_stack: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'subnet_ids', subnet_ids)
            __dataclass__object_setattr(self, 'security_group_ids', security_group_ids)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'ipv6_allowed_for_dual_stack', ipv6_allowed_for_dual_stack)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"subnet_ids={self.subnet_ids!r}")
            parts.append(f"security_group_ids={self.security_group_ids!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"ipv6_allowed_for_dual_stack={self.ipv6_allowed_for_dual_stack!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('entry_point', 'command', 'working_directory')), EqPlan(fields=('entry_point', 'co"
        "mmand', 'working_directory')), FrozenPlan(fields=('__shape__', 'entry_point', 'command', 'working_directory'),"
        " allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('entry_point', 'command', 'working_director"
        "y'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.anno"
        "tation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerc"
        "e=None, validate=None, check_type=None), InitPlan.Field(name='entry_point', annotation=OpRef(name='init.fields"
        ".1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='command', a"
        "nnotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory"
        "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
        " InitPlan.Field(name='working_directory', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(nam"
        "e='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('entry_point', "
        "'command', 'working_directory'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()"
        "), ReprPlan(fields=(ReprPlan.Field(name='entry_point', kw_only=True, fn=None), ReprPlan.Field(name='command', "
        "kw_only=True, fn=None), ReprPlan.Field(name='working_directory', kw_only=True, fn=None)), id=False, terse=Fals"
        "e, default_fn=None)))"
    ),
    plan_repr_sha1='ae03700d2ed8d061b79f46b2ac2de69041ed914c',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'ImageConfig'),
    ),
)
def _process_dataclass__ae03700d2ed8d061b79f46b2ac2de69041ed914c():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                entry_point=self.entry_point,
                command=self.command,
                working_directory=self.working_directory,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.entry_point == other.entry_point and
                self.command == other.command and
                self.working_directory == other.working_directory
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'entry_point',
            'command',
            'working_directory',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'entry_point',
            'command',
            'working_directory',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.entry_point,
                self.command,
                self.working_directory,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            entry_point: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            command: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            working_directory: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'entry_point', entry_point)
            __dataclass__object_setattr(self, 'command', command)
            __dataclass__object_setattr(self, 'working_directory', working_directory)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"entry_point={self.entry_point!r}")
            parts.append(f"command={self.command!r}")
            parts.append(f"working_directory={self.working_directory!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('key', 'last_modified', 'etag', 'checksum_algorithm', 'checksum_type', 'size', 'st"
        "orage_class', 'owner', 'restore_status')), EqPlan(fields=('key', 'last_modified', 'etag', 'checksum_algorithm'"
        ", 'checksum_type', 'size', 'storage_class', 'owner', 'restore_status')), FrozenPlan(fields=('__shape__', 'key'"
        ", 'last_modified', 'etag', 'checksum_algorithm', 'checksum_type', 'size', 'storage_class', 'owner', 'restore_s"
        "tatus'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('key', 'last_modified', 'etag', 'ch"
        "ecksum_algorithm', 'checksum_type', 'size', 'storage_class', 'owner', 'restore_status'), cache=False), InitPla"
        "n(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='key', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(nam"
        "e='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='last_modified', annotation=OpRef(name='init.f"
        "ields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=F"
        "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='etag',"
        " annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_facto"
        "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
        "), InitPlan.Field(name='checksum_algorithm', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef("
        "name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
        " coerce=None, validate=None, check_type=None), InitPlan.Field(name='checksum_type', annotation=OpRef(name='ini"
        "t.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='siz"
        "e', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_fa"
        "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
        "one), InitPlan.Field(name='storage_class', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(na"
        "me='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
        "oerce=None, validate=None, check_type=None), InitPlan.Field(name='owner', annotation=OpRef(name='init.fields.8"
        ".annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='restore_statu"
        "s', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_fa"
        "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
        "one)), self_param='self', std_params=(), kw_only_params=('key', 'last_modified', 'etag', 'checksum_algorithm',"
        " 'checksum_type', 'size', 'storage_class', 'owner', 'restore_status'), frozen=True, slots=False, post_init_par"
        "ams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='key', kw_only=True, fn=None), R"
        "eprPlan.Field(name='last_modified', kw_only=True, fn=None), ReprPlan.Field(name='etag', kw_only=True, fn=None)"
        ", ReprPlan.Field(name='checksum_algorithm', kw_only=True, fn=None), ReprPlan.Field(name='checksum_type', kw_on"
        "ly=True, fn=None), ReprPlan.Field(name='size', kw_only=True, fn=None), ReprPlan.Field(name='storage_class', kw"
        "_only=True, fn=None), ReprPlan.Field(name='owner', kw_only=True, fn=None), ReprPlan.Field(name='restore_status"
        "', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='b01292dbfa1522a534fcd63057c34e2b308f37ec',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.s3', 'Object'),
    ),
)
def _process_dataclass__b01292dbfa1522a534fcd63057c34e2b308f37ec():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                key=self.key,
                last_modified=self.last_modified,
                etag=self.etag,
                checksum_algorithm=self.checksum_algorithm,
                checksum_type=self.checksum_type,
                size=self.size,
                storage_class=self.storage_class,
                owner=self.owner,
                restore_status=self.restore_status,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.key == other.key and
                self.last_modified == other.last_modified and
                self.etag == other.etag and
                self.checksum_algorithm == other.checksum_algorithm and
                self.checksum_type == other.checksum_type and
                self.size == other.size and
                self.storage_class == other.storage_class and
                self.owner == other.owner and
                self.restore_status == other.restore_status
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'key',
            'last_modified',
            'etag',
            'checksum_algorithm',
            'checksum_type',
            'size',
            'storage_class',
            'owner',
            'restore_status',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'key',
            'last_modified',
            'etag',
            'checksum_algorithm',
            'checksum_type',
            'size',
            'storage_class',
            'owner',
            'restore_status',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.key,
                self.last_modified,
                self.etag,
                self.checksum_algorithm,
                self.checksum_type,
                self.size,
                self.storage_class,
                self.owner,
                self.restore_status,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            key: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            last_modified: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            etag: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            checksum_algorithm: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            checksum_type: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            size: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            storage_class: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            owner: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            restore_status: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'key', key)
            __dataclass__object_setattr(self, 'last_modified', last_modified)
            __dataclass__object_setattr(self, 'etag', etag)
            __dataclass__object_setattr(self, 'checksum_algorithm', checksum_algorithm)
            __dataclass__object_setattr(self, 'checksum_type', checksum_type)
            __dataclass__object_setattr(self, 'size', size)
            __dataclass__object_setattr(self, 'storage_class', storage_class)
            __dataclass__object_setattr(self, 'owner', owner)
            __dataclass__object_setattr(self, 'restore_status', restore_status)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"key={self.key!r}")
            parts.append(f"last_modified={self.last_modified!r}")
            parts.append(f"etag={self.etag!r}")
            parts.append(f"checksum_algorithm={self.checksum_algorithm!r}")
            parts.append(f"checksum_type={self.checksum_type!r}")
            parts.append(f"size={self.size!r}")
            parts.append(f"storage_class={self.storage_class!r}")
            parts.append(f"owner={self.owner!r}")
            parts.append(f"restore_status={self.restore_status!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('next_token', 'max_results', 'dry_run', 'internet_gateway_ids', 'filters')), EqPla"
        "n(fields=('next_token', 'max_results', 'dry_run', 'internet_gateway_ids', 'filters')), FrozenPlan(fields=('__s"
        "hape__', 'next_token', 'max_results', 'dry_run', 'internet_gateway_ids', 'filters'), allow_dynamic_dunder_attr"
        "s=False), HashPlan(action='add', fields=('next_token', 'max_results', 'dry_run', 'internet_gateway_ids', 'filt"
        "ers'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.an"
        "notation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.field"
        "s.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False"
        ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_result"
        "s', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_fa"
        "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
        "one), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='in"
        "it.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='internet_gateway_ids', annotation=OpRef(name='init"
        ".fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override"
        "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='filt"
        "ers', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None)), self_param='self', std_params=(), kw_only_params=('next_token', 'max_results', 'dry_run', 'internet_g"
        "ateway_ids', 'filters'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
        "lan(fields=(ReprPlan.Field(name='next_token', kw_only=True, fn=None), ReprPlan.Field(name='max_results', kw_on"
        "ly=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='internet_gatewa"
        "y_ids', kw_only=True, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn=None)), id=False, terse=False,"
        " default_fn=None)))"
    ),
    plan_repr_sha1='b03db18cab42cf448c5be8bcbfd53886cb044431',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeInternetGatewaysRequest'),
    ),
)
def _process_dataclass__b03db18cab42cf448c5be8bcbfd53886cb044431():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                next_token=self.next_token,
                max_results=self.max_results,
                dry_run=self.dry_run,
                internet_gateway_ids=self.internet_gateway_ids,
                filters=self.filters,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.next_token == other.next_token and
                self.max_results == other.max_results and
                self.dry_run == other.dry_run and
                self.internet_gateway_ids == other.internet_gateway_ids and
                self.filters == other.filters
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'next_token',
            'max_results',
            'dry_run',
            'internet_gateway_ids',
            'filters',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'next_token',
            'max_results',
            'dry_run',
            'internet_gateway_ids',
            'filters',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.next_token,
                self.max_results,
                self.dry_run,
                self.internet_gateway_ids,
                self.filters,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            max_results: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            dry_run: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            internet_gateway_ids: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            filters: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'max_results', max_results)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'internet_gateway_ids', internet_gateway_ids)
            __dataclass__object_setattr(self, 'filters', filters)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"max_results={self.max_results!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"internet_gateway_ids={self.internet_gateway_ids!r}")
            parts.append(f"filters={self.filters!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('supported_versions',)), EqPlan(fields=('supported_versions',)), FrozenPlan(fields"
        "=('__shape__', 'supported_versions'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('suppo"
        "rted_versions',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init."
        "fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLA"
        "SS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='supported_versions', annotation=OpR"
        "ef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param="
        "'self', std_params=(), kw_only_params=('supported_versions',), frozen=True, slots=False, post_init_params=None"
        ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='supported_versions', kw_only=True, fn=N"
        "one),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='b21e63103b657587ad4e98ea3e1e6b9c55c51087',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NitroTpmInfo'),
    ),
)
def _process_dataclass__b21e63103b657587ad4e98ea3e1e6b9c55c51087():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                supported_versions=self.supported_versions,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.supported_versions == other.supported_versions
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'supported_versions',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'supported_versions',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.supported_versions,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            supported_versions: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'supported_versions', supported_versions)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"supported_versions={self.supported_versions!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('instance_id', 'current_state', 'previous_state')), EqPlan(fields=('instance_id', "
        "'current_state', 'previous_state')), FrozenPlan(fields=('__shape__', 'instance_id', 'current_state', 'previous"
        "_state'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('instance_id', 'current_state', 'p"
        "revious_state'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.f"
        "ields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLAS"
        "S_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_id', annotation=OpRef(name="
        "'init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
        "'current_state', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='previous_state', annotation=OpRef(name='init.fields.3.annotation'), de"
        "fault=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=("
        "'instance_id', 'current_state', 'previous_state'), frozen=True, slots=False, post_init_params=None, init_fns=("
        "), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='instance_id', kw_only=True, fn=None), ReprPlan.Fiel"
        "d(name='current_state', kw_only=True, fn=None), ReprPlan.Field(name='previous_state', kw_only=True, fn=None)),"
        " id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='b37870e1fb3b8b28bae14f82ea3a92213b6d8404',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceStateChange'),
    ),
)
def _process_dataclass__b37870e1fb3b8b28bae14f82ea3a92213b6d8404():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                instance_id=self.instance_id,
                current_state=self.current_state,
                previous_state=self.previous_state,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.instance_id == other.instance_id and
                self.current_state == other.current_state and
                self.previous_state == other.previous_state
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'instance_id',
            'current_state',
            'previous_state',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'instance_id',
            'current_state',
            'previous_state',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.instance_id,
                self.current_state,
                self.previous_state,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            instance_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            current_state: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            previous_state: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'instance_id', instance_id)
            __dataclass__object_setattr(self, 'current_state', current_state)
            __dataclass__object_setattr(self, 'previous_state', previous_state)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"instance_id={self.instance_id!r}")
            parts.append(f"current_state={self.current_state!r}")
            parts.append(f"previous_state={self.previous_state!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('network_card_index', 'network_performance', 'maximum_network_interfaces', 'baseli"
        "ne_bandwidth_in_gbips', 'peak_bandwidth_in_gbips', 'default_ena_queue_count_per_interface', 'maximum_ena_queue"
        "_count', 'maximum_ena_queue_count_per_interface')), EqPlan(fields=('network_card_index', 'network_performance'"
        ", 'maximum_network_interfaces', 'baseline_bandwidth_in_gbips', 'peak_bandwidth_in_gbips', 'default_ena_queue_c"
        "ount_per_interface', 'maximum_ena_queue_count', 'maximum_ena_queue_count_per_interface')), FrozenPlan(fields=("
        "'__shape__', 'network_card_index', 'network_performance', 'maximum_network_interfaces', 'baseline_bandwidth_in"
        "_gbips', 'peak_bandwidth_in_gbips', 'default_ena_queue_count_per_interface', 'maximum_ena_queue_count', 'maxim"
        "um_ena_queue_count_per_interface'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('network"
        "_card_index', 'network_performance', 'maximum_network_interfaces', 'baseline_bandwidth_in_gbips', 'peak_bandwi"
        "dth_in_gbips', 'default_ena_queue_count_per_interface', 'maximum_ena_queue_count', 'maximum_ena_queue_count_pe"
        "r_interface'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fie"
        "lds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_"
        "VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_card_index', annotation=OpRef("
        "name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='network_performance', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields"
        ".2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='maximum_network_interfaces', annotation=OpRef(name='init.fi"
        "elds.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='baselin"
        "e_bandwidth_in_gbips', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.de"
        "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
        "=None, check_type=None), InitPlan.Field(name='peak_bandwidth_in_gbips', annotation=OpRef(name='init.fields.5.a"
        "nnotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='default_ena_que"
        "ue_count_per_interface', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='maximum_ena_queue_count', annotation=OpRef(name='init.fields.7"
        ".annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maximum_ena_q"
        "ueue_count_per_interface', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields."
        "8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
        "date=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('network_card_index', 'network"
        "_performance', 'maximum_network_interfaces', 'baseline_bandwidth_in_gbips', 'peak_bandwidth_in_gbips', 'defaul"
        "t_ena_queue_count_per_interface', 'maximum_ena_queue_count', 'maximum_ena_queue_count_per_interface'), frozen="
        "True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name="
        "'network_card_index', kw_only=True, fn=None), ReprPlan.Field(name='network_performance', kw_only=True, fn=None"
        "), ReprPlan.Field(name='maximum_network_interfaces', kw_only=True, fn=None), ReprPlan.Field(name='baseline_ban"
        "dwidth_in_gbips', kw_only=True, fn=None), ReprPlan.Field(name='peak_bandwidth_in_gbips', kw_only=True, fn=None"
        "), ReprPlan.Field(name='default_ena_queue_count_per_interface', kw_only=True, fn=None), ReprPlan.Field(name='m"
        "aximum_ena_queue_count', kw_only=True, fn=None), ReprPlan.Field(name='maximum_ena_queue_count_per_interface', "
        "kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='b3bdb620818515b71cb12c278f10b24b6b186a1d',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NetworkCardInfo'),
    ),
)
def _process_dataclass__b3bdb620818515b71cb12c278f10b24b6b186a1d():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                network_card_index=self.network_card_index,
                network_performance=self.network_performance,
                maximum_network_interfaces=self.maximum_network_interfaces,
                baseline_bandwidth_in_gbips=self.baseline_bandwidth_in_gbips,
                peak_bandwidth_in_gbips=self.peak_bandwidth_in_gbips,
                default_ena_queue_count_per_interface=self.default_ena_queue_count_per_interface,
                maximum_ena_queue_count=self.maximum_ena_queue_count,
                maximum_ena_queue_count_per_interface=self.maximum_ena_queue_count_per_interface,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.network_card_index == other.network_card_index and
                self.network_performance == other.network_performance and
                self.maximum_network_interfaces == other.maximum_network_interfaces and
                self.baseline_bandwidth_in_gbips == other.baseline_bandwidth_in_gbips and
                self.peak_bandwidth_in_gbips == other.peak_bandwidth_in_gbips and
                self.default_ena_queue_count_per_interface == other.default_ena_queue_count_per_interface and
                self.maximum_ena_queue_count == other.maximum_ena_queue_count and
                self.maximum_ena_queue_count_per_interface == other.maximum_ena_queue_count_per_interface
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'network_card_index',
            'network_performance',
            'maximum_network_interfaces',
            'baseline_bandwidth_in_gbips',
            'peak_bandwidth_in_gbips',
            'default_ena_queue_count_per_interface',
            'maximum_ena_queue_count',
            'maximum_ena_queue_count_per_interface',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'network_card_index',
            'network_performance',
            'maximum_network_interfaces',
            'baseline_bandwidth_in_gbips',
            'peak_bandwidth_in_gbips',
            'default_ena_queue_count_per_interface',
            'maximum_ena_queue_count',
            'maximum_ena_queue_count_per_interface',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.network_card_index,
                self.network_performance,
                self.maximum_network_interfaces,
                self.baseline_bandwidth_in_gbips,
                self.peak_bandwidth_in_gbips,
                self.default_ena_queue_count_per_interface,
                self.maximum_ena_queue_count,
                self.maximum_ena_queue_count_per_interface,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            network_card_index: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            network_performance: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            maximum_network_interfaces: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            baseline_bandwidth_in_gbips: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            peak_bandwidth_in_gbips: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            default_ena_queue_count_per_interface: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            maximum_ena_queue_count: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            maximum_ena_queue_count_per_interface: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'network_card_index', network_card_index)
            __dataclass__object_setattr(self, 'network_performance', network_performance)
            __dataclass__object_setattr(self, 'maximum_network_interfaces', maximum_network_interfaces)
            __dataclass__object_setattr(self, 'baseline_bandwidth_in_gbips', baseline_bandwidth_in_gbips)
            __dataclass__object_setattr(self, 'peak_bandwidth_in_gbips', peak_bandwidth_in_gbips)
            __dataclass__object_setattr(self, 'default_ena_queue_count_per_interface', default_ena_queue_count_per_interface)
            __dataclass__object_setattr(self, 'maximum_ena_queue_count', maximum_ena_queue_count)
            __dataclass__object_setattr(self, 'maximum_ena_queue_count_per_interface', maximum_ena_queue_count_per_interface)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"network_card_index={self.network_card_index!r}")
            parts.append(f"network_performance={self.network_performance!r}")
            parts.append(f"maximum_network_interfaces={self.maximum_network_interfaces!r}")
            parts.append(f"baseline_bandwidth_in_gbips={self.baseline_bandwidth_in_gbips!r}")
            parts.append(f"peak_bandwidth_in_gbips={self.peak_bandwidth_in_gbips!r}")
            parts.append(f"default_ena_queue_count_per_interface={self.default_ena_queue_count_per_interface!r}")
            parts.append(f"maximum_ena_queue_count={self.maximum_ena_queue_count!r}")
            parts.append(f"maximum_ena_queue_count_per_interface={self.maximum_ena_queue_count_per_interface!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('volume_name', 'allocated_storage', 'io_p_s', 'max_allocated_storage', 'storage_th"
        "roughput', 'storage_type')), EqPlan(fields=('volume_name', 'allocated_storage', 'io_p_s', 'max_allocated_stora"
        "ge', 'storage_throughput', 'storage_type')), FrozenPlan(fields=('__shape__', 'volume_name', 'allocated_storage"
        "', 'io_p_s', 'max_allocated_storage', 'storage_throughput', 'storage_type'), allow_dynamic_dunder_attrs=False)"
        ", HashPlan(action='add', fields=('volume_name', 'allocated_storage', 'io_p_s', 'max_allocated_storage', 'stora"
        "ge_throughput', 'storage_type'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=Op"
        "Ref(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='volume_name', annota"
        "tion=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='allocated_stor"
        "age', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='io_p_s', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='i"
        "nit.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='max_allocated_storage', annotation=OpRef(name='in"
        "it.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='st"
        "orage_throughput', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='storage_type', annotation=OpRef(name='init.fields.6.annotation'), de"
        "fault=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=("
        "'volume_name', 'allocated_storage', 'io_p_s', 'max_allocated_storage', 'storage_throughput', 'storage_type'), "
        "frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Fiel"
        "d(name='volume_name', kw_only=True, fn=None), ReprPlan.Field(name='allocated_storage', kw_only=True, fn=None),"
        " ReprPlan.Field(name='io_p_s', kw_only=True, fn=None), ReprPlan.Field(name='max_allocated_storage', kw_only=Tr"
        "ue, fn=None), ReprPlan.Field(name='storage_throughput', kw_only=True, fn=None), ReprPlan.Field(name='storage_t"
        "ype', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='b3d2bb68eb416c40051d4dcb36992bd90e305604',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'AdditionalStorageVolume'),
    ),
)
def _process_dataclass__b3d2bb68eb416c40051d4dcb36992bd90e305604():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                volume_name=self.volume_name,
                allocated_storage=self.allocated_storage,
                io_p_s=self.io_p_s,
                max_allocated_storage=self.max_allocated_storage,
                storage_throughput=self.storage_throughput,
                storage_type=self.storage_type,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.volume_name == other.volume_name and
                self.allocated_storage == other.allocated_storage and
                self.io_p_s == other.io_p_s and
                self.max_allocated_storage == other.max_allocated_storage and
                self.storage_throughput == other.storage_throughput and
                self.storage_type == other.storage_type
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'volume_name',
            'allocated_storage',
            'io_p_s',
            'max_allocated_storage',
            'storage_throughput',
            'storage_type',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'volume_name',
            'allocated_storage',
            'io_p_s',
            'max_allocated_storage',
            'storage_throughput',
            'storage_type',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.volume_name,
                self.allocated_storage,
                self.io_p_s,
                self.max_allocated_storage,
                self.storage_throughput,
                self.storage_type,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            volume_name: __dataclass__init__fields__1__annotation,
            allocated_storage: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            io_p_s: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            max_allocated_storage: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            storage_throughput: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            storage_type: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'volume_name', volume_name)
            __dataclass__object_setattr(self, 'allocated_storage', allocated_storage)
            __dataclass__object_setattr(self, 'io_p_s', io_p_s)
            __dataclass__object_setattr(self, 'max_allocated_storage', max_allocated_storage)
            __dataclass__object_setattr(self, 'storage_throughput', storage_throughput)
            __dataclass__object_setattr(self, 'storage_type', storage_type)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"volume_name={self.volume_name!r}")
            parts.append(f"allocated_storage={self.allocated_storage!r}")
            parts.append(f"io_p_s={self.io_p_s!r}")
            parts.append(f"max_allocated_storage={self.max_allocated_storage!r}")
            parts.append(f"storage_throughput={self.storage_throughput!r}")
            parts.append(f"storage_type={self.storage_type!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('role_arn', 'feature_name', 'status')), EqPlan(fields=('role_arn', 'feature_name',"
        " 'status')), FrozenPlan(fields=('__shape__', 'role_arn', 'feature_name', 'status'), allow_dynamic_dunder_attrs"
        "=False), HashPlan(action='add', fields=('role_arn', 'feature_name', 'status'), cache=False), InitPlan(fields=("
        "InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='role_arn', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='in"
        "it.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='feature_name', annotation=OpRef(name='init.fields."
        "2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='status', ann"
        "otation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), "
        "self_param='self', std_params=(), kw_only_params=('role_arn', 'feature_name', 'status'), frozen=True, slots=Fa"
        "lse, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='role_arn', kw"
        "_only=True, fn=None), ReprPlan.Field(name='feature_name', kw_only=True, fn=None), ReprPlan.Field(name='status'"
        ", kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='b3fadeb3592e8dc008bb27dac3148f342ce359b3',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'DBInstanceRole'),
    ),
)
def _process_dataclass__b3fadeb3592e8dc008bb27dac3148f342ce359b3():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                role_arn=self.role_arn,
                feature_name=self.feature_name,
                status=self.status,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.role_arn == other.role_arn and
                self.feature_name == other.feature_name and
                self.status == other.status
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'role_arn',
            'feature_name',
            'status',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'role_arn',
            'feature_name',
            'status',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.role_arn,
                self.feature_name,
                self.status,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            role_arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            feature_name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            status: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'role_arn', role_arn)
            __dataclass__object_setattr(self, 'feature_name', feature_name)
            __dataclass__object_setattr(self, 'status', status)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"role_arn={self.role_arn!r}")
            parts.append(f"feature_name={self.feature_name!r}")
            parts.append(f"status={self.status!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('fpgas', 'total_fpga_memory_in_mi_b')), EqPlan(fields=('fpgas', 'total_fpga_memory"
        "_in_mi_b')), FrozenPlan(fields=('__shape__', 'fpgas', 'total_fpga_memory_in_mi_b'), allow_dynamic_dunder_attrs"
        "=False), HashPlan(action='add', fields=('fpgas', 'total_fpga_memory_in_mi_b'), cache=False), InitPlan(fields=("
        "InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='fpgas', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init."
        "fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
        "e, validate=None, check_type=None), InitPlan.Field(name='total_fpga_memory_in_mi_b', annotation=OpRef(name='in"
        "it.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std"
        "_params=(), kw_only_params=('fpgas', 'total_fpga_memory_in_mi_b'), frozen=True, slots=False, post_init_params="
        "None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='fpgas', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='total_fpga_memory_in_mi_b', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)"
        "))"
    ),
    plan_repr_sha1='b47f98d2dfe23b3a2cf6a92d0f4c034225e81fae',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'FpgaInfo'),
    ),
)
def _process_dataclass__b47f98d2dfe23b3a2cf6a92d0f4c034225e81fae():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                fpgas=self.fpgas,
                total_fpga_memory_in_mi_b=self.total_fpga_memory_in_mi_b,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.fpgas == other.fpgas and
                self.total_fpga_memory_in_mi_b == other.total_fpga_memory_in_mi_b
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'fpgas',
            'total_fpga_memory_in_mi_b',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'fpgas',
            'total_fpga_memory_in_mi_b',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.fpgas,
                self.total_fpga_memory_in_mi_b,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            fpgas: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            total_fpga_memory_in_mi_b: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'fpgas', fpgas)
            __dataclass__object_setattr(self, 'total_fpga_memory_in_mi_b', total_fpga_memory_in_mi_b)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"fpgas={self.fpgas!r}")
            parts.append(f"total_fpga_memory_in_mi_b={self.total_fpga_memory_in_mi_b!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('accelerators', 'total_inference_memory_in_mi_b')), EqPlan(fields=('accelerators',"
        " 'total_inference_memory_in_mi_b')), FrozenPlan(fields=('__shape__', 'accelerators', 'total_inference_memory_i"
        "n_mi_b'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('accelerators', 'total_inference_m"
        "emory_in_mi_b'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.f"
        "ields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLAS"
        "S_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='accelerators', annotation=OpRef(name"
        "='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, ov"
        "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='total_inference_memory_in_mi_b', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init"
        ".fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('accelerators', 'total"
        "_inference_memory_in_mi_b'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), R"
        "eprPlan(fields=(ReprPlan.Field(name='accelerators', kw_only=True, fn=None), ReprPlan.Field(name='total_inferen"
        "ce_memory_in_mi_b', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='b6cdadd468d96d55e67c5c44dca06681ea9dd5f3',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InferenceAcceleratorInfo'),
    ),
)
def _process_dataclass__b6cdadd468d96d55e67c5c44dca06681ea9dd5f3():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                accelerators=self.accelerators,
                total_inference_memory_in_mi_b=self.total_inference_memory_in_mi_b,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.accelerators == other.accelerators and
                self.total_inference_memory_in_mi_b == other.total_inference_memory_in_mi_b
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'accelerators',
            'total_inference_memory_in_mi_b',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'accelerators',
            'total_inference_memory_in_mi_b',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.accelerators,
                self.total_inference_memory_in_mi_b,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            accelerators: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            total_inference_memory_in_mi_b: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'accelerators', accelerators)
            __dataclass__object_setattr(self, 'total_inference_memory_in_mi_b', total_inference_memory_in_mi_b)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"accelerators={self.accelerators!r}")
            parts.append(f"total_inference_memory_in_mi_b={self.total_inference_memory_in_mi_b!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('subnet_identifier', 'subnet_availability_zone', 'subnet_outpost', 'subnet_status'"
        ")), EqPlan(fields=('subnet_identifier', 'subnet_availability_zone', 'subnet_outpost', 'subnet_status')), Froze"
        "nPlan(fields=('__shape__', 'subnet_identifier', 'subnet_availability_zone', 'subnet_outpost', 'subnet_status')"
        ", allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('subnet_identifier', 'subnet_availability_"
        "zone', 'subnet_outpost', 'subnet_status'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', ann"
        "otation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False,"
        " field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnet_ide"
        "ntifier', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='subnet_availability_zone', annotation=OpRef(name='init.fields.2.annotation'),"
        " default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnet_outpost', annotation"
        "=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
        ".Field(name='subnet_status', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.field"
        "s.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
        "lidate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('subnet_identifier', 'subnet"
        "_availability_zone', 'subnet_outpost', 'subnet_status'), frozen=True, slots=False, post_init_params=None, init"
        "_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='subnet_identifier', kw_only=True, fn=None), R"
        "eprPlan.Field(name='subnet_availability_zone', kw_only=True, fn=None), ReprPlan.Field(name='subnet_outpost', k"
        "w_only=True, fn=None), ReprPlan.Field(name='subnet_status', kw_only=True, fn=None)), id=False, terse=False, de"
        "fault_fn=None)))"
    ),
    plan_repr_sha1='b82211610cc9a83bb833ac58c5308bb0733d9d00',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'Subnet'),
    ),
)
def _process_dataclass__b82211610cc9a83bb833ac58c5308bb0733d9d00():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                subnet_identifier=self.subnet_identifier,
                subnet_availability_zone=self.subnet_availability_zone,
                subnet_outpost=self.subnet_outpost,
                subnet_status=self.subnet_status,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.subnet_identifier == other.subnet_identifier and
                self.subnet_availability_zone == other.subnet_availability_zone and
                self.subnet_outpost == other.subnet_outpost and
                self.subnet_status == other.subnet_status
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'subnet_identifier',
            'subnet_availability_zone',
            'subnet_outpost',
            'subnet_status',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'subnet_identifier',
            'subnet_availability_zone',
            'subnet_outpost',
            'subnet_status',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.subnet_identifier,
                self.subnet_availability_zone,
                self.subnet_outpost,
                self.subnet_status,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            subnet_identifier: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            subnet_availability_zone: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            subnet_outpost: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            subnet_status: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'subnet_identifier', subnet_identifier)
            __dataclass__object_setattr(self, 'subnet_availability_zone', subnet_availability_zone)
            __dataclass__object_setattr(self, 'subnet_outpost', subnet_outpost)
            __dataclass__object_setattr(self, 'subnet_status', subnet_status)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"subnet_identifier={self.subnet_identifier!r}")
            parts.append(f"subnet_availability_zone={self.subnet_availability_zone!r}")
            parts.append(f"subnet_outpost={self.subnet_outpost!r}")
            parts.append(f"subnet_status={self.subnet_status!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('next_token', 'max_results', 'dry_run', 'network_interface_ids', 'filters')), EqPl"
        "an(fields=('next_token', 'max_results', 'dry_run', 'network_interface_ids', 'filters')), FrozenPlan(fields=('_"
        "_shape__', 'next_token', 'max_results', 'dry_run', 'network_interface_ids', 'filters'), allow_dynamic_dunder_a"
        "ttrs=False), HashPlan(action='add', fields=('next_token', 'max_results', 'dry_run', 'network_interface_ids', '"
        "filters'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields."
        "0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR,"
        " coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.f"
        "ields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=F"
        "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_re"
        "sults', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), defaul"
        "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
        "pe=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name"
        "='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='network_interface_ids', annotation=OpRef(name="
        "'init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
        "'filters', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), def"
        "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
        "_type=None)), self_param='self', std_params=(), kw_only_params=('next_token', 'max_results', 'dry_run', 'netwo"
        "rk_interface_ids', 'filters'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
        " ReprPlan(fields=(ReprPlan.Field(name='next_token', kw_only=True, fn=None), ReprPlan.Field(name='max_results',"
        " kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='network_i"
        "nterface_ids', kw_only=True, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn=None)), id=False, terse"
        "=False, default_fn=None)))"
    ),
    plan_repr_sha1='b91d9c5662c7bfe568a38413ef5d6e2c620d11b9',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeNetworkInterfacesRequest'),
    ),
)
def _process_dataclass__b91d9c5662c7bfe568a38413ef5d6e2c620d11b9():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                next_token=self.next_token,
                max_results=self.max_results,
                dry_run=self.dry_run,
                network_interface_ids=self.network_interface_ids,
                filters=self.filters,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.next_token == other.next_token and
                self.max_results == other.max_results and
                self.dry_run == other.dry_run and
                self.network_interface_ids == other.network_interface_ids and
                self.filters == other.filters
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'next_token',
            'max_results',
            'dry_run',
            'network_interface_ids',
            'filters',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'next_token',
            'max_results',
            'dry_run',
            'network_interface_ids',
            'filters',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.next_token,
                self.max_results,
                self.dry_run,
                self.network_interface_ids,
                self.filters,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            max_results: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            dry_run: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            network_interface_ids: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            filters: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'max_results', max_results)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'network_interface_ids', network_interface_ids)
            __dataclass__object_setattr(self, 'filters', filters)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"max_results={self.max_results!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"network_interface_ids={self.network_interface_ids!r}")
            parts.append(f"filters={self.filters!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('group_id', 'tags', 'security_group_arn')), EqPlan(fields=('group_id', 'tags', 'se"
        "curity_group_arn')), FrozenPlan(fields=('__shape__', 'group_id', 'tags', 'security_group_arn'), allow_dynamic_"
        "dunder_attrs=False), HashPlan(action='add', fields=('group_id', 'tags', 'security_group_arn'), cache=False), I"
        "nitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=No"
        "ne, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='group_id', annotation=OpRef(name='init.fields.1.annotation'), defaul"
        "t=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
        "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='init"
        ".fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override"
        "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='secu"
        "rity_group_arn', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None)), self_param='self', std_params=(), kw_only_params=('group_id', 'tags', 'security_group_arn'"
        "), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.F"
        "ield(name='group_id', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=True, fn=None), ReprPlan.Fie"
        "ld(name='security_group_arn', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='b95b4bb68c708e0fe14cdbbc23446dad9ba20de1',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CreateSecurityGroupResult'),
    ),
)
def _process_dataclass__b95b4bb68c708e0fe14cdbbc23446dad9ba20de1():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                group_id=self.group_id,
                tags=self.tags,
                security_group_arn=self.security_group_arn,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.group_id == other.group_id and
                self.tags == other.tags and
                self.security_group_arn == other.security_group_arn
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'group_id',
            'tags',
            'security_group_arn',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'group_id',
            'tags',
            'security_group_arn',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.group_id,
                self.tags,
                self.security_group_arn,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            group_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            tags: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            security_group_arn: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'group_id', group_id)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'security_group_arn', security_group_arn)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"group_id={self.group_id!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"security_group_arn={self.security_group_arn!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('size',)), EqPlan(fields=('size',)), FrozenPlan(fields=('__shape__', 'size'), allo"
        "w_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('size',), cache=False), InitPlan(fields=(InitPla"
        "n.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='size', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), se"
        "lf_param='self', std_params=(), kw_only_params=('size',), frozen=True, slots=False, post_init_params=None, ini"
        "t_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='size', kw_only=True, fn=None),), id=False, t"
        "erse=False, default_fn=None)))"
    ),
    plan_repr_sha1='ba17cf6d4b72f343a67190bab2265616e5cbaebc',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'EphemeralStorage'),
    ),
)
def _process_dataclass__ba17cf6d4b72f343a67190bab2265616e5cbaebc():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                size=self.size,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.size == other.size
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'size',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'size',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.size,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            size: __dataclass__init__fields__1__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'size', size)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"size={self.size!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('enabled',)), EqPlan(fields=('enabled',)), FrozenPlan(fields=('__shape__', 'enable"
        "d'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('enabled',), cache=False), InitPlan(fie"
        "lds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default"
        "_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_ty"
        "pe=None), InitPlan.Field(name='enabled', annotation=OpRef(name='init.fields.1.annotation'), default=None, defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None)), self_param='self', std_params=(), kw_only_params=('enabled',), frozen=True, slots=False, post_ini"
        "t_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='enabled', kw_only=True, fn"
        "=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='bb4476bedb74d1ffda10b96b3aa1736540de06a7',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'RunInstancesMonitoringEnabled'),
    ),
)
def _process_dataclass__bb4476bedb74d1ffda10b96b3aa1736540de06a7():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                enabled=self.enabled,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.enabled == other.enabled
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'enabled',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'enabled',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.enabled,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            enabled: __dataclass__init__fields__1__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'enabled', enabled)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"enabled={self.enabled!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('market_type', 'spot_options')), EqPlan(fields=('market_type', 'spot_options')), F"
        "rozenPlan(fields=('__shape__', 'market_type', 'spot_options'), allow_dynamic_dunder_attrs=False), HashPlan(act"
        "ion='add', fields=('market_type', 'spot_options'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape"
        "__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ma"
        "rket_type', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
        "k_type=None), InitPlan.Field(name='spot_options', annotation=OpRef(name='init.fields.2.annotation'), default=O"
        "pRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('market"
        "_type', 'spot_options'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
        "lan(fields=(ReprPlan.Field(name='market_type', kw_only=True, fn=None), ReprPlan.Field(name='spot_options', kw_"
        "only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='bd26d720ea503182d9d997ea2d4ffcd48eb89f62',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceMarketOptionsRequest'),
    ),
)
def _process_dataclass__bd26d720ea503182d9d997ea2d4ffcd48eb89f62():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                market_type=self.market_type,
                spot_options=self.spot_options,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.market_type == other.market_type and
                self.spot_options == other.spot_options
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'market_type',
            'spot_options',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'market_type',
            'spot_options',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.market_type,
                self.spot_options,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            market_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            spot_options: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'market_type', market_type)
            __dataclass__object_setattr(self, 'spot_options', spot_options)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"market_type={self.market_type!r}")
            parts.append(f"spot_options={self.spot_options!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('bucket', 'key', 'mfa', 'version_id', 'request_payer', 'bypass_governance_retentio"
        "n', 'expected_bucket_owner', 'if_match', 'if_match_last_modified_time', 'if_match_size')), EqPlan(fields=('buc"
        "ket', 'key', 'mfa', 'version_id', 'request_payer', 'bypass_governance_retention', 'expected_bucket_owner', 'if"
        "_match', 'if_match_last_modified_time', 'if_match_size')), FrozenPlan(fields=('__shape__', 'bucket', 'key', 'm"
        "fa', 'version_id', 'request_payer', 'bypass_governance_retention', 'expected_bucket_owner', 'if_match', 'if_ma"
        "tch_last_modified_time', 'if_match_size'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('"
        "bucket', 'key', 'mfa', 'version_id', 'request_payer', 'bypass_governance_retention', 'expected_bucket_owner', "
        "'if_match', 'if_match_last_modified_time', 'if_match_size'), cache=False), InitPlan(fields=(InitPlan.Field(nam"
        "e='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='bucket', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
        "ld(name='key', annotation=OpRef(name='init.fields.2.annotation'), default=None, default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='mfa', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), d"
        "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='version_id', annotation=OpRef(name='init.fields.4.annotation'), default=Op"
        "Ref(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
        "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='request_payer', annotation=OpRef(name="
        "'init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
        "'bypass_governance_retention', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fie"
        "lds.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='expected_bucket_owner', annotation=OpRef(name='init.fiel"
        "ds.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='if_match'"
        ", annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='if_match_last_modified_time', annotation=OpRef(name='init.fields.9.annotation'), defa"
        "ult=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='if_match_size', annotation=OpRef"
        "(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param="
        "'self', std_params=(), kw_only_params=('bucket', 'key', 'mfa', 'version_id', 'request_payer', 'bypass_governan"
        "ce_retention', 'expected_bucket_owner', 'if_match', 'if_match_last_modified_time', 'if_match_size'), frozen=Tr"
        "ue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='b"
        "ucket', kw_only=True, fn=None), ReprPlan.Field(name='key', kw_only=True, fn=None), ReprPlan.Field(name='mfa', "
        "kw_only=True, fn=None), ReprPlan.Field(name='version_id', kw_only=True, fn=None), ReprPlan.Field(name='request"
        "_payer', kw_only=True, fn=None), ReprPlan.Field(name='bypass_governance_retention', kw_only=True, fn=None), Re"
        "prPlan.Field(name='expected_bucket_owner', kw_only=True, fn=None), ReprPlan.Field(name='if_match', kw_only=Tru"
        "e, fn=None), ReprPlan.Field(name='if_match_last_modified_time', kw_only=True, fn=None), ReprPlan.Field(name='i"
        "f_match_size', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='bd390e7b31997c27ea5409e88251dc81fe0c3a03',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.s3', 'DeleteObjectRequest'),
    ),
)
def _process_dataclass__bd390e7b31997c27ea5409e88251dc81fe0c3a03():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                bucket=self.bucket,
                key=self.key,
                mfa=self.mfa,
                version_id=self.version_id,
                request_payer=self.request_payer,
                bypass_governance_retention=self.bypass_governance_retention,
                expected_bucket_owner=self.expected_bucket_owner,
                if_match=self.if_match,
                if_match_last_modified_time=self.if_match_last_modified_time,
                if_match_size=self.if_match_size,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.bucket == other.bucket and
                self.key == other.key and
                self.mfa == other.mfa and
                self.version_id == other.version_id and
                self.request_payer == other.request_payer and
                self.bypass_governance_retention == other.bypass_governance_retention and
                self.expected_bucket_owner == other.expected_bucket_owner and
                self.if_match == other.if_match and
                self.if_match_last_modified_time == other.if_match_last_modified_time and
                self.if_match_size == other.if_match_size
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'bucket',
            'key',
            'mfa',
            'version_id',
            'request_payer',
            'bypass_governance_retention',
            'expected_bucket_owner',
            'if_match',
            'if_match_last_modified_time',
            'if_match_size',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'bucket',
            'key',
            'mfa',
            'version_id',
            'request_payer',
            'bypass_governance_retention',
            'expected_bucket_owner',
            'if_match',
            'if_match_last_modified_time',
            'if_match_size',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.bucket,
                self.key,
                self.mfa,
                self.version_id,
                self.request_payer,
                self.bypass_governance_retention,
                self.expected_bucket_owner,
                self.if_match,
                self.if_match_last_modified_time,
                self.if_match_size,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            bucket: __dataclass__init__fields__1__annotation,
            key: __dataclass__init__fields__2__annotation,
            mfa: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            version_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            request_payer: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            bypass_governance_retention: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            expected_bucket_owner: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            if_match: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            if_match_last_modified_time: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            if_match_size: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'bucket', bucket)
            __dataclass__object_setattr(self, 'key', key)
            __dataclass__object_setattr(self, 'mfa', mfa)
            __dataclass__object_setattr(self, 'version_id', version_id)
            __dataclass__object_setattr(self, 'request_payer', request_payer)
            __dataclass__object_setattr(self, 'bypass_governance_retention', bypass_governance_retention)
            __dataclass__object_setattr(self, 'expected_bucket_owner', expected_bucket_owner)
            __dataclass__object_setattr(self, 'if_match', if_match)
            __dataclass__object_setattr(self, 'if_match_last_modified_time', if_match_last_modified_time)
            __dataclass__object_setattr(self, 'if_match_size', if_match_size)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"bucket={self.bucket!r}")
            parts.append(f"key={self.key!r}")
            parts.append(f"mfa={self.mfa!r}")
            parts.append(f"version_id={self.version_id!r}")
            parts.append(f"request_payer={self.request_payer!r}")
            parts.append(f"bypass_governance_retention={self.bypass_governance_retention!r}")
            parts.append(f"expected_bucket_owner={self.expected_bucket_owner!r}")
            parts.append(f"if_match={self.if_match!r}")
            parts.append(f"if_match_last_modified_time={self.if_match_last_modified_time!r}")
            parts.append(f"if_match_size={self.if_match_size!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('supported_architectures', 'sustained_clock_speed_in_ghz', 'supported_features', '"
        "manufacturer')), EqPlan(fields=('supported_architectures', 'sustained_clock_speed_in_ghz', 'supported_features"
        "', 'manufacturer')), FrozenPlan(fields=('__shape__', 'supported_architectures', 'sustained_clock_speed_in_ghz'"
        ", 'supported_features', 'manufacturer'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('su"
        "pported_architectures', 'sustained_clock_speed_in_ghz', 'supported_features', 'manufacturer'), cache=False), I"
        "nitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=No"
        "ne, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='supported_architectures', annotation=OpRef(name='init.fields.1.annot"
        "ation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='sustained_clock_spe"
        "ed_in_ghz', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
        "k_type=None), InitPlan.Field(name='supported_features', annotation=OpRef(name='init.fields.3.annotation'), def"
        "ault=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='manufacturer', annotation=OpRef"
        "(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='s"
        "elf', std_params=(), kw_only_params=('supported_architectures', 'sustained_clock_speed_in_ghz', 'supported_fea"
        "tures', 'manufacturer'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
        "lan(fields=(ReprPlan.Field(name='supported_architectures', kw_only=True, fn=None), ReprPlan.Field(name='sustai"
        "ned_clock_speed_in_ghz', kw_only=True, fn=None), ReprPlan.Field(name='supported_features', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='manufacturer', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='bdbd9e5b5f43b4f9e7c788b19f3b006c841abc0e',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'ProcessorInfo'),
    ),
)
def _process_dataclass__bdbd9e5b5f43b4f9e7c788b19f3b006c841abc0e():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                supported_architectures=self.supported_architectures,
                sustained_clock_speed_in_ghz=self.sustained_clock_speed_in_ghz,
                supported_features=self.supported_features,
                manufacturer=self.manufacturer,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.supported_architectures == other.supported_architectures and
                self.sustained_clock_speed_in_ghz == other.sustained_clock_speed_in_ghz and
                self.supported_features == other.supported_features and
                self.manufacturer == other.manufacturer
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'supported_architectures',
            'sustained_clock_speed_in_ghz',
            'supported_features',
            'manufacturer',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'supported_architectures',
            'sustained_clock_speed_in_ghz',
            'supported_features',
            'manufacturer',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.supported_architectures,
                self.sustained_clock_speed_in_ghz,
                self.supported_features,
                self.manufacturer,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            supported_architectures: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            sustained_clock_speed_in_ghz: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            supported_features: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            manufacturer: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'supported_architectures', supported_architectures)
            __dataclass__object_setattr(self, 'sustained_clock_speed_in_ghz', sustained_clock_speed_in_ghz)
            __dataclass__object_setattr(self, 'supported_features', supported_features)
            __dataclass__object_setattr(self, 'manufacturer', manufacturer)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"supported_architectures={self.supported_architectures!r}")
            parts.append(f"sustained_clock_speed_in_ghz={self.sustained_clock_speed_in_ghz!r}")
            parts.append(f"supported_features={self.supported_features!r}")
            parts.append(f"manufacturer={self.manufacturer!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('group_id', 'group_name')), EqPlan(fields=('group_id', 'group_name')), FrozenPlan("
        "fields=('__shape__', 'group_id', 'group_name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fiel"
        "ds=('group_id', 'group_name'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRe"
        "f(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type="
        "FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_id', annotation="
        "OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='group_name', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('group_id', 'group_name'), froze"
        "n=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
        "e='group_id', kw_only=True, fn=None), ReprPlan.Field(name='group_name', kw_only=True, fn=None)), id=False, ter"
        "se=False, default_fn=None)))"
    ),
    plan_repr_sha1='be5230305c7479cce885630743068b6dd28216ec',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'GroupIdentifier'),
    ),
)
def _process_dataclass__be5230305c7479cce885630743068b6dd28216ec():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                group_id=self.group_id,
                group_name=self.group_name,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.group_id == other.group_id and
                self.group_name == other.group_name
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'group_id',
            'group_name',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'group_id',
            'group_name',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.group_id,
                self.group_name,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            group_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            group_name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'group_id', group_id)
            __dataclass__object_setattr(self, 'group_name', group_name)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"group_id={self.group_id!r}")
            parts.append(f"group_name={self.group_name!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('enabled',)), EqPlan(fields=('enabled',)), FrozenPlan(fields=('__shape__', 'enable"
        "d'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('enabled',), cache=False), InitPlan(fie"
        "lds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default"
        "_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_ty"
        "pe=None), InitPlan.Field(name='enabled', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name"
        "='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('enabled',), fro"
        "zen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(n"
        "ame='enabled', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='bf29f91bc455fecb2ff96fc4818097e80745770c',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'EnclaveOptions'),
        ('ominfra.clouds.aws.models.services.ec2', 'EnclaveOptionsRequest'),
    ),
)
def _process_dataclass__bf29f91bc455fecb2ff96fc4818097e80745770c():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                enabled=self.enabled,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.enabled == other.enabled
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'enabled',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'enabled',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.enabled,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            enabled: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'enabled', enabled)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"enabled={self.enabled!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('configured',)), EqPlan(fields=('configured',)), FrozenPlan(fields=('__shape__', '"
        "configured'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('configured',), cache=False), "
        "InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=N"
        "one, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='configured', annotation=OpRef(name='init.fields.1.annotation'), def"
        "ault=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('"
        "configured',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields"
        "=(ReprPlan.Field(name='configured', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='bfb29a4d3541281cf2ad9adb1c9aa94bee08ff4d',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'HibernationOptions'),
        ('ominfra.clouds.aws.models.services.ec2', 'HibernationOptionsRequest'),
    ),
)
def _process_dataclass__bfb29a4d3541281cf2ad9adb1c9aa94bee08ff4d():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                configured=self.configured,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.configured == other.configured
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'configured',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'configured',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.configured,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            configured: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'configured', configured)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"configured={self.configured!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('attach_time', 'attachment_id', 'delete_on_termination', 'device_index', 'network_"
        "card_index', 'instance_id', 'instance_owner_id', 'status', 'ena_srd_specification', 'ena_queue_count')), EqPla"
        "n(fields=('attach_time', 'attachment_id', 'delete_on_termination', 'device_index', 'network_card_index', 'inst"
        "ance_id', 'instance_owner_id', 'status', 'ena_srd_specification', 'ena_queue_count')), FrozenPlan(fields=('__s"
        "hape__', 'attach_time', 'attachment_id', 'delete_on_termination', 'device_index', 'network_card_index', 'insta"
        "nce_id', 'instance_owner_id', 'status', 'ena_srd_specification', 'ena_queue_count'), allow_dynamic_dunder_attr"
        "s=False), HashPlan(action='add', fields=('attach_time', 'attachment_id', 'delete_on_termination', 'device_inde"
        "x', 'network_card_index', 'instance_id', 'instance_owner_id', 'status', 'ena_srd_specification', 'ena_queue_co"
        "unt'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.an"
        "notation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='attach_time', annotation=OpRef(name='init.fiel"
        "ds.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='attachmen"
        "t_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default"
        "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='delete_on_termination', annotation=OpRef(name='init.fields.3.annotation'), defau"
        "lt=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType."
        "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='device_index', annotation=OpRef(n"
        "ame='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='network_card_index', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None), InitPlan.Field(name='instance_id', annotation=OpRef(name='init.fields.6.annotation"
        "'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=F"
        "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_owner_id', anno"
        "tation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='status', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields"
        ".8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='ena_srd_specification', annotation=OpRef(name='init.fields."
        "9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_queue_co"
        "unt', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), defaul"
        "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
        "pe=None)), self_param='self', std_params=(), kw_only_params=('attach_time', 'attachment_id', 'delete_on_termin"
        "ation', 'device_index', 'network_card_index', 'instance_id', 'instance_owner_id', 'status', 'ena_srd_specifica"
        "tion', 'ena_queue_count'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Rep"
        "rPlan(fields=(ReprPlan.Field(name='attach_time', kw_only=True, fn=None), ReprPlan.Field(name='attachment_id', "
        "kw_only=True, fn=None), ReprPlan.Field(name='delete_on_termination', kw_only=True, fn=None), ReprPlan.Field(na"
        "me='device_index', kw_only=True, fn=None), ReprPlan.Field(name='network_card_index', kw_only=True, fn=None), R"
        "eprPlan.Field(name='instance_id', kw_only=True, fn=None), ReprPlan.Field(name='instance_owner_id', kw_only=Tru"
        "e, fn=None), ReprPlan.Field(name='status', kw_only=True, fn=None), ReprPlan.Field(name='ena_srd_specification'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='ena_queue_count', kw_only=True, fn=None)), id=False, terse=Fals"
        "e, default_fn=None)))"
    ),
    plan_repr_sha1='c062d3ee4ff14428774ed2e1093da14147ac2647',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NetworkInterfaceAttachment'),
    ),
)
def _process_dataclass__c062d3ee4ff14428774ed2e1093da14147ac2647():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                attach_time=self.attach_time,
                attachment_id=self.attachment_id,
                delete_on_termination=self.delete_on_termination,
                device_index=self.device_index,
                network_card_index=self.network_card_index,
                instance_id=self.instance_id,
                instance_owner_id=self.instance_owner_id,
                status=self.status,
                ena_srd_specification=self.ena_srd_specification,
                ena_queue_count=self.ena_queue_count,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.attach_time == other.attach_time and
                self.attachment_id == other.attachment_id and
                self.delete_on_termination == other.delete_on_termination and
                self.device_index == other.device_index and
                self.network_card_index == other.network_card_index and
                self.instance_id == other.instance_id and
                self.instance_owner_id == other.instance_owner_id and
                self.status == other.status and
                self.ena_srd_specification == other.ena_srd_specification and
                self.ena_queue_count == other.ena_queue_count
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'attach_time',
            'attachment_id',
            'delete_on_termination',
            'device_index',
            'network_card_index',
            'instance_id',
            'instance_owner_id',
            'status',
            'ena_srd_specification',
            'ena_queue_count',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'attach_time',
            'attachment_id',
            'delete_on_termination',
            'device_index',
            'network_card_index',
            'instance_id',
            'instance_owner_id',
            'status',
            'ena_srd_specification',
            'ena_queue_count',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.attach_time,
                self.attachment_id,
                self.delete_on_termination,
                self.device_index,
                self.network_card_index,
                self.instance_id,
                self.instance_owner_id,
                self.status,
                self.ena_srd_specification,
                self.ena_queue_count,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            attach_time: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            attachment_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            delete_on_termination: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            device_index: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            network_card_index: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            instance_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            instance_owner_id: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            status: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            ena_srd_specification: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            ena_queue_count: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'attach_time', attach_time)
            __dataclass__object_setattr(self, 'attachment_id', attachment_id)
            __dataclass__object_setattr(self, 'delete_on_termination', delete_on_termination)
            __dataclass__object_setattr(self, 'device_index', device_index)
            __dataclass__object_setattr(self, 'network_card_index', network_card_index)
            __dataclass__object_setattr(self, 'instance_id', instance_id)
            __dataclass__object_setattr(self, 'instance_owner_id', instance_owner_id)
            __dataclass__object_setattr(self, 'status', status)
            __dataclass__object_setattr(self, 'ena_srd_specification', ena_srd_specification)
            __dataclass__object_setattr(self, 'ena_queue_count', ena_queue_count)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"attach_time={self.attach_time!r}")
            parts.append(f"attachment_id={self.attachment_id!r}")
            parts.append(f"delete_on_termination={self.delete_on_termination!r}")
            parts.append(f"device_index={self.device_index!r}")
            parts.append(f"network_card_index={self.network_card_index!r}")
            parts.append(f"instance_id={self.instance_id!r}")
            parts.append(f"instance_owner_id={self.instance_owner_id!r}")
            parts.append(f"status={self.status!r}")
            parts.append(f"ena_srd_specification={self.ena_srd_specification!r}")
            parts.append(f"ena_queue_count={self.ena_queue_count!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('name',)), EqPlan(fields=('name',)), FrozenPlan(fields=('__shape__', 'name'), allo"
        "w_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name',), cache=False), InitPlan(fields=(InitPla"
        "n.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('name',), frozen=True, slots=Fa"
        "lse, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_onl"
        "y=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='c34f3093a6550242a3325f4944a4df47a9b48420',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'AvailabilityZone'),
    ),
)
def _process_dataclass__c34f3093a6550242a3325f4944a4df47a9b48420():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                name=self.name,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.name == other.name
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'name',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'name',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.name,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'name', name)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"name={self.name!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('instance_ids', 'hibernate', 'skip_os_shutdown', 'dry_run', 'force')), EqPlan(fiel"
        "ds=('instance_ids', 'hibernate', 'skip_os_shutdown', 'dry_run', 'force')), FrozenPlan(fields=('__shape__', 'in"
        "stance_ids', 'hibernate', 'skip_os_shutdown', 'dry_run', 'force'), allow_dynamic_dunder_attrs=False), HashPlan"
        "(action='add', fields=('instance_ids', 'hibernate', 'skip_os_shutdown', 'dry_run', 'force'), cache=False), Ini"
        "tPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None"
        ", default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='instance_ids', annotation=OpRef(name='init.fields.1.annotation'), defa"
        "ult=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='hibernate', annotation=OpRef(name='init.fields.2.annotation'), "
        "default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='skip_os_shutdown', annotatio"
        "n=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='dry_run', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='force', annotation=OpRef(name='init.fields.5.annotation'), defa"
        "ult=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('i"
        "nstance_ids', 'hibernate', 'skip_os_shutdown', 'dry_run', 'force'), frozen=True, slots=False, post_init_params"
        "=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='instance_ids', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='hibernate', kw_only=True, fn=None), ReprPlan.Field(name='skip_os_shutdown', kw_only="
        "True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='force', kw_only=Tr"
        "ue, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='c3adac5db74dbc3a32afc8eb06cfdde4e0d7df27',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'StopInstancesRequest'),
    ),
)
def _process_dataclass__c3adac5db74dbc3a32afc8eb06cfdde4e0d7df27():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                instance_ids=self.instance_ids,
                hibernate=self.hibernate,
                skip_os_shutdown=self.skip_os_shutdown,
                dry_run=self.dry_run,
                force=self.force,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.instance_ids == other.instance_ids and
                self.hibernate == other.hibernate and
                self.skip_os_shutdown == other.skip_os_shutdown and
                self.dry_run == other.dry_run and
                self.force == other.force
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'hibernate',
            'skip_os_shutdown',
            'dry_run',
            'force',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'hibernate',
            'skip_os_shutdown',
            'dry_run',
            'force',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.instance_ids,
                self.hibernate,
                self.skip_os_shutdown,
                self.dry_run,
                self.force,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            instance_ids: __dataclass__init__fields__1__annotation,
            hibernate: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            skip_os_shutdown: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            dry_run: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            force: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'instance_ids', instance_ids)
            __dataclass__object_setattr(self, 'hibernate', hibernate)
            __dataclass__object_setattr(self, 'skip_os_shutdown', skip_os_shutdown)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'force', force)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"instance_ids={self.instance_ids!r}")
            parts.append(f"hibernate={self.hibernate!r}")
            parts.append(f"skip_os_shutdown={self.skip_os_shutdown!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"force={self.force!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('instance_ids', 'dry_run')), EqPlan(fields=('instance_ids', 'dry_run')), FrozenPla"
        "n(fields=('__shape__', 'instance_ids', 'dry_run'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', f"
        "ields=('instance_ids', 'dry_run'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation="
        "OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_ids', ann"
        "otation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', a"
        "nnotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory"
        "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None))"
        ", self_param='self', std_params=(), kw_only_params=('instance_ids', 'dry_run'), frozen=True, slots=False, post"
        "_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='instance_ids', kw_only"
        "=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None)), id=False, terse=False, default_fn=Non"
        "e)))"
    ),
    plan_repr_sha1='c569820b05e8694651bb4d8885a11d68f50dc213',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'RebootInstancesRequest'),
    ),
)
def _process_dataclass__c569820b05e8694651bb4d8885a11d68f50dc213():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                instance_ids=self.instance_ids,
                dry_run=self.dry_run,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.instance_ids == other.instance_ids and
                self.dry_run == other.dry_run
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'dry_run',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'dry_run',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.instance_ids,
                self.dry_run,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            instance_ids: __dataclass__init__fields__1__annotation,
            dry_run: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'instance_ids', instance_ids)
            __dataclass__object_setattr(self, 'dry_run', dry_run)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"instance_ids={self.instance_ids!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('association', 'attachment', 'availability_zone', 'connection_tracking_configurati"
        "on', 'description', 'groups', 'interface_type', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'outp"
        "ost_arn', 'owner_id', 'private_dns_name', 'public_dns_name', 'public_ip_dns_name_options', 'private_ip_address"
        "', 'private_ip_addresses', 'ipv4_prefixes', 'ipv6_prefixes', 'requester_id', 'requester_managed', 'source_dest"
        "_check', 'status', 'subnet_id', 'tag_set', 'vpc_id', 'deny_all_igw_traffic', 'ipv6_native', 'ipv6_address', 'o"
        "perator', 'associated_subnets', 'availability_zone_id')), EqPlan(fields=('association', 'attachment', 'availab"
        "ility_zone', 'connection_tracking_configuration', 'description', 'groups', 'interface_type', 'ipv6_addresses',"
        " 'mac_address', 'network_interface_id', 'outpost_arn', 'owner_id', 'private_dns_name', 'public_dns_name', 'pub"
        "lic_ip_dns_name_options', 'private_ip_address', 'private_ip_addresses', 'ipv4_prefixes', 'ipv6_prefixes', 'req"
        "uester_id', 'requester_managed', 'source_dest_check', 'status', 'subnet_id', 'tag_set', 'vpc_id', 'deny_all_ig"
        "w_traffic', 'ipv6_native', 'ipv6_address', 'operator', 'associated_subnets', 'availability_zone_id')), FrozenP"
        "lan(fields=('__shape__', 'association', 'attachment', 'availability_zone', 'connection_tracking_configuration'"
        ", 'description', 'groups', 'interface_type', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'outpost"
        "_arn', 'owner_id', 'private_dns_name', 'public_dns_name', 'public_ip_dns_name_options', 'private_ip_address', "
        "'private_ip_addresses', 'ipv4_prefixes', 'ipv6_prefixes', 'requester_id', 'requester_managed', 'source_dest_ch"
        "eck', 'status', 'subnet_id', 'tag_set', 'vpc_id', 'deny_all_igw_traffic', 'ipv6_native', 'ipv6_address', 'oper"
        "ator', 'associated_subnets', 'availability_zone_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add'"
        ", fields=('association', 'attachment', 'availability_zone', 'connection_tracking_configuration', 'description'"
        ", 'groups', 'interface_type', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'outpost_arn', 'owner_i"
        "d', 'private_dns_name', 'public_dns_name', 'public_ip_dns_name_options', 'private_ip_address', 'private_ip_add"
        "resses', 'ipv4_prefixes', 'ipv6_prefixes', 'requester_id', 'requester_managed', 'source_dest_check', 'status',"
        " 'subnet_id', 'tag_set', 'vpc_id', 'deny_all_igw_traffic', 'ipv6_native', 'ipv6_address', 'operator', 'associa"
        "ted_subnets', 'availability_zone_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotat"
        "ion=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='association', "
        "annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='attachment', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='ini"
        "t.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
        "one, validate=None, check_type=None), InitPlan.Field(name='availability_zone', annotation=OpRef(name='init.fie"
        "lds.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='connecti"
        "on_tracking_configuration', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields"
        ".4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='description', annotation=OpRef(name='init.fields.5.annotati"
        "on'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type"
        "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='groups', annotation=Op"
        "Ref(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init="
        "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
        "eld(name='interface_type', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields."
        "7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='ipv6_addresses', annotation=OpRef(name='init.fields.8.annota"
        "tion'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='mac_address', annota"
        "tion=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='network_interface_id', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name"
        "='init.fields.10.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='outpost_arn', annotation=OpRef(name='init.fie"
        "lds.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=F"
        "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='owner_"
        "id', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default"
        "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='private_dns_name', annotation=OpRef(name='init.fields.13.annotation'), default=O"
        "pRef(name='init.fields.13.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_dns_name', annotation=OpRef(n"
        "ame='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='public_ip_dns_name_options', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='in"
        "it.fields.15.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='private_ip_address', annotation=OpRef(name='init."
        "fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='pri"
        "vate_ip_addresses', annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.def"
        "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
        "None, check_type=None), InitPlan.Field(name='ipv4_prefixes', annotation=OpRef(name='init.fields.18.annotation'"
        "), default=OpRef(name='init.fields.18.default'), default_factory=None, init=True, override=False, field_type=F"
        "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_prefixes', annotati"
        "on=OpRef(name='init.fields.19.annotation'), default=OpRef(name='init.fields.19.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='requester_id', annotation=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.f"
        "ields.20.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
        "e, validate=None, check_type=None), InitPlan.Field(name='requester_managed', annotation=OpRef(name='init.field"
        "s.21.annotation'), default=OpRef(name='init.fields.21.default'), default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='source_d"
        "est_check', annotation=OpRef(name='init.fields.22.annotation'), default=OpRef(name='init.fields.22.default'), "
        "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
        "eck_type=None), InitPlan.Field(name='status', annotation=OpRef(name='init.fields.23.annotation'), default=OpRe"
        "f(name='init.fields.23.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnet_id', annotation=OpRef(name='init"
        ".fields.24.annotation'), default=OpRef(name='init.fields.24.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ta"
        "g_set', annotation=OpRef(name='init.fields.25.annotation'), default=OpRef(name='init.fields.25.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.26.annotation'), default=OpRef(na"
        "me='init.fields.26.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
        "coerce=None, validate=None, check_type=None), InitPlan.Field(name='deny_all_igw_traffic', annotation=OpRef(nam"
        "e='init.fields.27.annotation'), default=OpRef(name='init.fields.27.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='ipv6_native', annotation=OpRef(name='init.fields.28.annotation'), default=OpRef(name='init.fields.28.defa"
        "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
        "one, check_type=None), InitPlan.Field(name='ipv6_address', annotation=OpRef(name='init.fields.29.annotation'),"
        " default=OpRef(name='init.fields.29.default'), default_factory=None, init=True, override=False, field_type=Fie"
        "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='operator', annotation=OpRe"
        "f(name='init.fields.30.annotation'), default=OpRef(name='init.fields.30.default'), default_factory=None, init="
        "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
        "eld(name='associated_subnets', annotation=OpRef(name='init.fields.31.annotation'), default=OpRef(name='init.fi"
        "elds.31.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='availability_zone_id', annotation=OpRef(name='init.fie"
        "lds.32.annotation'), default=OpRef(name='init.fields.32.default'), default_factory=None, init=True, override=F"
        "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_par"
        "ams=(), kw_only_params=('association', 'attachment', 'availability_zone', 'connection_tracking_configuration',"
        " 'description', 'groups', 'interface_type', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'outpost_"
        "arn', 'owner_id', 'private_dns_name', 'public_dns_name', 'public_ip_dns_name_options', 'private_ip_address', '"
        "private_ip_addresses', 'ipv4_prefixes', 'ipv6_prefixes', 'requester_id', 'requester_managed', 'source_dest_che"
        "ck', 'status', 'subnet_id', 'tag_set', 'vpc_id', 'deny_all_igw_traffic', 'ipv6_native', 'ipv6_address', 'opera"
        "tor', 'associated_subnets', 'availability_zone_id'), frozen=True, slots=False, post_init_params=None, init_fns"
        "=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='association', kw_only=True, fn=None), ReprPlan.Fi"
        "eld(name='attachment', kw_only=True, fn=None), ReprPlan.Field(name='availability_zone', kw_only=True, fn=None)"
        ", ReprPlan.Field(name='connection_tracking_configuration', kw_only=True, fn=None), ReprPlan.Field(name='descri"
        "ption', kw_only=True, fn=None), ReprPlan.Field(name='groups', kw_only=True, fn=None), ReprPlan.Field(name='int"
        "erface_type', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_addresses', kw_only=True, fn=None), ReprPlan.F"
        "ield(name='mac_address', kw_only=True, fn=None), ReprPlan.Field(name='network_interface_id', kw_only=True, fn="
        "None), ReprPlan.Field(name='outpost_arn', kw_only=True, fn=None), ReprPlan.Field(name='owner_id', kw_only=True"
        ", fn=None), ReprPlan.Field(name='private_dns_name', kw_only=True, fn=None), ReprPlan.Field(name='public_dns_na"
        "me', kw_only=True, fn=None), ReprPlan.Field(name='public_ip_dns_name_options', kw_only=True, fn=None), ReprPla"
        "n.Field(name='private_ip_address', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_addresses', kw_only"
        "=True, fn=None), ReprPlan.Field(name='ipv4_prefixes', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_prefix"
        "es', kw_only=True, fn=None), ReprPlan.Field(name='requester_id', kw_only=True, fn=None), ReprPlan.Field(name='"
        "requester_managed', kw_only=True, fn=None), ReprPlan.Field(name='source_dest_check', kw_only=True, fn=None), R"
        "eprPlan.Field(name='status', kw_only=True, fn=None), ReprPlan.Field(name='subnet_id', kw_only=True, fn=None), "
        "ReprPlan.Field(name='tag_set', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), R"
        "eprPlan.Field(name='deny_all_igw_traffic', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_native', kw_only="
        "True, fn=None), ReprPlan.Field(name='ipv6_address', kw_only=True, fn=None), ReprPlan.Field(name='operator', kw"
        "_only=True, fn=None), ReprPlan.Field(name='associated_subnets', kw_only=True, fn=None), ReprPlan.Field(name='a"
        "vailability_zone_id', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='c56cd673ae581949b4aded8799612b0330bd060b',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__24__annotation',
        '__dataclass__init__fields__24__default',
        '__dataclass__init__fields__25__annotation',
        '__dataclass__init__fields__25__default',
        '__dataclass__init__fields__26__annotation',
        '__dataclass__init__fields__26__default',
        '__dataclass__init__fields__27__annotation',
        '__dataclass__init__fields__27__default',
        '__dataclass__init__fields__28__annotation',
        '__dataclass__init__fields__28__default',
        '__dataclass__init__fields__29__annotation',
        '__dataclass__init__fields__29__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__30__annotation',
        '__dataclass__init__fields__30__default',
        '__dataclass__init__fields__31__annotation',
        '__dataclass__init__fields__31__default',
        '__dataclass__init__fields__32__annotation',
        '__dataclass__init__fields__32__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NetworkInterface'),
    ),
)
def _process_dataclass__c56cd673ae581949b4aded8799612b0330bd060b():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__24__annotation,
        __dataclass__init__fields__24__default,
        __dataclass__init__fields__25__annotation,
        __dataclass__init__fields__25__default,
        __dataclass__init__fields__26__annotation,
        __dataclass__init__fields__26__default,
        __dataclass__init__fields__27__annotation,
        __dataclass__init__fields__27__default,
        __dataclass__init__fields__28__annotation,
        __dataclass__init__fields__28__default,
        __dataclass__init__fields__29__annotation,
        __dataclass__init__fields__29__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__30__annotation,
        __dataclass__init__fields__30__default,
        __dataclass__init__fields__31__annotation,
        __dataclass__init__fields__31__default,
        __dataclass__init__fields__32__annotation,
        __dataclass__init__fields__32__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                association=self.association,
                attachment=self.attachment,
                availability_zone=self.availability_zone,
                connection_tracking_configuration=self.connection_tracking_configuration,
                description=self.description,
                groups=self.groups,
                interface_type=self.interface_type,
                ipv6_addresses=self.ipv6_addresses,
                mac_address=self.mac_address,
                network_interface_id=self.network_interface_id,
                outpost_arn=self.outpost_arn,
                owner_id=self.owner_id,
                private_dns_name=self.private_dns_name,
                public_dns_name=self.public_dns_name,
                public_ip_dns_name_options=self.public_ip_dns_name_options,
                private_ip_address=self.private_ip_address,
                private_ip_addresses=self.private_ip_addresses,
                ipv4_prefixes=self.ipv4_prefixes,
                ipv6_prefixes=self.ipv6_prefixes,
                requester_id=self.requester_id,
                requester_managed=self.requester_managed,
                source_dest_check=self.source_dest_check,
                status=self.status,
                subnet_id=self.subnet_id,
                tag_set=self.tag_set,
                vpc_id=self.vpc_id,
                deny_all_igw_traffic=self.deny_all_igw_traffic,
                ipv6_native=self.ipv6_native,
                ipv6_address=self.ipv6_address,
                operator=self.operator,
                associated_subnets=self.associated_subnets,
                availability_zone_id=self.availability_zone_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.association == other.association and
                self.attachment == other.attachment and
                self.availability_zone == other.availability_zone and
                self.connection_tracking_configuration == other.connection_tracking_configuration and
                self.description == other.description and
                self.groups == other.groups and
                self.interface_type == other.interface_type and
                self.ipv6_addresses == other.ipv6_addresses and
                self.mac_address == other.mac_address and
                self.network_interface_id == other.network_interface_id and
                self.outpost_arn == other.outpost_arn and
                self.owner_id == other.owner_id and
                self.private_dns_name == other.private_dns_name and
                self.public_dns_name == other.public_dns_name and
                self.public_ip_dns_name_options == other.public_ip_dns_name_options and
                self.private_ip_address == other.private_ip_address and
                self.private_ip_addresses == other.private_ip_addresses and
                self.ipv4_prefixes == other.ipv4_prefixes and
                self.ipv6_prefixes == other.ipv6_prefixes and
                self.requester_id == other.requester_id and
                self.requester_managed == other.requester_managed and
                self.source_dest_check == other.source_dest_check and
                self.status == other.status and
                self.subnet_id == other.subnet_id and
                self.tag_set == other.tag_set and
                self.vpc_id == other.vpc_id and
                self.deny_all_igw_traffic == other.deny_all_igw_traffic and
                self.ipv6_native == other.ipv6_native and
                self.ipv6_address == other.ipv6_address and
                self.operator == other.operator and
                self.associated_subnets == other.associated_subnets and
                self.availability_zone_id == other.availability_zone_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'association',
            'attachment',
            'availability_zone',
            'connection_tracking_configuration',
            'description',
            'groups',
            'interface_type',
            'ipv6_addresses',
            'mac_address',
            'network_interface_id',
            'outpost_arn',
            'owner_id',
            'private_dns_name',
            'public_dns_name',
            'public_ip_dns_name_options',
            'private_ip_address',
            'private_ip_addresses',
            'ipv4_prefixes',
            'ipv6_prefixes',
            'requester_id',
            'requester_managed',
            'source_dest_check',
            'status',
            'subnet_id',
            'tag_set',
            'vpc_id',
            'deny_all_igw_traffic',
            'ipv6_native',
            'ipv6_address',
            'operator',
            'associated_subnets',
            'availability_zone_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'association',
            'attachment',
            'availability_zone',
            'connection_tracking_configuration',
            'description',
            'groups',
            'interface_type',
            'ipv6_addresses',
            'mac_address',
            'network_interface_id',
            'outpost_arn',
            'owner_id',
            'private_dns_name',
            'public_dns_name',
            'public_ip_dns_name_options',
            'private_ip_address',
            'private_ip_addresses',
            'ipv4_prefixes',
            'ipv6_prefixes',
            'requester_id',
            'requester_managed',
            'source_dest_check',
            'status',
            'subnet_id',
            'tag_set',
            'vpc_id',
            'deny_all_igw_traffic',
            'ipv6_native',
            'ipv6_address',
            'operator',
            'associated_subnets',
            'availability_zone_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.association,
                self.attachment,
                self.availability_zone,
                self.connection_tracking_configuration,
                self.description,
                self.groups,
                self.interface_type,
                self.ipv6_addresses,
                self.mac_address,
                self.network_interface_id,
                self.outpost_arn,
                self.owner_id,
                self.private_dns_name,
                self.public_dns_name,
                self.public_ip_dns_name_options,
                self.private_ip_address,
                self.private_ip_addresses,
                self.ipv4_prefixes,
                self.ipv6_prefixes,
                self.requester_id,
                self.requester_managed,
                self.source_dest_check,
                self.status,
                self.subnet_id,
                self.tag_set,
                self.vpc_id,
                self.deny_all_igw_traffic,
                self.ipv6_native,
                self.ipv6_address,
                self.operator,
                self.associated_subnets,
                self.availability_zone_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            association: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            attachment: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            availability_zone: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            connection_tracking_configuration: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            description: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            groups: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            interface_type: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            ipv6_addresses: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            mac_address: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            network_interface_id: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            outpost_arn: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            owner_id: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            private_dns_name: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            public_dns_name: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            public_ip_dns_name_options: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            private_ip_address: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            private_ip_addresses: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            ipv4_prefixes: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            ipv6_prefixes: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            requester_id: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            requester_managed: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            source_dest_check: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            status: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
            subnet_id: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
            tag_set: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
            vpc_id: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
            deny_all_igw_traffic: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
            ipv6_native: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
            ipv6_address: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
            operator: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
            associated_subnets: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
            availability_zone_id: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'association', association)
            __dataclass__object_setattr(self, 'attachment', attachment)
            __dataclass__object_setattr(self, 'availability_zone', availability_zone)
            __dataclass__object_setattr(self, 'connection_tracking_configuration', connection_tracking_configuration)
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'groups', groups)
            __dataclass__object_setattr(self, 'interface_type', interface_type)
            __dataclass__object_setattr(self, 'ipv6_addresses', ipv6_addresses)
            __dataclass__object_setattr(self, 'mac_address', mac_address)
            __dataclass__object_setattr(self, 'network_interface_id', network_interface_id)
            __dataclass__object_setattr(self, 'outpost_arn', outpost_arn)
            __dataclass__object_setattr(self, 'owner_id', owner_id)
            __dataclass__object_setattr(self, 'private_dns_name', private_dns_name)
            __dataclass__object_setattr(self, 'public_dns_name', public_dns_name)
            __dataclass__object_setattr(self, 'public_ip_dns_name_options', public_ip_dns_name_options)
            __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)
            __dataclass__object_setattr(self, 'private_ip_addresses', private_ip_addresses)
            __dataclass__object_setattr(self, 'ipv4_prefixes', ipv4_prefixes)
            __dataclass__object_setattr(self, 'ipv6_prefixes', ipv6_prefixes)
            __dataclass__object_setattr(self, 'requester_id', requester_id)
            __dataclass__object_setattr(self, 'requester_managed', requester_managed)
            __dataclass__object_setattr(self, 'source_dest_check', source_dest_check)
            __dataclass__object_setattr(self, 'status', status)
            __dataclass__object_setattr(self, 'subnet_id', subnet_id)
            __dataclass__object_setattr(self, 'tag_set', tag_set)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'deny_all_igw_traffic', deny_all_igw_traffic)
            __dataclass__object_setattr(self, 'ipv6_native', ipv6_native)
            __dataclass__object_setattr(self, 'ipv6_address', ipv6_address)
            __dataclass__object_setattr(self, 'operator', operator)
            __dataclass__object_setattr(self, 'associated_subnets', associated_subnets)
            __dataclass__object_setattr(self, 'availability_zone_id', availability_zone_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"association={self.association!r}")
            parts.append(f"attachment={self.attachment!r}")
            parts.append(f"availability_zone={self.availability_zone!r}")
            parts.append(f"connection_tracking_configuration={self.connection_tracking_configuration!r}")
            parts.append(f"description={self.description!r}")
            parts.append(f"groups={self.groups!r}")
            parts.append(f"interface_type={self.interface_type!r}")
            parts.append(f"ipv6_addresses={self.ipv6_addresses!r}")
            parts.append(f"mac_address={self.mac_address!r}")
            parts.append(f"network_interface_id={self.network_interface_id!r}")
            parts.append(f"outpost_arn={self.outpost_arn!r}")
            parts.append(f"owner_id={self.owner_id!r}")
            parts.append(f"private_dns_name={self.private_dns_name!r}")
            parts.append(f"public_dns_name={self.public_dns_name!r}")
            parts.append(f"public_ip_dns_name_options={self.public_ip_dns_name_options!r}")
            parts.append(f"private_ip_address={self.private_ip_address!r}")
            parts.append(f"private_ip_addresses={self.private_ip_addresses!r}")
            parts.append(f"ipv4_prefixes={self.ipv4_prefixes!r}")
            parts.append(f"ipv6_prefixes={self.ipv6_prefixes!r}")
            parts.append(f"requester_id={self.requester_id!r}")
            parts.append(f"requester_managed={self.requester_managed!r}")
            parts.append(f"source_dest_check={self.source_dest_check!r}")
            parts.append(f"status={self.status!r}")
            parts.append(f"subnet_id={self.subnet_id!r}")
            parts.append(f"tag_set={self.tag_set!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"deny_all_igw_traffic={self.deny_all_igw_traffic!r}")
            parts.append(f"ipv6_native={self.ipv6_native!r}")
            parts.append(f"ipv6_address={self.ipv6_address!r}")
            parts.append(f"operator={self.operator!r}")
            parts.append(f"associated_subnets={self.associated_subnets!r}")
            parts.append(f"availability_zone_id={self.availability_zone_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('count', 'name', 'manufacturer', 'memory_info')), EqPlan(fields=('count', 'name', "
        "'manufacturer', 'memory_info')), FrozenPlan(fields=('__shape__', 'count', 'name', 'manufacturer', 'memory_info"
        "'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('count', 'name', 'manufacturer', 'memory"
        "_info'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0."
        "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, c"
        "oerce=None, validate=None, check_type=None), InitPlan.Field(name='count', annotation=OpRef(name='init.fields.1"
        ".annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annota"
        "tion=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='manufacturer', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fi"
        "elds.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='memory_info', annotation=OpRef(name='init.fields.4.anno"
        "tation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_o"
        "nly_params=('count', 'name', 'manufacturer', 'memory_info'), frozen=True, slots=False, post_init_params=None, "
        "init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='count', kw_only=True, fn=None), ReprPlan."
        "Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='manufacturer', kw_only=True, fn=None), ReprPla"
        "n.Field(name='memory_info', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='c61c1debd6c8733c987556e95fc6934a226ef909',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InferenceDeviceInfo'),
        ('ominfra.clouds.aws.models.services.ec2', 'MediaDeviceInfo'),
    ),
)
def _process_dataclass__c61c1debd6c8733c987556e95fc6934a226ef909():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                count=self.count,
                name=self.name,
                manufacturer=self.manufacturer,
                memory_info=self.memory_info,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.count == other.count and
                self.name == other.name and
                self.manufacturer == other.manufacturer and
                self.memory_info == other.memory_info
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'count',
            'name',
            'manufacturer',
            'memory_info',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'count',
            'name',
            'manufacturer',
            'memory_info',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.count,
                self.name,
                self.manufacturer,
                self.memory_info,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            count: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            manufacturer: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            memory_info: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'count', count)
            __dataclass__object_setattr(self, 'name', name)
            __dataclass__object_setattr(self, 'manufacturer', manufacturer)
            __dataclass__object_setattr(self, 'memory_info', memory_info)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"count={self.count!r}")
            parts.append(f"name={self.name!r}")
            parts.append(f"manufacturer={self.manufacturer!r}")
            parts.append(f"memory_info={self.memory_info!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('option_group_name', 'status')), EqPlan(fields=('option_group_name', 'status')), F"
        "rozenPlan(fields=('__shape__', 'option_group_name', 'status'), allow_dynamic_dunder_attrs=False), HashPlan(act"
        "ion='add', fields=('option_group_name', 'status'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape"
        "__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='op"
        "tion_group_name', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default"
        "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
        ", check_type=None), InitPlan.Field(name='status', annotation=OpRef(name='init.fields.2.annotation'), default=O"
        "pRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('option"
        "_group_name', 'status'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
        "lan(fields=(ReprPlan.Field(name='option_group_name', kw_only=True, fn=None), ReprPlan.Field(name='status', kw_"
        "only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='c79ef861fd4c5615b5f048e9aec3299540fa33f7',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'OptionGroupMembership'),
    ),
)
def _process_dataclass__c79ef861fd4c5615b5f048e9aec3299540fa33f7():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                option_group_name=self.option_group_name,
                status=self.status,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.option_group_name == other.option_group_name and
                self.status == other.status
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'option_group_name',
            'status',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'option_group_name',
            'status',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.option_group_name,
                self.status,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            option_group_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            status: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'option_group_name', option_group_name)
            __dataclass__object_setattr(self, 'status', status)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"option_group_name={self.option_group_name!r}")
            parts.append(f"status={self.status!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('neuron_devices', 'total_neuron_device_memory_in_mi_b')), EqPlan(fields=('neuron_d"
        "evices', 'total_neuron_device_memory_in_mi_b')), FrozenPlan(fields=('__shape__', 'neuron_devices', 'total_neur"
        "on_device_memory_in_mi_b'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('neuron_devices'"
        ", 'total_neuron_device_memory_in_mi_b'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annot"
        "ation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='neuron_devic"
        "es', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None), InitPlan.Field(name='total_neuron_device_memory_in_mi_b', annotation=OpRef(name='init.fields.2.annotati"
        "on'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type"
        "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_"
        "params=('neuron_devices', 'total_neuron_device_memory_in_mi_b'), frozen=True, slots=False, post_init_params=No"
        "ne, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='neuron_devices', kw_only=True, fn=Non"
        "e), ReprPlan.Field(name='total_neuron_device_memory_in_mi_b', kw_only=True, fn=None)), id=False, terse=False, "
        "default_fn=None)))"
    ),
    plan_repr_sha1='cb350e551ebaec6d052e77a79144de2121b49254',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NeuronInfo'),
    ),
)
def _process_dataclass__cb350e551ebaec6d052e77a79144de2121b49254():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                neuron_devices=self.neuron_devices,
                total_neuron_device_memory_in_mi_b=self.total_neuron_device_memory_in_mi_b,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.neuron_devices == other.neuron_devices and
                self.total_neuron_device_memory_in_mi_b == other.total_neuron_device_memory_in_mi_b
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'neuron_devices',
            'total_neuron_device_memory_in_mi_b',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'neuron_devices',
            'total_neuron_device_memory_in_mi_b',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.neuron_devices,
                self.total_neuron_device_memory_in_mi_b,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            neuron_devices: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            total_neuron_device_memory_in_mi_b: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'neuron_devices', neuron_devices)
            __dataclass__object_setattr(self, 'total_neuron_device_memory_in_mi_b', total_neuron_device_memory_in_mi_b)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"neuron_devices={self.neuron_devices!r}")
            parts.append(f"total_neuron_device_memory_in_mi_b={self.total_neuron_device_memory_in_mi_b!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('db_subnet_group_name', 'db_subnet_group_description', 'vpc_id', 'subnet_group_sta"
        "tus', 'subnets', 'db_subnet_group_arn', 'supported_network_types')), EqPlan(fields=('db_subnet_group_name', 'd"
        "b_subnet_group_description', 'vpc_id', 'subnet_group_status', 'subnets', 'db_subnet_group_arn', 'supported_net"
        "work_types')), FrozenPlan(fields=('__shape__', 'db_subnet_group_name', 'db_subnet_group_description', 'vpc_id'"
        ", 'subnet_group_status', 'subnets', 'db_subnet_group_arn', 'supported_network_types'), allow_dynamic_dunder_at"
        "trs=False), HashPlan(action='add', fields=('db_subnet_group_name', 'db_subnet_group_description', 'vpc_id', 's"
        "ubnet_group_status', 'subnets', 'db_subnet_group_arn', 'supported_network_types'), cache=False), InitPlan(fiel"
        "ds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_"
        "factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='db_subnet_group_name', annotation=OpRef(name='init.fields.1.annotation'), defaul"
        "t=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
        "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_subnet_group_description', anno"
        "tation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields"
        ".3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='subnet_group_status', annotation=OpRef(name='init.fields.4."
        "annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnets', anno"
        "tation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='db_subnet_group_arn', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name"
        "='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='supported_network_types', annotation=OpRef(nam"
        "e='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self'"
        ", std_params=(), kw_only_params=('db_subnet_group_name', 'db_subnet_group_description', 'vpc_id', 'subnet_grou"
        "p_status', 'subnets', 'db_subnet_group_arn', 'supported_network_types'), frozen=True, slots=False, post_init_p"
        "arams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db_subnet_group_name', kw_onl"
        "y=True, fn=None), ReprPlan.Field(name='db_subnet_group_description', kw_only=True, fn=None), ReprPlan.Field(na"
        "me='vpc_id', kw_only=True, fn=None), ReprPlan.Field(name='subnet_group_status', kw_only=True, fn=None), ReprPl"
        "an.Field(name='subnets', kw_only=True, fn=None), ReprPlan.Field(name='db_subnet_group_arn', kw_only=True, fn=N"
        "one), ReprPlan.Field(name='supported_network_types', kw_only=True, fn=None)), id=False, terse=False, default_f"
        "n=None)))"
    ),
    plan_repr_sha1='ce03050de49b8021c089e9bac61e7cf378cb13ea',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'DBSubnetGroup'),
    ),
)
def _process_dataclass__ce03050de49b8021c089e9bac61e7cf378cb13ea():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                db_subnet_group_name=self.db_subnet_group_name,
                db_subnet_group_description=self.db_subnet_group_description,
                vpc_id=self.vpc_id,
                subnet_group_status=self.subnet_group_status,
                subnets=self.subnets,
                db_subnet_group_arn=self.db_subnet_group_arn,
                supported_network_types=self.supported_network_types,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.db_subnet_group_name == other.db_subnet_group_name and
                self.db_subnet_group_description == other.db_subnet_group_description and
                self.vpc_id == other.vpc_id and
                self.subnet_group_status == other.subnet_group_status and
                self.subnets == other.subnets and
                self.db_subnet_group_arn == other.db_subnet_group_arn and
                self.supported_network_types == other.supported_network_types
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'db_subnet_group_name',
            'db_subnet_group_description',
            'vpc_id',
            'subnet_group_status',
            'subnets',
            'db_subnet_group_arn',
            'supported_network_types',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'db_subnet_group_name',
            'db_subnet_group_description',
            'vpc_id',
            'subnet_group_status',
            'subnets',
            'db_subnet_group_arn',
            'supported_network_types',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.db_subnet_group_name,
                self.db_subnet_group_description,
                self.vpc_id,
                self.subnet_group_status,
                self.subnets,
                self.db_subnet_group_arn,
                self.supported_network_types,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            db_subnet_group_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            db_subnet_group_description: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            vpc_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            subnet_group_status: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            subnets: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            db_subnet_group_arn: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            supported_network_types: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'db_subnet_group_name', db_subnet_group_name)
            __dataclass__object_setattr(self, 'db_subnet_group_description', db_subnet_group_description)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'subnet_group_status', subnet_group_status)
            __dataclass__object_setattr(self, 'subnets', subnets)
            __dataclass__object_setattr(self, 'db_subnet_group_arn', db_subnet_group_arn)
            __dataclass__object_setattr(self, 'supported_network_types', supported_network_types)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"db_subnet_group_name={self.db_subnet_group_name!r}")
            parts.append(f"db_subnet_group_description={self.db_subnet_group_description!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"subnet_group_status={self.subnet_group_status!r}")
            parts.append(f"subnets={self.subnets!r}")
            parts.append(f"db_subnet_group_arn={self.db_subnet_group_arn!r}")
            parts.append(f"supported_network_types={self.supported_network_types!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('dns_hostname_type', 'public_ipv4_dns_name', 'public_ipv6_dns_name', 'public_dual_"
        "stack_dns_name')), EqPlan(fields=('dns_hostname_type', 'public_ipv4_dns_name', 'public_ipv6_dns_name', 'public"
        "_dual_stack_dns_name')), FrozenPlan(fields=('__shape__', 'dns_hostname_type', 'public_ipv4_dns_name', 'public_"
        "ipv6_dns_name', 'public_dual_stack_dns_name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', field"
        "s=('dns_hostname_type', 'public_ipv4_dns_name', 'public_ipv6_dns_name', 'public_dual_stack_dns_name'), cache=F"
        "alse), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), de"
        "fault=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='dns_hostname_type', annotation=OpRef(name='init.fields.1.ann"
        "otation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_ipv4_dns_n"
        "ame', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='public_ipv6_dns_name', annotation=OpRef(name='init.fields.3.annotation'), default"
        "=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
        "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_dual_stack_dns_name', annota"
        "tion=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), sel"
        "f_param='self', std_params=(), kw_only_params=('dns_hostname_type', 'public_ipv4_dns_name', 'public_ipv6_dns_n"
        "ame', 'public_dual_stack_dns_name'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fn"
        "s=()), ReprPlan(fields=(ReprPlan.Field(name='dns_hostname_type', kw_only=True, fn=None), ReprPlan.Field(name='"
        "public_ipv4_dns_name', kw_only=True, fn=None), ReprPlan.Field(name='public_ipv6_dns_name', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='public_dual_stack_dns_name', kw_only=True, fn=None)), id=False, terse=False, default"
        "_fn=None)))"
    ),
    plan_repr_sha1='ce7d79af67863ed76184828a5195f4fe33df604c',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'PublicIpDnsNameOptions'),
    ),
)
def _process_dataclass__ce7d79af67863ed76184828a5195f4fe33df604c():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                dns_hostname_type=self.dns_hostname_type,
                public_ipv4_dns_name=self.public_ipv4_dns_name,
                public_ipv6_dns_name=self.public_ipv6_dns_name,
                public_dual_stack_dns_name=self.public_dual_stack_dns_name,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.dns_hostname_type == other.dns_hostname_type and
                self.public_ipv4_dns_name == other.public_ipv4_dns_name and
                self.public_ipv6_dns_name == other.public_ipv6_dns_name and
                self.public_dual_stack_dns_name == other.public_dual_stack_dns_name
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'dns_hostname_type',
            'public_ipv4_dns_name',
            'public_ipv6_dns_name',
            'public_dual_stack_dns_name',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'dns_hostname_type',
            'public_ipv4_dns_name',
            'public_ipv6_dns_name',
            'public_dual_stack_dns_name',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.dns_hostname_type,
                self.public_ipv4_dns_name,
                self.public_ipv6_dns_name,
                self.public_dual_stack_dns_name,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            dns_hostname_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            public_ipv4_dns_name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            public_ipv6_dns_name: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            public_dual_stack_dns_name: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'dns_hostname_type', dns_hostname_type)
            __dataclass__object_setattr(self, 'public_ipv4_dns_name', public_ipv4_dns_name)
            __dataclass__object_setattr(self, 'public_ipv6_dns_name', public_ipv6_dns_name)
            __dataclass__object_setattr(self, 'public_dual_stack_dns_name', public_dual_stack_dns_name)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"dns_hostname_type={self.dns_hostname_type!r}")
            parts.append(f"public_ipv4_dns_name={self.public_ipv4_dns_name!r}")
            parts.append(f"public_ipv6_dns_name={self.public_ipv6_dns_name!r}")
            parts.append(f"public_dual_stack_dns_name={self.public_dual_stack_dns_name!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('allocation_id', 'association_id', 'ip_owner_id', 'public_dns_name', 'public_ip', "
        "'customer_owned_ip', 'carrier_ip')), EqPlan(fields=('allocation_id', 'association_id', 'ip_owner_id', 'public_"
        "dns_name', 'public_ip', 'customer_owned_ip', 'carrier_ip')), FrozenPlan(fields=('__shape__', 'allocation_id', "
        "'association_id', 'ip_owner_id', 'public_dns_name', 'public_ip', 'customer_owned_ip', 'carrier_ip'), allow_dyn"
        "amic_dunder_attrs=False), HashPlan(action='add', fields=('allocation_id', 'association_id', 'ip_owner_id', 'pu"
        "blic_dns_name', 'public_ip', 'customer_owned_ip', 'carrier_ip'), cache=False), InitPlan(fields=(InitPlan.Field"
        "(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init"
        "=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='allocation_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields"
        ".1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='association_id', annotation=OpRef(name='init.fields.2.annot"
        "ation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ip_owner_id', annot"
        "ation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='public_dns_name', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='ini"
        "t.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
        "one, validate=None, check_type=None), InitPlan.Field(name='public_ip', annotation=OpRef(name='init.fields.5.an"
        "notation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, fiel"
        "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='customer_owned_i"
        "p', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_fa"
        "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
        "one), InitPlan.Field(name='carrier_ip', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name="
        "'init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('allocation_id', "
        "'association_id', 'ip_owner_id', 'public_dns_name', 'public_ip', 'customer_owned_ip', 'carrier_ip'), frozen=Tr"
        "ue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='a"
        "llocation_id', kw_only=True, fn=None), ReprPlan.Field(name='association_id', kw_only=True, fn=None), ReprPlan."
        "Field(name='ip_owner_id', kw_only=True, fn=None), ReprPlan.Field(name='public_dns_name', kw_only=True, fn=None"
        "), ReprPlan.Field(name='public_ip', kw_only=True, fn=None), ReprPlan.Field(name='customer_owned_ip', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='carrier_ip', kw_only=True, fn=None)), id=False, terse=False, default_fn=No"
        "ne)))"
    ),
    plan_repr_sha1='cf29ec57560fe99a689b868df651118a8fab1f0b',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NetworkInterfaceAssociation'),
    ),
)
def _process_dataclass__cf29ec57560fe99a689b868df651118a8fab1f0b():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                allocation_id=self.allocation_id,
                association_id=self.association_id,
                ip_owner_id=self.ip_owner_id,
                public_dns_name=self.public_dns_name,
                public_ip=self.public_ip,
                customer_owned_ip=self.customer_owned_ip,
                carrier_ip=self.carrier_ip,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.allocation_id == other.allocation_id and
                self.association_id == other.association_id and
                self.ip_owner_id == other.ip_owner_id and
                self.public_dns_name == other.public_dns_name and
                self.public_ip == other.public_ip and
                self.customer_owned_ip == other.customer_owned_ip and
                self.carrier_ip == other.carrier_ip
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'allocation_id',
            'association_id',
            'ip_owner_id',
            'public_dns_name',
            'public_ip',
            'customer_owned_ip',
            'carrier_ip',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'allocation_id',
            'association_id',
            'ip_owner_id',
            'public_dns_name',
            'public_ip',
            'customer_owned_ip',
            'carrier_ip',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.allocation_id,
                self.association_id,
                self.ip_owner_id,
                self.public_dns_name,
                self.public_ip,
                self.customer_owned_ip,
                self.carrier_ip,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            allocation_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            association_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            ip_owner_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            public_dns_name: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            public_ip: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            customer_owned_ip: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            carrier_ip: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'allocation_id', allocation_id)
            __dataclass__object_setattr(self, 'association_id', association_id)
            __dataclass__object_setattr(self, 'ip_owner_id', ip_owner_id)
            __dataclass__object_setattr(self, 'public_dns_name', public_dns_name)
            __dataclass__object_setattr(self, 'public_ip', public_ip)
            __dataclass__object_setattr(self, 'customer_owned_ip', customer_owned_ip)
            __dataclass__object_setattr(self, 'carrier_ip', carrier_ip)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"allocation_id={self.allocation_id!r}")
            parts.append(f"association_id={self.association_id!r}")
            parts.append(f"ip_owner_id={self.ip_owner_id!r}")
            parts.append(f"public_dns_name={self.public_dns_name!r}")
            parts.append(f"public_ip={self.public_ip!r}")
            parts.append(f"customer_owned_ip={self.customer_owned_ip!r}")
            parts.append(f"carrier_ip={self.carrier_ip!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('terminating_instances',)), EqPlan(fields=('terminating_instances',)), FrozenPlan("
        "fields=('__shape__', 'terminating_instances'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', field"
        "s=('terminating_instances',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef"
        "(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=F"
        "ieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='terminating_instances',"
        " annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_facto"
        "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
        ")), self_param='self', std_params=(), kw_only_params=('terminating_instances',), frozen=True, slots=False, pos"
        "t_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='terminating_instances"
        "', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='cf5ef8fece55e5fdc025db18d19108aa811ff60c',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'TerminateInstancesResult'),
    ),
)
def _process_dataclass__cf5ef8fece55e5fdc025db18d19108aa811ff60c():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                terminating_instances=self.terminating_instances,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.terminating_instances == other.terminating_instances
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'terminating_instances',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'terminating_instances',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.terminating_instances,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            terminating_instances: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'terminating_instances', terminating_instances)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"terminating_instances={self.terminating_instances!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('filters', 'vpc_ids', 'next_token', 'max_results', 'dry_run')), EqPlan(fields=('fi"
        "lters', 'vpc_ids', 'next_token', 'max_results', 'dry_run')), FrozenPlan(fields=('__shape__', 'filters', 'vpc_i"
        "ds', 'next_token', 'max_results', 'dry_run'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields"
        "=('filters', 'vpc_ids', 'next_token', 'max_results', 'dry_run'), cache=False), InitPlan(fields=(InitPlan.Field"
        "(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init"
        "=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='filters', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.def"
        "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
        "None, check_type=None), InitPlan.Field(name='vpc_ids', annotation=OpRef(name='init.fields.2.annotation'), defa"
        "ult=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(na"
        "me='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='max_results', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default"
        "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
        ", check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.5.annotation'), default="
        "OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('filte"
        "rs', 'vpc_ids', 'next_token', 'max_results', 'dry_run'), frozen=True, slots=False, post_init_params=None, init"
        "_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='filters', kw_only=True, fn=None), ReprPlan.Fi"
        "eld(name='vpc_ids', kw_only=True, fn=None), ReprPlan.Field(name='next_token', kw_only=True, fn=None), ReprPlan"
        ".Field(name='max_results', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None)), id="
        "False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='cf7570e9b1968a56c54a998eaf8d69fc36327954',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeVpcsRequest'),
    ),
)
def _process_dataclass__cf7570e9b1968a56c54a998eaf8d69fc36327954():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                filters=self.filters,
                vpc_ids=self.vpc_ids,
                next_token=self.next_token,
                max_results=self.max_results,
                dry_run=self.dry_run,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.filters == other.filters and
                self.vpc_ids == other.vpc_ids and
                self.next_token == other.next_token and
                self.max_results == other.max_results and
                self.dry_run == other.dry_run
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'filters',
            'vpc_ids',
            'next_token',
            'max_results',
            'dry_run',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'filters',
            'vpc_ids',
            'next_token',
            'max_results',
            'dry_run',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.filters,
                self.vpc_ids,
                self.next_token,
                self.max_results,
                self.dry_run,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            filters: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            vpc_ids: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            next_token: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            max_results: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            dry_run: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'filters', filters)
            __dataclass__object_setattr(self, 'vpc_ids', vpc_ids)
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'max_results', max_results)
            __dataclass__object_setattr(self, 'dry_run', dry_run)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"filters={self.filters!r}")
            parts.append(f"vpc_ids={self.vpc_ids!r}")
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"max_results={self.max_results!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('primary', 'private_ip_address')), EqPlan(fields=('primary', 'private_ip_address')"
        "), FrozenPlan(fields=('__shape__', 'primary', 'private_ip_address'), allow_dynamic_dunder_attrs=False), HashPl"
        "an(action='add', fields=('primary', 'private_ip_address'), cache=False), InitPlan(fields=(InitPlan.Field(name="
        "'__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True,"
        " override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='primary', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default')"
        ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='private_ip_address', annotation=OpRef(name='init.fields.2.annotation'),"
        " default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_param"
        "s=('primary', 'private_ip_address'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fn"
        "s=()), ReprPlan(fields=(ReprPlan.Field(name='primary', kw_only=True, fn=None), ReprPlan.Field(name='private_ip"
        "_address', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d00a853b7290f4501b8d6289a3edd5190154a1e1',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'PrivateIpAddressSpecification'),
    ),
)
def _process_dataclass__d00a853b7290f4501b8d6289a3edd5190154a1e1():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                primary=self.primary,
                private_ip_address=self.private_ip_address,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.primary == other.primary and
                self.private_ip_address == other.private_ip_address
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'primary',
            'private_ip_address',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'primary',
            'private_ip_address',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.primary,
                self.private_ip_address,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            primary: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            private_ip_address: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'primary', primary)
            __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"primary={self.primary!r}")
            parts.append(f"private_ip_address={self.private_ip_address!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ca_identifier', 'valid_till')), EqPlan(fields=('ca_identifier', 'valid_till')), F"
        "rozenPlan(fields=('__shape__', 'ca_identifier', 'valid_till'), allow_dynamic_dunder_attrs=False), HashPlan(act"
        "ion='add', fields=('ca_identifier', 'valid_till'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape"
        "__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ca"
        "_identifier', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), "
        "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
        "eck_type=None), InitPlan.Field(name='valid_till', annotation=OpRef(name='init.fields.2.annotation'), default=O"
        "pRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('ca_ide"
        "ntifier', 'valid_till'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
        "lan(fields=(ReprPlan.Field(name='ca_identifier', kw_only=True, fn=None), ReprPlan.Field(name='valid_till', kw_"
        "only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d06e7fd09a465a218bf317b3d6b6c4d46dec5ff4',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'CertificateDetails'),
    ),
)
def _process_dataclass__d06e7fd09a465a218bf317b3d6b6c4d46dec5ff4():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ca_identifier=self.ca_identifier,
                valid_till=self.valid_till,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ca_identifier == other.ca_identifier and
                self.valid_till == other.valid_till
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ca_identifier',
            'valid_till',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ca_identifier',
            'valid_till',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ca_identifier,
                self.valid_till,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ca_identifier: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            valid_till: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ca_identifier', ca_identifier)
            __dataclass__object_setattr(self, 'valid_till', valid_till)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ca_identifier={self.ca_identifier!r}")
            parts.append(f"valid_till={self.valid_till!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('destination_cidr_block', 'destination_ipv6_cidr_block', 'destination_prefix_list_"
        "id', 'egress_only_internet_gateway_id', 'gateway_id', 'instance_id', 'instance_owner_id', 'nat_gateway_id', 't"
        "ransit_gateway_id', 'local_gateway_id', 'carrier_gateway_id', 'network_interface_id', 'origin', 'state', 'vpc_"
        "peering_connection_id', 'core_network_arn', 'odb_network_arn', 'ip_address')), EqPlan(fields=('destination_cid"
        "r_block', 'destination_ipv6_cidr_block', 'destination_prefix_list_id', 'egress_only_internet_gateway_id', 'gat"
        "eway_id', 'instance_id', 'instance_owner_id', 'nat_gateway_id', 'transit_gateway_id', 'local_gateway_id', 'car"
        "rier_gateway_id', 'network_interface_id', 'origin', 'state', 'vpc_peering_connection_id', 'core_network_arn', "
        "'odb_network_arn', 'ip_address')), FrozenPlan(fields=('__shape__', 'destination_cidr_block', 'destination_ipv6"
        "_cidr_block', 'destination_prefix_list_id', 'egress_only_internet_gateway_id', 'gateway_id', 'instance_id', 'i"
        "nstance_owner_id', 'nat_gateway_id', 'transit_gateway_id', 'local_gateway_id', 'carrier_gateway_id', 'network_"
        "interface_id', 'origin', 'state', 'vpc_peering_connection_id', 'core_network_arn', 'odb_network_arn', 'ip_addr"
        "ess'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('destination_cidr_block', 'destinatio"
        "n_ipv6_cidr_block', 'destination_prefix_list_id', 'egress_only_internet_gateway_id', 'gateway_id', 'instance_i"
        "d', 'instance_owner_id', 'nat_gateway_id', 'transit_gateway_id', 'local_gateway_id', 'carrier_gateway_id', 'ne"
        "twork_interface_id', 'origin', 'state', 'vpc_peering_connection_id', 'core_network_arn', 'odb_network_arn', 'i"
        "p_address'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.field"
        "s.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VA"
        "R, coerce=None, validate=None, check_type=None), InitPlan.Field(name='destination_cidr_block', annotation=OpRe"
        "f(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='destination_ipv6_cidr_block', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='i"
        "nit.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='destination_prefix_list_id', annotation=OpRef(nam"
        "e='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='egress_only_internet_gateway_id', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='in"
        "it.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='gateway_id', annotation=OpRef(name='init.fields.5."
        "annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_id', "
        "annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='instance_owner_id', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(na"
        "me='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
        "oerce=None, validate=None, check_type=None), InitPlan.Field(name='nat_gateway_id', annotation=OpRef(name='init"
        ".fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override"
        "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tran"
        "sit_gateway_id', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='local_gateway_id', annotation=OpRef(name='init.fields.10.annotation'),"
        " default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_type=Fie"
        "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='carrier_gateway_id', annot"
        "ation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='network_interface_id', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(n"
        "ame='init.fields.12.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
        " coerce=None, validate=None, check_type=None), InitPlan.Field(name='origin', annotation=OpRef(name='init.field"
        "s.13.annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state', "
        "annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='vpc_peering_connection_id', annotation=OpRef(name='init.fields.15.annotation'), defau"
        "lt=OpRef(name='init.fields.15.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='core_network_arn', annotation=Op"
        "Ref(name='init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='odb_network_arn', annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fie"
        "lds.17.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='ip_address', annotation=OpRef(name='init.fields.18.anno"
        "tation'), default=OpRef(name='init.fields.18.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_"
        "only_params=('destination_cidr_block', 'destination_ipv6_cidr_block', 'destination_prefix_list_id', 'egress_on"
        "ly_internet_gateway_id', 'gateway_id', 'instance_id', 'instance_owner_id', 'nat_gateway_id', 'transit_gateway_"
        "id', 'local_gateway_id', 'carrier_gateway_id', 'network_interface_id', 'origin', 'state', 'vpc_peering_connect"
        "ion_id', 'core_network_arn', 'odb_network_arn', 'ip_address'), frozen=True, slots=False, post_init_params=None"
        ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='destination_cidr_block', kw_only=True, "
        "fn=None), ReprPlan.Field(name='destination_ipv6_cidr_block', kw_only=True, fn=None), ReprPlan.Field(name='dest"
        "ination_prefix_list_id', kw_only=True, fn=None), ReprPlan.Field(name='egress_only_internet_gateway_id', kw_onl"
        "y=True, fn=None), ReprPlan.Field(name='gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='instance_id',"
        " kw_only=True, fn=None), ReprPlan.Field(name='instance_owner_id', kw_only=True, fn=None), ReprPlan.Field(name="
        "'nat_gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='transit_gateway_id', kw_only=True, fn=None), Re"
        "prPlan.Field(name='local_gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='carrier_gateway_id', kw_onl"
        "y=True, fn=None), ReprPlan.Field(name='network_interface_id', kw_only=True, fn=None), ReprPlan.Field(name='ori"
        "gin', kw_only=True, fn=None), ReprPlan.Field(name='state', kw_only=True, fn=None), ReprPlan.Field(name='vpc_pe"
        "ering_connection_id', kw_only=True, fn=None), ReprPlan.Field(name='core_network_arn', kw_only=True, fn=None), "
        "ReprPlan.Field(name='odb_network_arn', kw_only=True, fn=None), ReprPlan.Field(name='ip_address', kw_only=True,"
        " fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d10b36836b385aa819993a55a03255210a1b5dd1',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Route'),
    ),
)
def _process_dataclass__d10b36836b385aa819993a55a03255210a1b5dd1():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                destination_cidr_block=self.destination_cidr_block,
                destination_ipv6_cidr_block=self.destination_ipv6_cidr_block,
                destination_prefix_list_id=self.destination_prefix_list_id,
                egress_only_internet_gateway_id=self.egress_only_internet_gateway_id,
                gateway_id=self.gateway_id,
                instance_id=self.instance_id,
                instance_owner_id=self.instance_owner_id,
                nat_gateway_id=self.nat_gateway_id,
                transit_gateway_id=self.transit_gateway_id,
                local_gateway_id=self.local_gateway_id,
                carrier_gateway_id=self.carrier_gateway_id,
                network_interface_id=self.network_interface_id,
                origin=self.origin,
                state=self.state,
                vpc_peering_connection_id=self.vpc_peering_connection_id,
                core_network_arn=self.core_network_arn,
                odb_network_arn=self.odb_network_arn,
                ip_address=self.ip_address,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.destination_cidr_block == other.destination_cidr_block and
                self.destination_ipv6_cidr_block == other.destination_ipv6_cidr_block and
                self.destination_prefix_list_id == other.destination_prefix_list_id and
                self.egress_only_internet_gateway_id == other.egress_only_internet_gateway_id and
                self.gateway_id == other.gateway_id and
                self.instance_id == other.instance_id and
                self.instance_owner_id == other.instance_owner_id and
                self.nat_gateway_id == other.nat_gateway_id and
                self.transit_gateway_id == other.transit_gateway_id and
                self.local_gateway_id == other.local_gateway_id and
                self.carrier_gateway_id == other.carrier_gateway_id and
                self.network_interface_id == other.network_interface_id and
                self.origin == other.origin and
                self.state == other.state and
                self.vpc_peering_connection_id == other.vpc_peering_connection_id and
                self.core_network_arn == other.core_network_arn and
                self.odb_network_arn == other.odb_network_arn and
                self.ip_address == other.ip_address
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'destination_cidr_block',
            'destination_ipv6_cidr_block',
            'destination_prefix_list_id',
            'egress_only_internet_gateway_id',
            'gateway_id',
            'instance_id',
            'instance_owner_id',
            'nat_gateway_id',
            'transit_gateway_id',
            'local_gateway_id',
            'carrier_gateway_id',
            'network_interface_id',
            'origin',
            'state',
            'vpc_peering_connection_id',
            'core_network_arn',
            'odb_network_arn',
            'ip_address',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'destination_cidr_block',
            'destination_ipv6_cidr_block',
            'destination_prefix_list_id',
            'egress_only_internet_gateway_id',
            'gateway_id',
            'instance_id',
            'instance_owner_id',
            'nat_gateway_id',
            'transit_gateway_id',
            'local_gateway_id',
            'carrier_gateway_id',
            'network_interface_id',
            'origin',
            'state',
            'vpc_peering_connection_id',
            'core_network_arn',
            'odb_network_arn',
            'ip_address',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.destination_cidr_block,
                self.destination_ipv6_cidr_block,
                self.destination_prefix_list_id,
                self.egress_only_internet_gateway_id,
                self.gateway_id,
                self.instance_id,
                self.instance_owner_id,
                self.nat_gateway_id,
                self.transit_gateway_id,
                self.local_gateway_id,
                self.carrier_gateway_id,
                self.network_interface_id,
                self.origin,
                self.state,
                self.vpc_peering_connection_id,
                self.core_network_arn,
                self.odb_network_arn,
                self.ip_address,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            destination_cidr_block: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            destination_ipv6_cidr_block: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            destination_prefix_list_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            egress_only_internet_gateway_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            gateway_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            instance_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            instance_owner_id: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            nat_gateway_id: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            transit_gateway_id: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            local_gateway_id: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            carrier_gateway_id: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            network_interface_id: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            origin: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            state: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            vpc_peering_connection_id: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            core_network_arn: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            odb_network_arn: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            ip_address: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'destination_cidr_block', destination_cidr_block)
            __dataclass__object_setattr(self, 'destination_ipv6_cidr_block', destination_ipv6_cidr_block)
            __dataclass__object_setattr(self, 'destination_prefix_list_id', destination_prefix_list_id)
            __dataclass__object_setattr(self, 'egress_only_internet_gateway_id', egress_only_internet_gateway_id)
            __dataclass__object_setattr(self, 'gateway_id', gateway_id)
            __dataclass__object_setattr(self, 'instance_id', instance_id)
            __dataclass__object_setattr(self, 'instance_owner_id', instance_owner_id)
            __dataclass__object_setattr(self, 'nat_gateway_id', nat_gateway_id)
            __dataclass__object_setattr(self, 'transit_gateway_id', transit_gateway_id)
            __dataclass__object_setattr(self, 'local_gateway_id', local_gateway_id)
            __dataclass__object_setattr(self, 'carrier_gateway_id', carrier_gateway_id)
            __dataclass__object_setattr(self, 'network_interface_id', network_interface_id)
            __dataclass__object_setattr(self, 'origin', origin)
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'vpc_peering_connection_id', vpc_peering_connection_id)
            __dataclass__object_setattr(self, 'core_network_arn', core_network_arn)
            __dataclass__object_setattr(self, 'odb_network_arn', odb_network_arn)
            __dataclass__object_setattr(self, 'ip_address', ip_address)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"destination_cidr_block={self.destination_cidr_block!r}")
            parts.append(f"destination_ipv6_cidr_block={self.destination_ipv6_cidr_block!r}")
            parts.append(f"destination_prefix_list_id={self.destination_prefix_list_id!r}")
            parts.append(f"egress_only_internet_gateway_id={self.egress_only_internet_gateway_id!r}")
            parts.append(f"gateway_id={self.gateway_id!r}")
            parts.append(f"instance_id={self.instance_id!r}")
            parts.append(f"instance_owner_id={self.instance_owner_id!r}")
            parts.append(f"nat_gateway_id={self.nat_gateway_id!r}")
            parts.append(f"transit_gateway_id={self.transit_gateway_id!r}")
            parts.append(f"local_gateway_id={self.local_gateway_id!r}")
            parts.append(f"carrier_gateway_id={self.carrier_gateway_id!r}")
            parts.append(f"network_interface_id={self.network_interface_id!r}")
            parts.append(f"origin={self.origin!r}")
            parts.append(f"state={self.state!r}")
            parts.append(f"vpc_peering_connection_id={self.vpc_peering_connection_id!r}")
            parts.append(f"core_network_arn={self.core_network_arn!r}")
            parts.append(f"odb_network_arn={self.odb_network_arn!r}")
            parts.append(f"ip_address={self.ip_address!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('db_instance_identifier', 'skip_final_snapshot', 'final_db_snapshot_identifier', '"
        "delete_automated_backups')), EqPlan(fields=('db_instance_identifier', 'skip_final_snapshot', 'final_db_snapsho"
        "t_identifier', 'delete_automated_backups')), FrozenPlan(fields=('__shape__', 'db_instance_identifier', 'skip_f"
        "inal_snapshot', 'final_db_snapshot_identifier', 'delete_automated_backups'), allow_dynamic_dunder_attrs=False)"
        ", HashPlan(action='add', fields=('db_instance_identifier', 'skip_final_snapshot', 'final_db_snapshot_identifie"
        "r', 'delete_automated_backups'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=Op"
        "Ref(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_instance_identifi"
        "er', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ski"
        "p_final_snapshot', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='final_db_snapshot_identifier', annotation=OpRef(name='init.fields.3."
        "annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='delete_automat"
        "ed_backups', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), d"
        "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
        "ck_type=None)), self_param='self', std_params=(), kw_only_params=('db_instance_identifier', 'skip_final_snapsh"
        "ot', 'final_db_snapshot_identifier', 'delete_automated_backups'), frozen=True, slots=False, post_init_params=N"
        "one, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db_instance_identifier', kw_only=Tru"
        "e, fn=None), ReprPlan.Field(name='skip_final_snapshot', kw_only=True, fn=None), ReprPlan.Field(name='final_db_"
        "snapshot_identifier', kw_only=True, fn=None), ReprPlan.Field(name='delete_automated_backups', kw_only=True, fn"
        "=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d2a0a84e41592cea9c8d2689d8b23123fbb2dca2',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'DeleteDBInstanceMessage'),
    ),
)
def _process_dataclass__d2a0a84e41592cea9c8d2689d8b23123fbb2dca2():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                db_instance_identifier=self.db_instance_identifier,
                skip_final_snapshot=self.skip_final_snapshot,
                final_db_snapshot_identifier=self.final_db_snapshot_identifier,
                delete_automated_backups=self.delete_automated_backups,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.db_instance_identifier == other.db_instance_identifier and
                self.skip_final_snapshot == other.skip_final_snapshot and
                self.final_db_snapshot_identifier == other.final_db_snapshot_identifier and
                self.delete_automated_backups == other.delete_automated_backups
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'db_instance_identifier',
            'skip_final_snapshot',
            'final_db_snapshot_identifier',
            'delete_automated_backups',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'db_instance_identifier',
            'skip_final_snapshot',
            'final_db_snapshot_identifier',
            'delete_automated_backups',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.db_instance_identifier,
                self.skip_final_snapshot,
                self.final_db_snapshot_identifier,
                self.delete_automated_backups,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            db_instance_identifier: __dataclass__init__fields__1__annotation,
            skip_final_snapshot: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            final_db_snapshot_identifier: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            delete_automated_backups: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'db_instance_identifier', db_instance_identifier)
            __dataclass__object_setattr(self, 'skip_final_snapshot', skip_final_snapshot)
            __dataclass__object_setattr(self, 'final_db_snapshot_identifier', final_db_snapshot_identifier)
            __dataclass__object_setattr(self, 'delete_automated_backups', delete_automated_backups)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"db_instance_identifier={self.db_instance_identifier!r}")
            parts.append(f"skip_final_snapshot={self.skip_final_snapshot!r}")
            parts.append(f"final_db_snapshot_identifier={self.final_db_snapshot_identifier!r}")
            parts.append(f"delete_automated_backups={self.delete_automated_backups!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('public_ips', 'dry_run', 'filters', 'allocation_ids')), EqPlan(fields=('public_ips"
        "', 'dry_run', 'filters', 'allocation_ids')), FrozenPlan(fields=('__shape__', 'public_ips', 'dry_run', 'filters"
        "', 'allocation_ids'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('public_ips', 'dry_run"
        "', 'filters', 'allocation_ids'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=Op"
        "Ref(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_ips', annotat"
        "ion=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None,"
        " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
        "lan.Field(name='dry_run', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None), InitPlan.Field(name='filters', annotation=OpRef(name='init.fields.3.annotation'), "
        "default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='allocation_ids', annotation="
        "OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_par"
        "am='self', std_params=(), kw_only_params=('public_ips', 'dry_run', 'filters', 'allocation_ids'), frozen=True, "
        "slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='publi"
        "c_ips', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='fi"
        "lters', kw_only=True, fn=None), ReprPlan.Field(name='allocation_ids', kw_only=True, fn=None)), id=False, terse"
        "=False, default_fn=None)))"
    ),
    plan_repr_sha1='d2e4d44d054c756027bfa674782dd7a1a3096885',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeAddressesRequest'),
    ),
)
def _process_dataclass__d2e4d44d054c756027bfa674782dd7a1a3096885():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                public_ips=self.public_ips,
                dry_run=self.dry_run,
                filters=self.filters,
                allocation_ids=self.allocation_ids,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.public_ips == other.public_ips and
                self.dry_run == other.dry_run and
                self.filters == other.filters and
                self.allocation_ids == other.allocation_ids
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'public_ips',
            'dry_run',
            'filters',
            'allocation_ids',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'public_ips',
            'dry_run',
            'filters',
            'allocation_ids',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.public_ips,
                self.dry_run,
                self.filters,
                self.allocation_ids,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            public_ips: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            dry_run: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            filters: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            allocation_ids: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'public_ips', public_ips)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'filters', filters)
            __dataclass__object_setattr(self, 'allocation_ids', allocation_ids)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"public_ips={self.public_ips!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"filters={self.filters!r}")
            parts.append(f"allocation_ids={self.allocation_ids!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('attach_time', 'attachment_id', 'delete_on_termination', 'device_index', 'status',"
        " 'network_card_index', 'ena_srd_specification', 'ena_queue_count')), EqPlan(fields=('attach_time', 'attachment"
        "_id', 'delete_on_termination', 'device_index', 'status', 'network_card_index', 'ena_srd_specification', 'ena_q"
        "ueue_count')), FrozenPlan(fields=('__shape__', 'attach_time', 'attachment_id', 'delete_on_termination', 'devic"
        "e_index', 'status', 'network_card_index', 'ena_srd_specification', 'ena_queue_count'), allow_dynamic_dunder_at"
        "trs=False), HashPlan(action='add', fields=('attach_time', 'attachment_id', 'delete_on_termination', 'device_in"
        "dex', 'status', 'network_card_index', 'ena_srd_specification', 'ena_queue_count'), cache=False), InitPlan(fiel"
        "ds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_"
        "factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='attach_time', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(n"
        "ame='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
        "coerce=None, validate=None, check_type=None), InitPlan.Field(name='attachment_id', annotation=OpRef(name='init"
        ".fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override"
        "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dele"
        "te_on_termination', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='device_index', annotation=OpRef(name='init.fields.4.annotation'), d"
        "efault=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='status', annotation=OpRef(nam"
        "e='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='network_card_index', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='ena_srd_specification', annotation=OpRef(name='init.fields.7.an"
        "notation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, fiel"
        "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_queue_count'"
        ", annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e)), self_param='self', std_params=(), kw_only_params=('attach_time', 'attachment_id', 'delete_on_termination'"
        ", 'device_index', 'status', 'network_card_index', 'ena_srd_specification', 'ena_queue_count'), frozen=True, sl"
        "ots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='attach_"
        "time', kw_only=True, fn=None), ReprPlan.Field(name='attachment_id', kw_only=True, fn=None), ReprPlan.Field(nam"
        "e='delete_on_termination', kw_only=True, fn=None), ReprPlan.Field(name='device_index', kw_only=True, fn=None),"
        " ReprPlan.Field(name='status', kw_only=True, fn=None), ReprPlan.Field(name='network_card_index', kw_only=True,"
        " fn=None), ReprPlan.Field(name='ena_srd_specification', kw_only=True, fn=None), ReprPlan.Field(name='ena_queue"
        "_count', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d3168df540d7e8ab8fa773b5212bd293a057edb3',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceNetworkInterfaceAttachment'),
    ),
)
def _process_dataclass__d3168df540d7e8ab8fa773b5212bd293a057edb3():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                attach_time=self.attach_time,
                attachment_id=self.attachment_id,
                delete_on_termination=self.delete_on_termination,
                device_index=self.device_index,
                status=self.status,
                network_card_index=self.network_card_index,
                ena_srd_specification=self.ena_srd_specification,
                ena_queue_count=self.ena_queue_count,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.attach_time == other.attach_time and
                self.attachment_id == other.attachment_id and
                self.delete_on_termination == other.delete_on_termination and
                self.device_index == other.device_index and
                self.status == other.status and
                self.network_card_index == other.network_card_index and
                self.ena_srd_specification == other.ena_srd_specification and
                self.ena_queue_count == other.ena_queue_count
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'attach_time',
            'attachment_id',
            'delete_on_termination',
            'device_index',
            'status',
            'network_card_index',
            'ena_srd_specification',
            'ena_queue_count',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'attach_time',
            'attachment_id',
            'delete_on_termination',
            'device_index',
            'status',
            'network_card_index',
            'ena_srd_specification',
            'ena_queue_count',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.attach_time,
                self.attachment_id,
                self.delete_on_termination,
                self.device_index,
                self.status,
                self.network_card_index,
                self.ena_srd_specification,
                self.ena_queue_count,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            attach_time: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            attachment_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            delete_on_termination: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            device_index: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            status: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            network_card_index: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            ena_srd_specification: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            ena_queue_count: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'attach_time', attach_time)
            __dataclass__object_setattr(self, 'attachment_id', attachment_id)
            __dataclass__object_setattr(self, 'delete_on_termination', delete_on_termination)
            __dataclass__object_setattr(self, 'device_index', device_index)
            __dataclass__object_setattr(self, 'status', status)
            __dataclass__object_setattr(self, 'network_card_index', network_card_index)
            __dataclass__object_setattr(self, 'ena_srd_specification', ena_srd_specification)
            __dataclass__object_setattr(self, 'ena_queue_count', ena_queue_count)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"attach_time={self.attach_time!r}")
            parts.append(f"attachment_id={self.attachment_id!r}")
            parts.append(f"delete_on_termination={self.delete_on_termination!r}")
            parts.append(f"device_index={self.device_index!r}")
            parts.append(f"status={self.status!r}")
            parts.append(f"network_card_index={self.network_card_index!r}")
            parts.append(f"ena_srd_specification={self.ena_srd_specification!r}")
            parts.append(f"ena_queue_count={self.ena_queue_count!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('architecture', 'block_device_mappings', 'client_token', 'ebs_optimized', 'ena_sup"
        "port', 'hypervisor', 'iam_instance_profile', 'instance_lifecycle', 'elastic_gpu_associations', 'elastic_infere"
        "nce_accelerator_associations', 'network_interfaces', 'outpost_arn', 'root_device_name', 'root_device_type', 's"
        "ecurity_groups', 'source_dest_check', 'spot_instance_request_id', 'sriov_net_support', 'state_reason', 'tags',"
        " 'virtualization_type', 'cpu_options', 'capacity_block_id', 'capacity_reservation_id', 'capacity_reservation_s"
        "pecification', 'hibernation_options', 'licenses', 'metadata_options', 'enclave_options', 'boot_mode', 'platfor"
        "m_details', 'usage_operation', 'usage_operation_update_time', 'private_dns_name_options', 'ipv6_address', 'tpm"
        "_support', 'maintenance_options', 'current_instance_boot_mode', 'network_performance_options', 'operator', 'in"
        "stance_id', 'image_id', 'state', 'private_dns_name', 'public_dns_name', 'state_transition_reason', 'key_name',"
        " 'ami_launch_index', 'product_codes', 'instance_type', 'launch_time', 'placement', 'kernel_id', 'ramdisk_id', "
        "'platform', 'monitoring', 'subnet_id', 'vpc_id', 'private_ip_address', 'public_ip_address')), EqPlan(fields=('"
        "architecture', 'block_device_mappings', 'client_token', 'ebs_optimized', 'ena_support', 'hypervisor', 'iam_ins"
        "tance_profile', 'instance_lifecycle', 'elastic_gpu_associations', 'elastic_inference_accelerator_associations'"
        ", 'network_interfaces', 'outpost_arn', 'root_device_name', 'root_device_type', 'security_groups', 'source_dest"
        "_check', 'spot_instance_request_id', 'sriov_net_support', 'state_reason', 'tags', 'virtualization_type', 'cpu_"
        "options', 'capacity_block_id', 'capacity_reservation_id', 'capacity_reservation_specification', 'hibernation_o"
        "ptions', 'licenses', 'metadata_options', 'enclave_options', 'boot_mode', 'platform_details', 'usage_operation'"
        ", 'usage_operation_update_time', 'private_dns_name_options', 'ipv6_address', 'tpm_support', 'maintenance_optio"
        "ns', 'current_instance_boot_mode', 'network_performance_options', 'operator', 'instance_id', 'image_id', 'stat"
        "e', 'private_dns_name', 'public_dns_name', 'state_transition_reason', 'key_name', 'ami_launch_index', 'product"
        "_codes', 'instance_type', 'launch_time', 'placement', 'kernel_id', 'ramdisk_id', 'platform', 'monitoring', 'su"
        "bnet_id', 'vpc_id', 'private_ip_address', 'public_ip_address')), FrozenPlan(fields=('__shape__', 'architecture"
        "', 'block_device_mappings', 'client_token', 'ebs_optimized', 'ena_support', 'hypervisor', 'iam_instance_profil"
        "e', 'instance_lifecycle', 'elastic_gpu_associations', 'elastic_inference_accelerator_associations', 'network_i"
        "nterfaces', 'outpost_arn', 'root_device_name', 'root_device_type', 'security_groups', 'source_dest_check', 'sp"
        "ot_instance_request_id', 'sriov_net_support', 'state_reason', 'tags', 'virtualization_type', 'cpu_options', 'c"
        "apacity_block_id', 'capacity_reservation_id', 'capacity_reservation_specification', 'hibernation_options', 'li"
        "censes', 'metadata_options', 'enclave_options', 'boot_mode', 'platform_details', 'usage_operation', 'usage_ope"
        "ration_update_time', 'private_dns_name_options', 'ipv6_address', 'tpm_support', 'maintenance_options', 'curren"
        "t_instance_boot_mode', 'network_performance_options', 'operator', 'instance_id', 'image_id', 'state', 'private"
        "_dns_name', 'public_dns_name', 'state_transition_reason', 'key_name', 'ami_launch_index', 'product_codes', 'in"
        "stance_type', 'launch_time', 'placement', 'kernel_id', 'ramdisk_id', 'platform', 'monitoring', 'subnet_id', 'v"
        "pc_id', 'private_ip_address', 'public_ip_address'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', "
        "fields=('architecture', 'block_device_mappings', 'client_token', 'ebs_optimized', 'ena_support', 'hypervisor',"
        " 'iam_instance_profile', 'instance_lifecycle', 'elastic_gpu_associations', 'elastic_inference_accelerator_asso"
        "ciations', 'network_interfaces', 'outpost_arn', 'root_device_name', 'root_device_type', 'security_groups', 'so"
        "urce_dest_check', 'spot_instance_request_id', 'sriov_net_support', 'state_reason', 'tags', 'virtualization_typ"
        "e', 'cpu_options', 'capacity_block_id', 'capacity_reservation_id', 'capacity_reservation_specification', 'hibe"
        "rnation_options', 'licenses', 'metadata_options', 'enclave_options', 'boot_mode', 'platform_details', 'usage_o"
        "peration', 'usage_operation_update_time', 'private_dns_name_options', 'ipv6_address', 'tpm_support', 'maintena"
        "nce_options', 'current_instance_boot_mode', 'network_performance_options', 'operator', 'instance_id', 'image_i"
        "d', 'state', 'private_dns_name', 'public_dns_name', 'state_transition_reason', 'key_name', 'ami_launch_index',"
        " 'product_codes', 'instance_type', 'launch_time', 'placement', 'kernel_id', 'ramdisk_id', 'platform', 'monitor"
        "ing', 'subnet_id', 'vpc_id', 'private_ip_address', 'public_ip_address'), cache=False), InitPlan(fields=(InitPl"
        "an.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='architecture', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init"
        ".fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='block_device_mappings', annotation=OpRef(name='init."
        "fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override="
        "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='clien"
        "t_token', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='ebs_optimized', annotation=OpRef(name='init.fields.4.annotation'), default=Op"
        "Ref(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
        "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_support', annotation=OpRef(name='i"
        "nit.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='h"
        "ypervisor', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
        "k_type=None), InitPlan.Field(name='iam_instance_profile', annotation=OpRef(name='init.fields.7.annotation'), d"
        "efault=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_lifecycle', annotati"
        "on=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='elastic_gpu_associations', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(nam"
        "e='init.fields.9.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='elastic_inference_accelerator_associations', "
        "annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='network_interfaces', annotation=OpRef(name='init.fields.11.annotation'), default=OpRe"
        "f(name='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='outpost_arn', annotation=OpRef(name='in"
        "it.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True, over"
        "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "root_device_name', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13.defa"
        "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
        "one, check_type=None), InitPlan.Field(name='root_device_type', annotation=OpRef(name='init.fields.14.annotatio"
        "n'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=False, field_type"
        "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='security_groups', anno"
        "tation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), default_factory="
        "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
        "InitPlan.Field(name='source_dest_check', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef(nam"
        "e='init.fields.16.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
        "oerce=None, validate=None, check_type=None), InitPlan.Field(name='spot_instance_request_id', annotation=OpRef("
        "name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='sriov_net_support', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.field"
        "s.18.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None), InitPlan.Field(name='state_reason', annotation=OpRef(name='init.fields.19.anno"
        "tation'), default=OpRef(name='init.fields.19.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags', annotation"
        "=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.fields.20.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='virtualization_type', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='i"
        "nit.fields.21.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
        "e=None, validate=None, check_type=None), InitPlan.Field(name='cpu_options', annotation=OpRef(name='init.fields"
        ".22.annotation'), default=OpRef(name='init.fields.22.default'), default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='capacity_"
        "block_id', annotation=OpRef(name='init.fields.23.annotation'), default=OpRef(name='init.fields.23.default'), d"
        "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='capacity_reservation_id', annotation=OpRef(name='init.fields.24.annotation"
        "'), default=OpRef(name='init.fields.24.default'), default_factory=None, init=True, override=False, field_type="
        "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='capacity_reservation_sp"
        "ecification', annotation=OpRef(name='init.fields.25.annotation'), default=OpRef(name='init.fields.25.default')"
        ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='hibernation_options', annotation=OpRef(name='init.fields.26.annotation'"
        "), default=OpRef(name='init.fields.26.default'), default_factory=None, init=True, override=False, field_type=F"
        "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='licenses', annotation=Op"
        "Ref(name='init.fields.27.annotation'), default=OpRef(name='init.fields.27.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='metadata_options', annotation=OpRef(name='init.fields.28.annotation'), default=OpRef(name='init.fi"
        "elds.28.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='enclave_options', annotation=OpRef(name='init.fields.2"
        "9.annotation'), default=OpRef(name='init.fields.29.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='boot_mode',"
        " annotation=OpRef(name='init.fields.30.annotation'), default=OpRef(name='init.fields.30.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='platform_details', annotation=OpRef(name='init.fields.31.annotation'), default=OpRef"
        "(name='init.fields.31.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
        "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='usage_operation', annotation=OpRef(name="
        "'init.fields.32.annotation'), default=OpRef(name='init.fields.32.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='usage_operation_update_time', annotation=OpRef(name='init.fields.33.annotation'), default=OpRef(name='init."
        "fields.33.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='private_dns_name_options', annotation=OpRef(name='in"
        "it.fields.34.annotation'), default=OpRef(name='init.fields.34.default'), default_factory=None, init=True, over"
        "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "ipv6_address', annotation=OpRef(name='init.fields.35.annotation'), default=OpRef(name='init.fields.35.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='tpm_support', annotation=OpRef(name='init.fields.36.annotation'), defa"
        "ult=OpRef(name='init.fields.36.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maintenance_options', annotatio"
        "n=OpRef(name='init.fields.37.annotation'), default=OpRef(name='init.fields.37.default'), default_factory=None,"
        " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
        "lan.Field(name='current_instance_boot_mode', annotation=OpRef(name='init.fields.38.annotation'), default=OpRef"
        "(name='init.fields.38.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
        "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_performance_options', annotation"
        "=OpRef(name='init.fields.39.annotation'), default=OpRef(name='init.fields.39.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='operator', annotation=OpRef(name='init.fields.40.annotation'), default=OpRef(name='init.fields."
        "40.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='instance_id', annotation=OpRef(name='init.fields.41.annotat"
        "ion'), default=OpRef(name='init.fields.41.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='image_id', annotatio"
        "n=OpRef(name='init.fields.42.annotation'), default=OpRef(name='init.fields.42.default'), default_factory=None,"
        " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
        "lan.Field(name='state', annotation=OpRef(name='init.fields.43.annotation'), default=OpRef(name='init.fields.43"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None), InitPlan.Field(name='private_dns_name', annotation=OpRef(name='init.fields.44.anno"
        "tation'), default=OpRef(name='init.fields.44.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_dns_name',"
        " annotation=OpRef(name='init.fields.45.annotation'), default=OpRef(name='init.fields.45.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='state_transition_reason', annotation=OpRef(name='init.fields.46.annotation'), defaul"
        "t=OpRef(name='init.fields.46.default'), default_factory=None, init=True, override=False, field_type=FieldType."
        "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='key_name', annotation=OpRef(name="
        "'init.fields.47.annotation'), default=OpRef(name='init.fields.47.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='ami_launch_index', annotation=OpRef(name='init.fields.48.annotation'), default=OpRef(name='init.fields.48.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='product_codes', annotation=OpRef(name='init.fields.49.annotatio"
        "n'), default=OpRef(name='init.fields.49.default'), default_factory=None, init=True, override=False, field_type"
        "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_type', annota"
        "tion=OpRef(name='init.fields.50.annotation'), default=OpRef(name='init.fields.50.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='launch_time', annotation=OpRef(name='init.fields.51.annotation'), default=OpRef(name='init."
        "fields.51.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='placement', annotation=OpRef(name='init.fields.52.an"
        "notation'), default=OpRef(name='init.fields.52.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='kernel_id', ann"
        "otation=OpRef(name='init.fields.53.annotation'), default=OpRef(name='init.fields.53.default'), default_factory"
        "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
        " InitPlan.Field(name='ramdisk_id', annotation=OpRef(name='init.fields.54.annotation'), default=OpRef(name='ini"
        "t.fields.54.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='platform', annotation=OpRef(name='init.fields.55.a"
        "nnotation'), default=OpRef(name='init.fields.55.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='monitoring', a"
        "nnotation=OpRef(name='init.fields.56.annotation'), default=OpRef(name='init.fields.56.default'), default_facto"
        "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
        "), InitPlan.Field(name='subnet_id', annotation=OpRef(name='init.fields.57.annotation'), default=OpRef(name='in"
        "it.fields.57.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.58.an"
        "notation'), default=OpRef(name='init.fields.58.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='private_ip_addr"
        "ess', annotation=OpRef(name='init.fields.59.annotation'), default=OpRef(name='init.fields.59.default'), defaul"
        "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
        "pe=None), InitPlan.Field(name='public_ip_address', annotation=OpRef(name='init.fields.60.annotation'), default"
        "=OpRef(name='init.fields.60.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
        "NSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('arc"
        "hitecture', 'block_device_mappings', 'client_token', 'ebs_optimized', 'ena_support', 'hypervisor', 'iam_instan"
        "ce_profile', 'instance_lifecycle', 'elastic_gpu_associations', 'elastic_inference_accelerator_associations', '"
        "network_interfaces', 'outpost_arn', 'root_device_name', 'root_device_type', 'security_groups', 'source_dest_ch"
        "eck', 'spot_instance_request_id', 'sriov_net_support', 'state_reason', 'tags', 'virtualization_type', 'cpu_opt"
        "ions', 'capacity_block_id', 'capacity_reservation_id', 'capacity_reservation_specification', 'hibernation_opti"
        "ons', 'licenses', 'metadata_options', 'enclave_options', 'boot_mode', 'platform_details', 'usage_operation', '"
        "usage_operation_update_time', 'private_dns_name_options', 'ipv6_address', 'tpm_support', 'maintenance_options'"
        ", 'current_instance_boot_mode', 'network_performance_options', 'operator', 'instance_id', 'image_id', 'state',"
        " 'private_dns_name', 'public_dns_name', 'state_transition_reason', 'key_name', 'ami_launch_index', 'product_co"
        "des', 'instance_type', 'launch_time', 'placement', 'kernel_id', 'ramdisk_id', 'platform', 'monitoring', 'subne"
        "t_id', 'vpc_id', 'private_ip_address', 'public_ip_address'), frozen=True, slots=False, post_init_params=None, "
        "init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='architecture', kw_only=True, fn=None), Re"
        "prPlan.Field(name='block_device_mappings', kw_only=True, fn=None), ReprPlan.Field(name='client_token', kw_only"
        "=True, fn=None), ReprPlan.Field(name='ebs_optimized', kw_only=True, fn=None), ReprPlan.Field(name='ena_support"
        "', kw_only=True, fn=None), ReprPlan.Field(name='hypervisor', kw_only=True, fn=None), ReprPlan.Field(name='iam_"
        "instance_profile', kw_only=True, fn=None), ReprPlan.Field(name='instance_lifecycle', kw_only=True, fn=None), R"
        "eprPlan.Field(name='elastic_gpu_associations', kw_only=True, fn=None), ReprPlan.Field(name='elastic_inference_"
        "accelerator_associations', kw_only=True, fn=None), ReprPlan.Field(name='network_interfaces', kw_only=True, fn="
        "None), ReprPlan.Field(name='outpost_arn', kw_only=True, fn=None), ReprPlan.Field(name='root_device_name', kw_o"
        "nly=True, fn=None), ReprPlan.Field(name='root_device_type', kw_only=True, fn=None), ReprPlan.Field(name='secur"
        "ity_groups', kw_only=True, fn=None), ReprPlan.Field(name='source_dest_check', kw_only=True, fn=None), ReprPlan"
        ".Field(name='spot_instance_request_id', kw_only=True, fn=None), ReprPlan.Field(name='sriov_net_support', kw_on"
        "ly=True, fn=None), ReprPlan.Field(name='state_reason', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_"
        "only=True, fn=None), ReprPlan.Field(name='virtualization_type', kw_only=True, fn=None), ReprPlan.Field(name='c"
        "pu_options', kw_only=True, fn=None), ReprPlan.Field(name='capacity_block_id', kw_only=True, fn=None), ReprPlan"
        ".Field(name='capacity_reservation_id', kw_only=True, fn=None), ReprPlan.Field(name='capacity_reservation_speci"
        "fication', kw_only=True, fn=None), ReprPlan.Field(name='hibernation_options', kw_only=True, fn=None), ReprPlan"
        ".Field(name='licenses', kw_only=True, fn=None), ReprPlan.Field(name='metadata_options', kw_only=True, fn=None)"
        ", ReprPlan.Field(name='enclave_options', kw_only=True, fn=None), ReprPlan.Field(name='boot_mode', kw_only=True"
        ", fn=None), ReprPlan.Field(name='platform_details', kw_only=True, fn=None), ReprPlan.Field(name='usage_operati"
        "on', kw_only=True, fn=None), ReprPlan.Field(name='usage_operation_update_time', kw_only=True, fn=None), ReprPl"
        "an.Field(name='private_dns_name_options', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_address', kw_only="
        "True, fn=None), ReprPlan.Field(name='tpm_support', kw_only=True, fn=None), ReprPlan.Field(name='maintenance_op"
        "tions', kw_only=True, fn=None), ReprPlan.Field(name='current_instance_boot_mode', kw_only=True, fn=None), Repr"
        "Plan.Field(name='network_performance_options', kw_only=True, fn=None), ReprPlan.Field(name='operator', kw_only"
        "=True, fn=None), ReprPlan.Field(name='instance_id', kw_only=True, fn=None), ReprPlan.Field(name='image_id', kw"
        "_only=True, fn=None), ReprPlan.Field(name='state', kw_only=True, fn=None), ReprPlan.Field(name='private_dns_na"
        "me', kw_only=True, fn=None), ReprPlan.Field(name='public_dns_name', kw_only=True, fn=None), ReprPlan.Field(nam"
        "e='state_transition_reason', kw_only=True, fn=None), ReprPlan.Field(name='key_name', kw_only=True, fn=None), R"
        "eprPlan.Field(name='ami_launch_index', kw_only=True, fn=None), ReprPlan.Field(name='product_codes', kw_only=Tr"
        "ue, fn=None), ReprPlan.Field(name='instance_type', kw_only=True, fn=None), ReprPlan.Field(name='launch_time', "
        "kw_only=True, fn=None), ReprPlan.Field(name='placement', kw_only=True, fn=None), ReprPlan.Field(name='kernel_i"
        "d', kw_only=True, fn=None), ReprPlan.Field(name='ramdisk_id', kw_only=True, fn=None), ReprPlan.Field(name='pla"
        "tform', kw_only=True, fn=None), ReprPlan.Field(name='monitoring', kw_only=True, fn=None), ReprPlan.Field(name="
        "'subnet_id', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPlan.Field(name"
        "='private_ip_address', kw_only=True, fn=None), ReprPlan.Field(name='public_ip_address', kw_only=True, fn=None)"
        "), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d45987ff0590fa3929458ba88230e38e2606ca1b',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__24__annotation',
        '__dataclass__init__fields__24__default',
        '__dataclass__init__fields__25__annotation',
        '__dataclass__init__fields__25__default',
        '__dataclass__init__fields__26__annotation',
        '__dataclass__init__fields__26__default',
        '__dataclass__init__fields__27__annotation',
        '__dataclass__init__fields__27__default',
        '__dataclass__init__fields__28__annotation',
        '__dataclass__init__fields__28__default',
        '__dataclass__init__fields__29__annotation',
        '__dataclass__init__fields__29__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__30__annotation',
        '__dataclass__init__fields__30__default',
        '__dataclass__init__fields__31__annotation',
        '__dataclass__init__fields__31__default',
        '__dataclass__init__fields__32__annotation',
        '__dataclass__init__fields__32__default',
        '__dataclass__init__fields__33__annotation',
        '__dataclass__init__fields__33__default',
        '__dataclass__init__fields__34__annotation',
        '__dataclass__init__fields__34__default',
        '__dataclass__init__fields__35__annotation',
        '__dataclass__init__fields__35__default',
        '__dataclass__init__fields__36__annotation',
        '__dataclass__init__fields__36__default',
        '__dataclass__init__fields__37__annotation',
        '__dataclass__init__fields__37__default',
        '__dataclass__init__fields__38__annotation',
        '__dataclass__init__fields__38__default',
        '__dataclass__init__fields__39__annotation',
        '__dataclass__init__fields__39__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__40__annotation',
        '__dataclass__init__fields__40__default',
        '__dataclass__init__fields__41__annotation',
        '__dataclass__init__fields__41__default',
        '__dataclass__init__fields__42__annotation',
        '__dataclass__init__fields__42__default',
        '__dataclass__init__fields__43__annotation',
        '__dataclass__init__fields__43__default',
        '__dataclass__init__fields__44__annotation',
        '__dataclass__init__fields__44__default',
        '__dataclass__init__fields__45__annotation',
        '__dataclass__init__fields__45__default',
        '__dataclass__init__fields__46__annotation',
        '__dataclass__init__fields__46__default',
        '__dataclass__init__fields__47__annotation',
        '__dataclass__init__fields__47__default',
        '__dataclass__init__fields__48__annotation',
        '__dataclass__init__fields__48__default',
        '__dataclass__init__fields__49__annotation',
        '__dataclass__init__fields__49__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__50__annotation',
        '__dataclass__init__fields__50__default',
        '__dataclass__init__fields__51__annotation',
        '__dataclass__init__fields__51__default',
        '__dataclass__init__fields__52__annotation',
        '__dataclass__init__fields__52__default',
        '__dataclass__init__fields__53__annotation',
        '__dataclass__init__fields__53__default',
        '__dataclass__init__fields__54__annotation',
        '__dataclass__init__fields__54__default',
        '__dataclass__init__fields__55__annotation',
        '__dataclass__init__fields__55__default',
        '__dataclass__init__fields__56__annotation',
        '__dataclass__init__fields__56__default',
        '__dataclass__init__fields__57__annotation',
        '__dataclass__init__fields__57__default',
        '__dataclass__init__fields__58__annotation',
        '__dataclass__init__fields__58__default',
        '__dataclass__init__fields__59__annotation',
        '__dataclass__init__fields__59__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__60__annotation',
        '__dataclass__init__fields__60__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Instance'),
    ),
)
def _process_dataclass__d45987ff0590fa3929458ba88230e38e2606ca1b():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__24__annotation,
        __dataclass__init__fields__24__default,
        __dataclass__init__fields__25__annotation,
        __dataclass__init__fields__25__default,
        __dataclass__init__fields__26__annotation,
        __dataclass__init__fields__26__default,
        __dataclass__init__fields__27__annotation,
        __dataclass__init__fields__27__default,
        __dataclass__init__fields__28__annotation,
        __dataclass__init__fields__28__default,
        __dataclass__init__fields__29__annotation,
        __dataclass__init__fields__29__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__30__annotation,
        __dataclass__init__fields__30__default,
        __dataclass__init__fields__31__annotation,
        __dataclass__init__fields__31__default,
        __dataclass__init__fields__32__annotation,
        __dataclass__init__fields__32__default,
        __dataclass__init__fields__33__annotation,
        __dataclass__init__fields__33__default,
        __dataclass__init__fields__34__annotation,
        __dataclass__init__fields__34__default,
        __dataclass__init__fields__35__annotation,
        __dataclass__init__fields__35__default,
        __dataclass__init__fields__36__annotation,
        __dataclass__init__fields__36__default,
        __dataclass__init__fields__37__annotation,
        __dataclass__init__fields__37__default,
        __dataclass__init__fields__38__annotation,
        __dataclass__init__fields__38__default,
        __dataclass__init__fields__39__annotation,
        __dataclass__init__fields__39__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__40__annotation,
        __dataclass__init__fields__40__default,
        __dataclass__init__fields__41__annotation,
        __dataclass__init__fields__41__default,
        __dataclass__init__fields__42__annotation,
        __dataclass__init__fields__42__default,
        __dataclass__init__fields__43__annotation,
        __dataclass__init__fields__43__default,
        __dataclass__init__fields__44__annotation,
        __dataclass__init__fields__44__default,
        __dataclass__init__fields__45__annotation,
        __dataclass__init__fields__45__default,
        __dataclass__init__fields__46__annotation,
        __dataclass__init__fields__46__default,
        __dataclass__init__fields__47__annotation,
        __dataclass__init__fields__47__default,
        __dataclass__init__fields__48__annotation,
        __dataclass__init__fields__48__default,
        __dataclass__init__fields__49__annotation,
        __dataclass__init__fields__49__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__50__annotation,
        __dataclass__init__fields__50__default,
        __dataclass__init__fields__51__annotation,
        __dataclass__init__fields__51__default,
        __dataclass__init__fields__52__annotation,
        __dataclass__init__fields__52__default,
        __dataclass__init__fields__53__annotation,
        __dataclass__init__fields__53__default,
        __dataclass__init__fields__54__annotation,
        __dataclass__init__fields__54__default,
        __dataclass__init__fields__55__annotation,
        __dataclass__init__fields__55__default,
        __dataclass__init__fields__56__annotation,
        __dataclass__init__fields__56__default,
        __dataclass__init__fields__57__annotation,
        __dataclass__init__fields__57__default,
        __dataclass__init__fields__58__annotation,
        __dataclass__init__fields__58__default,
        __dataclass__init__fields__59__annotation,
        __dataclass__init__fields__59__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__60__annotation,
        __dataclass__init__fields__60__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                architecture=self.architecture,
                block_device_mappings=self.block_device_mappings,
                client_token=self.client_token,
                ebs_optimized=self.ebs_optimized,
                ena_support=self.ena_support,
                hypervisor=self.hypervisor,
                iam_instance_profile=self.iam_instance_profile,
                instance_lifecycle=self.instance_lifecycle,
                elastic_gpu_associations=self.elastic_gpu_associations,
                elastic_inference_accelerator_associations=self.elastic_inference_accelerator_associations,
                network_interfaces=self.network_interfaces,
                outpost_arn=self.outpost_arn,
                root_device_name=self.root_device_name,
                root_device_type=self.root_device_type,
                security_groups=self.security_groups,
                source_dest_check=self.source_dest_check,
                spot_instance_request_id=self.spot_instance_request_id,
                sriov_net_support=self.sriov_net_support,
                state_reason=self.state_reason,
                tags=self.tags,
                virtualization_type=self.virtualization_type,
                cpu_options=self.cpu_options,
                capacity_block_id=self.capacity_block_id,
                capacity_reservation_id=self.capacity_reservation_id,
                capacity_reservation_specification=self.capacity_reservation_specification,
                hibernation_options=self.hibernation_options,
                licenses=self.licenses,
                metadata_options=self.metadata_options,
                enclave_options=self.enclave_options,
                boot_mode=self.boot_mode,
                platform_details=self.platform_details,
                usage_operation=self.usage_operation,
                usage_operation_update_time=self.usage_operation_update_time,
                private_dns_name_options=self.private_dns_name_options,
                ipv6_address=self.ipv6_address,
                tpm_support=self.tpm_support,
                maintenance_options=self.maintenance_options,
                current_instance_boot_mode=self.current_instance_boot_mode,
                network_performance_options=self.network_performance_options,
                operator=self.operator,
                instance_id=self.instance_id,
                image_id=self.image_id,
                state=self.state,
                private_dns_name=self.private_dns_name,
                public_dns_name=self.public_dns_name,
                state_transition_reason=self.state_transition_reason,
                key_name=self.key_name,
                ami_launch_index=self.ami_launch_index,
                product_codes=self.product_codes,
                instance_type=self.instance_type,
                launch_time=self.launch_time,
                placement=self.placement,
                kernel_id=self.kernel_id,
                ramdisk_id=self.ramdisk_id,
                platform=self.platform,
                monitoring=self.monitoring,
                subnet_id=self.subnet_id,
                vpc_id=self.vpc_id,
                private_ip_address=self.private_ip_address,
                public_ip_address=self.public_ip_address,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.architecture == other.architecture and
                self.block_device_mappings == other.block_device_mappings and
                self.client_token == other.client_token and
                self.ebs_optimized == other.ebs_optimized and
                self.ena_support == other.ena_support and
                self.hypervisor == other.hypervisor and
                self.iam_instance_profile == other.iam_instance_profile and
                self.instance_lifecycle == other.instance_lifecycle and
                self.elastic_gpu_associations == other.elastic_gpu_associations and
                self.elastic_inference_accelerator_associations == other.elastic_inference_accelerator_associations and
                self.network_interfaces == other.network_interfaces and
                self.outpost_arn == other.outpost_arn and
                self.root_device_name == other.root_device_name and
                self.root_device_type == other.root_device_type and
                self.security_groups == other.security_groups and
                self.source_dest_check == other.source_dest_check and
                self.spot_instance_request_id == other.spot_instance_request_id and
                self.sriov_net_support == other.sriov_net_support and
                self.state_reason == other.state_reason and
                self.tags == other.tags and
                self.virtualization_type == other.virtualization_type and
                self.cpu_options == other.cpu_options and
                self.capacity_block_id == other.capacity_block_id and
                self.capacity_reservation_id == other.capacity_reservation_id and
                self.capacity_reservation_specification == other.capacity_reservation_specification and
                self.hibernation_options == other.hibernation_options and
                self.licenses == other.licenses and
                self.metadata_options == other.metadata_options and
                self.enclave_options == other.enclave_options and
                self.boot_mode == other.boot_mode and
                self.platform_details == other.platform_details and
                self.usage_operation == other.usage_operation and
                self.usage_operation_update_time == other.usage_operation_update_time and
                self.private_dns_name_options == other.private_dns_name_options and
                self.ipv6_address == other.ipv6_address and
                self.tpm_support == other.tpm_support and
                self.maintenance_options == other.maintenance_options and
                self.current_instance_boot_mode == other.current_instance_boot_mode and
                self.network_performance_options == other.network_performance_options and
                self.operator == other.operator and
                self.instance_id == other.instance_id and
                self.image_id == other.image_id and
                self.state == other.state and
                self.private_dns_name == other.private_dns_name and
                self.public_dns_name == other.public_dns_name and
                self.state_transition_reason == other.state_transition_reason and
                self.key_name == other.key_name and
                self.ami_launch_index == other.ami_launch_index and
                self.product_codes == other.product_codes and
                self.instance_type == other.instance_type and
                self.launch_time == other.launch_time and
                self.placement == other.placement and
                self.kernel_id == other.kernel_id and
                self.ramdisk_id == other.ramdisk_id and
                self.platform == other.platform and
                self.monitoring == other.monitoring and
                self.subnet_id == other.subnet_id and
                self.vpc_id == other.vpc_id and
                self.private_ip_address == other.private_ip_address and
                self.public_ip_address == other.public_ip_address
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'architecture',
            'block_device_mappings',
            'client_token',
            'ebs_optimized',
            'ena_support',
            'hypervisor',
            'iam_instance_profile',
            'instance_lifecycle',
            'elastic_gpu_associations',
            'elastic_inference_accelerator_associations',
            'network_interfaces',
            'outpost_arn',
            'root_device_name',
            'root_device_type',
            'security_groups',
            'source_dest_check',
            'spot_instance_request_id',
            'sriov_net_support',
            'state_reason',
            'tags',
            'virtualization_type',
            'cpu_options',
            'capacity_block_id',
            'capacity_reservation_id',
            'capacity_reservation_specification',
            'hibernation_options',
            'licenses',
            'metadata_options',
            'enclave_options',
            'boot_mode',
            'platform_details',
            'usage_operation',
            'usage_operation_update_time',
            'private_dns_name_options',
            'ipv6_address',
            'tpm_support',
            'maintenance_options',
            'current_instance_boot_mode',
            'network_performance_options',
            'operator',
            'instance_id',
            'image_id',
            'state',
            'private_dns_name',
            'public_dns_name',
            'state_transition_reason',
            'key_name',
            'ami_launch_index',
            'product_codes',
            'instance_type',
            'launch_time',
            'placement',
            'kernel_id',
            'ramdisk_id',
            'platform',
            'monitoring',
            'subnet_id',
            'vpc_id',
            'private_ip_address',
            'public_ip_address',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'architecture',
            'block_device_mappings',
            'client_token',
            'ebs_optimized',
            'ena_support',
            'hypervisor',
            'iam_instance_profile',
            'instance_lifecycle',
            'elastic_gpu_associations',
            'elastic_inference_accelerator_associations',
            'network_interfaces',
            'outpost_arn',
            'root_device_name',
            'root_device_type',
            'security_groups',
            'source_dest_check',
            'spot_instance_request_id',
            'sriov_net_support',
            'state_reason',
            'tags',
            'virtualization_type',
            'cpu_options',
            'capacity_block_id',
            'capacity_reservation_id',
            'capacity_reservation_specification',
            'hibernation_options',
            'licenses',
            'metadata_options',
            'enclave_options',
            'boot_mode',
            'platform_details',
            'usage_operation',
            'usage_operation_update_time',
            'private_dns_name_options',
            'ipv6_address',
            'tpm_support',
            'maintenance_options',
            'current_instance_boot_mode',
            'network_performance_options',
            'operator',
            'instance_id',
            'image_id',
            'state',
            'private_dns_name',
            'public_dns_name',
            'state_transition_reason',
            'key_name',
            'ami_launch_index',
            'product_codes',
            'instance_type',
            'launch_time',
            'placement',
            'kernel_id',
            'ramdisk_id',
            'platform',
            'monitoring',
            'subnet_id',
            'vpc_id',
            'private_ip_address',
            'public_ip_address',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.architecture,
                self.block_device_mappings,
                self.client_token,
                self.ebs_optimized,
                self.ena_support,
                self.hypervisor,
                self.iam_instance_profile,
                self.instance_lifecycle,
                self.elastic_gpu_associations,
                self.elastic_inference_accelerator_associations,
                self.network_interfaces,
                self.outpost_arn,
                self.root_device_name,
                self.root_device_type,
                self.security_groups,
                self.source_dest_check,
                self.spot_instance_request_id,
                self.sriov_net_support,
                self.state_reason,
                self.tags,
                self.virtualization_type,
                self.cpu_options,
                self.capacity_block_id,
                self.capacity_reservation_id,
                self.capacity_reservation_specification,
                self.hibernation_options,
                self.licenses,
                self.metadata_options,
                self.enclave_options,
                self.boot_mode,
                self.platform_details,
                self.usage_operation,
                self.usage_operation_update_time,
                self.private_dns_name_options,
                self.ipv6_address,
                self.tpm_support,
                self.maintenance_options,
                self.current_instance_boot_mode,
                self.network_performance_options,
                self.operator,
                self.instance_id,
                self.image_id,
                self.state,
                self.private_dns_name,
                self.public_dns_name,
                self.state_transition_reason,
                self.key_name,
                self.ami_launch_index,
                self.product_codes,
                self.instance_type,
                self.launch_time,
                self.placement,
                self.kernel_id,
                self.ramdisk_id,
                self.platform,
                self.monitoring,
                self.subnet_id,
                self.vpc_id,
                self.private_ip_address,
                self.public_ip_address,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            architecture: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            block_device_mappings: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            client_token: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            ebs_optimized: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            ena_support: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            hypervisor: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            iam_instance_profile: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            instance_lifecycle: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            elastic_gpu_associations: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            elastic_inference_accelerator_associations: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            network_interfaces: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            outpost_arn: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            root_device_name: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            root_device_type: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            security_groups: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            source_dest_check: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            spot_instance_request_id: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            sriov_net_support: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            state_reason: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            tags: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            virtualization_type: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            cpu_options: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            capacity_block_id: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
            capacity_reservation_id: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
            capacity_reservation_specification: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
            hibernation_options: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
            licenses: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
            metadata_options: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
            enclave_options: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
            boot_mode: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
            platform_details: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
            usage_operation: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
            usage_operation_update_time: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
            private_dns_name_options: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
            ipv6_address: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
            tpm_support: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
            maintenance_options: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
            current_instance_boot_mode: __dataclass__init__fields__38__annotation = __dataclass__init__fields__38__default,
            network_performance_options: __dataclass__init__fields__39__annotation = __dataclass__init__fields__39__default,
            operator: __dataclass__init__fields__40__annotation = __dataclass__init__fields__40__default,
            instance_id: __dataclass__init__fields__41__annotation = __dataclass__init__fields__41__default,
            image_id: __dataclass__init__fields__42__annotation = __dataclass__init__fields__42__default,
            state: __dataclass__init__fields__43__annotation = __dataclass__init__fields__43__default,
            private_dns_name: __dataclass__init__fields__44__annotation = __dataclass__init__fields__44__default,
            public_dns_name: __dataclass__init__fields__45__annotation = __dataclass__init__fields__45__default,
            state_transition_reason: __dataclass__init__fields__46__annotation = __dataclass__init__fields__46__default,
            key_name: __dataclass__init__fields__47__annotation = __dataclass__init__fields__47__default,
            ami_launch_index: __dataclass__init__fields__48__annotation = __dataclass__init__fields__48__default,
            product_codes: __dataclass__init__fields__49__annotation = __dataclass__init__fields__49__default,
            instance_type: __dataclass__init__fields__50__annotation = __dataclass__init__fields__50__default,
            launch_time: __dataclass__init__fields__51__annotation = __dataclass__init__fields__51__default,
            placement: __dataclass__init__fields__52__annotation = __dataclass__init__fields__52__default,
            kernel_id: __dataclass__init__fields__53__annotation = __dataclass__init__fields__53__default,
            ramdisk_id: __dataclass__init__fields__54__annotation = __dataclass__init__fields__54__default,
            platform: __dataclass__init__fields__55__annotation = __dataclass__init__fields__55__default,
            monitoring: __dataclass__init__fields__56__annotation = __dataclass__init__fields__56__default,
            subnet_id: __dataclass__init__fields__57__annotation = __dataclass__init__fields__57__default,
            vpc_id: __dataclass__init__fields__58__annotation = __dataclass__init__fields__58__default,
            private_ip_address: __dataclass__init__fields__59__annotation = __dataclass__init__fields__59__default,
            public_ip_address: __dataclass__init__fields__60__annotation = __dataclass__init__fields__60__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'architecture', architecture)
            __dataclass__object_setattr(self, 'block_device_mappings', block_device_mappings)
            __dataclass__object_setattr(self, 'client_token', client_token)
            __dataclass__object_setattr(self, 'ebs_optimized', ebs_optimized)
            __dataclass__object_setattr(self, 'ena_support', ena_support)
            __dataclass__object_setattr(self, 'hypervisor', hypervisor)
            __dataclass__object_setattr(self, 'iam_instance_profile', iam_instance_profile)
            __dataclass__object_setattr(self, 'instance_lifecycle', instance_lifecycle)
            __dataclass__object_setattr(self, 'elastic_gpu_associations', elastic_gpu_associations)
            __dataclass__object_setattr(self, 'elastic_inference_accelerator_associations', elastic_inference_accelerator_associations)
            __dataclass__object_setattr(self, 'network_interfaces', network_interfaces)
            __dataclass__object_setattr(self, 'outpost_arn', outpost_arn)
            __dataclass__object_setattr(self, 'root_device_name', root_device_name)
            __dataclass__object_setattr(self, 'root_device_type', root_device_type)
            __dataclass__object_setattr(self, 'security_groups', security_groups)
            __dataclass__object_setattr(self, 'source_dest_check', source_dest_check)
            __dataclass__object_setattr(self, 'spot_instance_request_id', spot_instance_request_id)
            __dataclass__object_setattr(self, 'sriov_net_support', sriov_net_support)
            __dataclass__object_setattr(self, 'state_reason', state_reason)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'virtualization_type', virtualization_type)
            __dataclass__object_setattr(self, 'cpu_options', cpu_options)
            __dataclass__object_setattr(self, 'capacity_block_id', capacity_block_id)
            __dataclass__object_setattr(self, 'capacity_reservation_id', capacity_reservation_id)
            __dataclass__object_setattr(self, 'capacity_reservation_specification', capacity_reservation_specification)
            __dataclass__object_setattr(self, 'hibernation_options', hibernation_options)
            __dataclass__object_setattr(self, 'licenses', licenses)
            __dataclass__object_setattr(self, 'metadata_options', metadata_options)
            __dataclass__object_setattr(self, 'enclave_options', enclave_options)
            __dataclass__object_setattr(self, 'boot_mode', boot_mode)
            __dataclass__object_setattr(self, 'platform_details', platform_details)
            __dataclass__object_setattr(self, 'usage_operation', usage_operation)
            __dataclass__object_setattr(self, 'usage_operation_update_time', usage_operation_update_time)
            __dataclass__object_setattr(self, 'private_dns_name_options', private_dns_name_options)
            __dataclass__object_setattr(self, 'ipv6_address', ipv6_address)
            __dataclass__object_setattr(self, 'tpm_support', tpm_support)
            __dataclass__object_setattr(self, 'maintenance_options', maintenance_options)
            __dataclass__object_setattr(self, 'current_instance_boot_mode', current_instance_boot_mode)
            __dataclass__object_setattr(self, 'network_performance_options', network_performance_options)
            __dataclass__object_setattr(self, 'operator', operator)
            __dataclass__object_setattr(self, 'instance_id', instance_id)
            __dataclass__object_setattr(self, 'image_id', image_id)
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'private_dns_name', private_dns_name)
            __dataclass__object_setattr(self, 'public_dns_name', public_dns_name)
            __dataclass__object_setattr(self, 'state_transition_reason', state_transition_reason)
            __dataclass__object_setattr(self, 'key_name', key_name)
            __dataclass__object_setattr(self, 'ami_launch_index', ami_launch_index)
            __dataclass__object_setattr(self, 'product_codes', product_codes)
            __dataclass__object_setattr(self, 'instance_type', instance_type)
            __dataclass__object_setattr(self, 'launch_time', launch_time)
            __dataclass__object_setattr(self, 'placement', placement)
            __dataclass__object_setattr(self, 'kernel_id', kernel_id)
            __dataclass__object_setattr(self, 'ramdisk_id', ramdisk_id)
            __dataclass__object_setattr(self, 'platform', platform)
            __dataclass__object_setattr(self, 'monitoring', monitoring)
            __dataclass__object_setattr(self, 'subnet_id', subnet_id)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)
            __dataclass__object_setattr(self, 'public_ip_address', public_ip_address)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"architecture={self.architecture!r}")
            parts.append(f"block_device_mappings={self.block_device_mappings!r}")
            parts.append(f"client_token={self.client_token!r}")
            parts.append(f"ebs_optimized={self.ebs_optimized!r}")
            parts.append(f"ena_support={self.ena_support!r}")
            parts.append(f"hypervisor={self.hypervisor!r}")
            parts.append(f"iam_instance_profile={self.iam_instance_profile!r}")
            parts.append(f"instance_lifecycle={self.instance_lifecycle!r}")
            parts.append(f"elastic_gpu_associations={self.elastic_gpu_associations!r}")
            parts.append(f"elastic_inference_accelerator_associations={self.elastic_inference_accelerator_associations!r}")
            parts.append(f"network_interfaces={self.network_interfaces!r}")
            parts.append(f"outpost_arn={self.outpost_arn!r}")
            parts.append(f"root_device_name={self.root_device_name!r}")
            parts.append(f"root_device_type={self.root_device_type!r}")
            parts.append(f"security_groups={self.security_groups!r}")
            parts.append(f"source_dest_check={self.source_dest_check!r}")
            parts.append(f"spot_instance_request_id={self.spot_instance_request_id!r}")
            parts.append(f"sriov_net_support={self.sriov_net_support!r}")
            parts.append(f"state_reason={self.state_reason!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"virtualization_type={self.virtualization_type!r}")
            parts.append(f"cpu_options={self.cpu_options!r}")
            parts.append(f"capacity_block_id={self.capacity_block_id!r}")
            parts.append(f"capacity_reservation_id={self.capacity_reservation_id!r}")
            parts.append(f"capacity_reservation_specification={self.capacity_reservation_specification!r}")
            parts.append(f"hibernation_options={self.hibernation_options!r}")
            parts.append(f"licenses={self.licenses!r}")
            parts.append(f"metadata_options={self.metadata_options!r}")
            parts.append(f"enclave_options={self.enclave_options!r}")
            parts.append(f"boot_mode={self.boot_mode!r}")
            parts.append(f"platform_details={self.platform_details!r}")
            parts.append(f"usage_operation={self.usage_operation!r}")
            parts.append(f"usage_operation_update_time={self.usage_operation_update_time!r}")
            parts.append(f"private_dns_name_options={self.private_dns_name_options!r}")
            parts.append(f"ipv6_address={self.ipv6_address!r}")
            parts.append(f"tpm_support={self.tpm_support!r}")
            parts.append(f"maintenance_options={self.maintenance_options!r}")
            parts.append(f"current_instance_boot_mode={self.current_instance_boot_mode!r}")
            parts.append(f"network_performance_options={self.network_performance_options!r}")
            parts.append(f"operator={self.operator!r}")
            parts.append(f"instance_id={self.instance_id!r}")
            parts.append(f"image_id={self.image_id!r}")
            parts.append(f"state={self.state!r}")
            parts.append(f"private_dns_name={self.private_dns_name!r}")
            parts.append(f"public_dns_name={self.public_dns_name!r}")
            parts.append(f"state_transition_reason={self.state_transition_reason!r}")
            parts.append(f"key_name={self.key_name!r}")
            parts.append(f"ami_launch_index={self.ami_launch_index!r}")
            parts.append(f"product_codes={self.product_codes!r}")
            parts.append(f"instance_type={self.instance_type!r}")
            parts.append(f"launch_time={self.launch_time!r}")
            parts.append(f"placement={self.placement!r}")
            parts.append(f"kernel_id={self.kernel_id!r}")
            parts.append(f"ramdisk_id={self.ramdisk_id!r}")
            parts.append(f"platform={self.platform!r}")
            parts.append(f"monitoring={self.monitoring!r}")
            parts.append(f"subnet_id={self.subnet_id!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"private_ip_address={self.private_ip_address!r}")
            parts.append(f"public_ip_address={self.public_ip_address!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('associate_public_ip_address', 'delete_on_termination', 'description', 'device_ind"
        "ex', 'groups', 'ipv6_address_count', 'ipv6_addresses', 'network_interface_id', 'private_ip_address', 'private_"
        "ip_addresses', 'secondary_private_ip_address_count', 'subnet_id', 'associate_carrier_ip_address', 'interface_t"
        "ype', 'network_card_index', 'ipv4_prefixes', 'ipv4_prefix_count', 'ipv6_prefixes', 'ipv6_prefix_count', 'prima"
        "ry_ipv6', 'ena_srd_specification', 'connection_tracking_specification', 'ena_queue_count')), EqPlan(fields=('a"
        "ssociate_public_ip_address', 'delete_on_termination', 'description', 'device_index', 'groups', 'ipv6_address_c"
        "ount', 'ipv6_addresses', 'network_interface_id', 'private_ip_address', 'private_ip_addresses', 'secondary_priv"
        "ate_ip_address_count', 'subnet_id', 'associate_carrier_ip_address', 'interface_type', 'network_card_index', 'i"
        "pv4_prefixes', 'ipv4_prefix_count', 'ipv6_prefixes', 'ipv6_prefix_count', 'primary_ipv6', 'ena_srd_specificati"
        "on', 'connection_tracking_specification', 'ena_queue_count')), FrozenPlan(fields=('__shape__', 'associate_publ"
        "ic_ip_address', 'delete_on_termination', 'description', 'device_index', 'groups', 'ipv6_address_count', 'ipv6_"
        "addresses', 'network_interface_id', 'private_ip_address', 'private_ip_addresses', 'secondary_private_ip_addres"
        "s_count', 'subnet_id', 'associate_carrier_ip_address', 'interface_type', 'network_card_index', 'ipv4_prefixes'"
        ", 'ipv4_prefix_count', 'ipv6_prefixes', 'ipv6_prefix_count', 'primary_ipv6', 'ena_srd_specification', 'connect"
        "ion_tracking_specification', 'ena_queue_count'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fie"
        "lds=('associate_public_ip_address', 'delete_on_termination', 'description', 'device_index', 'groups', 'ipv6_ad"
        "dress_count', 'ipv6_addresses', 'network_interface_id', 'private_ip_address', 'private_ip_addresses', 'seconda"
        "ry_private_ip_address_count', 'subnet_id', 'associate_carrier_ip_address', 'interface_type', 'network_card_ind"
        "ex', 'ipv4_prefixes', 'ipv4_prefix_count', 'ipv6_prefixes', 'ipv6_prefix_count', 'primary_ipv6', 'ena_srd_spec"
        "ification', 'connection_tracking_specification', 'ena_queue_count'), cache=False), InitPlan(fields=(InitPlan.F"
        "ield(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, "
        "init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitP"
        "lan.Field(name='associate_public_ip_address', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef"
        "(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='delete_on_termination', annotation=OpRef("
        "name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='description', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='device_index', annotation=OpRef(name='init.fields.4.annotation'), d"
        "efault=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='groups', annotation=OpRef(nam"
        "e='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='ipv6_address_count', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='ipv6_addresses', annotation=OpRef(name='init.fields.7.annotatio"
        "n'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type="
        "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_interface_id', "
        "annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='private_ip_address', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(n"
        "ame='init.fields.9.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
        "coerce=None, validate=None, check_type=None), InitPlan.Field(name='private_ip_addresses', annotation=OpRef(nam"
        "e='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='secondary_private_ip_address_count', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(na"
        "me='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
        "coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnet_id', annotation=OpRef(name='init.fie"
        "lds.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True, override=F"
        "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='associ"
        "ate_carrier_ip_address', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.1"
        "3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='interface_type', annotation=OpRef(name='init.fields.14.annot"
        "ation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_card_index"
        "', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None), InitPlan.Field(name='ipv4_prefixes', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef("
        "name='init.fields.16.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv4_prefix_count', annotation=OpRef(name"
        "='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='ipv6_prefixes', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.18.def"
        "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
        "None, check_type=None), InitPlan.Field(name='ipv6_prefix_count', annotation=OpRef(name='init.fields.19.annotat"
        "ion'), default=OpRef(name='init.fields.19.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='primary_ipv6', annot"
        "ation=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.fields.20.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='ena_srd_specification', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef("
        "name='init.fields.21.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='connection_tracking_specification', annot"
        "ation=OpRef(name='init.fields.22.annotation'), default=OpRef(name='init.fields.22.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='ena_queue_count', annotation=OpRef(name='init.fields.23.annotation'), default=OpRef(name='"
        "init.fields.23.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('associate_public"
        "_ip_address', 'delete_on_termination', 'description', 'device_index', 'groups', 'ipv6_address_count', 'ipv6_ad"
        "dresses', 'network_interface_id', 'private_ip_address', 'private_ip_addresses', 'secondary_private_ip_address_"
        "count', 'subnet_id', 'associate_carrier_ip_address', 'interface_type', 'network_card_index', 'ipv4_prefixes', "
        "'ipv4_prefix_count', 'ipv6_prefixes', 'ipv6_prefix_count', 'primary_ipv6', 'ena_srd_specification', 'connectio"
        "n_tracking_specification', 'ena_queue_count'), frozen=True, slots=False, post_init_params=None, init_fns=(), v"
        "alidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='associate_public_ip_address', kw_only=True, fn=None), R"
        "eprPlan.Field(name='delete_on_termination', kw_only=True, fn=None), ReprPlan.Field(name='description', kw_only"
        "=True, fn=None), ReprPlan.Field(name='device_index', kw_only=True, fn=None), ReprPlan.Field(name='groups', kw_"
        "only=True, fn=None), ReprPlan.Field(name='ipv6_address_count', kw_only=True, fn=None), ReprPlan.Field(name='ip"
        "v6_addresses', kw_only=True, fn=None), ReprPlan.Field(name='network_interface_id', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='private_ip_address', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_addresses', kw_"
        "only=True, fn=None), ReprPlan.Field(name='secondary_private_ip_address_count', kw_only=True, fn=None), ReprPla"
        "n.Field(name='subnet_id', kw_only=True, fn=None), ReprPlan.Field(name='associate_carrier_ip_address', kw_only="
        "True, fn=None), ReprPlan.Field(name='interface_type', kw_only=True, fn=None), ReprPlan.Field(name='network_car"
        "d_index', kw_only=True, fn=None), ReprPlan.Field(name='ipv4_prefixes', kw_only=True, fn=None), ReprPlan.Field("
        "name='ipv4_prefix_count', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_prefixes', kw_only=True, fn=None),"
        " ReprPlan.Field(name='ipv6_prefix_count', kw_only=True, fn=None), ReprPlan.Field(name='primary_ipv6', kw_only="
        "True, fn=None), ReprPlan.Field(name='ena_srd_specification', kw_only=True, fn=None), ReprPlan.Field(name='conn"
        "ection_tracking_specification', kw_only=True, fn=None), ReprPlan.Field(name='ena_queue_count', kw_only=True, f"
        "n=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d6ea01a33163f433cc27fd38db73e13a68f9e565',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceNetworkInterfaceSpecification'),
    ),
)
def _process_dataclass__d6ea01a33163f433cc27fd38db73e13a68f9e565():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                associate_public_ip_address=self.associate_public_ip_address,
                delete_on_termination=self.delete_on_termination,
                description=self.description,
                device_index=self.device_index,
                groups=self.groups,
                ipv6_address_count=self.ipv6_address_count,
                ipv6_addresses=self.ipv6_addresses,
                network_interface_id=self.network_interface_id,
                private_ip_address=self.private_ip_address,
                private_ip_addresses=self.private_ip_addresses,
                secondary_private_ip_address_count=self.secondary_private_ip_address_count,
                subnet_id=self.subnet_id,
                associate_carrier_ip_address=self.associate_carrier_ip_address,
                interface_type=self.interface_type,
                network_card_index=self.network_card_index,
                ipv4_prefixes=self.ipv4_prefixes,
                ipv4_prefix_count=self.ipv4_prefix_count,
                ipv6_prefixes=self.ipv6_prefixes,
                ipv6_prefix_count=self.ipv6_prefix_count,
                primary_ipv6=self.primary_ipv6,
                ena_srd_specification=self.ena_srd_specification,
                connection_tracking_specification=self.connection_tracking_specification,
                ena_queue_count=self.ena_queue_count,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.associate_public_ip_address == other.associate_public_ip_address and
                self.delete_on_termination == other.delete_on_termination and
                self.description == other.description and
                self.device_index == other.device_index and
                self.groups == other.groups and
                self.ipv6_address_count == other.ipv6_address_count and
                self.ipv6_addresses == other.ipv6_addresses and
                self.network_interface_id == other.network_interface_id and
                self.private_ip_address == other.private_ip_address and
                self.private_ip_addresses == other.private_ip_addresses and
                self.secondary_private_ip_address_count == other.secondary_private_ip_address_count and
                self.subnet_id == other.subnet_id and
                self.associate_carrier_ip_address == other.associate_carrier_ip_address and
                self.interface_type == other.interface_type and
                self.network_card_index == other.network_card_index and
                self.ipv4_prefixes == other.ipv4_prefixes and
                self.ipv4_prefix_count == other.ipv4_prefix_count and
                self.ipv6_prefixes == other.ipv6_prefixes and
                self.ipv6_prefix_count == other.ipv6_prefix_count and
                self.primary_ipv6 == other.primary_ipv6 and
                self.ena_srd_specification == other.ena_srd_specification and
                self.connection_tracking_specification == other.connection_tracking_specification and
                self.ena_queue_count == other.ena_queue_count
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'associate_public_ip_address',
            'delete_on_termination',
            'description',
            'device_index',
            'groups',
            'ipv6_address_count',
            'ipv6_addresses',
            'network_interface_id',
            'private_ip_address',
            'private_ip_addresses',
            'secondary_private_ip_address_count',
            'subnet_id',
            'associate_carrier_ip_address',
            'interface_type',
            'network_card_index',
            'ipv4_prefixes',
            'ipv4_prefix_count',
            'ipv6_prefixes',
            'ipv6_prefix_count',
            'primary_ipv6',
            'ena_srd_specification',
            'connection_tracking_specification',
            'ena_queue_count',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'associate_public_ip_address',
            'delete_on_termination',
            'description',
            'device_index',
            'groups',
            'ipv6_address_count',
            'ipv6_addresses',
            'network_interface_id',
            'private_ip_address',
            'private_ip_addresses',
            'secondary_private_ip_address_count',
            'subnet_id',
            'associate_carrier_ip_address',
            'interface_type',
            'network_card_index',
            'ipv4_prefixes',
            'ipv4_prefix_count',
            'ipv6_prefixes',
            'ipv6_prefix_count',
            'primary_ipv6',
            'ena_srd_specification',
            'connection_tracking_specification',
            'ena_queue_count',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.associate_public_ip_address,
                self.delete_on_termination,
                self.description,
                self.device_index,
                self.groups,
                self.ipv6_address_count,
                self.ipv6_addresses,
                self.network_interface_id,
                self.private_ip_address,
                self.private_ip_addresses,
                self.secondary_private_ip_address_count,
                self.subnet_id,
                self.associate_carrier_ip_address,
                self.interface_type,
                self.network_card_index,
                self.ipv4_prefixes,
                self.ipv4_prefix_count,
                self.ipv6_prefixes,
                self.ipv6_prefix_count,
                self.primary_ipv6,
                self.ena_srd_specification,
                self.connection_tracking_specification,
                self.ena_queue_count,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            associate_public_ip_address: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            delete_on_termination: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            description: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            device_index: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            groups: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            ipv6_address_count: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            ipv6_addresses: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            network_interface_id: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            private_ip_address: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            private_ip_addresses: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            secondary_private_ip_address_count: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            subnet_id: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            associate_carrier_ip_address: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            interface_type: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            network_card_index: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            ipv4_prefixes: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            ipv4_prefix_count: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            ipv6_prefixes: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            ipv6_prefix_count: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            primary_ipv6: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            ena_srd_specification: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            connection_tracking_specification: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            ena_queue_count: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'associate_public_ip_address', associate_public_ip_address)
            __dataclass__object_setattr(self, 'delete_on_termination', delete_on_termination)
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'device_index', device_index)
            __dataclass__object_setattr(self, 'groups', groups)
            __dataclass__object_setattr(self, 'ipv6_address_count', ipv6_address_count)
            __dataclass__object_setattr(self, 'ipv6_addresses', ipv6_addresses)
            __dataclass__object_setattr(self, 'network_interface_id', network_interface_id)
            __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)
            __dataclass__object_setattr(self, 'private_ip_addresses', private_ip_addresses)
            __dataclass__object_setattr(self, 'secondary_private_ip_address_count', secondary_private_ip_address_count)
            __dataclass__object_setattr(self, 'subnet_id', subnet_id)
            __dataclass__object_setattr(self, 'associate_carrier_ip_address', associate_carrier_ip_address)
            __dataclass__object_setattr(self, 'interface_type', interface_type)
            __dataclass__object_setattr(self, 'network_card_index', network_card_index)
            __dataclass__object_setattr(self, 'ipv4_prefixes', ipv4_prefixes)
            __dataclass__object_setattr(self, 'ipv4_prefix_count', ipv4_prefix_count)
            __dataclass__object_setattr(self, 'ipv6_prefixes', ipv6_prefixes)
            __dataclass__object_setattr(self, 'ipv6_prefix_count', ipv6_prefix_count)
            __dataclass__object_setattr(self, 'primary_ipv6', primary_ipv6)
            __dataclass__object_setattr(self, 'ena_srd_specification', ena_srd_specification)
            __dataclass__object_setattr(self, 'connection_tracking_specification', connection_tracking_specification)
            __dataclass__object_setattr(self, 'ena_queue_count', ena_queue_count)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"associate_public_ip_address={self.associate_public_ip_address!r}")
            parts.append(f"delete_on_termination={self.delete_on_termination!r}")
            parts.append(f"description={self.description!r}")
            parts.append(f"device_index={self.device_index!r}")
            parts.append(f"groups={self.groups!r}")
            parts.append(f"ipv6_address_count={self.ipv6_address_count!r}")
            parts.append(f"ipv6_addresses={self.ipv6_addresses!r}")
            parts.append(f"network_interface_id={self.network_interface_id!r}")
            parts.append(f"private_ip_address={self.private_ip_address!r}")
            parts.append(f"private_ip_addresses={self.private_ip_addresses!r}")
            parts.append(f"secondary_private_ip_address_count={self.secondary_private_ip_address_count!r}")
            parts.append(f"subnet_id={self.subnet_id!r}")
            parts.append(f"associate_carrier_ip_address={self.associate_carrier_ip_address!r}")
            parts.append(f"interface_type={self.interface_type!r}")
            parts.append(f"network_card_index={self.network_card_index!r}")
            parts.append(f"ipv4_prefixes={self.ipv4_prefixes!r}")
            parts.append(f"ipv4_prefix_count={self.ipv4_prefix_count!r}")
            parts.append(f"ipv6_prefixes={self.ipv6_prefixes!r}")
            parts.append(f"ipv6_prefix_count={self.ipv6_prefix_count!r}")
            parts.append(f"primary_ipv6={self.primary_ipv6!r}")
            parts.append(f"ena_srd_specification={self.ena_srd_specification!r}")
            parts.append(f"connection_tracking_specification={self.connection_tracking_specification!r}")
            parts.append(f"ena_queue_count={self.ena_queue_count!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('owner_id', 'instance_tenancy', 'ipv6_cidr_block_association_set', 'cidr_block_ass"
        "ociation_set', 'is_default', 'encryption_control', 'tags', 'block_public_access_states', 'vpc_id', 'state', 'c"
        "idr_block', 'dhcp_options_id')), EqPlan(fields=('owner_id', 'instance_tenancy', 'ipv6_cidr_block_association_s"
        "et', 'cidr_block_association_set', 'is_default', 'encryption_control', 'tags', 'block_public_access_states', '"
        "vpc_id', 'state', 'cidr_block', 'dhcp_options_id')), FrozenPlan(fields=('__shape__', 'owner_id', 'instance_ten"
        "ancy', 'ipv6_cidr_block_association_set', 'cidr_block_association_set', 'is_default', 'encryption_control', 't"
        "ags', 'block_public_access_states', 'vpc_id', 'state', 'cidr_block', 'dhcp_options_id'), allow_dynamic_dunder_"
        "attrs=False), HashPlan(action='add', fields=('owner_id', 'instance_tenancy', 'ipv6_cidr_block_association_set'"
        ", 'cidr_block_association_set', 'is_default', 'encryption_control', 'tags', 'block_public_access_states', 'vpc"
        "_id', 'state', 'cidr_block', 'dhcp_options_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__"
        "', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override="
        "False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='owne"
        "r_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default"
        "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='instance_tenancy', annotation=OpRef(name='init.fields.2.annotation'), default=Op"
        "Ref(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
        "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_cidr_block_association_set', anno"
        "tation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='cidr_block_association_set', annotation=OpRef(name='init.fields.4.annotation'), default=OpR"
        "ef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='is_default', annotation=OpRef(name='ini"
        "t.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='enc"
        "ryption_control', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default"
        "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
        ", check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='init.fields.7.annotation'), default=OpR"
        "ef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='block_public_access_states', annotation"
        "=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
        ".Field(name='vpc_id', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.def"
        "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
        "None, check_type=None), InitPlan.Field(name='state', annotation=OpRef(name='init.fields.10.annotation'), defau"
        "lt=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cidr_block', annotation=OpRef(na"
        "me='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='dhcp_options_id', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('owner_id', 'instance_tenancy',"
        " 'ipv6_cidr_block_association_set', 'cidr_block_association_set', 'is_default', 'encryption_control', 'tags', "
        "'block_public_access_states', 'vpc_id', 'state', 'cidr_block', 'dhcp_options_id'), frozen=True, slots=False, p"
        "ost_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='owner_id', kw_only="
        "True, fn=None), ReprPlan.Field(name='instance_tenancy', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_cidr"
        "_block_association_set', kw_only=True, fn=None), ReprPlan.Field(name='cidr_block_association_set', kw_only=Tru"
        "e, fn=None), ReprPlan.Field(name='is_default', kw_only=True, fn=None), ReprPlan.Field(name='encryption_control"
        "', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=True, fn=None), ReprPlan.Field(name='block_publ"
        "ic_access_states', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPlan.Fiel"
        "d(name='state', kw_only=True, fn=None), ReprPlan.Field(name='cidr_block', kw_only=True, fn=None), ReprPlan.Fie"
        "ld(name='dhcp_options_id', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d719e59ed39034940f5557de3b6e95b675f461c6',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Vpc'),
    ),
)
def _process_dataclass__d719e59ed39034940f5557de3b6e95b675f461c6():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                owner_id=self.owner_id,
                instance_tenancy=self.instance_tenancy,
                ipv6_cidr_block_association_set=self.ipv6_cidr_block_association_set,
                cidr_block_association_set=self.cidr_block_association_set,
                is_default=self.is_default,
                encryption_control=self.encryption_control,
                tags=self.tags,
                block_public_access_states=self.block_public_access_states,
                vpc_id=self.vpc_id,
                state=self.state,
                cidr_block=self.cidr_block,
                dhcp_options_id=self.dhcp_options_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.owner_id == other.owner_id and
                self.instance_tenancy == other.instance_tenancy and
                self.ipv6_cidr_block_association_set == other.ipv6_cidr_block_association_set and
                self.cidr_block_association_set == other.cidr_block_association_set and
                self.is_default == other.is_default and
                self.encryption_control == other.encryption_control and
                self.tags == other.tags and
                self.block_public_access_states == other.block_public_access_states and
                self.vpc_id == other.vpc_id and
                self.state == other.state and
                self.cidr_block == other.cidr_block and
                self.dhcp_options_id == other.dhcp_options_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'owner_id',
            'instance_tenancy',
            'ipv6_cidr_block_association_set',
            'cidr_block_association_set',
            'is_default',
            'encryption_control',
            'tags',
            'block_public_access_states',
            'vpc_id',
            'state',
            'cidr_block',
            'dhcp_options_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'owner_id',
            'instance_tenancy',
            'ipv6_cidr_block_association_set',
            'cidr_block_association_set',
            'is_default',
            'encryption_control',
            'tags',
            'block_public_access_states',
            'vpc_id',
            'state',
            'cidr_block',
            'dhcp_options_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.owner_id,
                self.instance_tenancy,
                self.ipv6_cidr_block_association_set,
                self.cidr_block_association_set,
                self.is_default,
                self.encryption_control,
                self.tags,
                self.block_public_access_states,
                self.vpc_id,
                self.state,
                self.cidr_block,
                self.dhcp_options_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            owner_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            instance_tenancy: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            ipv6_cidr_block_association_set: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            cidr_block_association_set: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            is_default: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            encryption_control: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            tags: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            block_public_access_states: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            vpc_id: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            state: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            cidr_block: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            dhcp_options_id: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'owner_id', owner_id)
            __dataclass__object_setattr(self, 'instance_tenancy', instance_tenancy)
            __dataclass__object_setattr(self, 'ipv6_cidr_block_association_set', ipv6_cidr_block_association_set)
            __dataclass__object_setattr(self, 'cidr_block_association_set', cidr_block_association_set)
            __dataclass__object_setattr(self, 'is_default', is_default)
            __dataclass__object_setattr(self, 'encryption_control', encryption_control)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'block_public_access_states', block_public_access_states)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'cidr_block', cidr_block)
            __dataclass__object_setattr(self, 'dhcp_options_id', dhcp_options_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"owner_id={self.owner_id!r}")
            parts.append(f"instance_tenancy={self.instance_tenancy!r}")
            parts.append(f"ipv6_cidr_block_association_set={self.ipv6_cidr_block_association_set!r}")
            parts.append(f"cidr_block_association_set={self.cidr_block_association_set!r}")
            parts.append(f"is_default={self.is_default!r}")
            parts.append(f"encryption_control={self.encryption_control!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"block_public_access_states={self.block_public_access_states!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"state={self.state!r}")
            parts.append(f"cidr_block={self.cidr_block!r}")
            parts.append(f"dhcp_options_id={self.dhcp_options_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('destination_prefix_list_id', 'vpc_endpoint_id', 'transit_gateway_id', 'local_gate"
        "way_id', 'carrier_gateway_id', 'core_network_arn', 'odb_network_arn', 'dry_run', 'route_table_id', 'destinatio"
        "n_cidr_block', 'gateway_id', 'destination_ipv6_cidr_block', 'egress_only_internet_gateway_id', 'instance_id', "
        "'network_interface_id', 'vpc_peering_connection_id', 'nat_gateway_id')), EqPlan(fields=('destination_prefix_li"
        "st_id', 'vpc_endpoint_id', 'transit_gateway_id', 'local_gateway_id', 'carrier_gateway_id', 'core_network_arn',"
        " 'odb_network_arn', 'dry_run', 'route_table_id', 'destination_cidr_block', 'gateway_id', 'destination_ipv6_cid"
        "r_block', 'egress_only_internet_gateway_id', 'instance_id', 'network_interface_id', 'vpc_peering_connection_id"
        "', 'nat_gateway_id')), FrozenPlan(fields=('__shape__', 'destination_prefix_list_id', 'vpc_endpoint_id', 'trans"
        "it_gateway_id', 'local_gateway_id', 'carrier_gateway_id', 'core_network_arn', 'odb_network_arn', 'dry_run', 'r"
        "oute_table_id', 'destination_cidr_block', 'gateway_id', 'destination_ipv6_cidr_block', 'egress_only_internet_g"
        "ateway_id', 'instance_id', 'network_interface_id', 'vpc_peering_connection_id', 'nat_gateway_id'), allow_dynam"
        "ic_dunder_attrs=False), HashPlan(action='add', fields=('destination_prefix_list_id', 'vpc_endpoint_id', 'trans"
        "it_gateway_id', 'local_gateway_id', 'carrier_gateway_id', 'core_network_arn', 'odb_network_arn', 'dry_run', 'r"
        "oute_table_id', 'destination_cidr_block', 'gateway_id', 'destination_ipv6_cidr_block', 'egress_only_internet_g"
        "ateway_id', 'instance_id', 'network_interface_id', 'vpc_peering_connection_id', 'nat_gateway_id'), cache=False"
        "), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defaul"
        "t=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate"
        "=None, check_type=None), InitPlan.Field(name='destination_prefix_list_id', annotation=OpRef(name='init.fields."
        "1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_endpoint"
        "_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='transit_gateway_id', annotation=OpRef(name='init.fields.3.annotation'), default=O"
        "pRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='local_gateway_id', annotation=OpRef(n"
        "ame='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='carrier_gateway_id', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None), InitPlan.Field(name='core_network_arn', annotation=OpRef(name='init.fields.6.annot"
        "ation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='odb_network_arn', a"
        "nnotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory"
        "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
        " InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fi"
        "elds.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='route_table_id', annotation=OpRef(name='init.fields.9.a"
        "nnotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='destination_cidr_block', annotation=OpRef(name"
        "='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='gateway_id', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='destination_ipv6_cidr_block', annotation=OpRef(name='init.fields.12."
        "annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='egress_only_i"
        "nternet_gateway_id', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13.de"
        "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
        "=None, check_type=None), InitPlan.Field(name='instance_id', annotation=OpRef(name='init.fields.14.annotation')"
        ", default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_interface_id', an"
        "notation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='vpc_peering_connection_id', annotation=OpRef(name='init.fields.16.annotation'), default"
        "=OpRef(name='init.fields.16.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
        "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='nat_gateway_id', annotation=OpRef("
        "name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='"
        "self', std_params=(), kw_only_params=('destination_prefix_list_id', 'vpc_endpoint_id', 'transit_gateway_id', '"
        "local_gateway_id', 'carrier_gateway_id', 'core_network_arn', 'odb_network_arn', 'dry_run', 'route_table_id', '"
        "destination_cidr_block', 'gateway_id', 'destination_ipv6_cidr_block', 'egress_only_internet_gateway_id', 'inst"
        "ance_id', 'network_interface_id', 'vpc_peering_connection_id', 'nat_gateway_id'), frozen=True, slots=False, po"
        "st_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='destination_prefix_l"
        "ist_id', kw_only=True, fn=None), ReprPlan.Field(name='vpc_endpoint_id', kw_only=True, fn=None), ReprPlan.Field"
        "(name='transit_gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='local_gateway_id', kw_only=True, fn=N"
        "one), ReprPlan.Field(name='carrier_gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='core_network_arn'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='odb_network_arn', kw_only=True, fn=None), ReprPlan.Field(name='"
        "dry_run', kw_only=True, fn=None), ReprPlan.Field(name='route_table_id', kw_only=True, fn=None), ReprPlan.Field"
        "(name='destination_cidr_block', kw_only=True, fn=None), ReprPlan.Field(name='gateway_id', kw_only=True, fn=Non"
        "e), ReprPlan.Field(name='destination_ipv6_cidr_block', kw_only=True, fn=None), ReprPlan.Field(name='egress_onl"
        "y_internet_gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='instance_id', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='network_interface_id', kw_only=True, fn=None), ReprPlan.Field(name='vpc_peering_connection_i"
        "d', kw_only=True, fn=None), ReprPlan.Field(name='nat_gateway_id', kw_only=True, fn=None)), id=False, terse=Fal"
        "se, default_fn=None)))"
    ),
    plan_repr_sha1='d80b3f6d522d7ad8f1bac2b374a92de1e4414478',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CreateRouteRequest'),
    ),
)
def _process_dataclass__d80b3f6d522d7ad8f1bac2b374a92de1e4414478():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                destination_prefix_list_id=self.destination_prefix_list_id,
                vpc_endpoint_id=self.vpc_endpoint_id,
                transit_gateway_id=self.transit_gateway_id,
                local_gateway_id=self.local_gateway_id,
                carrier_gateway_id=self.carrier_gateway_id,
                core_network_arn=self.core_network_arn,
                odb_network_arn=self.odb_network_arn,
                dry_run=self.dry_run,
                route_table_id=self.route_table_id,
                destination_cidr_block=self.destination_cidr_block,
                gateway_id=self.gateway_id,
                destination_ipv6_cidr_block=self.destination_ipv6_cidr_block,
                egress_only_internet_gateway_id=self.egress_only_internet_gateway_id,
                instance_id=self.instance_id,
                network_interface_id=self.network_interface_id,
                vpc_peering_connection_id=self.vpc_peering_connection_id,
                nat_gateway_id=self.nat_gateway_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.destination_prefix_list_id == other.destination_prefix_list_id and
                self.vpc_endpoint_id == other.vpc_endpoint_id and
                self.transit_gateway_id == other.transit_gateway_id and
                self.local_gateway_id == other.local_gateway_id and
                self.carrier_gateway_id == other.carrier_gateway_id and
                self.core_network_arn == other.core_network_arn and
                self.odb_network_arn == other.odb_network_arn and
                self.dry_run == other.dry_run and
                self.route_table_id == other.route_table_id and
                self.destination_cidr_block == other.destination_cidr_block and
                self.gateway_id == other.gateway_id and
                self.destination_ipv6_cidr_block == other.destination_ipv6_cidr_block and
                self.egress_only_internet_gateway_id == other.egress_only_internet_gateway_id and
                self.instance_id == other.instance_id and
                self.network_interface_id == other.network_interface_id and
                self.vpc_peering_connection_id == other.vpc_peering_connection_id and
                self.nat_gateway_id == other.nat_gateway_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'destination_prefix_list_id',
            'vpc_endpoint_id',
            'transit_gateway_id',
            'local_gateway_id',
            'carrier_gateway_id',
            'core_network_arn',
            'odb_network_arn',
            'dry_run',
            'route_table_id',
            'destination_cidr_block',
            'gateway_id',
            'destination_ipv6_cidr_block',
            'egress_only_internet_gateway_id',
            'instance_id',
            'network_interface_id',
            'vpc_peering_connection_id',
            'nat_gateway_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'destination_prefix_list_id',
            'vpc_endpoint_id',
            'transit_gateway_id',
            'local_gateway_id',
            'carrier_gateway_id',
            'core_network_arn',
            'odb_network_arn',
            'dry_run',
            'route_table_id',
            'destination_cidr_block',
            'gateway_id',
            'destination_ipv6_cidr_block',
            'egress_only_internet_gateway_id',
            'instance_id',
            'network_interface_id',
            'vpc_peering_connection_id',
            'nat_gateway_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.destination_prefix_list_id,
                self.vpc_endpoint_id,
                self.transit_gateway_id,
                self.local_gateway_id,
                self.carrier_gateway_id,
                self.core_network_arn,
                self.odb_network_arn,
                self.dry_run,
                self.route_table_id,
                self.destination_cidr_block,
                self.gateway_id,
                self.destination_ipv6_cidr_block,
                self.egress_only_internet_gateway_id,
                self.instance_id,
                self.network_interface_id,
                self.vpc_peering_connection_id,
                self.nat_gateway_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            destination_prefix_list_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            vpc_endpoint_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            transit_gateway_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            local_gateway_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            carrier_gateway_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            core_network_arn: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            odb_network_arn: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            dry_run: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            route_table_id: __dataclass__init__fields__9__annotation,
            destination_cidr_block: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            gateway_id: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            destination_ipv6_cidr_block: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            egress_only_internet_gateway_id: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            instance_id: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            network_interface_id: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            vpc_peering_connection_id: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            nat_gateway_id: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'destination_prefix_list_id', destination_prefix_list_id)
            __dataclass__object_setattr(self, 'vpc_endpoint_id', vpc_endpoint_id)
            __dataclass__object_setattr(self, 'transit_gateway_id', transit_gateway_id)
            __dataclass__object_setattr(self, 'local_gateway_id', local_gateway_id)
            __dataclass__object_setattr(self, 'carrier_gateway_id', carrier_gateway_id)
            __dataclass__object_setattr(self, 'core_network_arn', core_network_arn)
            __dataclass__object_setattr(self, 'odb_network_arn', odb_network_arn)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'route_table_id', route_table_id)
            __dataclass__object_setattr(self, 'destination_cidr_block', destination_cidr_block)
            __dataclass__object_setattr(self, 'gateway_id', gateway_id)
            __dataclass__object_setattr(self, 'destination_ipv6_cidr_block', destination_ipv6_cidr_block)
            __dataclass__object_setattr(self, 'egress_only_internet_gateway_id', egress_only_internet_gateway_id)
            __dataclass__object_setattr(self, 'instance_id', instance_id)
            __dataclass__object_setattr(self, 'network_interface_id', network_interface_id)
            __dataclass__object_setattr(self, 'vpc_peering_connection_id', vpc_peering_connection_id)
            __dataclass__object_setattr(self, 'nat_gateway_id', nat_gateway_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"destination_prefix_list_id={self.destination_prefix_list_id!r}")
            parts.append(f"vpc_endpoint_id={self.vpc_endpoint_id!r}")
            parts.append(f"transit_gateway_id={self.transit_gateway_id!r}")
            parts.append(f"local_gateway_id={self.local_gateway_id!r}")
            parts.append(f"carrier_gateway_id={self.carrier_gateway_id!r}")
            parts.append(f"core_network_arn={self.core_network_arn!r}")
            parts.append(f"odb_network_arn={self.odb_network_arn!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"route_table_id={self.route_table_id!r}")
            parts.append(f"destination_cidr_block={self.destination_cidr_block!r}")
            parts.append(f"gateway_id={self.gateway_id!r}")
            parts.append(f"destination_ipv6_cidr_block={self.destination_ipv6_cidr_block!r}")
            parts.append(f"egress_only_internet_gateway_id={self.egress_only_internet_gateway_id!r}")
            parts.append(f"instance_id={self.instance_id!r}")
            parts.append(f"network_interface_id={self.network_interface_id!r}")
            parts.append(f"vpc_peering_connection_id={self.vpc_peering_connection_id!r}")
            parts.append(f"nat_gateway_id={self.nat_gateway_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('filters', 'subnet_ids', 'next_token', 'max_results', 'dry_run')), EqPlan(fields=("
        "'filters', 'subnet_ids', 'next_token', 'max_results', 'dry_run')), FrozenPlan(fields=('__shape__', 'filters', "
        "'subnet_ids', 'next_token', 'max_results', 'dry_run'), allow_dynamic_dunder_attrs=False), HashPlan(action='add"
        "', fields=('filters', 'subnet_ids', 'next_token', 'max_results', 'dry_run'), cache=False), InitPlan(fields=(In"
        "itPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factor"
        "y=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None"
        "), InitPlan.Field(name='filters', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init."
        "fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
        "e, validate=None, check_type=None), InitPlan.Field(name='subnet_ids', annotation=OpRef(name='init.fields.2.ann"
        "otation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', anno"
        "tation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='max_results', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.f"
        "ields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.5.annotat"
        "ion'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only"
        "_params=('filters', 'subnet_ids', 'next_token', 'max_results', 'dry_run'), frozen=True, slots=False, post_init"
        "_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='filters', kw_only=True, fn="
        "None), ReprPlan.Field(name='subnet_ids', kw_only=True, fn=None), ReprPlan.Field(name='next_token', kw_only=Tru"
        "e, fn=None), ReprPlan.Field(name='max_results', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only"
        "=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d877c5731a33eef1abbb55f28cce22256c852312',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeSubnetsRequest'),
    ),
)
def _process_dataclass__d877c5731a33eef1abbb55f28cce22256c852312():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                filters=self.filters,
                subnet_ids=self.subnet_ids,
                next_token=self.next_token,
                max_results=self.max_results,
                dry_run=self.dry_run,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.filters == other.filters and
                self.subnet_ids == other.subnet_ids and
                self.next_token == other.next_token and
                self.max_results == other.max_results and
                self.dry_run == other.dry_run
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'filters',
            'subnet_ids',
            'next_token',
            'max_results',
            'dry_run',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'filters',
            'subnet_ids',
            'next_token',
            'max_results',
            'dry_run',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.filters,
                self.subnet_ids,
                self.next_token,
                self.max_results,
                self.dry_run,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            filters: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            subnet_ids: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            next_token: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            max_results: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            dry_run: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'filters', filters)
            __dataclass__object_setattr(self, 'subnet_ids', subnet_ids)
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'max_results', max_results)
            __dataclass__object_setattr(self, 'dry_run', dry_run)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"filters={self.filters!r}")
            parts.append(f"subnet_ids={self.subnet_ids!r}")
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"max_results={self.max_results!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('carrier_ip', 'customer_owned_ip', 'ip_owner_id', 'public_dns_name', 'public_ip'))"
        ", EqPlan(fields=('carrier_ip', 'customer_owned_ip', 'ip_owner_id', 'public_dns_name', 'public_ip')), FrozenPla"
        "n(fields=('__shape__', 'carrier_ip', 'customer_owned_ip', 'ip_owner_id', 'public_dns_name', 'public_ip'), allo"
        "w_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('carrier_ip', 'customer_owned_ip', 'ip_owner_id'"
        ", 'public_dns_name', 'public_ip'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation="
        "OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='carrier_ip', annot"
        "ation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='customer_owned_ip', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='i"
        "nit.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='ip_owner_id', annotation=OpRef(name='init.fields."
        "3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_dns_n"
        "ame', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='public_ip', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name"
        "='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('carrier_ip', 'c"
        "ustomer_owned_ip', 'ip_owner_id', 'public_dns_name', 'public_ip'), frozen=True, slots=False, post_init_params="
        "None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='carrier_ip', kw_only=True, fn=None)"
        ", ReprPlan.Field(name='customer_owned_ip', kw_only=True, fn=None), ReprPlan.Field(name='ip_owner_id', kw_only="
        "True, fn=None), ReprPlan.Field(name='public_dns_name', kw_only=True, fn=None), ReprPlan.Field(name='public_ip'"
        ", kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d8aaeba5664396a6bcbc2471a59e31cdc447f2fb',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceNetworkInterfaceAssociation'),
    ),
)
def _process_dataclass__d8aaeba5664396a6bcbc2471a59e31cdc447f2fb():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                carrier_ip=self.carrier_ip,
                customer_owned_ip=self.customer_owned_ip,
                ip_owner_id=self.ip_owner_id,
                public_dns_name=self.public_dns_name,
                public_ip=self.public_ip,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.carrier_ip == other.carrier_ip and
                self.customer_owned_ip == other.customer_owned_ip and
                self.ip_owner_id == other.ip_owner_id and
                self.public_dns_name == other.public_dns_name and
                self.public_ip == other.public_ip
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'carrier_ip',
            'customer_owned_ip',
            'ip_owner_id',
            'public_dns_name',
            'public_ip',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'carrier_ip',
            'customer_owned_ip',
            'ip_owner_id',
            'public_dns_name',
            'public_ip',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.carrier_ip,
                self.customer_owned_ip,
                self.ip_owner_id,
                self.public_dns_name,
                self.public_ip,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            carrier_ip: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            customer_owned_ip: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            ip_owner_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            public_dns_name: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            public_ip: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'carrier_ip', carrier_ip)
            __dataclass__object_setattr(self, 'customer_owned_ip', customer_owned_ip)
            __dataclass__object_setattr(self, 'ip_owner_id', ip_owner_id)
            __dataclass__object_setattr(self, 'public_dns_name', public_dns_name)
            __dataclass__object_setattr(self, 'public_ip', public_ip)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"carrier_ip={self.carrier_ip!r}")
            parts.append(f"customer_owned_ip={self.customer_owned_ip!r}")
            parts.append(f"ip_owner_id={self.ip_owner_id!r}")
            parts.append(f"public_dns_name={self.public_dns_name!r}")
            parts.append(f"public_ip={self.public_ip!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('cpu_credits',)), EqPlan(fields=('cpu_credits',)), FrozenPlan(fields=('__shape__',"
        " 'cpu_credits'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('cpu_credits',), cache=Fals"
        "e), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defau"
        "lt=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='cpu_credits', annotation=OpRef(name='init.fields.1.annotation')"
        ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('cpu_credits',), frozen=Tru"
        "e, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='cp"
        "u_credits', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d9f48cde06e7389dca07aabc1f82e684870460cf',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CreditSpecificationRequest'),
    ),
)
def _process_dataclass__d9f48cde06e7389dca07aabc1f82e684870460cf():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                cpu_credits=self.cpu_credits,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.cpu_credits == other.cpu_credits
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'cpu_credits',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'cpu_credits',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.cpu_credits,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            cpu_credits: __dataclass__init__fields__1__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'cpu_credits', cpu_credits)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"cpu_credits={self.cpu_credits!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('allocation_id', 'association_id', 'domain', 'network_interface_id', 'network_inte"
        "rface_owner_id', 'private_ip_address', 'tags', 'public_ipv4_pool', 'network_border_group', 'customer_owned_ip'"
        ", 'customer_owned_ipv4_pool', 'carrier_ip', 'subnet_id', 'service_managed', 'instance_id', 'public_ip')), EqPl"
        "an(fields=('allocation_id', 'association_id', 'domain', 'network_interface_id', 'network_interface_owner_id', "
        "'private_ip_address', 'tags', 'public_ipv4_pool', 'network_border_group', 'customer_owned_ip', 'customer_owned"
        "_ipv4_pool', 'carrier_ip', 'subnet_id', 'service_managed', 'instance_id', 'public_ip')), FrozenPlan(fields=('_"
        "_shape__', 'allocation_id', 'association_id', 'domain', 'network_interface_id', 'network_interface_owner_id', "
        "'private_ip_address', 'tags', 'public_ipv4_pool', 'network_border_group', 'customer_owned_ip', 'customer_owned"
        "_ipv4_pool', 'carrier_ip', 'subnet_id', 'service_managed', 'instance_id', 'public_ip'), allow_dynamic_dunder_a"
        "ttrs=False), HashPlan(action='add', fields=('allocation_id', 'association_id', 'domain', 'network_interface_id"
        "', 'network_interface_owner_id', 'private_ip_address', 'tags', 'public_ipv4_pool', 'network_border_group', 'cu"
        "stomer_owned_ip', 'customer_owned_ipv4_pool', 'carrier_ip', 'subnet_id', 'service_managed', 'instance_id', 'pu"
        "blic_ip'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields."
        "0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR,"
        " coerce=None, validate=None, check_type=None), InitPlan.Field(name='allocation_id', annotation=OpRef(name='ini"
        "t.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ass"
        "ociation_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), "
        "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
        "eck_type=None), InitPlan.Field(name='domain', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef"
        "(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_interface_id', annotation=OpRef(n"
        "ame='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='network_interface_owner_id', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init."
        "fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
        "e, validate=None, check_type=None), InitPlan.Field(name='private_ip_address', annotation=OpRef(name='init.fiel"
        "ds.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags', an"
        "notation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory="
        "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
        "InitPlan.Field(name='public_ipv4_pool', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name="
        "'init.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None), InitPlan.Field(name='network_border_group', annotation=OpRef(name='i"
        "nit.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='c"
        "ustomer_owned_ip', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.defa"
        "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
        "one, check_type=None), InitPlan.Field(name='customer_owned_ipv4_pool', annotation=OpRef(name='init.fields.11.a"
        "nnotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='carrier_ip', a"
        "nnotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_facto"
        "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
        "), InitPlan.Field(name='subnet_id', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='in"
        "it.fields.13.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='service_managed', annotation=OpRef(name='init.fie"
        "lds.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=F"
        "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instan"
        "ce_id', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='public_ip', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef"
        "(name='init.fields.16.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
        "E, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('allocatio"
        "n_id', 'association_id', 'domain', 'network_interface_id', 'network_interface_owner_id', 'private_ip_address',"
        " 'tags', 'public_ipv4_pool', 'network_border_group', 'customer_owned_ip', 'customer_owned_ipv4_pool', 'carrier"
        "_ip', 'subnet_id', 'service_managed', 'instance_id', 'public_ip'), frozen=True, slots=False, post_init_params="
        "None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='allocation_id', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='association_id', kw_only=True, fn=None), ReprPlan.Field(name='domain', kw_only=True,"
        " fn=None), ReprPlan.Field(name='network_interface_id', kw_only=True, fn=None), ReprPlan.Field(name='network_in"
        "terface_owner_id', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_address', kw_only=True, fn=None), R"
        "eprPlan.Field(name='tags', kw_only=True, fn=None), ReprPlan.Field(name='public_ipv4_pool', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='network_border_group', kw_only=True, fn=None), ReprPlan.Field(name='customer_owned_i"
        "p', kw_only=True, fn=None), ReprPlan.Field(name='customer_owned_ipv4_pool', kw_only=True, fn=None), ReprPlan.F"
        "ield(name='carrier_ip', kw_only=True, fn=None), ReprPlan.Field(name='subnet_id', kw_only=True, fn=None), ReprP"
        "lan.Field(name='service_managed', kw_only=True, fn=None), ReprPlan.Field(name='instance_id', kw_only=True, fn="
        "None), ReprPlan.Field(name='public_ip', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='db1126f8ac107695f46b0eb4548009951a2add6f',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Address'),
    ),
)
def _process_dataclass__db1126f8ac107695f46b0eb4548009951a2add6f():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                allocation_id=self.allocation_id,
                association_id=self.association_id,
                domain=self.domain,
                network_interface_id=self.network_interface_id,
                network_interface_owner_id=self.network_interface_owner_id,
                private_ip_address=self.private_ip_address,
                tags=self.tags,
                public_ipv4_pool=self.public_ipv4_pool,
                network_border_group=self.network_border_group,
                customer_owned_ip=self.customer_owned_ip,
                customer_owned_ipv4_pool=self.customer_owned_ipv4_pool,
                carrier_ip=self.carrier_ip,
                subnet_id=self.subnet_id,
                service_managed=self.service_managed,
                instance_id=self.instance_id,
                public_ip=self.public_ip,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.allocation_id == other.allocation_id and
                self.association_id == other.association_id and
                self.domain == other.domain and
                self.network_interface_id == other.network_interface_id and
                self.network_interface_owner_id == other.network_interface_owner_id and
                self.private_ip_address == other.private_ip_address and
                self.tags == other.tags and
                self.public_ipv4_pool == other.public_ipv4_pool and
                self.network_border_group == other.network_border_group and
                self.customer_owned_ip == other.customer_owned_ip and
                self.customer_owned_ipv4_pool == other.customer_owned_ipv4_pool and
                self.carrier_ip == other.carrier_ip and
                self.subnet_id == other.subnet_id and
                self.service_managed == other.service_managed and
                self.instance_id == other.instance_id and
                self.public_ip == other.public_ip
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'allocation_id',
            'association_id',
            'domain',
            'network_interface_id',
            'network_interface_owner_id',
            'private_ip_address',
            'tags',
            'public_ipv4_pool',
            'network_border_group',
            'customer_owned_ip',
            'customer_owned_ipv4_pool',
            'carrier_ip',
            'subnet_id',
            'service_managed',
            'instance_id',
            'public_ip',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'allocation_id',
            'association_id',
            'domain',
            'network_interface_id',
            'network_interface_owner_id',
            'private_ip_address',
            'tags',
            'public_ipv4_pool',
            'network_border_group',
            'customer_owned_ip',
            'customer_owned_ipv4_pool',
            'carrier_ip',
            'subnet_id',
            'service_managed',
            'instance_id',
            'public_ip',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.allocation_id,
                self.association_id,
                self.domain,
                self.network_interface_id,
                self.network_interface_owner_id,
                self.private_ip_address,
                self.tags,
                self.public_ipv4_pool,
                self.network_border_group,
                self.customer_owned_ip,
                self.customer_owned_ipv4_pool,
                self.carrier_ip,
                self.subnet_id,
                self.service_managed,
                self.instance_id,
                self.public_ip,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            allocation_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            association_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            domain: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            network_interface_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            network_interface_owner_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            private_ip_address: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            tags: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            public_ipv4_pool: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            network_border_group: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            customer_owned_ip: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            customer_owned_ipv4_pool: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            carrier_ip: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            subnet_id: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            service_managed: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            instance_id: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            public_ip: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'allocation_id', allocation_id)
            __dataclass__object_setattr(self, 'association_id', association_id)
            __dataclass__object_setattr(self, 'domain', domain)
            __dataclass__object_setattr(self, 'network_interface_id', network_interface_id)
            __dataclass__object_setattr(self, 'network_interface_owner_id', network_interface_owner_id)
            __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'public_ipv4_pool', public_ipv4_pool)
            __dataclass__object_setattr(self, 'network_border_group', network_border_group)
            __dataclass__object_setattr(self, 'customer_owned_ip', customer_owned_ip)
            __dataclass__object_setattr(self, 'customer_owned_ipv4_pool', customer_owned_ipv4_pool)
            __dataclass__object_setattr(self, 'carrier_ip', carrier_ip)
            __dataclass__object_setattr(self, 'subnet_id', subnet_id)
            __dataclass__object_setattr(self, 'service_managed', service_managed)
            __dataclass__object_setattr(self, 'instance_id', instance_id)
            __dataclass__object_setattr(self, 'public_ip', public_ip)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"allocation_id={self.allocation_id!r}")
            parts.append(f"association_id={self.association_id!r}")
            parts.append(f"domain={self.domain!r}")
            parts.append(f"network_interface_id={self.network_interface_id!r}")
            parts.append(f"network_interface_owner_id={self.network_interface_owner_id!r}")
            parts.append(f"private_ip_address={self.private_ip_address!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"public_ipv4_pool={self.public_ipv4_pool!r}")
            parts.append(f"network_border_group={self.network_border_group!r}")
            parts.append(f"customer_owned_ip={self.customer_owned_ip!r}")
            parts.append(f"customer_owned_ipv4_pool={self.customer_owned_ipv4_pool!r}")
            parts.append(f"carrier_ip={self.carrier_ip!r}")
            parts.append(f"subnet_id={self.subnet_id!r}")
            parts.append(f"service_managed={self.service_managed!r}")
            parts.append(f"instance_id={self.instance_id!r}")
            parts.append(f"public_ip={self.public_ip!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('next_token', 'vpcs')), EqPlan(fields=('next_token', 'vpcs')), FrozenPlan(fields=("
        "'__shape__', 'next_token', 'vpcs'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('next_to"
        "ken', 'vpcs'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fie"
        "lds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_"
        "VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='in"
        "it.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vp"
        "cs', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None)), self_param='self', std_params=(), kw_only_params=('next_token', 'vpcs'), frozen=True, slots=False, pos"
        "t_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='next_token', kw_only="
        "True, fn=None), ReprPlan.Field(name='vpcs', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='dc682e377d184de1251ca50f451df77defad2270',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeVpcsResult'),
    ),
)
def _process_dataclass__dc682e377d184de1251ca50f451df77defad2270():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                next_token=self.next_token,
                vpcs=self.vpcs,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.next_token == other.next_token and
                self.vpcs == other.vpcs
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'next_token',
            'vpcs',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'next_token',
            'vpcs',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.next_token,
                self.vpcs,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            vpcs: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'vpcs', vpcs)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"vpcs={self.vpcs!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('tag_specifications', 'client_token', 'dry_run', 'vpc_id')), EqPlan(fields=('tag_s"
        "pecifications', 'client_token', 'dry_run', 'vpc_id')), FrozenPlan(fields=('__shape__', 'tag_specifications', '"
        "client_token', 'dry_run', 'vpc_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('tag_sp"
        "ecifications', 'client_token', 'dry_run', 'vpc_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='__sha"
        "pe__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "tag_specifications', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defa"
        "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
        "one, check_type=None), InitPlan.Field(name='client_token', annotation=OpRef(name='init.fields.2.annotation'), "
        "default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(n"
        "ame='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='vpc_id', annotation=OpRef(name='init.fields.4.annotation'), default=None, default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='se"
        "lf', std_params=(), kw_only_params=('tag_specifications', 'client_token', 'dry_run', 'vpc_id'), frozen=True, s"
        "lots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='tag_sp"
        "ecifications', kw_only=True, fn=None), ReprPlan.Field(name='client_token', kw_only=True, fn=None), ReprPlan.Fi"
        "eld(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None)), id=False, t"
        "erse=False, default_fn=None)))"
    ),
    plan_repr_sha1='dea68351d63e2b1ddc527efbcd2431a54e2d0877',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CreateRouteTableRequest'),
    ),
)
def _process_dataclass__dea68351d63e2b1ddc527efbcd2431a54e2d0877():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                tag_specifications=self.tag_specifications,
                client_token=self.client_token,
                dry_run=self.dry_run,
                vpc_id=self.vpc_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.tag_specifications == other.tag_specifications and
                self.client_token == other.client_token and
                self.dry_run == other.dry_run and
                self.vpc_id == other.vpc_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'tag_specifications',
            'client_token',
            'dry_run',
            'vpc_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'tag_specifications',
            'client_token',
            'dry_run',
            'vpc_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.tag_specifications,
                self.client_token,
                self.dry_run,
                self.vpc_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            tag_specifications: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            client_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            dry_run: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            vpc_id: __dataclass__init__fields__4__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'tag_specifications', tag_specifications)
            __dataclass__object_setattr(self, 'client_token', client_token)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"tag_specifications={self.tag_specifications!r}")
            parts.append(f"client_token={self.client_token!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('main', 'route_table_association_id', 'route_table_id', 'subnet_id', 'gateway_id',"
        " 'public_ipv4_pool', 'association_state')), EqPlan(fields=('main', 'route_table_association_id', 'route_table_"
        "id', 'subnet_id', 'gateway_id', 'public_ipv4_pool', 'association_state')), FrozenPlan(fields=('__shape__', 'ma"
        "in', 'route_table_association_id', 'route_table_id', 'subnet_id', 'gateway_id', 'public_ipv4_pool', 'associati"
        "on_state'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('main', 'route_table_association"
        "_id', 'route_table_id', 'subnet_id', 'gateway_id', 'public_ipv4_pool', 'association_state'), cache=False), Ini"
        "tPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None"
        ", default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='main', annotation=OpRef(name='init.fields.1.annotation'), default=OpRe"
        "f(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
        "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='route_table_association_id', annotation="
        "OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='route_table_id', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.field"
        "s.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='subnet_id', annotation=OpRef(name='init.fields.4.annotatio"
        "n'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type="
        "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='gateway_id', annotation"
        "=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
        ".Field(name='public_ipv4_pool', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fi"
        "elds.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='association_state', annotation=OpRef(name='init.fields."
        "7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=()"
        ", kw_only_params=('main', 'route_table_association_id', 'route_table_id', 'subnet_id', 'gateway_id', 'public_i"
        "pv4_pool', 'association_state'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()"
        "), ReprPlan(fields=(ReprPlan.Field(name='main', kw_only=True, fn=None), ReprPlan.Field(name='route_table_assoc"
        "iation_id', kw_only=True, fn=None), ReprPlan.Field(name='route_table_id', kw_only=True, fn=None), ReprPlan.Fie"
        "ld(name='subnet_id', kw_only=True, fn=None), ReprPlan.Field(name='gateway_id', kw_only=True, fn=None), ReprPla"
        "n.Field(name='public_ipv4_pool', kw_only=True, fn=None), ReprPlan.Field(name='association_state', kw_only=True"
        ", fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='df63244c16b2a1951ab99d694225b97a336704c1',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'RouteTableAssociation'),
    ),
)
def _process_dataclass__df63244c16b2a1951ab99d694225b97a336704c1():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                main=self.main,
                route_table_association_id=self.route_table_association_id,
                route_table_id=self.route_table_id,
                subnet_id=self.subnet_id,
                gateway_id=self.gateway_id,
                public_ipv4_pool=self.public_ipv4_pool,
                association_state=self.association_state,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.main == other.main and
                self.route_table_association_id == other.route_table_association_id and
                self.route_table_id == other.route_table_id and
                self.subnet_id == other.subnet_id and
                self.gateway_id == other.gateway_id and
                self.public_ipv4_pool == other.public_ipv4_pool and
                self.association_state == other.association_state
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'main',
            'route_table_association_id',
            'route_table_id',
            'subnet_id',
            'gateway_id',
            'public_ipv4_pool',
            'association_state',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'main',
            'route_table_association_id',
            'route_table_id',
            'subnet_id',
            'gateway_id',
            'public_ipv4_pool',
            'association_state',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.main,
                self.route_table_association_id,
                self.route_table_id,
                self.subnet_id,
                self.gateway_id,
                self.public_ipv4_pool,
                self.association_state,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            main: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            route_table_association_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            route_table_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            subnet_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            gateway_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            public_ipv4_pool: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            association_state: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'main', main)
            __dataclass__object_setattr(self, 'route_table_association_id', route_table_association_id)
            __dataclass__object_setattr(self, 'route_table_id', route_table_id)
            __dataclass__object_setattr(self, 'subnet_id', subnet_id)
            __dataclass__object_setattr(self, 'gateway_id', gateway_id)
            __dataclass__object_setattr(self, 'public_ipv4_pool', public_ipv4_pool)
            __dataclass__object_setattr(self, 'association_state', association_state)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"main={self.main!r}")
            parts.append(f"route_table_association_id={self.route_table_association_id!r}")
            parts.append(f"route_table_id={self.route_table_id!r}")
            parts.append(f"subnet_id={self.subnet_id!r}")
            parts.append(f"gateway_id={self.gateway_id!r}")
            parts.append(f"public_ipv4_pool={self.public_ipv4_pool!r}")
            parts.append(f"association_state={self.association_state!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('name', 'values')), EqPlan(fields=('name', 'values')), FrozenPlan(fields=('__shape"
        "__', 'name', 'values'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'values'), c"
        "ache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation"
        "'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation"
        "'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='values', annotation=OpRef(name='init.fields.2.annotatio"
        "n'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
        ", validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('name', 'values'), froze"
        "n=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
        "e='name', kw_only=True, fn=None), ReprPlan.Field(name='values', kw_only=True, fn=None)), id=False, terse=False"
        ", default_fn=None)))"
    ),
    plan_repr_sha1='dfb68735498463724ba64285108de491926e61ec',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'Filter'),
    ),
)
def _process_dataclass__dfb68735498463724ba64285108de491926e61ec():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                name=self.name,
                values=self.values,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.name == other.name and
                self.values == other.values
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'name',
            'values',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'name',
            'values',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.name,
                self.values,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            name: __dataclass__init__fields__1__annotation,
            values: __dataclass__init__fields__2__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'name', name)
            __dataclass__object_setattr(self, 'values', values)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"name={self.name!r}")
            parts.append(f"values={self.values!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('status_type', 'normal', 'status', 'message')), EqPlan(fields=('status_type', 'nor"
        "mal', 'status', 'message')), FrozenPlan(fields=('__shape__', 'status_type', 'normal', 'status', 'message'), al"
        "low_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('status_type', 'normal', 'status', 'message'),"
        " cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotati"
        "on'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='status_type', annotation=OpRef(name='init.fields.1.a"
        "nnotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='normal', annota"
        "tion=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='status', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None), InitPlan.Field(name='message', annotation=OpRef(name='init.fields.4.annotation'), "
        "default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params"
        "=('status_type', 'normal', 'status', 'message'), frozen=True, slots=False, post_init_params=None, init_fns=(),"
        " validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='status_type', kw_only=True, fn=None), ReprPlan.Field("
        "name='normal', kw_only=True, fn=None), ReprPlan.Field(name='status', kw_only=True, fn=None), ReprPlan.Field(na"
        "me='message', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='dfef3bd76104061b462b6d622ccea966239e7922',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'DBInstanceStatusInfo'),
    ),
)
def _process_dataclass__dfef3bd76104061b462b6d622ccea966239e7922():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                status_type=self.status_type,
                normal=self.normal,
                status=self.status,
                message=self.message,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.status_type == other.status_type and
                self.normal == other.normal and
                self.status == other.status and
                self.message == other.message
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'status_type',
            'normal',
            'status',
            'message',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'status_type',
            'normal',
            'status',
            'message',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.status_type,
                self.normal,
                self.status,
                self.message,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            status_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            normal: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            status: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            message: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'status_type', status_type)
            __dataclass__object_setattr(self, 'normal', normal)
            __dataclass__object_setattr(self, 'status', status)
            __dataclass__object_setattr(self, 'message', message)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"status_type={self.status_type!r}")
            parts.append(f"normal={self.normal!r}")
            parts.append(f"status={self.status!r}")
            parts.append(f"message={self.message!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('body', 'delete_marker', 'accept_ranges', 'expiration', 'restore', 'last_modified'"
        ", 'content_length', 'etag', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc64_nvme', 'checksum_sha1', 'chec"
        "ksum_sha256', 'checksum_type', 'missing_meta', 'version_id', 'cache_control', 'content_disposition', 'content_"
        "encoding', 'content_language', 'content_range', 'content_type', 'expires', 'website_redirect_location', 'serve"
        "r_side_encryption', 'metadata', 'sse_customer_algorithm', 'sse_customer_key_md5', 'sse_kms_key_id', 'bucket_ke"
        "y_enabled', 'storage_class', 'request_charged', 'replication_status', 'parts_count', 'tag_count', 'object_lock"
        "_mode', 'object_lock_retain_until_date', 'object_lock_legal_hold_status')), EqPlan(fields=('body', 'delete_mar"
        "ker', 'accept_ranges', 'expiration', 'restore', 'last_modified', 'content_length', 'etag', 'checksum_crc32', '"
        "checksum_crc32c', 'checksum_crc64_nvme', 'checksum_sha1', 'checksum_sha256', 'checksum_type', 'missing_meta', "
        "'version_id', 'cache_control', 'content_disposition', 'content_encoding', 'content_language', 'content_range',"
        " 'content_type', 'expires', 'website_redirect_location', 'server_side_encryption', 'metadata', 'sse_customer_a"
        "lgorithm', 'sse_customer_key_md5', 'sse_kms_key_id', 'bucket_key_enabled', 'storage_class', 'request_charged',"
        " 'replication_status', 'parts_count', 'tag_count', 'object_lock_mode', 'object_lock_retain_until_date', 'objec"
        "t_lock_legal_hold_status')), FrozenPlan(fields=('__shape__', 'body', 'delete_marker', 'accept_ranges', 'expira"
        "tion', 'restore', 'last_modified', 'content_length', 'etag', 'checksum_crc32', 'checksum_crc32c', 'checksum_cr"
        "c64_nvme', 'checksum_sha1', 'checksum_sha256', 'checksum_type', 'missing_meta', 'version_id', 'cache_control',"
        " 'content_disposition', 'content_encoding', 'content_language', 'content_range', 'content_type', 'expires', 'w"
        "ebsite_redirect_location', 'server_side_encryption', 'metadata', 'sse_customer_algorithm', 'sse_customer_key_m"
        "d5', 'sse_kms_key_id', 'bucket_key_enabled', 'storage_class', 'request_charged', 'replication_status', 'parts_"
        "count', 'tag_count', 'object_lock_mode', 'object_lock_retain_until_date', 'object_lock_legal_hold_status'), al"
        "low_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('body', 'delete_marker', 'accept_ranges', 'exp"
        "iration', 'restore', 'last_modified', 'content_length', 'etag', 'checksum_crc32', 'checksum_crc32c', 'checksum"
        "_crc64_nvme', 'checksum_sha1', 'checksum_sha256', 'checksum_type', 'missing_meta', 'version_id', 'cache_contro"
        "l', 'content_disposition', 'content_encoding', 'content_language', 'content_range', 'content_type', 'expires',"
        " 'website_redirect_location', 'server_side_encryption', 'metadata', 'sse_customer_algorithm', 'sse_customer_ke"
        "y_md5', 'sse_kms_key_id', 'bucket_key_enabled', 'storage_class', 'request_charged', 'replication_status', 'par"
        "ts_count', 'tag_count', 'object_lock_mode', 'object_lock_retain_until_date', 'object_lock_legal_hold_status'),"
        " cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotati"
        "on'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='body', annotation=OpRef(name='init.fields.1.annotati"
        "on'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type"
        "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='delete_marker', annota"
        "tion=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='accept_ranges', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.f"
        "ields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='expiration', annotation=OpRef(name='init.fields.4.anno"
        "tation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='restore', annotati"
        "on=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='last_modified', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fie"
        "lds.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='content_length', annotation=OpRef(name='init.fields.7.an"
        "notation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, fiel"
        "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='etag', annotatio"
        "n=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='checksum_crc32', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fie"
        "lds.9.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='checksum_crc32c', annotation=OpRef(name='init.fields.10."
        "annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='checksum_crc6"
        "4_nvme', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), def"
        "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
        "_type=None), InitPlan.Field(name='checksum_sha1', annotation=OpRef(name='init.fields.12.annotation'), default="
        "OpRef(name='init.fields.12.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
        "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='checksum_sha256', annotation=OpRef("
        "name='init.fields.13.annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='checksum_type', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None), InitPlan.Field(name='missing_meta', annotation=OpRef(name='init.fields.15.annotati"
        "on'), default=OpRef(name='init.fields.15.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='version_id', annotati"
        "on=OpRef(name='init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='cache_control', annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init."
        "fields.17.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='content_disposition', annotation=OpRef(name='init.fi"
        "elds.18.annotation'), default=OpRef(name='init.fields.18.default'), default_factory=None, init=True, override="
        "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='conte"
        "nt_encoding', annotation=OpRef(name='init.fields.19.annotation'), default=OpRef(name='init.fields.19.default')"
        ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='content_language', annotation=OpRef(name='init.fields.20.annotation'), "
        "default=OpRef(name='init.fields.20.default'), default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='content_range', annotation="
        "OpRef(name='init.fields.21.annotation'), default=OpRef(name='init.fields.21.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='content_type', annotation=OpRef(name='init.fields.22.annotation'), default=OpRef(name='init.fiel"
        "ds.22.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='expires', annotation=OpRef(name='init.fields.23.annotati"
        "on'), default=OpRef(name='init.fields.23.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='website_redirect_loca"
        "tion', annotation=OpRef(name='init.fields.24.annotation'), default=OpRef(name='init.fields.24.default'), defau"
        "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
        "ype=None), InitPlan.Field(name='server_side_encryption', annotation=OpRef(name='init.fields.25.annotation'), d"
        "efault=OpRef(name='init.fields.25.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='metadata', annotation=OpRef("
        "name='init.fields.26.annotation'), default=OpRef(name='init.fields.26.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='sse_customer_algorithm', annotation=OpRef(name='init.fields.27.annotation'), default=OpRef(name='init."
        "fields.27.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='sse_customer_key_md5', annotation=OpRef(name='init.f"
        "ields.28.annotation'), default=OpRef(name='init.fields.28.default'), default_factory=None, init=True, override"
        "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='sse_"
        "kms_key_id', annotation=OpRef(name='init.fields.29.annotation'), default=OpRef(name='init.fields.29.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None), InitPlan.Field(name='bucket_key_enabled', annotation=OpRef(name='init.fields.30.annotation'),"
        " default=OpRef(name='init.fields.30.default'), default_factory=None, init=True, override=False, field_type=Fie"
        "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='storage_class', annotation"
        "=OpRef(name='init.fields.31.annotation'), default=OpRef(name='init.fields.31.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='request_charged', annotation=OpRef(name='init.fields.32.annotation'), default=OpRef(name='init."
        "fields.32.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='replication_status', annotation=OpRef(name='init.fie"
        "lds.33.annotation'), default=OpRef(name='init.fields.33.default'), default_factory=None, init=True, override=F"
        "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='parts_"
        "count', annotation=OpRef(name='init.fields.34.annotation'), default=OpRef(name='init.fields.34.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='tag_count', annotation=OpRef(name='init.fields.35.annotation'), default=OpRef"
        "(name='init.fields.35.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
        "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='object_lock_mode', annotation=OpRef(name"
        "='init.fields.36.annotation'), default=OpRef(name='init.fields.36.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='object_lock_retain_until_date', annotation=OpRef(name='init.fields.37.annotation'), default=OpRef(name='in"
        "it.fields.37.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='object_lock_legal_hold_status', annotation=OpRef("
        "name='init.fields.38.annotation'), default=OpRef(name='init.fields.38.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='"
        "self', std_params=(), kw_only_params=('body', 'delete_marker', 'accept_ranges', 'expiration', 'restore', 'last"
        "_modified', 'content_length', 'etag', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc64_nvme', 'checksum_sh"
        "a1', 'checksum_sha256', 'checksum_type', 'missing_meta', 'version_id', 'cache_control', 'content_disposition',"
        " 'content_encoding', 'content_language', 'content_range', 'content_type', 'expires', 'website_redirect_locatio"
        "n', 'server_side_encryption', 'metadata', 'sse_customer_algorithm', 'sse_customer_key_md5', 'sse_kms_key_id', "
        "'bucket_key_enabled', 'storage_class', 'request_charged', 'replication_status', 'parts_count', 'tag_count', 'o"
        "bject_lock_mode', 'object_lock_retain_until_date', 'object_lock_legal_hold_status'), frozen=True, slots=False,"
        " post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='body', kw_only=Tr"
        "ue, fn=None), ReprPlan.Field(name='delete_marker', kw_only=True, fn=None), ReprPlan.Field(name='accept_ranges'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='expiration', kw_only=True, fn=None), ReprPlan.Field(name='resto"
        "re', kw_only=True, fn=None), ReprPlan.Field(name='last_modified', kw_only=True, fn=None), ReprPlan.Field(name="
        "'content_length', kw_only=True, fn=None), ReprPlan.Field(name='etag', kw_only=True, fn=None), ReprPlan.Field(n"
        "ame='checksum_crc32', kw_only=True, fn=None), ReprPlan.Field(name='checksum_crc32c', kw_only=True, fn=None), R"
        "eprPlan.Field(name='checksum_crc64_nvme', kw_only=True, fn=None), ReprPlan.Field(name='checksum_sha1', kw_only"
        "=True, fn=None), ReprPlan.Field(name='checksum_sha256', kw_only=True, fn=None), ReprPlan.Field(name='checksum_"
        "type', kw_only=True, fn=None), ReprPlan.Field(name='missing_meta', kw_only=True, fn=None), ReprPlan.Field(name"
        "='version_id', kw_only=True, fn=None), ReprPlan.Field(name='cache_control', kw_only=True, fn=None), ReprPlan.F"
        "ield(name='content_disposition', kw_only=True, fn=None), ReprPlan.Field(name='content_encoding', kw_only=True,"
        " fn=None), ReprPlan.Field(name='content_language', kw_only=True, fn=None), ReprPlan.Field(name='content_range'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='content_type', kw_only=True, fn=None), ReprPlan.Field(name='exp"
        "ires', kw_only=True, fn=None), ReprPlan.Field(name='website_redirect_location', kw_only=True, fn=None), ReprPl"
        "an.Field(name='server_side_encryption', kw_only=True, fn=None), ReprPlan.Field(name='metadata', kw_only=True, "
        "fn=None), ReprPlan.Field(name='sse_customer_algorithm', kw_only=True, fn=None), ReprPlan.Field(name='sse_custo"
        "mer_key_md5', kw_only=True, fn=None), ReprPlan.Field(name='sse_kms_key_id', kw_only=True, fn=None), ReprPlan.F"
        "ield(name='bucket_key_enabled', kw_only=True, fn=None), ReprPlan.Field(name='storage_class', kw_only=True, fn="
        "None), ReprPlan.Field(name='request_charged', kw_only=True, fn=None), ReprPlan.Field(name='replication_status'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='parts_count', kw_only=True, fn=None), ReprPlan.Field(name='tag_"
        "count', kw_only=True, fn=None), ReprPlan.Field(name='object_lock_mode', kw_only=True, fn=None), ReprPlan.Field"
        "(name='object_lock_retain_until_date', kw_only=True, fn=None), ReprPlan.Field(name='object_lock_legal_hold_sta"
        "tus', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='e00af3fb98982d7658b90ccdb85e84af0566bbb9',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__24__annotation',
        '__dataclass__init__fields__24__default',
        '__dataclass__init__fields__25__annotation',
        '__dataclass__init__fields__25__default',
        '__dataclass__init__fields__26__annotation',
        '__dataclass__init__fields__26__default',
        '__dataclass__init__fields__27__annotation',
        '__dataclass__init__fields__27__default',
        '__dataclass__init__fields__28__annotation',
        '__dataclass__init__fields__28__default',
        '__dataclass__init__fields__29__annotation',
        '__dataclass__init__fields__29__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__30__annotation',
        '__dataclass__init__fields__30__default',
        '__dataclass__init__fields__31__annotation',
        '__dataclass__init__fields__31__default',
        '__dataclass__init__fields__32__annotation',
        '__dataclass__init__fields__32__default',
        '__dataclass__init__fields__33__annotation',
        '__dataclass__init__fields__33__default',
        '__dataclass__init__fields__34__annotation',
        '__dataclass__init__fields__34__default',
        '__dataclass__init__fields__35__annotation',
        '__dataclass__init__fields__35__default',
        '__dataclass__init__fields__36__annotation',
        '__dataclass__init__fields__36__default',
        '__dataclass__init__fields__37__annotation',
        '__dataclass__init__fields__37__default',
        '__dataclass__init__fields__38__annotation',
        '__dataclass__init__fields__38__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.s3', 'GetObjectOutput'),
    ),
)
def _process_dataclass__e00af3fb98982d7658b90ccdb85e84af0566bbb9():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__24__annotation,
        __dataclass__init__fields__24__default,
        __dataclass__init__fields__25__annotation,
        __dataclass__init__fields__25__default,
        __dataclass__init__fields__26__annotation,
        __dataclass__init__fields__26__default,
        __dataclass__init__fields__27__annotation,
        __dataclass__init__fields__27__default,
        __dataclass__init__fields__28__annotation,
        __dataclass__init__fields__28__default,
        __dataclass__init__fields__29__annotation,
        __dataclass__init__fields__29__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__30__annotation,
        __dataclass__init__fields__30__default,
        __dataclass__init__fields__31__annotation,
        __dataclass__init__fields__31__default,
        __dataclass__init__fields__32__annotation,
        __dataclass__init__fields__32__default,
        __dataclass__init__fields__33__annotation,
        __dataclass__init__fields__33__default,
        __dataclass__init__fields__34__annotation,
        __dataclass__init__fields__34__default,
        __dataclass__init__fields__35__annotation,
        __dataclass__init__fields__35__default,
        __dataclass__init__fields__36__annotation,
        __dataclass__init__fields__36__default,
        __dataclass__init__fields__37__annotation,
        __dataclass__init__fields__37__default,
        __dataclass__init__fields__38__annotation,
        __dataclass__init__fields__38__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                body=self.body,
                delete_marker=self.delete_marker,
                accept_ranges=self.accept_ranges,
                expiration=self.expiration,
                restore=self.restore,
                last_modified=self.last_modified,
                content_length=self.content_length,
                etag=self.etag,
                checksum_crc32=self.checksum_crc32,
                checksum_crc32c=self.checksum_crc32c,
                checksum_crc64_nvme=self.checksum_crc64_nvme,
                checksum_sha1=self.checksum_sha1,
                checksum_sha256=self.checksum_sha256,
                checksum_type=self.checksum_type,
                missing_meta=self.missing_meta,
                version_id=self.version_id,
                cache_control=self.cache_control,
                content_disposition=self.content_disposition,
                content_encoding=self.content_encoding,
                content_language=self.content_language,
                content_range=self.content_range,
                content_type=self.content_type,
                expires=self.expires,
                website_redirect_location=self.website_redirect_location,
                server_side_encryption=self.server_side_encryption,
                metadata=self.metadata,
                sse_customer_algorithm=self.sse_customer_algorithm,
                sse_customer_key_md5=self.sse_customer_key_md5,
                sse_kms_key_id=self.sse_kms_key_id,
                bucket_key_enabled=self.bucket_key_enabled,
                storage_class=self.storage_class,
                request_charged=self.request_charged,
                replication_status=self.replication_status,
                parts_count=self.parts_count,
                tag_count=self.tag_count,
                object_lock_mode=self.object_lock_mode,
                object_lock_retain_until_date=self.object_lock_retain_until_date,
                object_lock_legal_hold_status=self.object_lock_legal_hold_status,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.body == other.body and
                self.delete_marker == other.delete_marker and
                self.accept_ranges == other.accept_ranges and
                self.expiration == other.expiration and
                self.restore == other.restore and
                self.last_modified == other.last_modified and
                self.content_length == other.content_length and
                self.etag == other.etag and
                self.checksum_crc32 == other.checksum_crc32 and
                self.checksum_crc32c == other.checksum_crc32c and
                self.checksum_crc64_nvme == other.checksum_crc64_nvme and
                self.checksum_sha1 == other.checksum_sha1 and
                self.checksum_sha256 == other.checksum_sha256 and
                self.checksum_type == other.checksum_type and
                self.missing_meta == other.missing_meta and
                self.version_id == other.version_id and
                self.cache_control == other.cache_control and
                self.content_disposition == other.content_disposition and
                self.content_encoding == other.content_encoding and
                self.content_language == other.content_language and
                self.content_range == other.content_range and
                self.content_type == other.content_type and
                self.expires == other.expires and
                self.website_redirect_location == other.website_redirect_location and
                self.server_side_encryption == other.server_side_encryption and
                self.metadata == other.metadata and
                self.sse_customer_algorithm == other.sse_customer_algorithm and
                self.sse_customer_key_md5 == other.sse_customer_key_md5 and
                self.sse_kms_key_id == other.sse_kms_key_id and
                self.bucket_key_enabled == other.bucket_key_enabled and
                self.storage_class == other.storage_class and
                self.request_charged == other.request_charged and
                self.replication_status == other.replication_status and
                self.parts_count == other.parts_count and
                self.tag_count == other.tag_count and
                self.object_lock_mode == other.object_lock_mode and
                self.object_lock_retain_until_date == other.object_lock_retain_until_date and
                self.object_lock_legal_hold_status == other.object_lock_legal_hold_status
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'body',
            'delete_marker',
            'accept_ranges',
            'expiration',
            'restore',
            'last_modified',
            'content_length',
            'etag',
            'checksum_crc32',
            'checksum_crc32c',
            'checksum_crc64_nvme',
            'checksum_sha1',
            'checksum_sha256',
            'checksum_type',
            'missing_meta',
            'version_id',
            'cache_control',
            'content_disposition',
            'content_encoding',
            'content_language',
            'content_range',
            'content_type',
            'expires',
            'website_redirect_location',
            'server_side_encryption',
            'metadata',
            'sse_customer_algorithm',
            'sse_customer_key_md5',
            'sse_kms_key_id',
            'bucket_key_enabled',
            'storage_class',
            'request_charged',
            'replication_status',
            'parts_count',
            'tag_count',
            'object_lock_mode',
            'object_lock_retain_until_date',
            'object_lock_legal_hold_status',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'body',
            'delete_marker',
            'accept_ranges',
            'expiration',
            'restore',
            'last_modified',
            'content_length',
            'etag',
            'checksum_crc32',
            'checksum_crc32c',
            'checksum_crc64_nvme',
            'checksum_sha1',
            'checksum_sha256',
            'checksum_type',
            'missing_meta',
            'version_id',
            'cache_control',
            'content_disposition',
            'content_encoding',
            'content_language',
            'content_range',
            'content_type',
            'expires',
            'website_redirect_location',
            'server_side_encryption',
            'metadata',
            'sse_customer_algorithm',
            'sse_customer_key_md5',
            'sse_kms_key_id',
            'bucket_key_enabled',
            'storage_class',
            'request_charged',
            'replication_status',
            'parts_count',
            'tag_count',
            'object_lock_mode',
            'object_lock_retain_until_date',
            'object_lock_legal_hold_status',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.body,
                self.delete_marker,
                self.accept_ranges,
                self.expiration,
                self.restore,
                self.last_modified,
                self.content_length,
                self.etag,
                self.checksum_crc32,
                self.checksum_crc32c,
                self.checksum_crc64_nvme,
                self.checksum_sha1,
                self.checksum_sha256,
                self.checksum_type,
                self.missing_meta,
                self.version_id,
                self.cache_control,
                self.content_disposition,
                self.content_encoding,
                self.content_language,
                self.content_range,
                self.content_type,
                self.expires,
                self.website_redirect_location,
                self.server_side_encryption,
                self.metadata,
                self.sse_customer_algorithm,
                self.sse_customer_key_md5,
                self.sse_kms_key_id,
                self.bucket_key_enabled,
                self.storage_class,
                self.request_charged,
                self.replication_status,
                self.parts_count,
                self.tag_count,
                self.object_lock_mode,
                self.object_lock_retain_until_date,
                self.object_lock_legal_hold_status,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            body: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            delete_marker: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            accept_ranges: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            expiration: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            restore: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            last_modified: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            content_length: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            etag: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            checksum_crc32: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            checksum_crc32c: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            checksum_crc64_nvme: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            checksum_sha1: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            checksum_sha256: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            checksum_type: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            missing_meta: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            version_id: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            cache_control: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            content_disposition: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            content_encoding: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            content_language: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            content_range: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            content_type: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            expires: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
            website_redirect_location: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
            server_side_encryption: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
            metadata: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
            sse_customer_algorithm: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
            sse_customer_key_md5: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
            sse_kms_key_id: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
            bucket_key_enabled: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
            storage_class: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
            request_charged: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
            replication_status: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
            parts_count: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
            tag_count: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
            object_lock_mode: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
            object_lock_retain_until_date: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
            object_lock_legal_hold_status: __dataclass__init__fields__38__annotation = __dataclass__init__fields__38__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'body', body)
            __dataclass__object_setattr(self, 'delete_marker', delete_marker)
            __dataclass__object_setattr(self, 'accept_ranges', accept_ranges)
            __dataclass__object_setattr(self, 'expiration', expiration)
            __dataclass__object_setattr(self, 'restore', restore)
            __dataclass__object_setattr(self, 'last_modified', last_modified)
            __dataclass__object_setattr(self, 'content_length', content_length)
            __dataclass__object_setattr(self, 'etag', etag)
            __dataclass__object_setattr(self, 'checksum_crc32', checksum_crc32)
            __dataclass__object_setattr(self, 'checksum_crc32c', checksum_crc32c)
            __dataclass__object_setattr(self, 'checksum_crc64_nvme', checksum_crc64_nvme)
            __dataclass__object_setattr(self, 'checksum_sha1', checksum_sha1)
            __dataclass__object_setattr(self, 'checksum_sha256', checksum_sha256)
            __dataclass__object_setattr(self, 'checksum_type', checksum_type)
            __dataclass__object_setattr(self, 'missing_meta', missing_meta)
            __dataclass__object_setattr(self, 'version_id', version_id)
            __dataclass__object_setattr(self, 'cache_control', cache_control)
            __dataclass__object_setattr(self, 'content_disposition', content_disposition)
            __dataclass__object_setattr(self, 'content_encoding', content_encoding)
            __dataclass__object_setattr(self, 'content_language', content_language)
            __dataclass__object_setattr(self, 'content_range', content_range)
            __dataclass__object_setattr(self, 'content_type', content_type)
            __dataclass__object_setattr(self, 'expires', expires)
            __dataclass__object_setattr(self, 'website_redirect_location', website_redirect_location)
            __dataclass__object_setattr(self, 'server_side_encryption', server_side_encryption)
            __dataclass__object_setattr(self, 'metadata', metadata)
            __dataclass__object_setattr(self, 'sse_customer_algorithm', sse_customer_algorithm)
            __dataclass__object_setattr(self, 'sse_customer_key_md5', sse_customer_key_md5)
            __dataclass__object_setattr(self, 'sse_kms_key_id', sse_kms_key_id)
            __dataclass__object_setattr(self, 'bucket_key_enabled', bucket_key_enabled)
            __dataclass__object_setattr(self, 'storage_class', storage_class)
            __dataclass__object_setattr(self, 'request_charged', request_charged)
            __dataclass__object_setattr(self, 'replication_status', replication_status)
            __dataclass__object_setattr(self, 'parts_count', parts_count)
            __dataclass__object_setattr(self, 'tag_count', tag_count)
            __dataclass__object_setattr(self, 'object_lock_mode', object_lock_mode)
            __dataclass__object_setattr(self, 'object_lock_retain_until_date', object_lock_retain_until_date)
            __dataclass__object_setattr(self, 'object_lock_legal_hold_status', object_lock_legal_hold_status)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"body={self.body!r}")
            parts.append(f"delete_marker={self.delete_marker!r}")
            parts.append(f"accept_ranges={self.accept_ranges!r}")
            parts.append(f"expiration={self.expiration!r}")
            parts.append(f"restore={self.restore!r}")
            parts.append(f"last_modified={self.last_modified!r}")
            parts.append(f"content_length={self.content_length!r}")
            parts.append(f"etag={self.etag!r}")
            parts.append(f"checksum_crc32={self.checksum_crc32!r}")
            parts.append(f"checksum_crc32c={self.checksum_crc32c!r}")
            parts.append(f"checksum_crc64_nvme={self.checksum_crc64_nvme!r}")
            parts.append(f"checksum_sha1={self.checksum_sha1!r}")
            parts.append(f"checksum_sha256={self.checksum_sha256!r}")
            parts.append(f"checksum_type={self.checksum_type!r}")
            parts.append(f"missing_meta={self.missing_meta!r}")
            parts.append(f"version_id={self.version_id!r}")
            parts.append(f"cache_control={self.cache_control!r}")
            parts.append(f"content_disposition={self.content_disposition!r}")
            parts.append(f"content_encoding={self.content_encoding!r}")
            parts.append(f"content_language={self.content_language!r}")
            parts.append(f"content_range={self.content_range!r}")
            parts.append(f"content_type={self.content_type!r}")
            parts.append(f"expires={self.expires!r}")
            parts.append(f"website_redirect_location={self.website_redirect_location!r}")
            parts.append(f"server_side_encryption={self.server_side_encryption!r}")
            parts.append(f"metadata={self.metadata!r}")
            parts.append(f"sse_customer_algorithm={self.sse_customer_algorithm!r}")
            parts.append(f"sse_customer_key_md5={self.sse_customer_key_md5!r}")
            parts.append(f"sse_kms_key_id={self.sse_kms_key_id!r}")
            parts.append(f"bucket_key_enabled={self.bucket_key_enabled!r}")
            parts.append(f"storage_class={self.storage_class!r}")
            parts.append(f"request_charged={self.request_charged!r}")
            parts.append(f"replication_status={self.replication_status!r}")
            parts.append(f"parts_count={self.parts_count!r}")
            parts.append(f"tag_count={self.tag_count!r}")
            parts.append(f"object_lock_mode={self.object_lock_mode!r}")
            parts.append(f"object_lock_retain_until_date={self.object_lock_retain_until_date!r}")
            parts.append(f"object_lock_legal_hold_status={self.object_lock_legal_hold_status!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('auto_recovery',)), EqPlan(fields=('auto_recovery',)), FrozenPlan(fields=('__shape"
        "__', 'auto_recovery'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('auto_recovery',), ca"
        "che=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'"
        "), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='auto_recovery', annotation=OpRef(name='init.fields.1.an"
        "notation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fiel"
        "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw"
        "_only_params=('auto_recovery',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()"
        "), ReprPlan(fields=(ReprPlan.Field(name='auto_recovery', kw_only=True, fn=None),), id=False, terse=False, defa"
        "ult_fn=None)))"
    ),
    plan_repr_sha1='e05b242f8b4f9fce5a4bc4e5d5aa74dd579c9667',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceMaintenanceOptionsRequest'),
    ),
)
def _process_dataclass__e05b242f8b4f9fce5a4bc4e5d5aa74dd579c9667():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                auto_recovery=self.auto_recovery,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.auto_recovery == other.auto_recovery
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'auto_recovery',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'auto_recovery',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.auto_recovery,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            auto_recovery: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'auto_recovery', auto_recovery)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"auto_recovery={self.auto_recovery!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('db_name', 'db_instance_identifier', 'allocated_storage', 'db_instance_class', 'en"
        "gine', 'master_username', 'master_user_password', 'db_security_groups', 'vpc_security_group_ids', 'availabilit"
        "y_zone', 'db_subnet_group_name', 'preferred_maintenance_window', 'db_parameter_group_name', 'backup_retention_"
        "period', 'preferred_backup_window', 'port', 'multi_az', 'engine_version', 'auto_minor_version_upgrade', 'licen"
        "se_model', 'iops', 'storage_throughput', 'option_group_name', 'character_set_name', 'nchar_character_set_name'"
        ", 'publicly_accessible', 'tags', 'db_cluster_identifier', 'storage_type', 'tde_credential_arn', 'tde_credentia"
        "l_password', 'storage_encrypted', 'kms_key_id', 'domain', 'domain_fqdn', 'domain_ou', 'domain_auth_secret_arn'"
        ", 'domain_dns_ips', 'copy_tags_to_snapshot', 'monitoring_interval', 'monitoring_role_arn', 'domain_iam_role_na"
        "me', 'promotion_tier', 'timezone', 'enable_iam_database_authentication', 'database_insights_mode', 'enable_per"
        "formance_insights', 'performance_insights_kms_key_id', 'performance_insights_retention_period', 'enable_cloudw"
        "atch_logs_exports', 'processor_features', 'deletion_protection', 'max_allocated_storage', 'enable_customer_own"
        "ed_ip', 'network_type', 'backup_target', 'custom_iam_instance_profile', 'db_system_id', 'ca_certificate_identi"
        "fier', 'manage_master_user_password', 'master_user_secret_kms_key_id', 'multi_tenant', 'dedicated_log_volume',"
        " 'engine_lifecycle_support', 'master_user_authentication_type', 'additional_storage_volumes')), EqPlan(fields="
        "('db_name', 'db_instance_identifier', 'allocated_storage', 'db_instance_class', 'engine', 'master_username', '"
        "master_user_password', 'db_security_groups', 'vpc_security_group_ids', 'availability_zone', 'db_subnet_group_n"
        "ame', 'preferred_maintenance_window', 'db_parameter_group_name', 'backup_retention_period', 'preferred_backup_"
        "window', 'port', 'multi_az', 'engine_version', 'auto_minor_version_upgrade', 'license_model', 'iops', 'storage"
        "_throughput', 'option_group_name', 'character_set_name', 'nchar_character_set_name', 'publicly_accessible', 't"
        "ags', 'db_cluster_identifier', 'storage_type', 'tde_credential_arn', 'tde_credential_password', 'storage_encry"
        "pted', 'kms_key_id', 'domain', 'domain_fqdn', 'domain_ou', 'domain_auth_secret_arn', 'domain_dns_ips', 'copy_t"
        "ags_to_snapshot', 'monitoring_interval', 'monitoring_role_arn', 'domain_iam_role_name', 'promotion_tier', 'tim"
        "ezone', 'enable_iam_database_authentication', 'database_insights_mode', 'enable_performance_insights', 'perfor"
        "mance_insights_kms_key_id', 'performance_insights_retention_period', 'enable_cloudwatch_logs_exports', 'proces"
        "sor_features', 'deletion_protection', 'max_allocated_storage', 'enable_customer_owned_ip', 'network_type', 'ba"
        "ckup_target', 'custom_iam_instance_profile', 'db_system_id', 'ca_certificate_identifier', 'manage_master_user_"
        "password', 'master_user_secret_kms_key_id', 'multi_tenant', 'dedicated_log_volume', 'engine_lifecycle_support'"
        ", 'master_user_authentication_type', 'additional_storage_volumes')), FrozenPlan(fields=('__shape__', 'db_name'"
        ", 'db_instance_identifier', 'allocated_storage', 'db_instance_class', 'engine', 'master_username', 'master_use"
        "r_password', 'db_security_groups', 'vpc_security_group_ids', 'availability_zone', 'db_subnet_group_name', 'pre"
        "ferred_maintenance_window', 'db_parameter_group_name', 'backup_retention_period', 'preferred_backup_window', '"
        "port', 'multi_az', 'engine_version', 'auto_minor_version_upgrade', 'license_model', 'iops', 'storage_throughpu"
        "t', 'option_group_name', 'character_set_name', 'nchar_character_set_name', 'publicly_accessible', 'tags', 'db_"
        "cluster_identifier', 'storage_type', 'tde_credential_arn', 'tde_credential_password', 'storage_encrypted', 'km"
        "s_key_id', 'domain', 'domain_fqdn', 'domain_ou', 'domain_auth_secret_arn', 'domain_dns_ips', 'copy_tags_to_sna"
        "pshot', 'monitoring_interval', 'monitoring_role_arn', 'domain_iam_role_name', 'promotion_tier', 'timezone', 'e"
        "nable_iam_database_authentication', 'database_insights_mode', 'enable_performance_insights', 'performance_insi"
        "ghts_kms_key_id', 'performance_insights_retention_period', 'enable_cloudwatch_logs_exports', 'processor_featur"
        "es', 'deletion_protection', 'max_allocated_storage', 'enable_customer_owned_ip', 'network_type', 'backup_targe"
        "t', 'custom_iam_instance_profile', 'db_system_id', 'ca_certificate_identifier', 'manage_master_user_password',"
        " 'master_user_secret_kms_key_id', 'multi_tenant', 'dedicated_log_volume', 'engine_lifecycle_support', 'master_"
        "user_authentication_type', 'additional_storage_volumes'), allow_dynamic_dunder_attrs=False), HashPlan(action='"
        "add', fields=('db_name', 'db_instance_identifier', 'allocated_storage', 'db_instance_class', 'engine', 'master"
        "_username', 'master_user_password', 'db_security_groups', 'vpc_security_group_ids', 'availability_zone', 'db_s"
        "ubnet_group_name', 'preferred_maintenance_window', 'db_parameter_group_name', 'backup_retention_period', 'pref"
        "erred_backup_window', 'port', 'multi_az', 'engine_version', 'auto_minor_version_upgrade', 'license_model', 'io"
        "ps', 'storage_throughput', 'option_group_name', 'character_set_name', 'nchar_character_set_name', 'publicly_ac"
        "cessible', 'tags', 'db_cluster_identifier', 'storage_type', 'tde_credential_arn', 'tde_credential_password', '"
        "storage_encrypted', 'kms_key_id', 'domain', 'domain_fqdn', 'domain_ou', 'domain_auth_secret_arn', 'domain_dns_"
        "ips', 'copy_tags_to_snapshot', 'monitoring_interval', 'monitoring_role_arn', 'domain_iam_role_name', 'promotio"
        "n_tier', 'timezone', 'enable_iam_database_authentication', 'database_insights_mode', 'enable_performance_insig"
        "hts', 'performance_insights_kms_key_id', 'performance_insights_retention_period', 'enable_cloudwatch_logs_expo"
        "rts', 'processor_features', 'deletion_protection', 'max_allocated_storage', 'enable_customer_owned_ip', 'netwo"
        "rk_type', 'backup_target', 'custom_iam_instance_profile', 'db_system_id', 'ca_certificate_identifier', 'manage"
        "_master_user_password', 'master_user_secret_kms_key_id', 'multi_tenant', 'dedicated_log_volume', 'engine_lifec"
        "ycle_support', 'master_user_authentication_type', 'additional_storage_volumes'), cache=False), InitPlan(fields"
        "=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fa"
        "ctory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type="
        "None), InitPlan.Field(name='db_name', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='i"
        "nit.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='db_instance_identifier', annotation=OpRef(name='i"
        "nit.fields.2.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='allocated_storage', annotation=O"
        "pRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init"
        "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
        "ield(name='db_instance_class', annotation=OpRef(name='init.fields.4.annotation'), default=None, default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='engine', annotation=OpRef(name='init.fields.5.annotation'), default=None, default_facto"
        "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
        "), InitPlan.Field(name='master_username', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(nam"
        "e='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='master_user_password', annotation=OpRef(name="
        "'init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
        "'db_security_groups', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.def"
        "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
        "None, check_type=None), InitPlan.Field(name='vpc_security_group_ids', annotation=OpRef(name='init.fields.9.ann"
        "otation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='availability_zone"
        "', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None), InitPlan.Field(name='db_subnet_group_name', annotation=OpRef(name='init.fields.11.annotation'), default"
        "=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
        "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='preferred_maintenance_window', ann"
        "otation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory"
        "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
        " InitPlan.Field(name='db_parameter_group_name', annotation=OpRef(name='init.fields.13.annotation'), default=Op"
        "Ref(name='init.fields.13.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='backup_retention_period', annotation="
        "OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='preferred_backup_window', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name"
        "='init.fields.15.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='port', annotation=OpRef(name='init.fields.16."
        "annotation'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='multi_az', an"
        "notation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='engine_version', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name"
        "='init.fields.18.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='auto_minor_version_upgrade', annotation=OpRef"
        "(name='init.fields.19.annotation'), default=OpRef(name='init.fields.19.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
        "ld(name='license_model', annotation=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.fields.2"
        "0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='iops', annotation=OpRef(name='init.fields.21.annotation'), d"
        "efault=OpRef(name='init.fields.21.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='storage_throughput', annotat"
        "ion=OpRef(name='init.fields.22.annotation'), default=OpRef(name='init.fields.22.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='option_group_name', annotation=OpRef(name='init.fields.23.annotation'), default=OpRef(name='"
        "init.fields.23.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None), InitPlan.Field(name='character_set_name', annotation=OpRef(name='ini"
        "t.fields.24.annotation'), default=OpRef(name='init.fields.24.default'), default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='n"
        "char_character_set_name', annotation=OpRef(name='init.fields.25.annotation'), default=OpRef(name='init.fields."
        "25.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='publicly_accessible', annotation=OpRef(name='init.fields.26"
        ".annotation'), default=OpRef(name='init.fields.26.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags', annot"
        "ation=OpRef(name='init.fields.27.annotation'), default=OpRef(name='init.fields.27.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='db_cluster_identifier', annotation=OpRef(name='init.fields.28.annotation'), default=OpRef("
        "name='init.fields.28.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='storage_type', annotation=OpRef(name='ini"
        "t.fields.29.annotation'), default=OpRef(name='init.fields.29.default'), default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='t"
        "de_credential_arn', annotation=OpRef(name='init.fields.30.annotation'), default=OpRef(name='init.fields.30.def"
        "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
        "None, check_type=None), InitPlan.Field(name='tde_credential_password', annotation=OpRef(name='init.fields.31.a"
        "nnotation'), default=OpRef(name='init.fields.31.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='storage_encryp"
        "ted', annotation=OpRef(name='init.fields.32.annotation'), default=OpRef(name='init.fields.32.default'), defaul"
        "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
        "pe=None), InitPlan.Field(name='kms_key_id', annotation=OpRef(name='init.fields.33.annotation'), default=OpRef("
        "name='init.fields.33.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='domain', annotation=OpRef(name='init.fiel"
        "ds.34.annotation'), default=OpRef(name='init.fields.34.default'), default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='domain_"
        "fqdn', annotation=OpRef(name='init.fields.35.annotation'), default=OpRef(name='init.fields.35.default'), defau"
        "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
        "ype=None), InitPlan.Field(name='domain_ou', annotation=OpRef(name='init.fields.36.annotation'), default=OpRef("
        "name='init.fields.36.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='domain_auth_secret_arn', annotation=OpRef"
        "(name='init.fields.37.annotation'), default=OpRef(name='init.fields.37.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
        "ld(name='domain_dns_ips', annotation=OpRef(name='init.fields.38.annotation'), default=OpRef(name='init.fields."
        "38.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='copy_tags_to_snapshot', annotation=OpRef(name='init.fields."
        "39.annotation'), default=OpRef(name='init.fields.39.default'), default_factory=None, init=True, override=False"
        ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='monitoring"
        "_interval', annotation=OpRef(name='init.fields.40.annotation'), default=OpRef(name='init.fields.40.default'), "
        "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
        "eck_type=None), InitPlan.Field(name='monitoring_role_arn', annotation=OpRef(name='init.fields.41.annotation'),"
        " default=OpRef(name='init.fields.41.default'), default_factory=None, init=True, override=False, field_type=Fie"
        "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='domain_iam_role_name', ann"
        "otation=OpRef(name='init.fields.42.annotation'), default=OpRef(name='init.fields.42.default'), default_factory"
        "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
        " InitPlan.Field(name='promotion_tier', annotation=OpRef(name='init.fields.43.annotation'), default=OpRef(name="
        "'init.fields.43.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='timezone', annotation=OpRef(name='init.fields."
        "44.annotation'), default=OpRef(name='init.fields.44.default'), default_factory=None, init=True, override=False"
        ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='enable_iam"
        "_database_authentication', annotation=OpRef(name='init.fields.45.annotation'), default=OpRef(name='init.fields"
        ".45.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='database_insights_mode', annotation=OpRef(name='init.field"
        "s.46.annotation'), default=OpRef(name='init.fields.46.default'), default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='enable_p"
        "erformance_insights', annotation=OpRef(name='init.fields.47.annotation'), default=OpRef(name='init.fields.47.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='performance_insights_kms_key_id', annotation=OpRef(name='init.f"
        "ields.48.annotation'), default=OpRef(name='init.fields.48.default'), default_factory=None, init=True, override"
        "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='perf"
        "ormance_insights_retention_period', annotation=OpRef(name='init.fields.49.annotation'), default=OpRef(name='in"
        "it.fields.49.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='enable_cloudwatch_logs_exports', annotation=OpRef"
        "(name='init.fields.50.annotation'), default=OpRef(name='init.fields.50.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
        "ld(name='processor_features', annotation=OpRef(name='init.fields.51.annotation'), default=OpRef(name='init.fie"
        "lds.51.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='deletion_protection', annotation=OpRef(name='init.field"
        "s.52.annotation'), default=OpRef(name='init.fields.52.default'), default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_allo"
        "cated_storage', annotation=OpRef(name='init.fields.53.annotation'), default=OpRef(name='init.fields.53.default"
        "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
        ", check_type=None), InitPlan.Field(name='enable_customer_owned_ip', annotation=OpRef(name='init.fields.54.anno"
        "tation'), default=OpRef(name='init.fields.54.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_type', an"
        "notation=OpRef(name='init.fields.55.annotation'), default=OpRef(name='init.fields.55.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='backup_target', annotation=OpRef(name='init.fields.56.annotation'), default=OpRef(name="
        "'init.fields.56.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='custom_iam_instance_profile', annotation=OpRef"
        "(name='init.fields.57.annotation'), default=OpRef(name='init.fields.57.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
        "ld(name='db_system_id', annotation=OpRef(name='init.fields.58.annotation'), default=OpRef(name='init.fields.58"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None), InitPlan.Field(name='ca_certificate_identifier', annotation=OpRef(name='init.field"
        "s.59.annotation'), default=OpRef(name='init.fields.59.default'), default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='manage_m"
        "aster_user_password', annotation=OpRef(name='init.fields.60.annotation'), default=OpRef(name='init.fields.60.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='master_user_secret_kms_key_id', annotation=OpRef(name='init.fie"
        "lds.61.annotation'), default=OpRef(name='init.fields.61.default'), default_factory=None, init=True, override=F"
        "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='multi_"
        "tenant', annotation=OpRef(name='init.fields.62.annotation'), default=OpRef(name='init.fields.62.default'), def"
        "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
        "_type=None), InitPlan.Field(name='dedicated_log_volume', annotation=OpRef(name='init.fields.63.annotation'), d"
        "efault=OpRef(name='init.fields.63.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='engine_lifecycle_support', a"
        "nnotation=OpRef(name='init.fields.64.annotation'), default=OpRef(name='init.fields.64.default'), default_facto"
        "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
        "), InitPlan.Field(name='master_user_authentication_type', annotation=OpRef(name='init.fields.65.annotation'), "
        "default=OpRef(name='init.fields.65.default'), default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='additional_storage_volumes'"
        ", annotation=OpRef(name='init.fields.66.annotation'), default=OpRef(name='init.fields.66.default'), default_fa"
        "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
        "one)), self_param='self', std_params=(), kw_only_params=('db_name', 'db_instance_identifier', 'allocated_stora"
        "ge', 'db_instance_class', 'engine', 'master_username', 'master_user_password', 'db_security_groups', 'vpc_secu"
        "rity_group_ids', 'availability_zone', 'db_subnet_group_name', 'preferred_maintenance_window', 'db_parameter_gr"
        "oup_name', 'backup_retention_period', 'preferred_backup_window', 'port', 'multi_az', 'engine_version', 'auto_m"
        "inor_version_upgrade', 'license_model', 'iops', 'storage_throughput', 'option_group_name', 'character_set_name"
        "', 'nchar_character_set_name', 'publicly_accessible', 'tags', 'db_cluster_identifier', 'storage_type', 'tde_cr"
        "edential_arn', 'tde_credential_password', 'storage_encrypted', 'kms_key_id', 'domain', 'domain_fqdn', 'domain_"
        "ou', 'domain_auth_secret_arn', 'domain_dns_ips', 'copy_tags_to_snapshot', 'monitoring_interval', 'monitoring_r"
        "ole_arn', 'domain_iam_role_name', 'promotion_tier', 'timezone', 'enable_iam_database_authentication', 'databas"
        "e_insights_mode', 'enable_performance_insights', 'performance_insights_kms_key_id', 'performance_insights_rete"
        "ntion_period', 'enable_cloudwatch_logs_exports', 'processor_features', 'deletion_protection', 'max_allocated_s"
        "torage', 'enable_customer_owned_ip', 'network_type', 'backup_target', 'custom_iam_instance_profile', 'db_syste"
        "m_id', 'ca_certificate_identifier', 'manage_master_user_password', 'master_user_secret_kms_key_id', 'multi_ten"
        "ant', 'dedicated_log_volume', 'engine_lifecycle_support', 'master_user_authentication_type', 'additional_stora"
        "ge_volumes'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields="
        "(ReprPlan.Field(name='db_name', kw_only=True, fn=None), ReprPlan.Field(name='db_instance_identifier', kw_only="
        "True, fn=None), ReprPlan.Field(name='allocated_storage', kw_only=True, fn=None), ReprPlan.Field(name='db_insta"
        "nce_class', kw_only=True, fn=None), ReprPlan.Field(name='engine', kw_only=True, fn=None), ReprPlan.Field(name="
        "'master_username', kw_only=True, fn=None), ReprPlan.Field(name='master_user_password', kw_only=True, fn=None),"
        " ReprPlan.Field(name='db_security_groups', kw_only=True, fn=None), ReprPlan.Field(name='vpc_security_group_ids"
        "', kw_only=True, fn=None), ReprPlan.Field(name='availability_zone', kw_only=True, fn=None), ReprPlan.Field(nam"
        "e='db_subnet_group_name', kw_only=True, fn=None), ReprPlan.Field(name='preferred_maintenance_window', kw_only="
        "True, fn=None), ReprPlan.Field(name='db_parameter_group_name', kw_only=True, fn=None), ReprPlan.Field(name='ba"
        "ckup_retention_period', kw_only=True, fn=None), ReprPlan.Field(name='preferred_backup_window', kw_only=True, f"
        "n=None), ReprPlan.Field(name='port', kw_only=True, fn=None), ReprPlan.Field(name='multi_az', kw_only=True, fn="
        "None), ReprPlan.Field(name='engine_version', kw_only=True, fn=None), ReprPlan.Field(name='auto_minor_version_u"
        "pgrade', kw_only=True, fn=None), ReprPlan.Field(name='license_model', kw_only=True, fn=None), ReprPlan.Field(n"
        "ame='iops', kw_only=True, fn=None), ReprPlan.Field(name='storage_throughput', kw_only=True, fn=None), ReprPlan"
        ".Field(name='option_group_name', kw_only=True, fn=None), ReprPlan.Field(name='character_set_name', kw_only=Tru"
        "e, fn=None), ReprPlan.Field(name='nchar_character_set_name', kw_only=True, fn=None), ReprPlan.Field(name='publ"
        "icly_accessible', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=True, fn=None), ReprPlan.Field(n"
        "ame='db_cluster_identifier', kw_only=True, fn=None), ReprPlan.Field(name='storage_type', kw_only=True, fn=None"
        "), ReprPlan.Field(name='tde_credential_arn', kw_only=True, fn=None), ReprPlan.Field(name='tde_credential_passw"
        "ord', kw_only=True, fn=None), ReprPlan.Field(name='storage_encrypted', kw_only=True, fn=None), ReprPlan.Field("
        "name='kms_key_id', kw_only=True, fn=None), ReprPlan.Field(name='domain', kw_only=True, fn=None), ReprPlan.Fiel"
        "d(name='domain_fqdn', kw_only=True, fn=None), ReprPlan.Field(name='domain_ou', kw_only=True, fn=None), ReprPla"
        "n.Field(name='domain_auth_secret_arn', kw_only=True, fn=None), ReprPlan.Field(name='domain_dns_ips', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='copy_tags_to_snapshot', kw_only=True, fn=None), ReprPlan.Field(name='monit"
        "oring_interval', kw_only=True, fn=None), ReprPlan.Field(name='monitoring_role_arn', kw_only=True, fn=None), Re"
        "prPlan.Field(name='domain_iam_role_name', kw_only=True, fn=None), ReprPlan.Field(name='promotion_tier', kw_onl"
        "y=True, fn=None), ReprPlan.Field(name='timezone', kw_only=True, fn=None), ReprPlan.Field(name='enable_iam_data"
        "base_authentication', kw_only=True, fn=None), ReprPlan.Field(name='database_insights_mode', kw_only=True, fn=N"
        "one), ReprPlan.Field(name='enable_performance_insights', kw_only=True, fn=None), ReprPlan.Field(name='performa"
        "nce_insights_kms_key_id', kw_only=True, fn=None), ReprPlan.Field(name='performance_insights_retention_period',"
        " kw_only=True, fn=None), ReprPlan.Field(name='enable_cloudwatch_logs_exports', kw_only=True, fn=None), ReprPla"
        "n.Field(name='processor_features', kw_only=True, fn=None), ReprPlan.Field(name='deletion_protection', kw_only="
        "True, fn=None), ReprPlan.Field(name='max_allocated_storage', kw_only=True, fn=None), ReprPlan.Field(name='enab"
        "le_customer_owned_ip', kw_only=True, fn=None), ReprPlan.Field(name='network_type', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='backup_target', kw_only=True, fn=None), ReprPlan.Field(name='custom_iam_instance_profile', k"
        "w_only=True, fn=None), ReprPlan.Field(name='db_system_id', kw_only=True, fn=None), ReprPlan.Field(name='ca_cer"
        "tificate_identifier', kw_only=True, fn=None), ReprPlan.Field(name='manage_master_user_password', kw_only=True,"
        " fn=None), ReprPlan.Field(name='master_user_secret_kms_key_id', kw_only=True, fn=None), ReprPlan.Field(name='m"
        "ulti_tenant', kw_only=True, fn=None), ReprPlan.Field(name='dedicated_log_volume', kw_only=True, fn=None), Repr"
        "Plan.Field(name='engine_lifecycle_support', kw_only=True, fn=None), ReprPlan.Field(name='master_user_authentic"
        "ation_type', kw_only=True, fn=None), ReprPlan.Field(name='additional_storage_volumes', kw_only=True, fn=None))"
        ", id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='e0b36cd17bf218d50022119d36b015f0f52cd20c',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__24__annotation',
        '__dataclass__init__fields__24__default',
        '__dataclass__init__fields__25__annotation',
        '__dataclass__init__fields__25__default',
        '__dataclass__init__fields__26__annotation',
        '__dataclass__init__fields__26__default',
        '__dataclass__init__fields__27__annotation',
        '__dataclass__init__fields__27__default',
        '__dataclass__init__fields__28__annotation',
        '__dataclass__init__fields__28__default',
        '__dataclass__init__fields__29__annotation',
        '__dataclass__init__fields__29__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__30__annotation',
        '__dataclass__init__fields__30__default',
        '__dataclass__init__fields__31__annotation',
        '__dataclass__init__fields__31__default',
        '__dataclass__init__fields__32__annotation',
        '__dataclass__init__fields__32__default',
        '__dataclass__init__fields__33__annotation',
        '__dataclass__init__fields__33__default',
        '__dataclass__init__fields__34__annotation',
        '__dataclass__init__fields__34__default',
        '__dataclass__init__fields__35__annotation',
        '__dataclass__init__fields__35__default',
        '__dataclass__init__fields__36__annotation',
        '__dataclass__init__fields__36__default',
        '__dataclass__init__fields__37__annotation',
        '__dataclass__init__fields__37__default',
        '__dataclass__init__fields__38__annotation',
        '__dataclass__init__fields__38__default',
        '__dataclass__init__fields__39__annotation',
        '__dataclass__init__fields__39__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__40__annotation',
        '__dataclass__init__fields__40__default',
        '__dataclass__init__fields__41__annotation',
        '__dataclass__init__fields__41__default',
        '__dataclass__init__fields__42__annotation',
        '__dataclass__init__fields__42__default',
        '__dataclass__init__fields__43__annotation',
        '__dataclass__init__fields__43__default',
        '__dataclass__init__fields__44__annotation',
        '__dataclass__init__fields__44__default',
        '__dataclass__init__fields__45__annotation',
        '__dataclass__init__fields__45__default',
        '__dataclass__init__fields__46__annotation',
        '__dataclass__init__fields__46__default',
        '__dataclass__init__fields__47__annotation',
        '__dataclass__init__fields__47__default',
        '__dataclass__init__fields__48__annotation',
        '__dataclass__init__fields__48__default',
        '__dataclass__init__fields__49__annotation',
        '__dataclass__init__fields__49__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__50__annotation',
        '__dataclass__init__fields__50__default',
        '__dataclass__init__fields__51__annotation',
        '__dataclass__init__fields__51__default',
        '__dataclass__init__fields__52__annotation',
        '__dataclass__init__fields__52__default',
        '__dataclass__init__fields__53__annotation',
        '__dataclass__init__fields__53__default',
        '__dataclass__init__fields__54__annotation',
        '__dataclass__init__fields__54__default',
        '__dataclass__init__fields__55__annotation',
        '__dataclass__init__fields__55__default',
        '__dataclass__init__fields__56__annotation',
        '__dataclass__init__fields__56__default',
        '__dataclass__init__fields__57__annotation',
        '__dataclass__init__fields__57__default',
        '__dataclass__init__fields__58__annotation',
        '__dataclass__init__fields__58__default',
        '__dataclass__init__fields__59__annotation',
        '__dataclass__init__fields__59__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__60__annotation',
        '__dataclass__init__fields__60__default',
        '__dataclass__init__fields__61__annotation',
        '__dataclass__init__fields__61__default',
        '__dataclass__init__fields__62__annotation',
        '__dataclass__init__fields__62__default',
        '__dataclass__init__fields__63__annotation',
        '__dataclass__init__fields__63__default',
        '__dataclass__init__fields__64__annotation',
        '__dataclass__init__fields__64__default',
        '__dataclass__init__fields__65__annotation',
        '__dataclass__init__fields__65__default',
        '__dataclass__init__fields__66__annotation',
        '__dataclass__init__fields__66__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'CreateDBInstanceMessage'),
    ),
)
def _process_dataclass__e0b36cd17bf218d50022119d36b015f0f52cd20c():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__24__annotation,
        __dataclass__init__fields__24__default,
        __dataclass__init__fields__25__annotation,
        __dataclass__init__fields__25__default,
        __dataclass__init__fields__26__annotation,
        __dataclass__init__fields__26__default,
        __dataclass__init__fields__27__annotation,
        __dataclass__init__fields__27__default,
        __dataclass__init__fields__28__annotation,
        __dataclass__init__fields__28__default,
        __dataclass__init__fields__29__annotation,
        __dataclass__init__fields__29__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__30__annotation,
        __dataclass__init__fields__30__default,
        __dataclass__init__fields__31__annotation,
        __dataclass__init__fields__31__default,
        __dataclass__init__fields__32__annotation,
        __dataclass__init__fields__32__default,
        __dataclass__init__fields__33__annotation,
        __dataclass__init__fields__33__default,
        __dataclass__init__fields__34__annotation,
        __dataclass__init__fields__34__default,
        __dataclass__init__fields__35__annotation,
        __dataclass__init__fields__35__default,
        __dataclass__init__fields__36__annotation,
        __dataclass__init__fields__36__default,
        __dataclass__init__fields__37__annotation,
        __dataclass__init__fields__37__default,
        __dataclass__init__fields__38__annotation,
        __dataclass__init__fields__38__default,
        __dataclass__init__fields__39__annotation,
        __dataclass__init__fields__39__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__40__annotation,
        __dataclass__init__fields__40__default,
        __dataclass__init__fields__41__annotation,
        __dataclass__init__fields__41__default,
        __dataclass__init__fields__42__annotation,
        __dataclass__init__fields__42__default,
        __dataclass__init__fields__43__annotation,
        __dataclass__init__fields__43__default,
        __dataclass__init__fields__44__annotation,
        __dataclass__init__fields__44__default,
        __dataclass__init__fields__45__annotation,
        __dataclass__init__fields__45__default,
        __dataclass__init__fields__46__annotation,
        __dataclass__init__fields__46__default,
        __dataclass__init__fields__47__annotation,
        __dataclass__init__fields__47__default,
        __dataclass__init__fields__48__annotation,
        __dataclass__init__fields__48__default,
        __dataclass__init__fields__49__annotation,
        __dataclass__init__fields__49__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__50__annotation,
        __dataclass__init__fields__50__default,
        __dataclass__init__fields__51__annotation,
        __dataclass__init__fields__51__default,
        __dataclass__init__fields__52__annotation,
        __dataclass__init__fields__52__default,
        __dataclass__init__fields__53__annotation,
        __dataclass__init__fields__53__default,
        __dataclass__init__fields__54__annotation,
        __dataclass__init__fields__54__default,
        __dataclass__init__fields__55__annotation,
        __dataclass__init__fields__55__default,
        __dataclass__init__fields__56__annotation,
        __dataclass__init__fields__56__default,
        __dataclass__init__fields__57__annotation,
        __dataclass__init__fields__57__default,
        __dataclass__init__fields__58__annotation,
        __dataclass__init__fields__58__default,
        __dataclass__init__fields__59__annotation,
        __dataclass__init__fields__59__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__60__annotation,
        __dataclass__init__fields__60__default,
        __dataclass__init__fields__61__annotation,
        __dataclass__init__fields__61__default,
        __dataclass__init__fields__62__annotation,
        __dataclass__init__fields__62__default,
        __dataclass__init__fields__63__annotation,
        __dataclass__init__fields__63__default,
        __dataclass__init__fields__64__annotation,
        __dataclass__init__fields__64__default,
        __dataclass__init__fields__65__annotation,
        __dataclass__init__fields__65__default,
        __dataclass__init__fields__66__annotation,
        __dataclass__init__fields__66__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                db_name=self.db_name,
                db_instance_identifier=self.db_instance_identifier,
                allocated_storage=self.allocated_storage,
                db_instance_class=self.db_instance_class,
                engine=self.engine,
                master_username=self.master_username,
                master_user_password=self.master_user_password,
                db_security_groups=self.db_security_groups,
                vpc_security_group_ids=self.vpc_security_group_ids,
                availability_zone=self.availability_zone,
                db_subnet_group_name=self.db_subnet_group_name,
                preferred_maintenance_window=self.preferred_maintenance_window,
                db_parameter_group_name=self.db_parameter_group_name,
                backup_retention_period=self.backup_retention_period,
                preferred_backup_window=self.preferred_backup_window,
                port=self.port,
                multi_az=self.multi_az,
                engine_version=self.engine_version,
                auto_minor_version_upgrade=self.auto_minor_version_upgrade,
                license_model=self.license_model,
                iops=self.iops,
                storage_throughput=self.storage_throughput,
                option_group_name=self.option_group_name,
                character_set_name=self.character_set_name,
                nchar_character_set_name=self.nchar_character_set_name,
                publicly_accessible=self.publicly_accessible,
                tags=self.tags,
                db_cluster_identifier=self.db_cluster_identifier,
                storage_type=self.storage_type,
                tde_credential_arn=self.tde_credential_arn,
                tde_credential_password=self.tde_credential_password,
                storage_encrypted=self.storage_encrypted,
                kms_key_id=self.kms_key_id,
                domain=self.domain,
                domain_fqdn=self.domain_fqdn,
                domain_ou=self.domain_ou,
                domain_auth_secret_arn=self.domain_auth_secret_arn,
                domain_dns_ips=self.domain_dns_ips,
                copy_tags_to_snapshot=self.copy_tags_to_snapshot,
                monitoring_interval=self.monitoring_interval,
                monitoring_role_arn=self.monitoring_role_arn,
                domain_iam_role_name=self.domain_iam_role_name,
                promotion_tier=self.promotion_tier,
                timezone=self.timezone,
                enable_iam_database_authentication=self.enable_iam_database_authentication,
                database_insights_mode=self.database_insights_mode,
                enable_performance_insights=self.enable_performance_insights,
                performance_insights_kms_key_id=self.performance_insights_kms_key_id,
                performance_insights_retention_period=self.performance_insights_retention_period,
                enable_cloudwatch_logs_exports=self.enable_cloudwatch_logs_exports,
                processor_features=self.processor_features,
                deletion_protection=self.deletion_protection,
                max_allocated_storage=self.max_allocated_storage,
                enable_customer_owned_ip=self.enable_customer_owned_ip,
                network_type=self.network_type,
                backup_target=self.backup_target,
                custom_iam_instance_profile=self.custom_iam_instance_profile,
                db_system_id=self.db_system_id,
                ca_certificate_identifier=self.ca_certificate_identifier,
                manage_master_user_password=self.manage_master_user_password,
                master_user_secret_kms_key_id=self.master_user_secret_kms_key_id,
                multi_tenant=self.multi_tenant,
                dedicated_log_volume=self.dedicated_log_volume,
                engine_lifecycle_support=self.engine_lifecycle_support,
                master_user_authentication_type=self.master_user_authentication_type,
                additional_storage_volumes=self.additional_storage_volumes,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.db_name == other.db_name and
                self.db_instance_identifier == other.db_instance_identifier and
                self.allocated_storage == other.allocated_storage and
                self.db_instance_class == other.db_instance_class and
                self.engine == other.engine and
                self.master_username == other.master_username and
                self.master_user_password == other.master_user_password and
                self.db_security_groups == other.db_security_groups and
                self.vpc_security_group_ids == other.vpc_security_group_ids and
                self.availability_zone == other.availability_zone and
                self.db_subnet_group_name == other.db_subnet_group_name and
                self.preferred_maintenance_window == other.preferred_maintenance_window and
                self.db_parameter_group_name == other.db_parameter_group_name and
                self.backup_retention_period == other.backup_retention_period and
                self.preferred_backup_window == other.preferred_backup_window and
                self.port == other.port and
                self.multi_az == other.multi_az and
                self.engine_version == other.engine_version and
                self.auto_minor_version_upgrade == other.auto_minor_version_upgrade and
                self.license_model == other.license_model and
                self.iops == other.iops and
                self.storage_throughput == other.storage_throughput and
                self.option_group_name == other.option_group_name and
                self.character_set_name == other.character_set_name and
                self.nchar_character_set_name == other.nchar_character_set_name and
                self.publicly_accessible == other.publicly_accessible and
                self.tags == other.tags and
                self.db_cluster_identifier == other.db_cluster_identifier and
                self.storage_type == other.storage_type and
                self.tde_credential_arn == other.tde_credential_arn and
                self.tde_credential_password == other.tde_credential_password and
                self.storage_encrypted == other.storage_encrypted and
                self.kms_key_id == other.kms_key_id and
                self.domain == other.domain and
                self.domain_fqdn == other.domain_fqdn and
                self.domain_ou == other.domain_ou and
                self.domain_auth_secret_arn == other.domain_auth_secret_arn and
                self.domain_dns_ips == other.domain_dns_ips and
                self.copy_tags_to_snapshot == other.copy_tags_to_snapshot and
                self.monitoring_interval == other.monitoring_interval and
                self.monitoring_role_arn == other.monitoring_role_arn and
                self.domain_iam_role_name == other.domain_iam_role_name and
                self.promotion_tier == other.promotion_tier and
                self.timezone == other.timezone and
                self.enable_iam_database_authentication == other.enable_iam_database_authentication and
                self.database_insights_mode == other.database_insights_mode and
                self.enable_performance_insights == other.enable_performance_insights and
                self.performance_insights_kms_key_id == other.performance_insights_kms_key_id and
                self.performance_insights_retention_period == other.performance_insights_retention_period and
                self.enable_cloudwatch_logs_exports == other.enable_cloudwatch_logs_exports and
                self.processor_features == other.processor_features and
                self.deletion_protection == other.deletion_protection and
                self.max_allocated_storage == other.max_allocated_storage and
                self.enable_customer_owned_ip == other.enable_customer_owned_ip and
                self.network_type == other.network_type and
                self.backup_target == other.backup_target and
                self.custom_iam_instance_profile == other.custom_iam_instance_profile and
                self.db_system_id == other.db_system_id and
                self.ca_certificate_identifier == other.ca_certificate_identifier and
                self.manage_master_user_password == other.manage_master_user_password and
                self.master_user_secret_kms_key_id == other.master_user_secret_kms_key_id and
                self.multi_tenant == other.multi_tenant and
                self.dedicated_log_volume == other.dedicated_log_volume and
                self.engine_lifecycle_support == other.engine_lifecycle_support and
                self.master_user_authentication_type == other.master_user_authentication_type and
                self.additional_storage_volumes == other.additional_storage_volumes
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'db_name',
            'db_instance_identifier',
            'allocated_storage',
            'db_instance_class',
            'engine',
            'master_username',
            'master_user_password',
            'db_security_groups',
            'vpc_security_group_ids',
            'availability_zone',
            'db_subnet_group_name',
            'preferred_maintenance_window',
            'db_parameter_group_name',
            'backup_retention_period',
            'preferred_backup_window',
            'port',
            'multi_az',
            'engine_version',
            'auto_minor_version_upgrade',
            'license_model',
            'iops',
            'storage_throughput',
            'option_group_name',
            'character_set_name',
            'nchar_character_set_name',
            'publicly_accessible',
            'tags',
            'db_cluster_identifier',
            'storage_type',
            'tde_credential_arn',
            'tde_credential_password',
            'storage_encrypted',
            'kms_key_id',
            'domain',
            'domain_fqdn',
            'domain_ou',
            'domain_auth_secret_arn',
            'domain_dns_ips',
            'copy_tags_to_snapshot',
            'monitoring_interval',
            'monitoring_role_arn',
            'domain_iam_role_name',
            'promotion_tier',
            'timezone',
            'enable_iam_database_authentication',
            'database_insights_mode',
            'enable_performance_insights',
            'performance_insights_kms_key_id',
            'performance_insights_retention_period',
            'enable_cloudwatch_logs_exports',
            'processor_features',
            'deletion_protection',
            'max_allocated_storage',
            'enable_customer_owned_ip',
            'network_type',
            'backup_target',
            'custom_iam_instance_profile',
            'db_system_id',
            'ca_certificate_identifier',
            'manage_master_user_password',
            'master_user_secret_kms_key_id',
            'multi_tenant',
            'dedicated_log_volume',
            'engine_lifecycle_support',
            'master_user_authentication_type',
            'additional_storage_volumes',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'db_name',
            'db_instance_identifier',
            'allocated_storage',
            'db_instance_class',
            'engine',
            'master_username',
            'master_user_password',
            'db_security_groups',
            'vpc_security_group_ids',
            'availability_zone',
            'db_subnet_group_name',
            'preferred_maintenance_window',
            'db_parameter_group_name',
            'backup_retention_period',
            'preferred_backup_window',
            'port',
            'multi_az',
            'engine_version',
            'auto_minor_version_upgrade',
            'license_model',
            'iops',
            'storage_throughput',
            'option_group_name',
            'character_set_name',
            'nchar_character_set_name',
            'publicly_accessible',
            'tags',
            'db_cluster_identifier',
            'storage_type',
            'tde_credential_arn',
            'tde_credential_password',
            'storage_encrypted',
            'kms_key_id',
            'domain',
            'domain_fqdn',
            'domain_ou',
            'domain_auth_secret_arn',
            'domain_dns_ips',
            'copy_tags_to_snapshot',
            'monitoring_interval',
            'monitoring_role_arn',
            'domain_iam_role_name',
            'promotion_tier',
            'timezone',
            'enable_iam_database_authentication',
            'database_insights_mode',
            'enable_performance_insights',
            'performance_insights_kms_key_id',
            'performance_insights_retention_period',
            'enable_cloudwatch_logs_exports',
            'processor_features',
            'deletion_protection',
            'max_allocated_storage',
            'enable_customer_owned_ip',
            'network_type',
            'backup_target',
            'custom_iam_instance_profile',
            'db_system_id',
            'ca_certificate_identifier',
            'manage_master_user_password',
            'master_user_secret_kms_key_id',
            'multi_tenant',
            'dedicated_log_volume',
            'engine_lifecycle_support',
            'master_user_authentication_type',
            'additional_storage_volumes',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.db_name,
                self.db_instance_identifier,
                self.allocated_storage,
                self.db_instance_class,
                self.engine,
                self.master_username,
                self.master_user_password,
                self.db_security_groups,
                self.vpc_security_group_ids,
                self.availability_zone,
                self.db_subnet_group_name,
                self.preferred_maintenance_window,
                self.db_parameter_group_name,
                self.backup_retention_period,
                self.preferred_backup_window,
                self.port,
                self.multi_az,
                self.engine_version,
                self.auto_minor_version_upgrade,
                self.license_model,
                self.iops,
                self.storage_throughput,
                self.option_group_name,
                self.character_set_name,
                self.nchar_character_set_name,
                self.publicly_accessible,
                self.tags,
                self.db_cluster_identifier,
                self.storage_type,
                self.tde_credential_arn,
                self.tde_credential_password,
                self.storage_encrypted,
                self.kms_key_id,
                self.domain,
                self.domain_fqdn,
                self.domain_ou,
                self.domain_auth_secret_arn,
                self.domain_dns_ips,
                self.copy_tags_to_snapshot,
                self.monitoring_interval,
                self.monitoring_role_arn,
                self.domain_iam_role_name,
                self.promotion_tier,
                self.timezone,
                self.enable_iam_database_authentication,
                self.database_insights_mode,
                self.enable_performance_insights,
                self.performance_insights_kms_key_id,
                self.performance_insights_retention_period,
                self.enable_cloudwatch_logs_exports,
                self.processor_features,
                self.deletion_protection,
                self.max_allocated_storage,
                self.enable_customer_owned_ip,
                self.network_type,
                self.backup_target,
                self.custom_iam_instance_profile,
                self.db_system_id,
                self.ca_certificate_identifier,
                self.manage_master_user_password,
                self.master_user_secret_kms_key_id,
                self.multi_tenant,
                self.dedicated_log_volume,
                self.engine_lifecycle_support,
                self.master_user_authentication_type,
                self.additional_storage_volumes,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            db_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            db_instance_identifier: __dataclass__init__fields__2__annotation,
            allocated_storage: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            db_instance_class: __dataclass__init__fields__4__annotation,
            engine: __dataclass__init__fields__5__annotation,
            master_username: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            master_user_password: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            db_security_groups: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            vpc_security_group_ids: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            availability_zone: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            db_subnet_group_name: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            preferred_maintenance_window: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            db_parameter_group_name: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            backup_retention_period: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            preferred_backup_window: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            port: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            multi_az: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            engine_version: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            auto_minor_version_upgrade: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            license_model: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            iops: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            storage_throughput: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            option_group_name: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
            character_set_name: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
            nchar_character_set_name: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
            publicly_accessible: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
            tags: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
            db_cluster_identifier: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
            storage_type: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
            tde_credential_arn: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
            tde_credential_password: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
            storage_encrypted: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
            kms_key_id: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
            domain: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
            domain_fqdn: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
            domain_ou: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
            domain_auth_secret_arn: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
            domain_dns_ips: __dataclass__init__fields__38__annotation = __dataclass__init__fields__38__default,
            copy_tags_to_snapshot: __dataclass__init__fields__39__annotation = __dataclass__init__fields__39__default,
            monitoring_interval: __dataclass__init__fields__40__annotation = __dataclass__init__fields__40__default,
            monitoring_role_arn: __dataclass__init__fields__41__annotation = __dataclass__init__fields__41__default,
            domain_iam_role_name: __dataclass__init__fields__42__annotation = __dataclass__init__fields__42__default,
            promotion_tier: __dataclass__init__fields__43__annotation = __dataclass__init__fields__43__default,
            timezone: __dataclass__init__fields__44__annotation = __dataclass__init__fields__44__default,
            enable_iam_database_authentication: __dataclass__init__fields__45__annotation = __dataclass__init__fields__45__default,
            database_insights_mode: __dataclass__init__fields__46__annotation = __dataclass__init__fields__46__default,
            enable_performance_insights: __dataclass__init__fields__47__annotation = __dataclass__init__fields__47__default,
            performance_insights_kms_key_id: __dataclass__init__fields__48__annotation = __dataclass__init__fields__48__default,
            performance_insights_retention_period: __dataclass__init__fields__49__annotation = __dataclass__init__fields__49__default,
            enable_cloudwatch_logs_exports: __dataclass__init__fields__50__annotation = __dataclass__init__fields__50__default,
            processor_features: __dataclass__init__fields__51__annotation = __dataclass__init__fields__51__default,
            deletion_protection: __dataclass__init__fields__52__annotation = __dataclass__init__fields__52__default,
            max_allocated_storage: __dataclass__init__fields__53__annotation = __dataclass__init__fields__53__default,
            enable_customer_owned_ip: __dataclass__init__fields__54__annotation = __dataclass__init__fields__54__default,
            network_type: __dataclass__init__fields__55__annotation = __dataclass__init__fields__55__default,
            backup_target: __dataclass__init__fields__56__annotation = __dataclass__init__fields__56__default,
            custom_iam_instance_profile: __dataclass__init__fields__57__annotation = __dataclass__init__fields__57__default,
            db_system_id: __dataclass__init__fields__58__annotation = __dataclass__init__fields__58__default,
            ca_certificate_identifier: __dataclass__init__fields__59__annotation = __dataclass__init__fields__59__default,
            manage_master_user_password: __dataclass__init__fields__60__annotation = __dataclass__init__fields__60__default,
            master_user_secret_kms_key_id: __dataclass__init__fields__61__annotation = __dataclass__init__fields__61__default,
            multi_tenant: __dataclass__init__fields__62__annotation = __dataclass__init__fields__62__default,
            dedicated_log_volume: __dataclass__init__fields__63__annotation = __dataclass__init__fields__63__default,
            engine_lifecycle_support: __dataclass__init__fields__64__annotation = __dataclass__init__fields__64__default,
            master_user_authentication_type: __dataclass__init__fields__65__annotation = __dataclass__init__fields__65__default,
            additional_storage_volumes: __dataclass__init__fields__66__annotation = __dataclass__init__fields__66__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'db_name', db_name)
            __dataclass__object_setattr(self, 'db_instance_identifier', db_instance_identifier)
            __dataclass__object_setattr(self, 'allocated_storage', allocated_storage)
            __dataclass__object_setattr(self, 'db_instance_class', db_instance_class)
            __dataclass__object_setattr(self, 'engine', engine)
            __dataclass__object_setattr(self, 'master_username', master_username)
            __dataclass__object_setattr(self, 'master_user_password', master_user_password)
            __dataclass__object_setattr(self, 'db_security_groups', db_security_groups)
            __dataclass__object_setattr(self, 'vpc_security_group_ids', vpc_security_group_ids)
            __dataclass__object_setattr(self, 'availability_zone', availability_zone)
            __dataclass__object_setattr(self, 'db_subnet_group_name', db_subnet_group_name)
            __dataclass__object_setattr(self, 'preferred_maintenance_window', preferred_maintenance_window)
            __dataclass__object_setattr(self, 'db_parameter_group_name', db_parameter_group_name)
            __dataclass__object_setattr(self, 'backup_retention_period', backup_retention_period)
            __dataclass__object_setattr(self, 'preferred_backup_window', preferred_backup_window)
            __dataclass__object_setattr(self, 'port', port)
            __dataclass__object_setattr(self, 'multi_az', multi_az)
            __dataclass__object_setattr(self, 'engine_version', engine_version)
            __dataclass__object_setattr(self, 'auto_minor_version_upgrade', auto_minor_version_upgrade)
            __dataclass__object_setattr(self, 'license_model', license_model)
            __dataclass__object_setattr(self, 'iops', iops)
            __dataclass__object_setattr(self, 'storage_throughput', storage_throughput)
            __dataclass__object_setattr(self, 'option_group_name', option_group_name)
            __dataclass__object_setattr(self, 'character_set_name', character_set_name)
            __dataclass__object_setattr(self, 'nchar_character_set_name', nchar_character_set_name)
            __dataclass__object_setattr(self, 'publicly_accessible', publicly_accessible)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'db_cluster_identifier', db_cluster_identifier)
            __dataclass__object_setattr(self, 'storage_type', storage_type)
            __dataclass__object_setattr(self, 'tde_credential_arn', tde_credential_arn)
            __dataclass__object_setattr(self, 'tde_credential_password', tde_credential_password)
            __dataclass__object_setattr(self, 'storage_encrypted', storage_encrypted)
            __dataclass__object_setattr(self, 'kms_key_id', kms_key_id)
            __dataclass__object_setattr(self, 'domain', domain)
            __dataclass__object_setattr(self, 'domain_fqdn', domain_fqdn)
            __dataclass__object_setattr(self, 'domain_ou', domain_ou)
            __dataclass__object_setattr(self, 'domain_auth_secret_arn', domain_auth_secret_arn)
            __dataclass__object_setattr(self, 'domain_dns_ips', domain_dns_ips)
            __dataclass__object_setattr(self, 'copy_tags_to_snapshot', copy_tags_to_snapshot)
            __dataclass__object_setattr(self, 'monitoring_interval', monitoring_interval)
            __dataclass__object_setattr(self, 'monitoring_role_arn', monitoring_role_arn)
            __dataclass__object_setattr(self, 'domain_iam_role_name', domain_iam_role_name)
            __dataclass__object_setattr(self, 'promotion_tier', promotion_tier)
            __dataclass__object_setattr(self, 'timezone', timezone)
            __dataclass__object_setattr(self, 'enable_iam_database_authentication', enable_iam_database_authentication)
            __dataclass__object_setattr(self, 'database_insights_mode', database_insights_mode)
            __dataclass__object_setattr(self, 'enable_performance_insights', enable_performance_insights)
            __dataclass__object_setattr(self, 'performance_insights_kms_key_id', performance_insights_kms_key_id)
            __dataclass__object_setattr(self, 'performance_insights_retention_period', performance_insights_retention_period)
            __dataclass__object_setattr(self, 'enable_cloudwatch_logs_exports', enable_cloudwatch_logs_exports)
            __dataclass__object_setattr(self, 'processor_features', processor_features)
            __dataclass__object_setattr(self, 'deletion_protection', deletion_protection)
            __dataclass__object_setattr(self, 'max_allocated_storage', max_allocated_storage)
            __dataclass__object_setattr(self, 'enable_customer_owned_ip', enable_customer_owned_ip)
            __dataclass__object_setattr(self, 'network_type', network_type)
            __dataclass__object_setattr(self, 'backup_target', backup_target)
            __dataclass__object_setattr(self, 'custom_iam_instance_profile', custom_iam_instance_profile)
            __dataclass__object_setattr(self, 'db_system_id', db_system_id)
            __dataclass__object_setattr(self, 'ca_certificate_identifier', ca_certificate_identifier)
            __dataclass__object_setattr(self, 'manage_master_user_password', manage_master_user_password)
            __dataclass__object_setattr(self, 'master_user_secret_kms_key_id', master_user_secret_kms_key_id)
            __dataclass__object_setattr(self, 'multi_tenant', multi_tenant)
            __dataclass__object_setattr(self, 'dedicated_log_volume', dedicated_log_volume)
            __dataclass__object_setattr(self, 'engine_lifecycle_support', engine_lifecycle_support)
            __dataclass__object_setattr(self, 'master_user_authentication_type', master_user_authentication_type)
            __dataclass__object_setattr(self, 'additional_storage_volumes', additional_storage_volumes)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"db_name={self.db_name!r}")
            parts.append(f"db_instance_identifier={self.db_instance_identifier!r}")
            parts.append(f"allocated_storage={self.allocated_storage!r}")
            parts.append(f"db_instance_class={self.db_instance_class!r}")
            parts.append(f"engine={self.engine!r}")
            parts.append(f"master_username={self.master_username!r}")
            parts.append(f"master_user_password={self.master_user_password!r}")
            parts.append(f"db_security_groups={self.db_security_groups!r}")
            parts.append(f"vpc_security_group_ids={self.vpc_security_group_ids!r}")
            parts.append(f"availability_zone={self.availability_zone!r}")
            parts.append(f"db_subnet_group_name={self.db_subnet_group_name!r}")
            parts.append(f"preferred_maintenance_window={self.preferred_maintenance_window!r}")
            parts.append(f"db_parameter_group_name={self.db_parameter_group_name!r}")
            parts.append(f"backup_retention_period={self.backup_retention_period!r}")
            parts.append(f"preferred_backup_window={self.preferred_backup_window!r}")
            parts.append(f"port={self.port!r}")
            parts.append(f"multi_az={self.multi_az!r}")
            parts.append(f"engine_version={self.engine_version!r}")
            parts.append(f"auto_minor_version_upgrade={self.auto_minor_version_upgrade!r}")
            parts.append(f"license_model={self.license_model!r}")
            parts.append(f"iops={self.iops!r}")
            parts.append(f"storage_throughput={self.storage_throughput!r}")
            parts.append(f"option_group_name={self.option_group_name!r}")
            parts.append(f"character_set_name={self.character_set_name!r}")
            parts.append(f"nchar_character_set_name={self.nchar_character_set_name!r}")
            parts.append(f"publicly_accessible={self.publicly_accessible!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"db_cluster_identifier={self.db_cluster_identifier!r}")
            parts.append(f"storage_type={self.storage_type!r}")
            parts.append(f"tde_credential_arn={self.tde_credential_arn!r}")
            parts.append(f"tde_credential_password={self.tde_credential_password!r}")
            parts.append(f"storage_encrypted={self.storage_encrypted!r}")
            parts.append(f"kms_key_id={self.kms_key_id!r}")
            parts.append(f"domain={self.domain!r}")
            parts.append(f"domain_fqdn={self.domain_fqdn!r}")
            parts.append(f"domain_ou={self.domain_ou!r}")
            parts.append(f"domain_auth_secret_arn={self.domain_auth_secret_arn!r}")
            parts.append(f"domain_dns_ips={self.domain_dns_ips!r}")
            parts.append(f"copy_tags_to_snapshot={self.copy_tags_to_snapshot!r}")
            parts.append(f"monitoring_interval={self.monitoring_interval!r}")
            parts.append(f"monitoring_role_arn={self.monitoring_role_arn!r}")
            parts.append(f"domain_iam_role_name={self.domain_iam_role_name!r}")
            parts.append(f"promotion_tier={self.promotion_tier!r}")
            parts.append(f"timezone={self.timezone!r}")
            parts.append(f"enable_iam_database_authentication={self.enable_iam_database_authentication!r}")
            parts.append(f"database_insights_mode={self.database_insights_mode!r}")
            parts.append(f"enable_performance_insights={self.enable_performance_insights!r}")
            parts.append(f"performance_insights_kms_key_id={self.performance_insights_kms_key_id!r}")
            parts.append(f"performance_insights_retention_period={self.performance_insights_retention_period!r}")
            parts.append(f"enable_cloudwatch_logs_exports={self.enable_cloudwatch_logs_exports!r}")
            parts.append(f"processor_features={self.processor_features!r}")
            parts.append(f"deletion_protection={self.deletion_protection!r}")
            parts.append(f"max_allocated_storage={self.max_allocated_storage!r}")
            parts.append(f"enable_customer_owned_ip={self.enable_customer_owned_ip!r}")
            parts.append(f"network_type={self.network_type!r}")
            parts.append(f"backup_target={self.backup_target!r}")
            parts.append(f"custom_iam_instance_profile={self.custom_iam_instance_profile!r}")
            parts.append(f"db_system_id={self.db_system_id!r}")
            parts.append(f"ca_certificate_identifier={self.ca_certificate_identifier!r}")
            parts.append(f"manage_master_user_password={self.manage_master_user_password!r}")
            parts.append(f"master_user_secret_kms_key_id={self.master_user_secret_kms_key_id!r}")
            parts.append(f"multi_tenant={self.multi_tenant!r}")
            parts.append(f"dedicated_log_volume={self.dedicated_log_volume!r}")
            parts.append(f"engine_lifecycle_support={self.engine_lifecycle_support!r}")
            parts.append(f"master_user_authentication_type={self.master_user_authentication_type!r}")
            parts.append(f"additional_storage_volumes={self.additional_storage_volumes!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('auto_recovery', 'reboot_migration')), EqPlan(fields=('auto_recovery', 'reboot_mig"
        "ration')), FrozenPlan(fields=('__shape__', 'auto_recovery', 'reboot_migration'), allow_dynamic_dunder_attrs=Fa"
        "lse), HashPlan(action='add', fields=('auto_recovery', 'reboot_migration'), cache=False), InitPlan(fields=(Init"
        "Plan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory="
        "None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),"
        " InitPlan.Field(name='auto_recovery', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='i"
        "nit.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='reboot_migration', annotation=OpRef(name='init.fi"
        "elds.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_para"
        "ms=(), kw_only_params=('auto_recovery', 'reboot_migration'), frozen=True, slots=False, post_init_params=None, "
        "init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='auto_recovery', kw_only=True, fn=None), R"
        "eprPlan.Field(name='reboot_migration', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='e0c3340e1914e0150760c77299541042e47c75d9',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceMaintenanceOptions'),
    ),
)
def _process_dataclass__e0c3340e1914e0150760c77299541042e47c75d9():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                auto_recovery=self.auto_recovery,
                reboot_migration=self.reboot_migration,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.auto_recovery == other.auto_recovery and
                self.reboot_migration == other.reboot_migration
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'auto_recovery',
            'reboot_migration',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'auto_recovery',
            'reboot_migration',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.auto_recovery,
                self.reboot_migration,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            auto_recovery: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            reboot_migration: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'auto_recovery', auto_recovery)
            __dataclass__object_setattr(self, 'reboot_migration', reboot_migration)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"auto_recovery={self.auto_recovery!r}")
            parts.append(f"reboot_migration={self.reboot_migration!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('arn', 'code_size', 'signing_profile_version_arn', 'signing_job_arn')), EqPlan(fie"
        "lds=('arn', 'code_size', 'signing_profile_version_arn', 'signing_job_arn')), FrozenPlan(fields=('__shape__', '"
        "arn', 'code_size', 'signing_profile_version_arn', 'signing_job_arn'), allow_dynamic_dunder_attrs=False), HashP"
        "lan(action='add', fields=('arn', 'code_size', 'signing_profile_version_arn', 'signing_job_arn'), cache=False),"
        " InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default="
        "None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=N"
        "one, check_type=None), InitPlan.Field(name='arn', annotation=OpRef(name='init.fields.1.annotation'), default=O"
        "pRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='code_size', annotation=OpRef(name='in"
        "it.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='si"
        "gning_profile_version_arn', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields"
        ".3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='signing_job_arn', annotation=OpRef(name='init.fields.4.anno"
        "tation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_o"
        "nly_params=('arn', 'code_size', 'signing_profile_version_arn', 'signing_job_arn'), frozen=True, slots=False, p"
        "ost_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='arn', kw_only=True,"
        " fn=None), ReprPlan.Field(name='code_size', kw_only=True, fn=None), ReprPlan.Field(name='signing_profile_versi"
        "on_arn', kw_only=True, fn=None), ReprPlan.Field(name='signing_job_arn', kw_only=True, fn=None)), id=False, ter"
        "se=False, default_fn=None)))"
    ),
    plan_repr_sha1='e1e72a9e7b3e49b7385462d8740c9876d598e19a',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'Layer'),
    ),
)
def _process_dataclass__e1e72a9e7b3e49b7385462d8740c9876d598e19a():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                arn=self.arn,
                code_size=self.code_size,
                signing_profile_version_arn=self.signing_profile_version_arn,
                signing_job_arn=self.signing_job_arn,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.arn == other.arn and
                self.code_size == other.code_size and
                self.signing_profile_version_arn == other.signing_profile_version_arn and
                self.signing_job_arn == other.signing_job_arn
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'arn',
            'code_size',
            'signing_profile_version_arn',
            'signing_job_arn',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'arn',
            'code_size',
            'signing_profile_version_arn',
            'signing_job_arn',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.arn,
                self.code_size,
                self.signing_profile_version_arn,
                self.signing_job_arn,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            code_size: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            signing_profile_version_arn: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            signing_job_arn: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'arn', arn)
            __dataclass__object_setattr(self, 'code_size', code_size)
            __dataclass__object_setattr(self, 'signing_profile_version_arn', signing_profile_version_arn)
            __dataclass__object_setattr(self, 'signing_job_arn', signing_job_arn)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"arn={self.arn!r}")
            parts.append(f"code_size={self.code_size!r}")
            parts.append(f"signing_profile_version_arn={self.signing_profile_version_arn!r}")
            parts.append(f"signing_job_arn={self.signing_job_arn!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('association_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'network_border_grou"
        "p', 'ipv6_pool', 'ipv6_address_attribute', 'ip_source')), EqPlan(fields=('association_id', 'ipv6_cidr_block', "
        "'ipv6_cidr_block_state', 'network_border_group', 'ipv6_pool', 'ipv6_address_attribute', 'ip_source')), FrozenP"
        "lan(fields=('__shape__', 'association_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'network_border_group',"
        " 'ipv6_pool', 'ipv6_address_attribute', 'ip_source'), allow_dynamic_dunder_attrs=False), HashPlan(action='add'"
        ", fields=('association_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'network_border_group', 'ipv6_pool', '"
        "ipv6_address_attribute', 'ip_source'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotat"
        "ion=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='association_id"
        "', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='ipv6_cidr_block', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(n"
        "ame='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
        "coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_cidr_block_state', annotation=OpRef(na"
        "me='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='network_border_group', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields."
        "4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='ipv6_pool', annotation=OpRef(name='init.fields.5.annotation'"
        "), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_address_attribute', "
        "annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='ip_source', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init"
        ".fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('association_id', 'ipv"
        "6_cidr_block', 'ipv6_cidr_block_state', 'network_border_group', 'ipv6_pool', 'ipv6_address_attribute', 'ip_sou"
        "rce'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPl"
        "an.Field(name='association_id', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_cidr_block', kw_only=True, f"
        "n=None), ReprPlan.Field(name='ipv6_cidr_block_state', kw_only=True, fn=None), ReprPlan.Field(name='network_bor"
        "der_group', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_pool', kw_only=True, fn=None), ReprPlan.Field(na"
        "me='ipv6_address_attribute', kw_only=True, fn=None), ReprPlan.Field(name='ip_source', kw_only=True, fn=None)),"
        " id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='e23ed4d9f733a3418bb8ffcecaf739c352fd48ac',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'VpcIpv6CidrBlockAssociation'),
    ),
)
def _process_dataclass__e23ed4d9f733a3418bb8ffcecaf739c352fd48ac():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                association_id=self.association_id,
                ipv6_cidr_block=self.ipv6_cidr_block,
                ipv6_cidr_block_state=self.ipv6_cidr_block_state,
                network_border_group=self.network_border_group,
                ipv6_pool=self.ipv6_pool,
                ipv6_address_attribute=self.ipv6_address_attribute,
                ip_source=self.ip_source,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.association_id == other.association_id and
                self.ipv6_cidr_block == other.ipv6_cidr_block and
                self.ipv6_cidr_block_state == other.ipv6_cidr_block_state and
                self.network_border_group == other.network_border_group and
                self.ipv6_pool == other.ipv6_pool and
                self.ipv6_address_attribute == other.ipv6_address_attribute and
                self.ip_source == other.ip_source
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'association_id',
            'ipv6_cidr_block',
            'ipv6_cidr_block_state',
            'network_border_group',
            'ipv6_pool',
            'ipv6_address_attribute',
            'ip_source',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'association_id',
            'ipv6_cidr_block',
            'ipv6_cidr_block_state',
            'network_border_group',
            'ipv6_pool',
            'ipv6_address_attribute',
            'ip_source',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.association_id,
                self.ipv6_cidr_block,
                self.ipv6_cidr_block_state,
                self.network_border_group,
                self.ipv6_pool,
                self.ipv6_address_attribute,
                self.ip_source,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            association_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            ipv6_cidr_block: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            ipv6_cidr_block_state: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            network_border_group: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            ipv6_pool: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            ipv6_address_attribute: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            ip_source: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'association_id', association_id)
            __dataclass__object_setattr(self, 'ipv6_cidr_block', ipv6_cidr_block)
            __dataclass__object_setattr(self, 'ipv6_cidr_block_state', ipv6_cidr_block_state)
            __dataclass__object_setattr(self, 'network_border_group', network_border_group)
            __dataclass__object_setattr(self, 'ipv6_pool', ipv6_pool)
            __dataclass__object_setattr(self, 'ipv6_address_attribute', ipv6_address_attribute)
            __dataclass__object_setattr(self, 'ip_source', ip_source)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"association_id={self.association_id!r}")
            parts.append(f"ipv6_cidr_block={self.ipv6_cidr_block!r}")
            parts.append(f"ipv6_cidr_block_state={self.ipv6_cidr_block_state!r}")
            parts.append(f"network_border_group={self.network_border_group!r}")
            parts.append(f"ipv6_pool={self.ipv6_pool!r}")
            parts.append(f"ipv6_address_attribute={self.ipv6_address_attribute!r}")
            parts.append(f"ip_source={self.ip_source!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('stopping_instances',)), EqPlan(fields=('stopping_instances',)), FrozenPlan(fields"
        "=('__shape__', 'stopping_instances'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('stopp"
        "ing_instances',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init."
        "fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLA"
        "SS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='stopping_instances', annotation=OpR"
        "ef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param="
        "'self', std_params=(), kw_only_params=('stopping_instances',), frozen=True, slots=False, post_init_params=None"
        ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='stopping_instances', kw_only=True, fn=N"
        "one),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='e2d93455c9a1ab29f2896f8f9ffa88f634c68bc7',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'StopInstancesResult'),
    ),
)
def _process_dataclass__e2d93455c9a1ab29f2896f8f9ffa88f634c68bc7():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                stopping_instances=self.stopping_instances,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.stopping_instances == other.stopping_instances
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'stopping_instances',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'stopping_instances',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.stopping_instances,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            stopping_instances: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'stopping_instances', stopping_instances)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"stopping_instances={self.stopping_instances!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('db_instance',)), EqPlan(fields=('db_instance',)), FrozenPlan(fields=('__shape__',"
        " 'db_instance'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('db_instance',), cache=Fals"
        "e), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defau"
        "lt=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='db_instance', annotation=OpRef(name='init.fields.1.annotation')"
        ", default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fie"
        "ldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_para"
        "ms=('db_instance',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan("
        "fields=(ReprPlan.Field(name='db_instance', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='e370acdd02f632f5ffa5833dfc2b29fa253e1324',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'CreateDBInstanceResult'),
        ('ominfra.clouds.aws.models.services.rds', 'DeleteDBInstanceResult'),
        ('ominfra.clouds.aws.models.services.rds', 'RebootDBInstanceResult'),
        ('ominfra.clouds.aws.models.services.rds', 'StartDBInstanceResult'),
        ('ominfra.clouds.aws.models.services.rds', 'StopDBInstanceResult'),
    ),
)
def _process_dataclass__e370acdd02f632f5ffa5833dfc2b29fa253e1324():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                db_instance=self.db_instance,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.db_instance == other.db_instance
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'db_instance',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'db_instance',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.db_instance,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            db_instance: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'db_instance', db_instance)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"db_instance={self.db_instance!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ipv6_address', 'is_primary_ipv6')), EqPlan(fields=('ipv6_address', 'is_primary_ip"
        "v6')), FrozenPlan(fields=('__shape__', 'ipv6_address', 'is_primary_ipv6'), allow_dynamic_dunder_attrs=False), "
        "HashPlan(action='add', fields=('ipv6_address', 'is_primary_ipv6'), cache=False), InitPlan(fields=(InitPlan.Fie"
        "ld(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, in"
        "it=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='ipv6_address', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.field"
        "s.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='is_primary_ipv6', annotation=OpRef(name='init.fields.2.ann"
        "otation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_"
        "only_params=('ipv6_address', 'is_primary_ipv6'), frozen=True, slots=False, post_init_params=None, init_fns=(),"
        " validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ipv6_address', kw_only=True, fn=None), ReprPlan.Field"
        "(name='is_primary_ipv6', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='e3df2f77bf1c5ec8f5f1bdbae450a2fb046dfb07',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceIpv6Address'),
    ),
)
def _process_dataclass__e3df2f77bf1c5ec8f5f1bdbae450a2fb046dfb07():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ipv6_address=self.ipv6_address,
                is_primary_ipv6=self.is_primary_ipv6,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ipv6_address == other.ipv6_address and
                self.is_primary_ipv6 == other.is_primary_ipv6
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ipv6_address',
            'is_primary_ipv6',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ipv6_address',
            'is_primary_ipv6',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ipv6_address,
                self.is_primary_ipv6,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ipv6_address: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            is_primary_ipv6: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ipv6_address', ipv6_address)
            __dataclass__object_setattr(self, 'is_primary_ipv6', is_primary_ipv6)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ipv6_address={self.ipv6_address!r}")
            parts.append(f"is_primary_ipv6={self.is_primary_ipv6!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('key', 'value')), EqPlan(fields=('key', 'value')), FrozenPlan(fields=('key', 'valu"
        "e'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('key', 'value'), cache=False), InitPlan"
        "(fields=(InitPlan.Field(name='key', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None), InitPlan.Field(name='value', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None)), self_param='self', std_params=('key', 'value'), kw_only_params=(), frozen=True, slots=False, post_init"
        "_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='key', kw_only=False, fn=Non"
        "e), ReprPlan.Field(name='value', kw_only=False, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='e99da15cf5726b0f5d37d0fa8c353b161d357ea9',
    op_ref_idents=(
        '__dataclass__init__fields__0__annotation',
        '__dataclass__init__fields__1__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Tag'),
    ),
)
def _process_dataclass__e99da15cf5726b0f5d37d0fa8c353b161d357ea9():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__0__annotation,
        __dataclass__init__fields__1__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                key=self.key,
                value=self.value,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.key == other.key and
                self.value == other.value
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            'key',
            'value',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            'key',
            'value',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.key,
                self.value,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            key: __dataclass__init__fields__0__annotation,
            value: __dataclass__init__fields__1__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'key', key)
            __dataclass__object_setattr(self, 'value', value)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"key={self.key!r}")
            parts.append(f"value={self.value!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('address', 'port', 'hosted_zone_id')), EqPlan(fields=('address', 'port', 'hosted_z"
        "one_id')), FrozenPlan(fields=('__shape__', 'address', 'port', 'hosted_zone_id'), allow_dynamic_dunder_attrs=Fa"
        "lse), HashPlan(action='add', fields=('address', 'port', 'hosted_zone_id'), cache=False), InitPlan(fields=(Init"
        "Plan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory="
        "None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),"
        " InitPlan.Field(name='address', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fi"
        "elds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='port', annotation=OpRef(name='init.fields.2.annotation'"
        "), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='hosted_zone_id', annotati"
        "on=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_"
        "param='self', std_params=(), kw_only_params=('address', 'port', 'hosted_zone_id'), frozen=True, slots=False, p"
        "ost_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='address', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='port', kw_only=True, fn=None), ReprPlan.Field(name='hosted_zone_id', kw_on"
        "ly=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='e9db080acf593b4f064dabcf02ca124667d3f6ec',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'Endpoint'),
    ),
)
def _process_dataclass__e9db080acf593b4f064dabcf02ca124667d3f6ec():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                address=self.address,
                port=self.port,
                hosted_zone_id=self.hosted_zone_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.address == other.address and
                self.port == other.port and
                self.hosted_zone_id == other.hosted_zone_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'address',
            'port',
            'hosted_zone_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'address',
            'port',
            'hosted_zone_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.address,
                self.port,
                self.hosted_zone_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            address: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            port: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            hosted_zone_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'address', address)
            __dataclass__object_setattr(self, 'port', port)
            __dataclass__object_setattr(self, 'hosted_zone_id', hosted_zone_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"address={self.address!r}")
            parts.append(f"port={self.port!r}")
            parts.append(f"hosted_zone_id={self.hosted_zone_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('db_instance_class', 'allocated_storage', 'master_user_password', 'port', 'backup_"
        "retention_period', 'multi_az', 'engine_version', 'license_model', 'iops', 'storage_throughput', 'db_instance_i"
        "dentifier', 'storage_type', 'ca_certificate_identifier', 'db_subnet_group_name', 'pending_cloudwatch_logs_expo"
        "rts', 'processor_features', 'automation_mode', 'resume_full_automation_mode_time', 'multi_tenant', 'iam_databa"
        "se_authentication_enabled', 'dedicated_log_volume', 'engine', 'additional_storage_volumes')), EqPlan(fields=('"
        "db_instance_class', 'allocated_storage', 'master_user_password', 'port', 'backup_retention_period', 'multi_az'"
        ", 'engine_version', 'license_model', 'iops', 'storage_throughput', 'db_instance_identifier', 'storage_type', '"
        "ca_certificate_identifier', 'db_subnet_group_name', 'pending_cloudwatch_logs_exports', 'processor_features', '"
        "automation_mode', 'resume_full_automation_mode_time', 'multi_tenant', 'iam_database_authentication_enabled', '"
        "dedicated_log_volume', 'engine', 'additional_storage_volumes')), FrozenPlan(fields=('__shape__', 'db_instance_"
        "class', 'allocated_storage', 'master_user_password', 'port', 'backup_retention_period', 'multi_az', 'engine_ve"
        "rsion', 'license_model', 'iops', 'storage_throughput', 'db_instance_identifier', 'storage_type', 'ca_certifica"
        "te_identifier', 'db_subnet_group_name', 'pending_cloudwatch_logs_exports', 'processor_features', 'automation_m"
        "ode', 'resume_full_automation_mode_time', 'multi_tenant', 'iam_database_authentication_enabled', 'dedicated_lo"
        "g_volume', 'engine', 'additional_storage_volumes'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', "
        "fields=('db_instance_class', 'allocated_storage', 'master_user_password', 'port', 'backup_retention_period', '"
        "multi_az', 'engine_version', 'license_model', 'iops', 'storage_throughput', 'db_instance_identifier', 'storage"
        "_type', 'ca_certificate_identifier', 'db_subnet_group_name', 'pending_cloudwatch_logs_exports', 'processor_fea"
        "tures', 'automation_mode', 'resume_full_automation_mode_time', 'multi_tenant', 'iam_database_authentication_en"
        "abled', 'dedicated_log_volume', 'engine', 'additional_storage_volumes'), cache=False), InitPlan(fields=(InitPl"
        "an.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='db_instance_class', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name="
        "'init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None), InitPlan.Field(name='allocated_storage', annotation=OpRef(name='init"
        ".fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override"
        "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='mast"
        "er_user_password', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='port', annotation=OpRef(name='init.fields.4.annotation'), default=Op"
        "Ref(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
        "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='backup_retention_period', annotation=O"
        "pRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init"
        "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
        "ield(name='multi_az', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.def"
        "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
        "None, check_type=None), InitPlan.Field(name='engine_version', annotation=OpRef(name='init.fields.7.annotation'"
        "), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='license_model', annotatio"
        "n=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='iops', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.defa"
        "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
        "one, check_type=None), InitPlan.Field(name='storage_throughput', annotation=OpRef(name='init.fields.10.annotat"
        "ion'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_instance_identifi"
        "er', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default"
        "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='storage_type', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef"
        "(name='init.fields.12.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
        "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ca_certificate_identifier', annotation=O"
        "pRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
        ".Field(name='db_subnet_group_name', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='in"
        "it.fields.14.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='pending_cloudwatch_logs_exports', annotation=OpRe"
        "f(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), default_factory=None, init="
        "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
        "eld(name='processor_features', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef(name='init.fi"
        "elds.16.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='automation_mode', annotation=OpRef(name='init.fields.1"
        "7.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='resume_full"
        "_automation_mode_time', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.18"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None), InitPlan.Field(name='multi_tenant', annotation=OpRef(name='init.fields.19.annotati"
        "on'), default=OpRef(name='init.fields.19.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='iam_database_authenti"
        "cation_enabled', annotation=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.fields.20.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='dedicated_log_volume', annotation=OpRef(name='init.fields.21.annotat"
        "ion'), default=OpRef(name='init.fields.21.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='engine', annotation="
        "OpRef(name='init.fields.22.annotation'), default=OpRef(name='init.fields.22.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='additional_storage_volumes', annotation=OpRef(name='init.fields.23.annotation'), default=OpRef(n"
        "ame='init.fields.23.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
        " coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('db_instance"
        "_class', 'allocated_storage', 'master_user_password', 'port', 'backup_retention_period', 'multi_az', 'engine_v"
        "ersion', 'license_model', 'iops', 'storage_throughput', 'db_instance_identifier', 'storage_type', 'ca_certific"
        "ate_identifier', 'db_subnet_group_name', 'pending_cloudwatch_logs_exports', 'processor_features', 'automation_"
        "mode', 'resume_full_automation_mode_time', 'multi_tenant', 'iam_database_authentication_enabled', 'dedicated_l"
        "og_volume', 'engine', 'additional_storage_volumes'), frozen=True, slots=False, post_init_params=None, init_fns"
        "=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db_instance_class', kw_only=True, fn=None), ReprP"
        "lan.Field(name='allocated_storage', kw_only=True, fn=None), ReprPlan.Field(name='master_user_password', kw_onl"
        "y=True, fn=None), ReprPlan.Field(name='port', kw_only=True, fn=None), ReprPlan.Field(name='backup_retention_pe"
        "riod', kw_only=True, fn=None), ReprPlan.Field(name='multi_az', kw_only=True, fn=None), ReprPlan.Field(name='en"
        "gine_version', kw_only=True, fn=None), ReprPlan.Field(name='license_model', kw_only=True, fn=None), ReprPlan.F"
        "ield(name='iops', kw_only=True, fn=None), ReprPlan.Field(name='storage_throughput', kw_only=True, fn=None), Re"
        "prPlan.Field(name='db_instance_identifier', kw_only=True, fn=None), ReprPlan.Field(name='storage_type', kw_onl"
        "y=True, fn=None), ReprPlan.Field(name='ca_certificate_identifier', kw_only=True, fn=None), ReprPlan.Field(name"
        "='db_subnet_group_name', kw_only=True, fn=None), ReprPlan.Field(name='pending_cloudwatch_logs_exports', kw_onl"
        "y=True, fn=None), ReprPlan.Field(name='processor_features', kw_only=True, fn=None), ReprPlan.Field(name='autom"
        "ation_mode', kw_only=True, fn=None), ReprPlan.Field(name='resume_full_automation_mode_time', kw_only=True, fn="
        "None), ReprPlan.Field(name='multi_tenant', kw_only=True, fn=None), ReprPlan.Field(name='iam_database_authentic"
        "ation_enabled', kw_only=True, fn=None), ReprPlan.Field(name='dedicated_log_volume', kw_only=True, fn=None), Re"
        "prPlan.Field(name='engine', kw_only=True, fn=None), ReprPlan.Field(name='additional_storage_volumes', kw_only="
        "True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='ea2952e2a2b5ae7f726cb2c9405e887805a60ab8',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'PendingModifiedValues'),
    ),
)
def _process_dataclass__ea2952e2a2b5ae7f726cb2c9405e887805a60ab8():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                db_instance_class=self.db_instance_class,
                allocated_storage=self.allocated_storage,
                master_user_password=self.master_user_password,
                port=self.port,
                backup_retention_period=self.backup_retention_period,
                multi_az=self.multi_az,
                engine_version=self.engine_version,
                license_model=self.license_model,
                iops=self.iops,
                storage_throughput=self.storage_throughput,
                db_instance_identifier=self.db_instance_identifier,
                storage_type=self.storage_type,
                ca_certificate_identifier=self.ca_certificate_identifier,
                db_subnet_group_name=self.db_subnet_group_name,
                pending_cloudwatch_logs_exports=self.pending_cloudwatch_logs_exports,
                processor_features=self.processor_features,
                automation_mode=self.automation_mode,
                resume_full_automation_mode_time=self.resume_full_automation_mode_time,
                multi_tenant=self.multi_tenant,
                iam_database_authentication_enabled=self.iam_database_authentication_enabled,
                dedicated_log_volume=self.dedicated_log_volume,
                engine=self.engine,
                additional_storage_volumes=self.additional_storage_volumes,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.db_instance_class == other.db_instance_class and
                self.allocated_storage == other.allocated_storage and
                self.master_user_password == other.master_user_password and
                self.port == other.port and
                self.backup_retention_period == other.backup_retention_period and
                self.multi_az == other.multi_az and
                self.engine_version == other.engine_version and
                self.license_model == other.license_model and
                self.iops == other.iops and
                self.storage_throughput == other.storage_throughput and
                self.db_instance_identifier == other.db_instance_identifier and
                self.storage_type == other.storage_type and
                self.ca_certificate_identifier == other.ca_certificate_identifier and
                self.db_subnet_group_name == other.db_subnet_group_name and
                self.pending_cloudwatch_logs_exports == other.pending_cloudwatch_logs_exports and
                self.processor_features == other.processor_features and
                self.automation_mode == other.automation_mode and
                self.resume_full_automation_mode_time == other.resume_full_automation_mode_time and
                self.multi_tenant == other.multi_tenant and
                self.iam_database_authentication_enabled == other.iam_database_authentication_enabled and
                self.dedicated_log_volume == other.dedicated_log_volume and
                self.engine == other.engine and
                self.additional_storage_volumes == other.additional_storage_volumes
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'db_instance_class',
            'allocated_storage',
            'master_user_password',
            'port',
            'backup_retention_period',
            'multi_az',
            'engine_version',
            'license_model',
            'iops',
            'storage_throughput',
            'db_instance_identifier',
            'storage_type',
            'ca_certificate_identifier',
            'db_subnet_group_name',
            'pending_cloudwatch_logs_exports',
            'processor_features',
            'automation_mode',
            'resume_full_automation_mode_time',
            'multi_tenant',
            'iam_database_authentication_enabled',
            'dedicated_log_volume',
            'engine',
            'additional_storage_volumes',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'db_instance_class',
            'allocated_storage',
            'master_user_password',
            'port',
            'backup_retention_period',
            'multi_az',
            'engine_version',
            'license_model',
            'iops',
            'storage_throughput',
            'db_instance_identifier',
            'storage_type',
            'ca_certificate_identifier',
            'db_subnet_group_name',
            'pending_cloudwatch_logs_exports',
            'processor_features',
            'automation_mode',
            'resume_full_automation_mode_time',
            'multi_tenant',
            'iam_database_authentication_enabled',
            'dedicated_log_volume',
            'engine',
            'additional_storage_volumes',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.db_instance_class,
                self.allocated_storage,
                self.master_user_password,
                self.port,
                self.backup_retention_period,
                self.multi_az,
                self.engine_version,
                self.license_model,
                self.iops,
                self.storage_throughput,
                self.db_instance_identifier,
                self.storage_type,
                self.ca_certificate_identifier,
                self.db_subnet_group_name,
                self.pending_cloudwatch_logs_exports,
                self.processor_features,
                self.automation_mode,
                self.resume_full_automation_mode_time,
                self.multi_tenant,
                self.iam_database_authentication_enabled,
                self.dedicated_log_volume,
                self.engine,
                self.additional_storage_volumes,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            db_instance_class: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            allocated_storage: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            master_user_password: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            port: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            backup_retention_period: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            multi_az: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            engine_version: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            license_model: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            iops: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            storage_throughput: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            db_instance_identifier: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            storage_type: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            ca_certificate_identifier: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            db_subnet_group_name: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            pending_cloudwatch_logs_exports: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            processor_features: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            automation_mode: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            resume_full_automation_mode_time: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            multi_tenant: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            iam_database_authentication_enabled: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            dedicated_log_volume: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            engine: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            additional_storage_volumes: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'db_instance_class', db_instance_class)
            __dataclass__object_setattr(self, 'allocated_storage', allocated_storage)
            __dataclass__object_setattr(self, 'master_user_password', master_user_password)
            __dataclass__object_setattr(self, 'port', port)
            __dataclass__object_setattr(self, 'backup_retention_period', backup_retention_period)
            __dataclass__object_setattr(self, 'multi_az', multi_az)
            __dataclass__object_setattr(self, 'engine_version', engine_version)
            __dataclass__object_setattr(self, 'license_model', license_model)
            __dataclass__object_setattr(self, 'iops', iops)
            __dataclass__object_setattr(self, 'storage_throughput', storage_throughput)
            __dataclass__object_setattr(self, 'db_instance_identifier', db_instance_identifier)
            __dataclass__object_setattr(self, 'storage_type', storage_type)
            __dataclass__object_setattr(self, 'ca_certificate_identifier', ca_certificate_identifier)
            __dataclass__object_setattr(self, 'db_subnet_group_name', db_subnet_group_name)
            __dataclass__object_setattr(self, 'pending_cloudwatch_logs_exports', pending_cloudwatch_logs_exports)
            __dataclass__object_setattr(self, 'processor_features', processor_features)
            __dataclass__object_setattr(self, 'automation_mode', automation_mode)
            __dataclass__object_setattr(self, 'resume_full_automation_mode_time', resume_full_automation_mode_time)
            __dataclass__object_setattr(self, 'multi_tenant', multi_tenant)
            __dataclass__object_setattr(self, 'iam_database_authentication_enabled', iam_database_authentication_enabled)
            __dataclass__object_setattr(self, 'dedicated_log_volume', dedicated_log_volume)
            __dataclass__object_setattr(self, 'engine', engine)
            __dataclass__object_setattr(self, 'additional_storage_volumes', additional_storage_volumes)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"db_instance_class={self.db_instance_class!r}")
            parts.append(f"allocated_storage={self.allocated_storage!r}")
            parts.append(f"master_user_password={self.master_user_password!r}")
            parts.append(f"port={self.port!r}")
            parts.append(f"backup_retention_period={self.backup_retention_period!r}")
            parts.append(f"multi_az={self.multi_az!r}")
            parts.append(f"engine_version={self.engine_version!r}")
            parts.append(f"license_model={self.license_model!r}")
            parts.append(f"iops={self.iops!r}")
            parts.append(f"storage_throughput={self.storage_throughput!r}")
            parts.append(f"db_instance_identifier={self.db_instance_identifier!r}")
            parts.append(f"storage_type={self.storage_type!r}")
            parts.append(f"ca_certificate_identifier={self.ca_certificate_identifier!r}")
            parts.append(f"db_subnet_group_name={self.db_subnet_group_name!r}")
            parts.append(f"pending_cloudwatch_logs_exports={self.pending_cloudwatch_logs_exports!r}")
            parts.append(f"processor_features={self.processor_features!r}")
            parts.append(f"automation_mode={self.automation_mode!r}")
            parts.append(f"resume_full_automation_mode_time={self.resume_full_automation_mode_time!r}")
            parts.append(f"multi_tenant={self.multi_tenant!r}")
            parts.append(f"iam_database_authentication_enabled={self.iam_database_authentication_enabled!r}")
            parts.append(f"dedicated_log_volume={self.dedicated_log_volume!r}")
            parts.append(f"engine={self.engine!r}")
            parts.append(f"additional_storage_volumes={self.additional_storage_volumes!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('type', 'count')), EqPlan(fields=('type', 'count')), FrozenPlan(fields=('__shape__"
        "', 'type', 'count'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('type', 'count'), cache"
        "=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), "
        "default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.1.annotation'), "
        "default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='count', annotation=OpRef(name='init.fields.2.annotation'), "
        "default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params"
        "=('type', 'count'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(f"
        "ields=(ReprPlan.Field(name='type', kw_only=True, fn=None), ReprPlan.Field(name='count', kw_only=True, fn=None)"
        "), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='ea86637d45790a9ba24b794df89ae7899e5d8876',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'ElasticInferenceAccelerator'),
    ),
)
def _process_dataclass__ea86637d45790a9ba24b794df89ae7899e5d8876():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                type=self.type,
                count=self.count,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.type == other.type and
                self.count == other.count
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'type',
            'count',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'type',
            'count',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.type,
                self.count,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            type: __dataclass__init__fields__1__annotation,
            count: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'type', type)
            __dataclass__object_setattr(self, 'count', count)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"type={self.type!r}")
            parts.append(f"count={self.count!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('next_marker', 'functions')), EqPlan(fields=('next_marker', 'functions')), FrozenP"
        "lan(fields=('__shape__', 'next_marker', 'functions'), allow_dynamic_dunder_attrs=False), HashPlan(action='add'"
        ", fields=('next_marker', 'functions'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotat"
        "ion=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_marker', "
        "annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='functions', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init"
        ".fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('next_marker', 'functi"
        "ons'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPl"
        "an.Field(name='next_marker', kw_only=True, fn=None), ReprPlan.Field(name='functions', kw_only=True, fn=None)),"
        " id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='eadc397a64213fa413966469ed9bbbd79b79aa63',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'ListFunctionsResponse'),
    ),
)
def _process_dataclass__eadc397a64213fa413966469ed9bbbd79b79aa63():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                next_marker=self.next_marker,
                functions=self.functions,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.next_marker == other.next_marker and
                self.functions == other.functions
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'next_marker',
            'functions',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'next_marker',
            'functions',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.next_marker,
                self.functions,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            next_marker: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            functions: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'next_marker', next_marker)
            __dataclass__object_setattr(self, 'functions', functions)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"next_marker={self.next_marker!r}")
            parts.append(f"functions={self.functions!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('name', 'values')), EqPlan(fields=('name', 'values')), FrozenPlan(fields=('__shape"
        "__', 'name', 'values'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'values'), c"
        "ache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation"
        "'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation"
        "'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=F"
        "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='values', annotation=OpRe"
        "f(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='"
        "self', std_params=(), kw_only_params=('name', 'values'), frozen=True, slots=False, post_init_params=None, init"
        "_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field"
        "(name='values', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='ee43e7a1aa970fe321ca99f2a70e7310b221e1aa',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Filter'),
    ),
)
def _process_dataclass__ee43e7a1aa970fe321ca99f2a70e7310b221e1aa():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                name=self.name,
                values=self.values,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.name == other.name and
                self.values == other.values
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'name',
            'values',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'name',
            'values',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.name,
                self.values,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            values: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'name', name)
            __dataclass__object_setattr(self, 'values', values)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"name={self.name!r}")
            parts.append(f"values={self.values!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('code', 'name')), EqPlan(fields=('code', 'name')), FrozenPlan(fields=('__shape__',"
        " 'code', 'name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('code', 'name'), cache=Fal"
        "se), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defa"
        "ult=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='code', annotation=OpRef(name='init.fields.1.annotation'), defa"
        "ult=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='in"
        "it.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std"
        "_params=(), kw_only_params=('code', 'name'), frozen=True, slots=False, post_init_params=None, init_fns=(), val"
        "idate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='code', kw_only=True, fn=None), ReprPlan.Field(name='name'"
        ", kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='ef87c4fd27d904caa46d66d1804e9d4beeecae25',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceState'),
    ),
)
def _process_dataclass__ef87c4fd27d904caa46d66d1804e9d4beeecae25():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                code=self.code,
                name=self.name,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.code == other.code and
                self.name == other.name
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'code',
            'name',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'code',
            'name',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.code,
                self.name,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            code: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'code', code)
            __dataclass__object_setattr(self, 'name', name)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"code={self.code!r}")
            parts.append(f"name={self.name!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('attach_time', 'delete_on_termination', 'status', 'volume_id', 'associated_resourc"
        "e', 'volume_owner_id', 'operator')), EqPlan(fields=('attach_time', 'delete_on_termination', 'status', 'volume_"
        "id', 'associated_resource', 'volume_owner_id', 'operator')), FrozenPlan(fields=('__shape__', 'attach_time', 'd"
        "elete_on_termination', 'status', 'volume_id', 'associated_resource', 'volume_owner_id', 'operator'), allow_dyn"
        "amic_dunder_attrs=False), HashPlan(action='add', fields=('attach_time', 'delete_on_termination', 'status', 'vo"
        "lume_id', 'associated_resource', 'volume_owner_id', 'operator'), cache=False), InitPlan(fields=(InitPlan.Field"
        "(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init"
        "=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='attach_time', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None), InitPlan.Field(name='delete_on_termination', annotation=OpRef(name='init.fields.2."
        "annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='status', annot"
        "ation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='volume_id', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fiel"
        "ds.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None), InitPlan.Field(name='associated_resource', annotation=OpRef(name='init.fields."
        "5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='volume_owner"
        "_id', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='operator', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name="
        "'init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('attach_time', 'd"
        "elete_on_termination', 'status', 'volume_id', 'associated_resource', 'volume_owner_id', 'operator'), frozen=Tr"
        "ue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='a"
        "ttach_time', kw_only=True, fn=None), ReprPlan.Field(name='delete_on_termination', kw_only=True, fn=None), Repr"
        "Plan.Field(name='status', kw_only=True, fn=None), ReprPlan.Field(name='volume_id', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='associated_resource', kw_only=True, fn=None), ReprPlan.Field(name='volume_owner_id', kw_only"
        "=True, fn=None), ReprPlan.Field(name='operator', kw_only=True, fn=None)), id=False, terse=False, default_fn=No"
        "ne)))"
    ),
    plan_repr_sha1='efd31e877496bbd3d9214c4b87b5775f30e0bd24',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'EbsInstanceBlockDevice'),
    ),
)
def _process_dataclass__efd31e877496bbd3d9214c4b87b5775f30e0bd24():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                attach_time=self.attach_time,
                delete_on_termination=self.delete_on_termination,
                status=self.status,
                volume_id=self.volume_id,
                associated_resource=self.associated_resource,
                volume_owner_id=self.volume_owner_id,
                operator=self.operator,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.attach_time == other.attach_time and
                self.delete_on_termination == other.delete_on_termination and
                self.status == other.status and
                self.volume_id == other.volume_id and
                self.associated_resource == other.associated_resource and
                self.volume_owner_id == other.volume_owner_id and
                self.operator == other.operator
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'attach_time',
            'delete_on_termination',
            'status',
            'volume_id',
            'associated_resource',
            'volume_owner_id',
            'operator',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'attach_time',
            'delete_on_termination',
            'status',
            'volume_id',
            'associated_resource',
            'volume_owner_id',
            'operator',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.attach_time,
                self.delete_on_termination,
                self.status,
                self.volume_id,
                self.associated_resource,
                self.volume_owner_id,
                self.operator,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            attach_time: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            delete_on_termination: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            status: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            volume_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            associated_resource: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            volume_owner_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            operator: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'attach_time', attach_time)
            __dataclass__object_setattr(self, 'delete_on_termination', delete_on_termination)
            __dataclass__object_setattr(self, 'status', status)
            __dataclass__object_setattr(self, 'volume_id', volume_id)
            __dataclass__object_setattr(self, 'associated_resource', associated_resource)
            __dataclass__object_setattr(self, 'volume_owner_id', volume_owner_id)
            __dataclass__object_setattr(self, 'operator', operator)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"attach_time={self.attach_time!r}")
            parts.append(f"delete_on_termination={self.delete_on_termination!r}")
            parts.append(f"status={self.status!r}")
            parts.append(f"volume_id={self.volume_id!r}")
            parts.append(f"associated_resource={self.associated_resource!r}")
            parts.append(f"volume_owner_id={self.volume_owner_id!r}")
            parts.append(f"operator={self.operator!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('image_config', 'error')), EqPlan(fields=('image_config', 'error')), FrozenPlan(fi"
        "elds=('__shape__', 'image_config', 'error'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields="
        "('image_config', 'error'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(na"
        "me='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='image_config', annotation="
        "OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='error', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None)), self_param='self', std_params=(), kw_only_params=('image_config', 'error'), frozen=True"
        ", slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ima"
        "ge_config', kw_only=True, fn=None), ReprPlan.Field(name='error', kw_only=True, fn=None)), id=False, terse=Fals"
        "e, default_fn=None)))"
    ),
    plan_repr_sha1='f187f9f7e4a3a31f7e7c47ced435e80463092461',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'ImageConfigResponse'),
    ),
)
def _process_dataclass__f187f9f7e4a3a31f7e7c47ced435e80463092461():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                image_config=self.image_config,
                error=self.error,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.image_config == other.image_config and
                self.error == other.error
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'image_config',
            'error',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'image_config',
            'error',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.image_config,
                self.error,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            image_config: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            error: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'image_config', image_config)
            __dataclass__object_setattr(self, 'error', error)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"image_config={self.image_config!r}")
            parts.append(f"error={self.error!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('core_count', 'threads_per_core', 'amd_sev_snp')), EqPlan(fields=('core_count', 't"
        "hreads_per_core', 'amd_sev_snp')), FrozenPlan(fields=('__shape__', 'core_count', 'threads_per_core', 'amd_sev_"
        "snp'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('core_count', 'threads_per_core', 'am"
        "d_sev_snp'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.field"
        "s.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VA"
        "R, coerce=None, validate=None, check_type=None), InitPlan.Field(name='core_count', annotation=OpRef(name='init"
        ".fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override"
        "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='thre"
        "ads_per_core', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None), InitPlan.Field(name='amd_sev_snp', annotation=OpRef(name='init.fields.3.annotation'), default"
        "=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
        "STANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('core"
        "_count', 'threads_per_core', 'amd_sev_snp'), frozen=True, slots=False, post_init_params=None, init_fns=(), val"
        "idate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='core_count', kw_only=True, fn=None), ReprPlan.Field(name="
        "'threads_per_core', kw_only=True, fn=None), ReprPlan.Field(name='amd_sev_snp', kw_only=True, fn=None)), id=Fal"
        "se, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='f309cd6072681bb44dd6795348d4642efe3a7e7c',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CpuOptions'),
        ('ominfra.clouds.aws.models.services.ec2', 'CpuOptionsRequest'),
    ),
)
def _process_dataclass__f309cd6072681bb44dd6795348d4642efe3a7e7c():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                core_count=self.core_count,
                threads_per_core=self.threads_per_core,
                amd_sev_snp=self.amd_sev_snp,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.core_count == other.core_count and
                self.threads_per_core == other.threads_per_core and
                self.amd_sev_snp == other.amd_sev_snp
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'core_count',
            'threads_per_core',
            'amd_sev_snp',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'core_count',
            'threads_per_core',
            'amd_sev_snp',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.core_count,
                self.threads_per_core,
                self.amd_sev_snp,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            core_count: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            threads_per_core: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            amd_sev_snp: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'core_count', core_count)
            __dataclass__object_setattr(self, 'threads_per_core', threads_per_core)
            __dataclass__object_setattr(self, 'amd_sev_snp', amd_sev_snp)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"core_count={self.core_count!r}")
            parts.append(f"threads_per_core={self.threads_per_core!r}")
            parts.append(f"amd_sev_snp={self.amd_sev_snp!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('elastic_gpu_id', 'elastic_gpu_association_id', 'elastic_gpu_association_state', '"
        "elastic_gpu_association_time')), EqPlan(fields=('elastic_gpu_id', 'elastic_gpu_association_id', 'elastic_gpu_a"
        "ssociation_state', 'elastic_gpu_association_time')), FrozenPlan(fields=('__shape__', 'elastic_gpu_id', 'elasti"
        "c_gpu_association_id', 'elastic_gpu_association_state', 'elastic_gpu_association_time'), allow_dynamic_dunder_"
        "attrs=False), HashPlan(action='add', fields=('elastic_gpu_id', 'elastic_gpu_association_id', 'elastic_gpu_asso"
        "ciation_state', 'elastic_gpu_association_time'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__"
        "', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override="
        "False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='elas"
        "tic_gpu_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), d"
        "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='elastic_gpu_association_id', annotation=OpRef(name='init.fields.2.annotati"
        "on'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type"
        "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='elastic_gpu_associatio"
        "n_state', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='elastic_gpu_association_time', annotation=OpRef(name='init.fields.4.annotatio"
        "n'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type="
        "FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_p"
        "arams=('elastic_gpu_id', 'elastic_gpu_association_id', 'elastic_gpu_association_state', 'elastic_gpu_associati"
        "on_time'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Re"
        "prPlan.Field(name='elastic_gpu_id', kw_only=True, fn=None), ReprPlan.Field(name='elastic_gpu_association_id', "
        "kw_only=True, fn=None), ReprPlan.Field(name='elastic_gpu_association_state', kw_only=True, fn=None), ReprPlan."
        "Field(name='elastic_gpu_association_time', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='f30d75dad1fb5a55a81dc40317df8e7e42201245',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'ElasticGpuAssociation'),
    ),
)
def _process_dataclass__f30d75dad1fb5a55a81dc40317df8e7e42201245():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                elastic_gpu_id=self.elastic_gpu_id,
                elastic_gpu_association_id=self.elastic_gpu_association_id,
                elastic_gpu_association_state=self.elastic_gpu_association_state,
                elastic_gpu_association_time=self.elastic_gpu_association_time,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.elastic_gpu_id == other.elastic_gpu_id and
                self.elastic_gpu_association_id == other.elastic_gpu_association_id and
                self.elastic_gpu_association_state == other.elastic_gpu_association_state and
                self.elastic_gpu_association_time == other.elastic_gpu_association_time
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'elastic_gpu_id',
            'elastic_gpu_association_id',
            'elastic_gpu_association_state',
            'elastic_gpu_association_time',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'elastic_gpu_id',
            'elastic_gpu_association_id',
            'elastic_gpu_association_state',
            'elastic_gpu_association_time',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.elastic_gpu_id,
                self.elastic_gpu_association_id,
                self.elastic_gpu_association_state,
                self.elastic_gpu_association_time,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            elastic_gpu_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            elastic_gpu_association_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            elastic_gpu_association_state: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            elastic_gpu_association_time: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'elastic_gpu_id', elastic_gpu_id)
            __dataclass__object_setattr(self, 'elastic_gpu_association_id', elastic_gpu_association_id)
            __dataclass__object_setattr(self, 'elastic_gpu_association_state', elastic_gpu_association_state)
            __dataclass__object_setattr(self, 'elastic_gpu_association_time', elastic_gpu_association_time)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"elastic_gpu_id={self.elastic_gpu_id!r}")
            parts.append(f"elastic_gpu_association_id={self.elastic_gpu_association_id!r}")
            parts.append(f"elastic_gpu_association_state={self.elastic_gpu_association_state!r}")
            parts.append(f"elastic_gpu_association_time={self.elastic_gpu_association_time!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ipv6_prefix',)), EqPlan(fields=('ipv6_prefix',)), FrozenPlan(fields=('__shape__',"
        " 'ipv6_prefix'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ipv6_prefix',), cache=Fals"
        "e), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defau"
        "lt=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='ipv6_prefix', annotation=OpRef(name='init.fields.1.annotation')"
        ", default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fie"
        "ldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_para"
        "ms=('ipv6_prefix',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan("
        "fields=(ReprPlan.Field(name='ipv6_prefix', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='f4ee721ce3a60e7873bb18fb8b8c7733eca2c287',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceIpv6Prefix'),
        ('ominfra.clouds.aws.models.services.ec2', 'Ipv6PrefixSpecification'),
        ('ominfra.clouds.aws.models.services.ec2', 'Ipv6PrefixSpecificationRequest'),
    ),
)
def _process_dataclass__f4ee721ce3a60e7873bb18fb8b8c7733eca2c287():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ipv6_prefix=self.ipv6_prefix,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ipv6_prefix == other.ipv6_prefix
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ipv6_prefix',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ipv6_prefix',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ipv6_prefix,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ipv6_prefix: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ipv6_prefix', ipv6_prefix)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ipv6_prefix={self.ipv6_prefix!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('db_instance_automated_backups_arn',)), EqPlan(fields=('db_instance_automated_back"
        "ups_arn',)), FrozenPlan(fields=('__shape__', 'db_instance_automated_backups_arn'), allow_dynamic_dunder_attrs="
        "False), HashPlan(action='add', fields=('db_instance_automated_backups_arn',), cache=False), InitPlan(fields=(I"
        "nitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_facto"
        "ry=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='db_instance_automated_backups_arn', annotation=OpRef(name='init.fields.1.annotation')"
        ", default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fie"
        "ldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_para"
        "ms=('db_instance_automated_backups_arn',), frozen=True, slots=False, post_init_params=None, init_fns=(), valid"
        "ate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db_instance_automated_backups_arn', kw_only=True, fn=None),"
        "), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='f4f5e47cd22723462922683cb4fe9515739a3485',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'DBInstanceAutomatedBackupsReplication'),
    ),
)
def _process_dataclass__f4f5e47cd22723462922683cb4fe9515739a3485():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                db_instance_automated_backups_arn=self.db_instance_automated_backups_arn,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.db_instance_automated_backups_arn == other.db_instance_automated_backups_arn
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'db_instance_automated_backups_arn',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'db_instance_automated_backups_arn',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.db_instance_automated_backups_arn,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            db_instance_automated_backups_arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'db_instance_automated_backups_arn', db_instance_automated_backups_arn)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"db_instance_automated_backups_arn={self.db_instance_automated_backups_arn!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('state', 'status_message')), EqPlan(fields=('state', 'status_message')), FrozenPla"
        "n(fields=('__shape__', 'state', 'status_message'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', f"
        "ields=('state', 'status_message'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation="
        "OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state', annotation"
        "=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
        ".Field(name='status_message', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fiel"
        "ds.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('state', 'status_message'),"
        " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Fie"
        "ld(name='state', kw_only=True, fn=None), ReprPlan.Field(name='status_message', kw_only=True, fn=None)), id=Fal"
        "se, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='f5b11eca48f4c5e0caac03c39767918c6711dba4',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'RouteTableAssociationState'),
        ('ominfra.clouds.aws.models.services.ec2', 'SubnetCidrBlockState'),
        ('ominfra.clouds.aws.models.services.ec2', 'VpcCidrBlockState'),
    ),
)
def _process_dataclass__f5b11eca48f4c5e0caac03c39767918c6711dba4():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                state=self.state,
                status_message=self.status_message,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.state == other.state and
                self.status_message == other.status_message
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'state',
            'status_message',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'state',
            'status_message',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.state,
                self.status_message,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            state: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            status_message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'status_message', status_message)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"state={self.state!r}")
            parts.append(f"status_message={self.status_message!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('type',)), EqPlan(fields=('type',)), FrozenPlan(fields=('__shape__', 'type'), allo"
        "w_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('type',), cache=False), InitPlan(fields=(InitPla"
        "n.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='type', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), se"
        "lf_param='self', std_params=(), kw_only_params=('type',), frozen=True, slots=False, post_init_params=None, ini"
        "t_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='type', kw_only=True, fn=None),), id=False, t"
        "erse=False, default_fn=None)))"
    ),
    plan_repr_sha1='f6090dfb9aefee115aacb52174a1d6ede3fcc318',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'ElasticGpuSpecification'),
    ),
)
def _process_dataclass__f6090dfb9aefee115aacb52174a1d6ede3fcc318():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                type=self.type,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.type == other.type
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'type',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'type',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.type,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            type: __dataclass__init__fields__1__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'type', type)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"type={self.type!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('runtime_version_arn', 'error')), EqPlan(fields=('runtime_version_arn', 'error')),"
        " FrozenPlan(fields=('__shape__', 'runtime_version_arn', 'error'), allow_dynamic_dunder_attrs=False), HashPlan("
        "action='add', fields=('runtime_version_arn', 'error'), cache=False), InitPlan(fields=(InitPlan.Field(name='__s"
        "hape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='runtime_version_arn', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='error', annotation=OpRef(name='init.fields.2.annotation'), defa"
        "ult=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('r"
        "untime_version_arn', 'error'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
        " ReprPlan(fields=(ReprPlan.Field(name='runtime_version_arn', kw_only=True, fn=None), ReprPlan.Field(name='erro"
        "r', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='f7b1a123934c098577316105a6d2620d7d9e6557',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.lambda_', 'RuntimeVersionConfig'),
    ),
)
def _process_dataclass__f7b1a123934c098577316105a6d2620d7d9e6557():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                runtime_version_arn=self.runtime_version_arn,
                error=self.error,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.runtime_version_arn == other.runtime_version_arn and
                self.error == other.error
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'runtime_version_arn',
            'error',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'runtime_version_arn',
            'error',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.runtime_version_arn,
                self.error,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            runtime_version_arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            error: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'runtime_version_arn', runtime_version_arn)
            __dataclass__object_setattr(self, 'error', error)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"runtime_version_arn={self.runtime_version_arn!r}")
            parts.append(f"error={self.error!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('maximum_efa_interfaces',)), EqPlan(fields=('maximum_efa_interfaces',)), FrozenPla"
        "n(fields=('__shape__', 'maximum_efa_interfaces'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fi"
        "elds=('maximum_efa_interfaces',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=O"
        "pRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maximum_efa_interfa"
        "ces', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None)), self_param='self', std_params=(), kw_only_params=('maximum_efa_interfaces',), frozen=True, slots=Fals"
        "e, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='maximum_efa_int"
        "erfaces', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='f903ef18eed410fa657136064564ce91a649daee',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'EfaInfo'),
    ),
)
def _process_dataclass__f903ef18eed410fa657136064564ce91a649daee():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                maximum_efa_interfaces=self.maximum_efa_interfaces,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.maximum_efa_interfaces == other.maximum_efa_interfaces
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'maximum_efa_interfaces',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'maximum_efa_interfaces',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.maximum_efa_interfaces,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            maximum_efa_interfaces: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'maximum_efa_interfaces', maximum_efa_interfaces)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"maximum_efa_interfaces={self.maximum_efa_interfaces!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('key_pair_id', 'key_type', 'tags', 'public_key', 'create_time', 'key_name', 'key_f"
        "ingerprint')), EqPlan(fields=('key_pair_id', 'key_type', 'tags', 'public_key', 'create_time', 'key_name', 'key"
        "_fingerprint')), FrozenPlan(fields=('__shape__', 'key_pair_id', 'key_type', 'tags', 'public_key', 'create_time"
        "', 'key_name', 'key_fingerprint'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('key_pair"
        "_id', 'key_type', 'tags', 'public_key', 'create_time', 'key_name', 'key_fingerprint'), cache=False), InitPlan("
        "fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check"
        "_type=None), InitPlan.Field(name='key_pair_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpR"
        "ef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='key_type', annotation=OpRef(name='init."
        "fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override="
        "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags'"
        ", annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='public_key', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='i"
        "nit.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='create_time', annotation=OpRef(name='init.fields."
        "5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='key_name', a"
        "nnotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory"
        "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
        " InitPlan.Field(name='key_fingerprint', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name="
        "'init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('key_pair_id', 'k"
        "ey_type', 'tags', 'public_key', 'create_time', 'key_name', 'key_fingerprint'), frozen=True, slots=False, post_"
        "init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='key_pair_id', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='key_type', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=Tru"
        "e, fn=None), ReprPlan.Field(name='public_key', kw_only=True, fn=None), ReprPlan.Field(name='create_time', kw_o"
        "nly=True, fn=None), ReprPlan.Field(name='key_name', kw_only=True, fn=None), ReprPlan.Field(name='key_fingerpri"
        "nt', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='fae65c63a6b266a4414221936efc1a9baf08ed28',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'KeyPairInfo'),
    ),
)
def _process_dataclass__fae65c63a6b266a4414221936efc1a9baf08ed28():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                key_pair_id=self.key_pair_id,
                key_type=self.key_type,
                tags=self.tags,
                public_key=self.public_key,
                create_time=self.create_time,
                key_name=self.key_name,
                key_fingerprint=self.key_fingerprint,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.key_pair_id == other.key_pair_id and
                self.key_type == other.key_type and
                self.tags == other.tags and
                self.public_key == other.public_key and
                self.create_time == other.create_time and
                self.key_name == other.key_name and
                self.key_fingerprint == other.key_fingerprint
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'key_pair_id',
            'key_type',
            'tags',
            'public_key',
            'create_time',
            'key_name',
            'key_fingerprint',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'key_pair_id',
            'key_type',
            'tags',
            'public_key',
            'create_time',
            'key_name',
            'key_fingerprint',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.key_pair_id,
                self.key_type,
                self.tags,
                self.public_key,
                self.create_time,
                self.key_name,
                self.key_fingerprint,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            key_pair_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            key_type: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            tags: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            public_key: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            create_time: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            key_name: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            key_fingerprint: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'key_pair_id', key_pair_id)
            __dataclass__object_setattr(self, 'key_type', key_type)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'public_key', public_key)
            __dataclass__object_setattr(self, 'create_time', create_time)
            __dataclass__object_setattr(self, 'key_name', key_name)
            __dataclass__object_setattr(self, 'key_fingerprint', key_fingerprint)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"key_pair_id={self.key_pair_id!r}")
            parts.append(f"key_type={self.key_type!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"public_key={self.public_key!r}")
            parts.append(f"create_time={self.create_time!r}")
            parts.append(f"key_name={self.key_name!r}")
            parts.append(f"key_fingerprint={self.key_fingerprint!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('network_performance', 'maximum_network_interfaces', 'maximum_network_cards', 'def"
        "ault_network_card_index', 'network_cards', 'ipv4_addresses_per_interface', 'ipv6_addresses_per_interface', 'ip"
        "v6_supported', 'ena_support', 'efa_supported', 'efa_info', 'encryption_in_transit_supported', 'ena_srd_support"
        "ed', 'bandwidth_weightings', 'flexible_ena_queues_support')), EqPlan(fields=('network_performance', 'maximum_n"
        "etwork_interfaces', 'maximum_network_cards', 'default_network_card_index', 'network_cards', 'ipv4_addresses_pe"
        "r_interface', 'ipv6_addresses_per_interface', 'ipv6_supported', 'ena_support', 'efa_supported', 'efa_info', 'e"
        "ncryption_in_transit_supported', 'ena_srd_supported', 'bandwidth_weightings', 'flexible_ena_queues_support')),"
        " FrozenPlan(fields=('__shape__', 'network_performance', 'maximum_network_interfaces', 'maximum_network_cards',"
        " 'default_network_card_index', 'network_cards', 'ipv4_addresses_per_interface', 'ipv6_addresses_per_interface'"
        ", 'ipv6_supported', 'ena_support', 'efa_supported', 'efa_info', 'encryption_in_transit_supported', 'ena_srd_su"
        "pported', 'bandwidth_weightings', 'flexible_ena_queues_support'), allow_dynamic_dunder_attrs=False), HashPlan("
        "action='add', fields=('network_performance', 'maximum_network_interfaces', 'maximum_network_cards', 'default_n"
        "etwork_card_index', 'network_cards', 'ipv4_addresses_per_interface', 'ipv6_addresses_per_interface', 'ipv6_sup"
        "ported', 'ena_support', 'efa_supported', 'efa_info', 'encryption_in_transit_supported', 'ena_srd_supported', '"
        "bandwidth_weightings', 'flexible_ena_queues_support'), cache=False), InitPlan(fields=(InitPlan.Field(name='__s"
        "hape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='network_performance', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='maximum_network_interfaces', annotation=OpRef(name='init.fields"
        ".2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maximum_net"
        "work_cards', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), d"
        "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='default_network_card_index', annotation=OpRef(name='init.fields.4.annotati"
        "on'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type"
        "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_cards', annota"
        "tion=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='ipv4_addresses_per_interface', annotation=OpRef(name='init.fields.6.annotation'), default=OpR"
        "ef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_addresses_per_interface', annotati"
        "on=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='ipv6_supported', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fi"
        "elds.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='ena_support', annotation=OpRef(name='init.fields.9.anno"
        "tation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='efa_supported', an"
        "notation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='efa_info', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init"
        ".fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
        "one, validate=None, check_type=None), InitPlan.Field(name='encryption_in_transit_supported', annotation=OpRef("
        "name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='ena_srd_supported', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.field"
        "s.13.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None), InitPlan.Field(name='bandwidth_weightings', annotation=OpRef(name='init.fields"
        ".14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='flexible_"
        "ena_queues_support', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.de"
        "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
        "=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('network_performance', 'maximum_ne"
        "twork_interfaces', 'maximum_network_cards', 'default_network_card_index', 'network_cards', 'ipv4_addresses_per"
        "_interface', 'ipv6_addresses_per_interface', 'ipv6_supported', 'ena_support', 'efa_supported', 'efa_info', 'en"
        "cryption_in_transit_supported', 'ena_srd_supported', 'bandwidth_weightings', 'flexible_ena_queues_support'), f"
        "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field"
        "(name='network_performance', kw_only=True, fn=None), ReprPlan.Field(name='maximum_network_interfaces', kw_only"
        "=True, fn=None), ReprPlan.Field(name='maximum_network_cards', kw_only=True, fn=None), ReprPlan.Field(name='def"
        "ault_network_card_index', kw_only=True, fn=None), ReprPlan.Field(name='network_cards', kw_only=True, fn=None),"
        " ReprPlan.Field(name='ipv4_addresses_per_interface', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_address"
        "es_per_interface', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_supported', kw_only=True, fn=None), ReprP"
        "lan.Field(name='ena_support', kw_only=True, fn=None), ReprPlan.Field(name='efa_supported', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='efa_info', kw_only=True, fn=None), ReprPlan.Field(name='encryption_in_transit_suppor"
        "ted', kw_only=True, fn=None), ReprPlan.Field(name='ena_srd_supported', kw_only=True, fn=None), ReprPlan.Field("
        "name='bandwidth_weightings', kw_only=True, fn=None), ReprPlan.Field(name='flexible_ena_queues_support', kw_onl"
        "y=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='fc2d8824c718501214ee28cadff7d9c4c450ab6b',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NetworkInfo'),
    ),
)
def _process_dataclass__fc2d8824c718501214ee28cadff7d9c4c450ab6b():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                network_performance=self.network_performance,
                maximum_network_interfaces=self.maximum_network_interfaces,
                maximum_network_cards=self.maximum_network_cards,
                default_network_card_index=self.default_network_card_index,
                network_cards=self.network_cards,
                ipv4_addresses_per_interface=self.ipv4_addresses_per_interface,
                ipv6_addresses_per_interface=self.ipv6_addresses_per_interface,
                ipv6_supported=self.ipv6_supported,
                ena_support=self.ena_support,
                efa_supported=self.efa_supported,
                efa_info=self.efa_info,
                encryption_in_transit_supported=self.encryption_in_transit_supported,
                ena_srd_supported=self.ena_srd_supported,
                bandwidth_weightings=self.bandwidth_weightings,
                flexible_ena_queues_support=self.flexible_ena_queues_support,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.network_performance == other.network_performance and
                self.maximum_network_interfaces == other.maximum_network_interfaces and
                self.maximum_network_cards == other.maximum_network_cards and
                self.default_network_card_index == other.default_network_card_index and
                self.network_cards == other.network_cards and
                self.ipv4_addresses_per_interface == other.ipv4_addresses_per_interface and
                self.ipv6_addresses_per_interface == other.ipv6_addresses_per_interface and
                self.ipv6_supported == other.ipv6_supported and
                self.ena_support == other.ena_support and
                self.efa_supported == other.efa_supported and
                self.efa_info == other.efa_info and
                self.encryption_in_transit_supported == other.encryption_in_transit_supported and
                self.ena_srd_supported == other.ena_srd_supported and
                self.bandwidth_weightings == other.bandwidth_weightings and
                self.flexible_ena_queues_support == other.flexible_ena_queues_support
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'network_performance',
            'maximum_network_interfaces',
            'maximum_network_cards',
            'default_network_card_index',
            'network_cards',
            'ipv4_addresses_per_interface',
            'ipv6_addresses_per_interface',
            'ipv6_supported',
            'ena_support',
            'efa_supported',
            'efa_info',
            'encryption_in_transit_supported',
            'ena_srd_supported',
            'bandwidth_weightings',
            'flexible_ena_queues_support',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'network_performance',
            'maximum_network_interfaces',
            'maximum_network_cards',
            'default_network_card_index',
            'network_cards',
            'ipv4_addresses_per_interface',
            'ipv6_addresses_per_interface',
            'ipv6_supported',
            'ena_support',
            'efa_supported',
            'efa_info',
            'encryption_in_transit_supported',
            'ena_srd_supported',
            'bandwidth_weightings',
            'flexible_ena_queues_support',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.network_performance,
                self.maximum_network_interfaces,
                self.maximum_network_cards,
                self.default_network_card_index,
                self.network_cards,
                self.ipv4_addresses_per_interface,
                self.ipv6_addresses_per_interface,
                self.ipv6_supported,
                self.ena_support,
                self.efa_supported,
                self.efa_info,
                self.encryption_in_transit_supported,
                self.ena_srd_supported,
                self.bandwidth_weightings,
                self.flexible_ena_queues_support,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            network_performance: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            maximum_network_interfaces: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            maximum_network_cards: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            default_network_card_index: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            network_cards: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            ipv4_addresses_per_interface: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            ipv6_addresses_per_interface: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            ipv6_supported: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            ena_support: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            efa_supported: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            efa_info: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            encryption_in_transit_supported: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            ena_srd_supported: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            bandwidth_weightings: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            flexible_ena_queues_support: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'network_performance', network_performance)
            __dataclass__object_setattr(self, 'maximum_network_interfaces', maximum_network_interfaces)
            __dataclass__object_setattr(self, 'maximum_network_cards', maximum_network_cards)
            __dataclass__object_setattr(self, 'default_network_card_index', default_network_card_index)
            __dataclass__object_setattr(self, 'network_cards', network_cards)
            __dataclass__object_setattr(self, 'ipv4_addresses_per_interface', ipv4_addresses_per_interface)
            __dataclass__object_setattr(self, 'ipv6_addresses_per_interface', ipv6_addresses_per_interface)
            __dataclass__object_setattr(self, 'ipv6_supported', ipv6_supported)
            __dataclass__object_setattr(self, 'ena_support', ena_support)
            __dataclass__object_setattr(self, 'efa_supported', efa_supported)
            __dataclass__object_setattr(self, 'efa_info', efa_info)
            __dataclass__object_setattr(self, 'encryption_in_transit_supported', encryption_in_transit_supported)
            __dataclass__object_setattr(self, 'ena_srd_supported', ena_srd_supported)
            __dataclass__object_setattr(self, 'bandwidth_weightings', bandwidth_weightings)
            __dataclass__object_setattr(self, 'flexible_ena_queues_support', flexible_ena_queues_support)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"network_performance={self.network_performance!r}")
            parts.append(f"maximum_network_interfaces={self.maximum_network_interfaces!r}")
            parts.append(f"maximum_network_cards={self.maximum_network_cards!r}")
            parts.append(f"default_network_card_index={self.default_network_card_index!r}")
            parts.append(f"network_cards={self.network_cards!r}")
            parts.append(f"ipv4_addresses_per_interface={self.ipv4_addresses_per_interface!r}")
            parts.append(f"ipv6_addresses_per_interface={self.ipv6_addresses_per_interface!r}")
            parts.append(f"ipv6_supported={self.ipv6_supported!r}")
            parts.append(f"ena_support={self.ena_support!r}")
            parts.append(f"efa_supported={self.efa_supported!r}")
            parts.append(f"efa_info={self.efa_info!r}")
            parts.append(f"encryption_in_transit_supported={self.encryption_in_transit_supported!r}")
            parts.append(f"ena_srd_supported={self.ena_srd_supported!r}")
            parts.append(f"bandwidth_weightings={self.bandwidth_weightings!r}")
            parts.append(f"flexible_ena_queues_support={self.flexible_ena_queues_support!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('volume_name', 'storage_volume_status', 'allocated_storage', 'io_p_s', 'max_alloca"
        "ted_storage', 'storage_throughput', 'storage_type')), EqPlan(fields=('volume_name', 'storage_volume_status', '"
        "allocated_storage', 'io_p_s', 'max_allocated_storage', 'storage_throughput', 'storage_type')), FrozenPlan(fiel"
        "ds=('__shape__', 'volume_name', 'storage_volume_status', 'allocated_storage', 'io_p_s', 'max_allocated_storage"
        "', 'storage_throughput', 'storage_type'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('v"
        "olume_name', 'storage_volume_status', 'allocated_storage', 'io_p_s', 'max_allocated_storage', 'storage_through"
        "put', 'storage_type'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='"
        "init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='volume_name', annotation=OpRef"
        "(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='storage_volume_status', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fie"
        "lds.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='allocated_storage', annotation=OpRef(name='init.fields.3"
        ".annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='io_p_s', anno"
        "tation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='max_allocated_storage', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(na"
        "me='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
        "oerce=None, validate=None, check_type=None), InitPlan.Field(name='storage_throughput', annotation=OpRef(name='"
        "init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, over"
        "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "storage_type', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None)), self_param='self', std_params=(), kw_only_params=('volume_name', 'storage_volume_status', 'a"
        "llocated_storage', 'io_p_s', 'max_allocated_storage', 'storage_throughput', 'storage_type'), frozen=True, slot"
        "s=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='volume_na"
        "me', kw_only=True, fn=None), ReprPlan.Field(name='storage_volume_status', kw_only=True, fn=None), ReprPlan.Fie"
        "ld(name='allocated_storage', kw_only=True, fn=None), ReprPlan.Field(name='io_p_s', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='max_allocated_storage', kw_only=True, fn=None), ReprPlan.Field(name='storage_throughput', kw"
        "_only=True, fn=None), ReprPlan.Field(name='storage_type', kw_only=True, fn=None)), id=False, terse=False, defa"
        "ult_fn=None)))"
    ),
    plan_repr_sha1='fc87793e7821f2416bbe6cd808c7ead2d5e84c58',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'AdditionalStorageVolumeOutput'),
    ),
)
def _process_dataclass__fc87793e7821f2416bbe6cd808c7ead2d5e84c58():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                volume_name=self.volume_name,
                storage_volume_status=self.storage_volume_status,
                allocated_storage=self.allocated_storage,
                io_p_s=self.io_p_s,
                max_allocated_storage=self.max_allocated_storage,
                storage_throughput=self.storage_throughput,
                storage_type=self.storage_type,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.volume_name == other.volume_name and
                self.storage_volume_status == other.storage_volume_status and
                self.allocated_storage == other.allocated_storage and
                self.io_p_s == other.io_p_s and
                self.max_allocated_storage == other.max_allocated_storage and
                self.storage_throughput == other.storage_throughput and
                self.storage_type == other.storage_type
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'volume_name',
            'storage_volume_status',
            'allocated_storage',
            'io_p_s',
            'max_allocated_storage',
            'storage_throughput',
            'storage_type',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'volume_name',
            'storage_volume_status',
            'allocated_storage',
            'io_p_s',
            'max_allocated_storage',
            'storage_throughput',
            'storage_type',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.volume_name,
                self.storage_volume_status,
                self.allocated_storage,
                self.io_p_s,
                self.max_allocated_storage,
                self.storage_throughput,
                self.storage_type,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            volume_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            storage_volume_status: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            allocated_storage: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            io_p_s: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            max_allocated_storage: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            storage_throughput: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            storage_type: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'volume_name', volume_name)
            __dataclass__object_setattr(self, 'storage_volume_status', storage_volume_status)
            __dataclass__object_setattr(self, 'allocated_storage', allocated_storage)
            __dataclass__object_setattr(self, 'io_p_s', io_p_s)
            __dataclass__object_setattr(self, 'max_allocated_storage', max_allocated_storage)
            __dataclass__object_setattr(self, 'storage_throughput', storage_throughput)
            __dataclass__object_setattr(self, 'storage_type', storage_type)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"volume_name={self.volume_name!r}")
            parts.append(f"storage_volume_status={self.storage_volume_status!r}")
            parts.append(f"allocated_storage={self.allocated_storage!r}")
            parts.append(f"io_p_s={self.io_p_s!r}")
            parts.append(f"max_allocated_storage={self.max_allocated_storage!r}")
            parts.append(f"storage_throughput={self.storage_throughput!r}")
            parts.append(f"storage_type={self.storage_type!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('next_token', 'subnets')), EqPlan(fields=('next_token', 'subnets')), FrozenPlan(fi"
        "elds=('__shape__', 'next_token', 'subnets'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields="
        "('next_token', 'subnets'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(na"
        "me='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=Op"
        "Ref(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init="
        "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
        "eld(name='subnets', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None)), self_param='self', std_params=(), kw_only_params=('next_token', 'subnets'), frozen=True"
        ", slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='nex"
        "t_token', kw_only=True, fn=None), ReprPlan.Field(name='subnets', kw_only=True, fn=None)), id=False, terse=Fals"
        "e, default_fn=None)))"
    ),
    plan_repr_sha1='fe250f783ecfe9530c43243559d68cf3aea75b7c',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeSubnetsResult'),
    ),
)
def _process_dataclass__fe250f783ecfe9530c43243559d68cf3aea75b7c():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                next_token=self.next_token,
                subnets=self.subnets,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.next_token == other.next_token and
                self.subnets == other.subnets
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'next_token',
            'subnets',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'next_token',
            'subnets',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.next_token,
                self.subnets,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            subnets: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'subnets', subnets)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"subnets={self.subnets!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('platform_details', 'usage_operation', 'block_device_mappings', 'description', 'en"
        "a_support', 'hypervisor', 'image_owner_alias', 'name', 'root_device_name', 'root_device_type', 'sriov_net_supp"
        "ort', 'state_reason', 'tags', 'virtualization_type', 'boot_mode', 'tpm_support', 'deprecation_time', 'imds_sup"
        "port', 'source_instance_id', 'deregistration_protection', 'last_launched_time', 'image_allowed', 'source_image"
        "_id', 'source_image_region', 'free_tier_eligible', 'image_id', 'image_location', 'state', 'owner_id', 'creatio"
        "n_date', 'public', 'product_codes', 'architecture', 'image_type', 'kernel_id', 'ramdisk_id', 'platform')), EqP"
        "lan(fields=('platform_details', 'usage_operation', 'block_device_mappings', 'description', 'ena_support', 'hyp"
        "ervisor', 'image_owner_alias', 'name', 'root_device_name', 'root_device_type', 'sriov_net_support', 'state_rea"
        "son', 'tags', 'virtualization_type', 'boot_mode', 'tpm_support', 'deprecation_time', 'imds_support', 'source_i"
        "nstance_id', 'deregistration_protection', 'last_launched_time', 'image_allowed', 'source_image_id', 'source_im"
        "age_region', 'free_tier_eligible', 'image_id', 'image_location', 'state', 'owner_id', 'creation_date', 'public"
        "', 'product_codes', 'architecture', 'image_type', 'kernel_id', 'ramdisk_id', 'platform')), FrozenPlan(fields=("
        "'__shape__', 'platform_details', 'usage_operation', 'block_device_mappings', 'description', 'ena_support', 'hy"
        "pervisor', 'image_owner_alias', 'name', 'root_device_name', 'root_device_type', 'sriov_net_support', 'state_re"
        "ason', 'tags', 'virtualization_type', 'boot_mode', 'tpm_support', 'deprecation_time', 'imds_support', 'source_"
        "instance_id', 'deregistration_protection', 'last_launched_time', 'image_allowed', 'source_image_id', 'source_i"
        "mage_region', 'free_tier_eligible', 'image_id', 'image_location', 'state', 'owner_id', 'creation_date', 'publi"
        "c', 'product_codes', 'architecture', 'image_type', 'kernel_id', 'ramdisk_id', 'platform'), allow_dynamic_dunde"
        "r_attrs=False), HashPlan(action='add', fields=('platform_details', 'usage_operation', 'block_device_mappings',"
        " 'description', 'ena_support', 'hypervisor', 'image_owner_alias', 'name', 'root_device_name', 'root_device_typ"
        "e', 'sriov_net_support', 'state_reason', 'tags', 'virtualization_type', 'boot_mode', 'tpm_support', 'deprecati"
        "on_time', 'imds_support', 'source_instance_id', 'deregistration_protection', 'last_launched_time', 'image_allo"
        "wed', 'source_image_id', 'source_image_region', 'free_tier_eligible', 'image_id', 'image_location', 'state', '"
        "owner_id', 'creation_date', 'public', 'product_codes', 'architecture', 'image_type', 'kernel_id', 'ramdisk_id'"
        ", 'platform'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fie"
        "lds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_"
        "VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='platform_details', annotation=OpRef(na"
        "me='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='usage_operation', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.def"
        "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
        "None, check_type=None), InitPlan.Field(name='block_device_mappings', annotation=OpRef(name='init.fields.3.anno"
        "tation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='description', anno"
        "tation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='ena_support', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.f"
        "ields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='hypervisor', annotation=OpRef(name='init.fields.6.anno"
        "tation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='image_owner_alias'"
        ", annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fi"
        "elds.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='root_device_name', annotation=OpRef(name='init.fields.9"
        ".annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='root_device_t"
        "ype', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), defaul"
        "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
        "pe=None), InitPlan.Field(name='sriov_net_support', annotation=OpRef(name='init.fields.11.annotation'), default"
        "=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
        "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state_reason', annotation=OpRef(na"
        "me='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='tags', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None), InitPlan.Field(name='virtualization_type', annotation=OpRef(name='init.fields.14.annotation')"
        ", default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='boot_mode', annotation=Op"
        "Ref(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='tpm_support', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef(name='init.fields."
        "16.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='deprecation_time', annotation=OpRef(name='init.fields.17.an"
        "notation'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='imds_support', "
        "annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.18.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='source_instance_id', annotation=OpRef(name='init.fields.19.annotation'), default=OpRe"
        "f(name='init.fields.19.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='deregistration_protection', annotation="
        "OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.fields.20.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='last_launched_time', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='ini"
        "t.fields.21.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='image_allowed', annotation=OpRef(name='init.fields"
        ".22.annotation'), default=OpRef(name='init.fields.22.default'), default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='source_im"
        "age_id', annotation=OpRef(name='init.fields.23.annotation'), default=OpRef(name='init.fields.23.default'), def"
        "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
        "_type=None), InitPlan.Field(name='source_image_region', annotation=OpRef(name='init.fields.24.annotation'), de"
        "fault=OpRef(name='init.fields.24.default'), default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='free_tier_eligible', annotati"
        "on=OpRef(name='init.fields.25.annotation'), default=OpRef(name='init.fields.25.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='image_id', annotation=OpRef(name='init.fields.26.annotation'), default=OpRef(name='init.field"
        "s.26.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None), InitPlan.Field(name='image_location', annotation=OpRef(name='init.fields.27.an"
        "notation'), default=OpRef(name='init.fields.27.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state', annotat"
        "ion=OpRef(name='init.fields.28.annotation'), default=OpRef(name='init.fields.28.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='owner_id', annotation=OpRef(name='init.fields.29.annotation'), default=OpRef(name='init.fiel"
        "ds.29.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='creation_date', annotation=OpRef(name='init.fields.30.an"
        "notation'), default=OpRef(name='init.fields.30.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public', annota"
        "tion=OpRef(name='init.fields.31.annotation'), default=OpRef(name='init.fields.31.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='product_codes', annotation=OpRef(name='init.fields.32.annotation'), default=OpRef(name='ini"
        "t.fields.32.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='architecture', annotation=OpRef(name='init.fields."
        "33.annotation'), default=OpRef(name='init.fields.33.default'), default_factory=None, init=True, override=False"
        ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='image_type"
        "', annotation=OpRef(name='init.fields.34.annotation'), default=OpRef(name='init.fields.34.default'), default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None), InitPlan.Field(name='kernel_id', annotation=OpRef(name='init.fields.35.annotation'), default=OpRef(name"
        "='init.fields.35.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='ramdisk_id', annotation=OpRef(name='init.fiel"
        "ds.36.annotation'), default=OpRef(name='init.fields.36.default'), default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='platfor"
        "m', annotation=OpRef(name='init.fields.37.annotation'), default=OpRef(name='init.fields.37.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None)), self_param='self', std_params=(), kw_only_params=('platform_details', 'usage_operation', 'block_devic"
        "e_mappings', 'description', 'ena_support', 'hypervisor', 'image_owner_alias', 'name', 'root_device_name', 'roo"
        "t_device_type', 'sriov_net_support', 'state_reason', 'tags', 'virtualization_type', 'boot_mode', 'tpm_support'"
        ", 'deprecation_time', 'imds_support', 'source_instance_id', 'deregistration_protection', 'last_launched_time',"
        " 'image_allowed', 'source_image_id', 'source_image_region', 'free_tier_eligible', 'image_id', 'image_location'"
        ", 'state', 'owner_id', 'creation_date', 'public', 'product_codes', 'architecture', 'image_type', 'kernel_id', "
        "'ramdisk_id', 'platform'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Rep"
        "rPlan(fields=(ReprPlan.Field(name='platform_details', kw_only=True, fn=None), ReprPlan.Field(name='usage_opera"
        "tion', kw_only=True, fn=None), ReprPlan.Field(name='block_device_mappings', kw_only=True, fn=None), ReprPlan.F"
        "ield(name='description', kw_only=True, fn=None), ReprPlan.Field(name='ena_support', kw_only=True, fn=None), Re"
        "prPlan.Field(name='hypervisor', kw_only=True, fn=None), ReprPlan.Field(name='image_owner_alias', kw_only=True,"
        " fn=None), ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='root_device_name', kw_only"
        "=True, fn=None), ReprPlan.Field(name='root_device_type', kw_only=True, fn=None), ReprPlan.Field(name='sriov_ne"
        "t_support', kw_only=True, fn=None), ReprPlan.Field(name='state_reason', kw_only=True, fn=None), ReprPlan.Field"
        "(name='tags', kw_only=True, fn=None), ReprPlan.Field(name='virtualization_type', kw_only=True, fn=None), ReprP"
        "lan.Field(name='boot_mode', kw_only=True, fn=None), ReprPlan.Field(name='tpm_support', kw_only=True, fn=None),"
        " ReprPlan.Field(name='deprecation_time', kw_only=True, fn=None), ReprPlan.Field(name='imds_support', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='source_instance_id', kw_only=True, fn=None), ReprPlan.Field(name='deregist"
        "ration_protection', kw_only=True, fn=None), ReprPlan.Field(name='last_launched_time', kw_only=True, fn=None), "
        "ReprPlan.Field(name='image_allowed', kw_only=True, fn=None), ReprPlan.Field(name='source_image_id', kw_only=Tr"
        "ue, fn=None), ReprPlan.Field(name='source_image_region', kw_only=True, fn=None), ReprPlan.Field(name='free_tie"
        "r_eligible', kw_only=True, fn=None), ReprPlan.Field(name='image_id', kw_only=True, fn=None), ReprPlan.Field(na"
        "me='image_location', kw_only=True, fn=None), ReprPlan.Field(name='state', kw_only=True, fn=None), ReprPlan.Fie"
        "ld(name='owner_id', kw_only=True, fn=None), ReprPlan.Field(name='creation_date', kw_only=True, fn=None), ReprP"
        "lan.Field(name='public', kw_only=True, fn=None), ReprPlan.Field(name='product_codes', kw_only=True, fn=None), "
        "ReprPlan.Field(name='architecture', kw_only=True, fn=None), ReprPlan.Field(name='image_type', kw_only=True, fn"
        "=None), ReprPlan.Field(name='kernel_id', kw_only=True, fn=None), ReprPlan.Field(name='ramdisk_id', kw_only=Tru"
        "e, fn=None), ReprPlan.Field(name='platform', kw_only=True, fn=None)), id=False, terse=False, default_fn=None))"
        ")"
    ),
    plan_repr_sha1='fe5045a4d78c719e770d3dfad1430428ecab7dfe',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__24__annotation',
        '__dataclass__init__fields__24__default',
        '__dataclass__init__fields__25__annotation',
        '__dataclass__init__fields__25__default',
        '__dataclass__init__fields__26__annotation',
        '__dataclass__init__fields__26__default',
        '__dataclass__init__fields__27__annotation',
        '__dataclass__init__fields__27__default',
        '__dataclass__init__fields__28__annotation',
        '__dataclass__init__fields__28__default',
        '__dataclass__init__fields__29__annotation',
        '__dataclass__init__fields__29__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__30__annotation',
        '__dataclass__init__fields__30__default',
        '__dataclass__init__fields__31__annotation',
        '__dataclass__init__fields__31__default',
        '__dataclass__init__fields__32__annotation',
        '__dataclass__init__fields__32__default',
        '__dataclass__init__fields__33__annotation',
        '__dataclass__init__fields__33__default',
        '__dataclass__init__fields__34__annotation',
        '__dataclass__init__fields__34__default',
        '__dataclass__init__fields__35__annotation',
        '__dataclass__init__fields__35__default',
        '__dataclass__init__fields__36__annotation',
        '__dataclass__init__fields__36__default',
        '__dataclass__init__fields__37__annotation',
        '__dataclass__init__fields__37__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Image'),
    ),
)
def _process_dataclass__fe5045a4d78c719e770d3dfad1430428ecab7dfe():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__24__annotation,
        __dataclass__init__fields__24__default,
        __dataclass__init__fields__25__annotation,
        __dataclass__init__fields__25__default,
        __dataclass__init__fields__26__annotation,
        __dataclass__init__fields__26__default,
        __dataclass__init__fields__27__annotation,
        __dataclass__init__fields__27__default,
        __dataclass__init__fields__28__annotation,
        __dataclass__init__fields__28__default,
        __dataclass__init__fields__29__annotation,
        __dataclass__init__fields__29__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__30__annotation,
        __dataclass__init__fields__30__default,
        __dataclass__init__fields__31__annotation,
        __dataclass__init__fields__31__default,
        __dataclass__init__fields__32__annotation,
        __dataclass__init__fields__32__default,
        __dataclass__init__fields__33__annotation,
        __dataclass__init__fields__33__default,
        __dataclass__init__fields__34__annotation,
        __dataclass__init__fields__34__default,
        __dataclass__init__fields__35__annotation,
        __dataclass__init__fields__35__default,
        __dataclass__init__fields__36__annotation,
        __dataclass__init__fields__36__default,
        __dataclass__init__fields__37__annotation,
        __dataclass__init__fields__37__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                platform_details=self.platform_details,
                usage_operation=self.usage_operation,
                block_device_mappings=self.block_device_mappings,
                description=self.description,
                ena_support=self.ena_support,
                hypervisor=self.hypervisor,
                image_owner_alias=self.image_owner_alias,
                name=self.name,
                root_device_name=self.root_device_name,
                root_device_type=self.root_device_type,
                sriov_net_support=self.sriov_net_support,
                state_reason=self.state_reason,
                tags=self.tags,
                virtualization_type=self.virtualization_type,
                boot_mode=self.boot_mode,
                tpm_support=self.tpm_support,
                deprecation_time=self.deprecation_time,
                imds_support=self.imds_support,
                source_instance_id=self.source_instance_id,
                deregistration_protection=self.deregistration_protection,
                last_launched_time=self.last_launched_time,
                image_allowed=self.image_allowed,
                source_image_id=self.source_image_id,
                source_image_region=self.source_image_region,
                free_tier_eligible=self.free_tier_eligible,
                image_id=self.image_id,
                image_location=self.image_location,
                state=self.state,
                owner_id=self.owner_id,
                creation_date=self.creation_date,
                public=self.public,
                product_codes=self.product_codes,
                architecture=self.architecture,
                image_type=self.image_type,
                kernel_id=self.kernel_id,
                ramdisk_id=self.ramdisk_id,
                platform=self.platform,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.platform_details == other.platform_details and
                self.usage_operation == other.usage_operation and
                self.block_device_mappings == other.block_device_mappings and
                self.description == other.description and
                self.ena_support == other.ena_support and
                self.hypervisor == other.hypervisor and
                self.image_owner_alias == other.image_owner_alias and
                self.name == other.name and
                self.root_device_name == other.root_device_name and
                self.root_device_type == other.root_device_type and
                self.sriov_net_support == other.sriov_net_support and
                self.state_reason == other.state_reason and
                self.tags == other.tags and
                self.virtualization_type == other.virtualization_type and
                self.boot_mode == other.boot_mode and
                self.tpm_support == other.tpm_support and
                self.deprecation_time == other.deprecation_time and
                self.imds_support == other.imds_support and
                self.source_instance_id == other.source_instance_id and
                self.deregistration_protection == other.deregistration_protection and
                self.last_launched_time == other.last_launched_time and
                self.image_allowed == other.image_allowed and
                self.source_image_id == other.source_image_id and
                self.source_image_region == other.source_image_region and
                self.free_tier_eligible == other.free_tier_eligible and
                self.image_id == other.image_id and
                self.image_location == other.image_location and
                self.state == other.state and
                self.owner_id == other.owner_id and
                self.creation_date == other.creation_date and
                self.public == other.public and
                self.product_codes == other.product_codes and
                self.architecture == other.architecture and
                self.image_type == other.image_type and
                self.kernel_id == other.kernel_id and
                self.ramdisk_id == other.ramdisk_id and
                self.platform == other.platform
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'platform_details',
            'usage_operation',
            'block_device_mappings',
            'description',
            'ena_support',
            'hypervisor',
            'image_owner_alias',
            'name',
            'root_device_name',
            'root_device_type',
            'sriov_net_support',
            'state_reason',
            'tags',
            'virtualization_type',
            'boot_mode',
            'tpm_support',
            'deprecation_time',
            'imds_support',
            'source_instance_id',
            'deregistration_protection',
            'last_launched_time',
            'image_allowed',
            'source_image_id',
            'source_image_region',
            'free_tier_eligible',
            'image_id',
            'image_location',
            'state',
            'owner_id',
            'creation_date',
            'public',
            'product_codes',
            'architecture',
            'image_type',
            'kernel_id',
            'ramdisk_id',
            'platform',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'platform_details',
            'usage_operation',
            'block_device_mappings',
            'description',
            'ena_support',
            'hypervisor',
            'image_owner_alias',
            'name',
            'root_device_name',
            'root_device_type',
            'sriov_net_support',
            'state_reason',
            'tags',
            'virtualization_type',
            'boot_mode',
            'tpm_support',
            'deprecation_time',
            'imds_support',
            'source_instance_id',
            'deregistration_protection',
            'last_launched_time',
            'image_allowed',
            'source_image_id',
            'source_image_region',
            'free_tier_eligible',
            'image_id',
            'image_location',
            'state',
            'owner_id',
            'creation_date',
            'public',
            'product_codes',
            'architecture',
            'image_type',
            'kernel_id',
            'ramdisk_id',
            'platform',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.platform_details,
                self.usage_operation,
                self.block_device_mappings,
                self.description,
                self.ena_support,
                self.hypervisor,
                self.image_owner_alias,
                self.name,
                self.root_device_name,
                self.root_device_type,
                self.sriov_net_support,
                self.state_reason,
                self.tags,
                self.virtualization_type,
                self.boot_mode,
                self.tpm_support,
                self.deprecation_time,
                self.imds_support,
                self.source_instance_id,
                self.deregistration_protection,
                self.last_launched_time,
                self.image_allowed,
                self.source_image_id,
                self.source_image_region,
                self.free_tier_eligible,
                self.image_id,
                self.image_location,
                self.state,
                self.owner_id,
                self.creation_date,
                self.public,
                self.product_codes,
                self.architecture,
                self.image_type,
                self.kernel_id,
                self.ramdisk_id,
                self.platform,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            platform_details: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            usage_operation: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            block_device_mappings: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            description: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            ena_support: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            hypervisor: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            image_owner_alias: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            name: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            root_device_name: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            root_device_type: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            sriov_net_support: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            state_reason: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            tags: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            virtualization_type: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            boot_mode: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            tpm_support: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            deprecation_time: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            imds_support: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            source_instance_id: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            deregistration_protection: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            last_launched_time: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            image_allowed: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            source_image_id: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
            source_image_region: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
            free_tier_eligible: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
            image_id: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
            image_location: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
            state: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
            owner_id: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
            creation_date: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
            public: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
            product_codes: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
            architecture: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
            image_type: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
            kernel_id: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
            ramdisk_id: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
            platform: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'platform_details', platform_details)
            __dataclass__object_setattr(self, 'usage_operation', usage_operation)
            __dataclass__object_setattr(self, 'block_device_mappings', block_device_mappings)
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'ena_support', ena_support)
            __dataclass__object_setattr(self, 'hypervisor', hypervisor)
            __dataclass__object_setattr(self, 'image_owner_alias', image_owner_alias)
            __dataclass__object_setattr(self, 'name', name)
            __dataclass__object_setattr(self, 'root_device_name', root_device_name)
            __dataclass__object_setattr(self, 'root_device_type', root_device_type)
            __dataclass__object_setattr(self, 'sriov_net_support', sriov_net_support)
            __dataclass__object_setattr(self, 'state_reason', state_reason)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'virtualization_type', virtualization_type)
            __dataclass__object_setattr(self, 'boot_mode', boot_mode)
            __dataclass__object_setattr(self, 'tpm_support', tpm_support)
            __dataclass__object_setattr(self, 'deprecation_time', deprecation_time)
            __dataclass__object_setattr(self, 'imds_support', imds_support)
            __dataclass__object_setattr(self, 'source_instance_id', source_instance_id)
            __dataclass__object_setattr(self, 'deregistration_protection', deregistration_protection)
            __dataclass__object_setattr(self, 'last_launched_time', last_launched_time)
            __dataclass__object_setattr(self, 'image_allowed', image_allowed)
            __dataclass__object_setattr(self, 'source_image_id', source_image_id)
            __dataclass__object_setattr(self, 'source_image_region', source_image_region)
            __dataclass__object_setattr(self, 'free_tier_eligible', free_tier_eligible)
            __dataclass__object_setattr(self, 'image_id', image_id)
            __dataclass__object_setattr(self, 'image_location', image_location)
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'owner_id', owner_id)
            __dataclass__object_setattr(self, 'creation_date', creation_date)
            __dataclass__object_setattr(self, 'public', public)
            __dataclass__object_setattr(self, 'product_codes', product_codes)
            __dataclass__object_setattr(self, 'architecture', architecture)
            __dataclass__object_setattr(self, 'image_type', image_type)
            __dataclass__object_setattr(self, 'kernel_id', kernel_id)
            __dataclass__object_setattr(self, 'ramdisk_id', ramdisk_id)
            __dataclass__object_setattr(self, 'platform', platform)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"platform_details={self.platform_details!r}")
            parts.append(f"usage_operation={self.usage_operation!r}")
            parts.append(f"block_device_mappings={self.block_device_mappings!r}")
            parts.append(f"description={self.description!r}")
            parts.append(f"ena_support={self.ena_support!r}")
            parts.append(f"hypervisor={self.hypervisor!r}")
            parts.append(f"image_owner_alias={self.image_owner_alias!r}")
            parts.append(f"name={self.name!r}")
            parts.append(f"root_device_name={self.root_device_name!r}")
            parts.append(f"root_device_type={self.root_device_type!r}")
            parts.append(f"sriov_net_support={self.sriov_net_support!r}")
            parts.append(f"state_reason={self.state_reason!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"virtualization_type={self.virtualization_type!r}")
            parts.append(f"boot_mode={self.boot_mode!r}")
            parts.append(f"tpm_support={self.tpm_support!r}")
            parts.append(f"deprecation_time={self.deprecation_time!r}")
            parts.append(f"imds_support={self.imds_support!r}")
            parts.append(f"source_instance_id={self.source_instance_id!r}")
            parts.append(f"deregistration_protection={self.deregistration_protection!r}")
            parts.append(f"last_launched_time={self.last_launched_time!r}")
            parts.append(f"image_allowed={self.image_allowed!r}")
            parts.append(f"source_image_id={self.source_image_id!r}")
            parts.append(f"source_image_region={self.source_image_region!r}")
            parts.append(f"free_tier_eligible={self.free_tier_eligible!r}")
            parts.append(f"image_id={self.image_id!r}")
            parts.append(f"image_location={self.image_location!r}")
            parts.append(f"state={self.state!r}")
            parts.append(f"owner_id={self.owner_id!r}")
            parts.append(f"creation_date={self.creation_date!r}")
            parts.append(f"public={self.public!r}")
            parts.append(f"product_codes={self.product_codes!r}")
            parts.append(f"architecture={self.architecture!r}")
            parts.append(f"image_type={self.image_type!r}")
            parts.append(f"kernel_id={self.kernel_id!r}")
            parts.append(f"ramdisk_id={self.ramdisk_id!r}")
            parts.append(f"platform={self.platform!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attr"
        "s=False), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', an"
        "notation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False"
        ", field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_param"
        "s=(), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
        "lan(fields=(), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='fe6ee985e5454d23ff07c1fb86524a86d9239cf5',
    op_ref_idents=(),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Shape'),
        ('ominfra.clouds.aws.models.services.rds', 'AuthorizationNotFoundFault'),
        ('ominfra.clouds.aws.models.services.rds', 'BackupPolicyNotFoundFault'),
        ('ominfra.clouds.aws.models.services.rds', 'CertificateNotFoundFault'),
        ('ominfra.clouds.aws.models.services.rds', 'DBClusterNotFoundFault'),
        ('ominfra.clouds.aws.models.services.rds', 'DBInstanceAlreadyExistsFault'),
        ('ominfra.clouds.aws.models.services.rds', 'DBInstanceAutomatedBackupQuotaExceededFault'),
        ('ominfra.clouds.aws.models.services.rds', 'DBInstanceNotFoundFault'),
        ('ominfra.clouds.aws.models.services.rds', 'DBParameterGroupNotFoundFault'),
        ('ominfra.clouds.aws.models.services.rds', 'DBSecurityGroupNotFoundFault'),
        ('ominfra.clouds.aws.models.services.rds', 'DBSnapshotAlreadyExistsFault'),
        ('ominfra.clouds.aws.models.services.rds', 'DBSubnetGroupDoesNotCoverEnoughAZs'),
        ('ominfra.clouds.aws.models.services.rds', 'DBSubnetGroupNotFoundFault'),
        ('ominfra.clouds.aws.models.services.rds', 'DomainNotFoundFault'),
        ('ominfra.clouds.aws.models.services.rds', 'InstanceQuotaExceededFault'),
        ('ominfra.clouds.aws.models.services.rds', 'InsufficientDBInstanceCapacityFault'),
        ('ominfra.clouds.aws.models.services.rds', 'InvalidDBClusterStateFault'),
        ('ominfra.clouds.aws.models.services.rds', 'InvalidDBInstanceStateFault'),
        ('ominfra.clouds.aws.models.services.rds', 'InvalidSubnet'),
        ('ominfra.clouds.aws.models.services.rds', 'InvalidVPCNetworkStateFault'),
        ('ominfra.clouds.aws.models.services.rds', 'KMSKeyNotAccessibleFault'),
        ('ominfra.clouds.aws.models.services.rds', 'NetworkTypeNotSupported'),
        ('ominfra.clouds.aws.models.services.rds', 'OptionGroupNotFoundFault'),
        ('ominfra.clouds.aws.models.services.rds', 'ProvisionedIopsNotAvailableInAZFault'),
        ('ominfra.clouds.aws.models.services.rds', 'SnapshotQuotaExceededFault'),
        ('ominfra.clouds.aws.models.services.rds', 'StorageQuotaExceededFault'),
        ('ominfra.clouds.aws.models.services.rds', 'StorageTypeNotSupportedFault'),
        ('ominfra.clouds.aws.models.services.rds', 'TenantDatabaseQuotaExceededFault'),
        ('ominfra.clouds.aws.models.services.rds', 'VpcEncryptionControlViolationException'),
        ('ominfra.clouds.aws.models.services.s3', 'EncryptionTypeMismatch'),
        ('ominfra.clouds.aws.models.services.s3', 'InvalidRequest'),
        ('ominfra.clouds.aws.models.services.s3', 'InvalidWriteOffset'),
        ('ominfra.clouds.aws.models.services.s3', 'NoSuchBucket'),
        ('ominfra.clouds.aws.models.services.s3', 'NoSuchKey'),
        ('ominfra.clouds.aws.models.services.s3', 'TooManyParts'),
    ),
)
def _process_dataclass__fe6ee985e5454d23ff07c1fb86524a86d9239cf5():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls()  # noqa

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return True

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash(())

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
        ) -> __dataclass__None:
            pass

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('db_instance_identifier', 'filters', 'max_records', 'marker')), EqPlan(fields=('db"
        "_instance_identifier', 'filters', 'max_records', 'marker')), FrozenPlan(fields=('__shape__', 'db_instance_iden"
        "tifier', 'filters', 'max_records', 'marker'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields"
        "=('db_instance_identifier', 'filters', 'max_records', 'marker'), cache=False), InitPlan(fields=(InitPlan.Field"
        "(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init"
        "=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='db_instance_identifier', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='in"
        "it.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='filters', annotation=OpRef(name='init.fields.2.ann"
        "otation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_records', ann"
        "otation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='marker', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.field"
        "s.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
        "lidate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('db_instance_identifier', 'f"
        "ilters', 'max_records', 'marker'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns="
        "()), ReprPlan(fields=(ReprPlan.Field(name='db_instance_identifier', kw_only=True, fn=None), ReprPlan.Field(nam"
        "e='filters', kw_only=True, fn=None), ReprPlan.Field(name='max_records', kw_only=True, fn=None), ReprPlan.Field"
        "(name='marker', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='ffdd6c338f4a6eedeec3d6928b24e8591a471f20',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.rds', 'DescribeDBInstancesMessage'),
    ),
)
def _process_dataclass__ffdd6c338f4a6eedeec3d6928b24e8591a471f20():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                db_instance_identifier=self.db_instance_identifier,
                filters=self.filters,
                max_records=self.max_records,
                marker=self.marker,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.db_instance_identifier == other.db_instance_identifier and
                self.filters == other.filters and
                self.max_records == other.max_records and
                self.marker == other.marker
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'db_instance_identifier',
            'filters',
            'max_records',
            'marker',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'db_instance_identifier',
            'filters',
            'max_records',
            'marker',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.db_instance_identifier,
                self.filters,
                self.max_records,
                self.marker,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            db_instance_identifier: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            filters: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            max_records: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            marker: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'db_instance_identifier', db_instance_identifier)
            __dataclass__object_setattr(self, 'filters', filters)
            __dataclass__object_setattr(self, 'max_records', max_records)
            __dataclass__object_setattr(self, 'marker', marker)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"db_instance_identifier={self.db_instance_identifier!r}")
            parts.append(f"filters={self.filters!r}")
            parts.append(f"max_records={self.max_records!r}")
            parts.append(f"marker={self.marker!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass
