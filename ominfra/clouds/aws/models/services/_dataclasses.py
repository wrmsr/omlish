# @omlish-generated
# type: ignore
# ruff: noqa
# flake8: noqa
import dataclasses
import reprlib
import types


##


REGISTRY = {}


def _register(plan_repr):
    def inner(fn):
        REGISTRY[fn.__name__] = (plan_repr, fn)
        return fn
    return inner


##


@_register(
    "Plans(tup=(CopyPlan(fields=('key', 'value')), EqPlan(fields=('key', 'value')), FrozenPlan(fields=('key', 'value'),"
    " allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('key', 'value'), cache=False), InitPlan(fields="
    "(InitPlan.Field(name='key', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None,"
    " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
    "Field(name='value', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self"
    "', std_params=('key', 'value'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), v"
    "alidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='key', kw_only=False, fn=None), ReprPlan.Field(name='value',"
    " kw_only=False, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fbase_2fTag(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            key=self.key,
            value=self.value,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.key == other.key and
            self.value == other.value
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'key',
        'value',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'key',
        'value',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.key,
            self.value,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        key: __dataclass__init__fields__0__annotation,
        value: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'key', key)
        __dataclass__object_setattr(self, 'value', value)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"key={self.key!r}")
        parts.append(f"value={self.value!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('e',)), EqPlan(fields=('e',)), FrozenPlan(fields=('e',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('e',), cache=False), InitPlan(fields=(InitPlan.Field(name='e', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('e',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='e', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fbase_2fListValueType(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            e=self.e,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.e == other.e
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'e',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'e',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.e,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        e: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'e', e)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"e={self.e!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('k', 'v')), EqPlan(fields=('k', 'v')), FrozenPlan(fields=('k', 'v'), allow_dynamic_dun"
    "der_attrs=False), HashPlan(action='add', fields=('k', 'v'), cache=False), InitPlan(fields=(InitPlan.Field(name='k'"
    ", annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='v', annotation"
    "=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('k', 'v'), kw_o"
    "nly_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Re"
    "prPlan.Field(name='k', kw_only=False, fn=None), ReprPlan.Field(name='v', kw_only=False, fn=None)), id=False, terse"
    "=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fbase_2fMapValueType(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            k=self.k,
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.k == other.k and
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'k',
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'k',
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.k,
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        k: __dataclass__init__fields__0__annotation,
        v: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'k', k)
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"k={self.k!r}")
        parts.append(f"v={self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fbase_2fShape(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'input', 'output', 'errors')), FrozenPlan(fields=('name', 'input', 'output', '"
    "errors'), allow_dynamic_dunder_attrs=False), InitPlan(fields=(InitPlan.Field(name='name', annotation=OpRef(name='i"
    "nit.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INS"
    "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='input', annotation=OpRef(name='init.fiel"
    "ds.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, f"
    "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='output', annotati"
    "on=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='errors', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), de"
    "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
    "pe=None)), self_param='self', std_params=(), kw_only_params=('name', 'input', 'output', 'errors'), frozen=True, sl"
    "ots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_o"
    "nly=True, fn=None), ReprPlan.Field(name='input', kw_only=True, fn=None), ReprPlan.Field(name='output', kw_only=Tru"
    "e, fn=None), ReprPlan.Field(name='errors', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fbase_2fOperation(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            input=self.input,
            output=self.output,
            errors=self.errors,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    __dataclass___setattr_frozen_fields = {
        'name',
        'input',
        'output',
        'errors',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
        'input',
        'output',
        'errors',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __init__(
        self,
        *,
        name: __dataclass__init__fields__0__annotation,
        input: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        output: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        errors: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'input', input)
        __dataclass__object_setattr(self, 'output', output)
        __dataclass__object_setattr(self, 'errors', errors)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"input={self.input!r}")
        parts.append(f"output={self.output!r}")
        parts.append(f"errors={self.errors!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('allocation_id', 'association_id', 'domain', 'network_interface_id', 'network_interfac"
    "e_owner_id', 'private_ip_address', 'tags', 'public_ipv4_pool', 'network_border_group', 'customer_owned_ip', 'custo"
    "mer_owned_ipv4_pool', 'carrier_ip', 'subnet_id', 'service_managed', 'instance_id', 'public_ip')), EqPlan(fields=('"
    "allocation_id', 'association_id', 'domain', 'network_interface_id', 'network_interface_owner_id', 'private_ip_addr"
    "ess', 'tags', 'public_ipv4_pool', 'network_border_group', 'customer_owned_ip', 'customer_owned_ipv4_pool', 'carrie"
    "r_ip', 'subnet_id', 'service_managed', 'instance_id', 'public_ip')), FrozenPlan(fields=('__shape__', 'allocation_i"
    "d', 'association_id', 'domain', 'network_interface_id', 'network_interface_owner_id', 'private_ip_address', 'tags'"
    ", 'public_ipv4_pool', 'network_border_group', 'customer_owned_ip', 'customer_owned_ipv4_pool', 'carrier_ip', 'subn"
    "et_id', 'service_managed', 'instance_id', 'public_ip'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', "
    "fields=('allocation_id', 'association_id', 'domain', 'network_interface_id', 'network_interface_owner_id', 'privat"
    "e_ip_address', 'tags', 'public_ipv4_pool', 'network_border_group', 'customer_owned_ip', 'customer_owned_ipv4_pool'"
    ", 'carrier_ip', 'subnet_id', 'service_managed', 'instance_id', 'public_ip'), cache=False), InitPlan(fields=(InitPl"
    "an.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, "
    "init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan."
    "Field(name='allocation_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.d"
    "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
    "ne, check_type=None), InitPlan.Field(name='association_id', annotation=OpRef(name='init.fields.2.annotation'), def"
    "ault=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='domain', annotation=OpRef(name='init.fi"
    "elds.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_interfa"
    "ce_id', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='network_interface_owner_id', annotation=OpRef(name='init.fields.5.annotation'), default=OpR"
    "ef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None), InitPlan.Field(name='private_ip_address', annotation=OpRef(name='ini"
    "t.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=Fa"
    "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags', anno"
    "tation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
    "ield(name='public_ipv4_pool', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8"
    ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None), InitPlan.Field(name='network_border_group', annotation=OpRef(name='init.fields.9.annotatio"
    "n'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='customer_owned_ip', annotation="
    "OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='customer_owned_ipv4_pool', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fiel"
    "ds.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None), InitPlan.Field(name='carrier_ip', annotation=OpRef(name='init.fields.12.annotation'),"
    " default=OpRef(name='init.fields.12.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
    "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnet_id', annotation=OpRef(name="
    "'init.fields.13.annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='servi"
    "ce_managed', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='instance_id', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name"
    "='init.fields.15.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='public_ip', annotation=OpRef(name='init.fields.16.ann"
    "otation'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=True, override=False, field_ty"
    "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_pa"
    "rams=('allocation_id', 'association_id', 'domain', 'network_interface_id', 'network_interface_owner_id', 'private_"
    "ip_address', 'tags', 'public_ipv4_pool', 'network_border_group', 'customer_owned_ip', 'customer_owned_ipv4_pool', "
    "'carrier_ip', 'subnet_id', 'service_managed', 'instance_id', 'public_ip'), frozen=True, slots=False, post_init_par"
    "ams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='allocation_id', kw_only=True, fn=No"
    "ne), ReprPlan.Field(name='association_id', kw_only=True, fn=None), ReprPlan.Field(name='domain', kw_only=True, fn="
    "None), ReprPlan.Field(name='network_interface_id', kw_only=True, fn=None), ReprPlan.Field(name='network_interface_"
    "owner_id', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_address', kw_only=True, fn=None), ReprPlan.Fiel"
    "d(name='tags', kw_only=True, fn=None), ReprPlan.Field(name='public_ipv4_pool', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='network_border_group', kw_only=True, fn=None), ReprPlan.Field(name='customer_owned_ip', kw_only=True, fn"
    "=None), ReprPlan.Field(name='customer_owned_ipv4_pool', kw_only=True, fn=None), ReprPlan.Field(name='carrier_ip', "
    "kw_only=True, fn=None), ReprPlan.Field(name='subnet_id', kw_only=True, fn=None), ReprPlan.Field(name='service_mana"
    "ged', kw_only=True, fn=None), ReprPlan.Field(name='instance_id', kw_only=True, fn=None), ReprPlan.Field(name='publ"
    "ic_ip', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fAddress(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            allocation_id=self.allocation_id,
            association_id=self.association_id,
            domain=self.domain,
            network_interface_id=self.network_interface_id,
            network_interface_owner_id=self.network_interface_owner_id,
            private_ip_address=self.private_ip_address,
            tags=self.tags,
            public_ipv4_pool=self.public_ipv4_pool,
            network_border_group=self.network_border_group,
            customer_owned_ip=self.customer_owned_ip,
            customer_owned_ipv4_pool=self.customer_owned_ipv4_pool,
            carrier_ip=self.carrier_ip,
            subnet_id=self.subnet_id,
            service_managed=self.service_managed,
            instance_id=self.instance_id,
            public_ip=self.public_ip,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.allocation_id == other.allocation_id and
            self.association_id == other.association_id and
            self.domain == other.domain and
            self.network_interface_id == other.network_interface_id and
            self.network_interface_owner_id == other.network_interface_owner_id and
            self.private_ip_address == other.private_ip_address and
            self.tags == other.tags and
            self.public_ipv4_pool == other.public_ipv4_pool and
            self.network_border_group == other.network_border_group and
            self.customer_owned_ip == other.customer_owned_ip and
            self.customer_owned_ipv4_pool == other.customer_owned_ipv4_pool and
            self.carrier_ip == other.carrier_ip and
            self.subnet_id == other.subnet_id and
            self.service_managed == other.service_managed and
            self.instance_id == other.instance_id and
            self.public_ip == other.public_ip
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'allocation_id',
        'association_id',
        'domain',
        'network_interface_id',
        'network_interface_owner_id',
        'private_ip_address',
        'tags',
        'public_ipv4_pool',
        'network_border_group',
        'customer_owned_ip',
        'customer_owned_ipv4_pool',
        'carrier_ip',
        'subnet_id',
        'service_managed',
        'instance_id',
        'public_ip',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'allocation_id',
        'association_id',
        'domain',
        'network_interface_id',
        'network_interface_owner_id',
        'private_ip_address',
        'tags',
        'public_ipv4_pool',
        'network_border_group',
        'customer_owned_ip',
        'customer_owned_ipv4_pool',
        'carrier_ip',
        'subnet_id',
        'service_managed',
        'instance_id',
        'public_ip',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.allocation_id,
            self.association_id,
            self.domain,
            self.network_interface_id,
            self.network_interface_owner_id,
            self.private_ip_address,
            self.tags,
            self.public_ipv4_pool,
            self.network_border_group,
            self.customer_owned_ip,
            self.customer_owned_ipv4_pool,
            self.carrier_ip,
            self.subnet_id,
            self.service_managed,
            self.instance_id,
            self.public_ip,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        allocation_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        association_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        domain: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        network_interface_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        network_interface_owner_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        private_ip_address: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        tags: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        public_ipv4_pool: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        network_border_group: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        customer_owned_ip: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        customer_owned_ipv4_pool: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        carrier_ip: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        subnet_id: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        service_managed: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        instance_id: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        public_ip: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'allocation_id', allocation_id)
        __dataclass__object_setattr(self, 'association_id', association_id)
        __dataclass__object_setattr(self, 'domain', domain)
        __dataclass__object_setattr(self, 'network_interface_id', network_interface_id)
        __dataclass__object_setattr(self, 'network_interface_owner_id', network_interface_owner_id)
        __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)
        __dataclass__object_setattr(self, 'tags', tags)
        __dataclass__object_setattr(self, 'public_ipv4_pool', public_ipv4_pool)
        __dataclass__object_setattr(self, 'network_border_group', network_border_group)
        __dataclass__object_setattr(self, 'customer_owned_ip', customer_owned_ip)
        __dataclass__object_setattr(self, 'customer_owned_ipv4_pool', customer_owned_ipv4_pool)
        __dataclass__object_setattr(self, 'carrier_ip', carrier_ip)
        __dataclass__object_setattr(self, 'subnet_id', subnet_id)
        __dataclass__object_setattr(self, 'service_managed', service_managed)
        __dataclass__object_setattr(self, 'instance_id', instance_id)
        __dataclass__object_setattr(self, 'public_ip', public_ip)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"allocation_id={self.allocation_id!r}")
        parts.append(f"association_id={self.association_id!r}")
        parts.append(f"domain={self.domain!r}")
        parts.append(f"network_interface_id={self.network_interface_id!r}")
        parts.append(f"network_interface_owner_id={self.network_interface_owner_id!r}")
        parts.append(f"private_ip_address={self.private_ip_address!r}")
        parts.append(f"tags={self.tags!r}")
        parts.append(f"public_ipv4_pool={self.public_ipv4_pool!r}")
        parts.append(f"network_border_group={self.network_border_group!r}")
        parts.append(f"customer_owned_ip={self.customer_owned_ip!r}")
        parts.append(f"customer_owned_ipv4_pool={self.customer_owned_ipv4_pool!r}")
        parts.append(f"carrier_ip={self.carrier_ip!r}")
        parts.append(f"subnet_id={self.subnet_id!r}")
        parts.append(f"service_managed={self.service_managed!r}")
        parts.append(f"instance_id={self.instance_id!r}")
        parts.append(f"public_ip={self.public_ip!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ena_srd_udp_enabled',)), EqPlan(fields=('ena_srd_udp_enabled',)), FrozenPlan(fields=("
    "'__shape__', 'ena_srd_udp_enabled'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ena_srd_ud"
    "p_enabled',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0"
    ".annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='ena_srd_udp_enabled', annotation=OpRef(name='init.f"
    "ields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), "
    "kw_only_params=('ena_srd_udp_enabled',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fn"
    "s=()), ReprPlan(fields=(ReprPlan.Field(name='ena_srd_udp_enabled', kw_only=True, fn=None),), id=False, terse=False"
    ", default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fAttachmentEnaSrdUdpSpecification(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ena_srd_udp_enabled=self.ena_srd_udp_enabled,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ena_srd_udp_enabled == other.ena_srd_udp_enabled
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'ena_srd_udp_enabled',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'ena_srd_udp_enabled',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ena_srd_udp_enabled,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ena_srd_udp_enabled: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ena_srd_udp_enabled', ena_srd_udp_enabled)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ena_srd_udp_enabled={self.ena_srd_udp_enabled!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('internet_gateway_block_mode',)), EqPlan(fields=('internet_gateway_block_mode',)), Fro"
    "zenPlan(fields=('__shape__', 'internet_gateway_block_mode'), allow_dynamic_dunder_attrs=False), HashPlan(action='a"
    "dd', fields=('internet_gateway_block_mode',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', anno"
    "tation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='internet_gateway_bl"
    "ock_mode', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default"
    "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
    "ne)), self_param='self', std_params=(), kw_only_params=('internet_gateway_block_mode',), frozen=True, slots=False,"
    " post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='internet_gateway_bloc"
    "k_mode', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fBlockPublicAccessStates(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            internet_gateway_block_mode=self.internet_gateway_block_mode,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.internet_gateway_block_mode == other.internet_gateway_block_mode
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'internet_gateway_block_mode',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'internet_gateway_block_mode',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.internet_gateway_block_mode,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        internet_gateway_block_mode: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'internet_gateway_block_mode', internet_gateway_block_mode)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"internet_gateway_block_mode={self.internet_gateway_block_mode!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('capacity_reservation_id', 'capacity_reservation_resource_group_arn')), EqPlan(fields="
    "('capacity_reservation_id', 'capacity_reservation_resource_group_arn')), FrozenPlan(fields=('__shape__', 'capacity"
    "_reservation_id', 'capacity_reservation_resource_group_arn'), allow_dynamic_dunder_attrs=False), HashPlan(action='"
    "add', fields=('capacity_reservation_id', 'capacity_reservation_resource_group_arn'), cache=False), InitPlan(fields"
    "=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factor"
    "y=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), I"
    "nitPlan.Field(name='capacity_reservation_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(nam"
    "e='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='capacity_reservation_resource_group_arn', annotation="
    "OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self"
    "', std_params=(), kw_only_params=('capacity_reservation_id', 'capacity_reservation_resource_group_arn'), frozen=Tr"
    "ue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='capac"
    "ity_reservation_id', kw_only=True, fn=None), ReprPlan.Field(name='capacity_reservation_resource_group_arn', kw_onl"
    "y=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fCapacityReservationTarget(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            capacity_reservation_id=self.capacity_reservation_id,
            capacity_reservation_resource_group_arn=self.capacity_reservation_resource_group_arn,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.capacity_reservation_id == other.capacity_reservation_id and
            self.capacity_reservation_resource_group_arn == other.capacity_reservation_resource_group_arn
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'capacity_reservation_id',
        'capacity_reservation_resource_group_arn',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'capacity_reservation_id',
        'capacity_reservation_resource_group_arn',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.capacity_reservation_id,
            self.capacity_reservation_resource_group_arn,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        capacity_reservation_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        capacity_reservation_resource_group_arn: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'capacity_reservation_id', capacity_reservation_id)
        __dataclass__object_setattr(self, 'capacity_reservation_resource_group_arn', capacity_reservation_resource_group_arn)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"capacity_reservation_id={self.capacity_reservation_id!r}")
        parts.append(f"capacity_reservation_resource_group_arn={self.capacity_reservation_resource_group_arn!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('capacity_reservation_id', 'capacity_reservation_resource_group_arn')), EqPlan(fields="
    "('capacity_reservation_id', 'capacity_reservation_resource_group_arn')), FrozenPlan(fields=('__shape__', 'capacity"
    "_reservation_id', 'capacity_reservation_resource_group_arn'), allow_dynamic_dunder_attrs=False), HashPlan(action='"
    "add', fields=('capacity_reservation_id', 'capacity_reservation_resource_group_arn'), cache=False), InitPlan(fields"
    "=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factor"
    "y=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), I"
    "nitPlan.Field(name='capacity_reservation_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(nam"
    "e='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='capacity_reservation_resource_group_arn', annotation="
    "OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self"
    "', std_params=(), kw_only_params=('capacity_reservation_id', 'capacity_reservation_resource_group_arn'), frozen=Tr"
    "ue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='capac"
    "ity_reservation_id', kw_only=True, fn=None), ReprPlan.Field(name='capacity_reservation_resource_group_arn', kw_onl"
    "y=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fCapacityReservationTargetResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            capacity_reservation_id=self.capacity_reservation_id,
            capacity_reservation_resource_group_arn=self.capacity_reservation_resource_group_arn,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.capacity_reservation_id == other.capacity_reservation_id and
            self.capacity_reservation_resource_group_arn == other.capacity_reservation_resource_group_arn
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'capacity_reservation_id',
        'capacity_reservation_resource_group_arn',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'capacity_reservation_id',
        'capacity_reservation_resource_group_arn',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.capacity_reservation_id,
            self.capacity_reservation_resource_group_arn,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        capacity_reservation_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        capacity_reservation_resource_group_arn: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'capacity_reservation_id', capacity_reservation_id)
        __dataclass__object_setattr(self, 'capacity_reservation_resource_group_arn', capacity_reservation_resource_group_arn)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"capacity_reservation_id={self.capacity_reservation_id!r}")
        parts.append(f"capacity_reservation_resource_group_arn={self.capacity_reservation_resource_group_arn!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('tcp_established_timeout', 'udp_stream_timeout', 'udp_timeout')), EqPlan(fields=('tcp_"
    "established_timeout', 'udp_stream_timeout', 'udp_timeout')), FrozenPlan(fields=('__shape__', 'tcp_established_time"
    "out', 'udp_stream_timeout', 'udp_timeout'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('tcp"
    "_established_timeout', 'udp_stream_timeout', 'udp_timeout'), cache=False), InitPlan(fields=(InitPlan.Field(name='_"
    "_shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tcp_"
    "established_timeout', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default"
    "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None), InitPlan.Field(name='udp_stream_timeout', annotation=OpRef(name='init.fields.2.annotation'), defau"
    "lt=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
    "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='udp_timeout', annotation=OpRef(name='init"
    ".fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=()"
    ", kw_only_params=('tcp_established_timeout', 'udp_stream_timeout', 'udp_timeout'), frozen=True, slots=False, post_"
    "init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='tcp_established_timeout', k"
    "w_only=True, fn=None), ReprPlan.Field(name='udp_stream_timeout', kw_only=True, fn=None), ReprPlan.Field(name='udp_"
    "timeout', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fConnectionTrackingConfiguration(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            tcp_established_timeout=self.tcp_established_timeout,
            udp_stream_timeout=self.udp_stream_timeout,
            udp_timeout=self.udp_timeout,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.tcp_established_timeout == other.tcp_established_timeout and
            self.udp_stream_timeout == other.udp_stream_timeout and
            self.udp_timeout == other.udp_timeout
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'tcp_established_timeout',
        'udp_stream_timeout',
        'udp_timeout',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'tcp_established_timeout',
        'udp_stream_timeout',
        'udp_timeout',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.tcp_established_timeout,
            self.udp_stream_timeout,
            self.udp_timeout,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        tcp_established_timeout: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        udp_stream_timeout: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        udp_timeout: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'tcp_established_timeout', tcp_established_timeout)
        __dataclass__object_setattr(self, 'udp_stream_timeout', udp_stream_timeout)
        __dataclass__object_setattr(self, 'udp_timeout', udp_timeout)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"tcp_established_timeout={self.tcp_established_timeout!r}")
        parts.append(f"udp_stream_timeout={self.udp_stream_timeout!r}")
        parts.append(f"udp_timeout={self.udp_timeout!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('tcp_established_timeout', 'udp_stream_timeout', 'udp_timeout')), EqPlan(fields=('tcp_"
    "established_timeout', 'udp_stream_timeout', 'udp_timeout')), FrozenPlan(fields=('__shape__', 'tcp_established_time"
    "out', 'udp_stream_timeout', 'udp_timeout'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('tcp"
    "_established_timeout', 'udp_stream_timeout', 'udp_timeout'), cache=False), InitPlan(fields=(InitPlan.Field(name='_"
    "_shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tcp_"
    "established_timeout', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default"
    "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None), InitPlan.Field(name='udp_stream_timeout', annotation=OpRef(name='init.fields.2.annotation'), defau"
    "lt=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
    "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='udp_timeout', annotation=OpRef(name='init"
    ".fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=()"
    ", kw_only_params=('tcp_established_timeout', 'udp_stream_timeout', 'udp_timeout'), frozen=True, slots=False, post_"
    "init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='tcp_established_timeout', k"
    "w_only=True, fn=None), ReprPlan.Field(name='udp_stream_timeout', kw_only=True, fn=None), ReprPlan.Field(name='udp_"
    "timeout', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fConnectionTrackingSpecificationRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            tcp_established_timeout=self.tcp_established_timeout,
            udp_stream_timeout=self.udp_stream_timeout,
            udp_timeout=self.udp_timeout,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.tcp_established_timeout == other.tcp_established_timeout and
            self.udp_stream_timeout == other.udp_stream_timeout and
            self.udp_timeout == other.udp_timeout
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'tcp_established_timeout',
        'udp_stream_timeout',
        'udp_timeout',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'tcp_established_timeout',
        'udp_stream_timeout',
        'udp_timeout',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.tcp_established_timeout,
            self.udp_stream_timeout,
            self.udp_timeout,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        tcp_established_timeout: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        udp_stream_timeout: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        udp_timeout: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'tcp_established_timeout', tcp_established_timeout)
        __dataclass__object_setattr(self, 'udp_stream_timeout', udp_stream_timeout)
        __dataclass__object_setattr(self, 'udp_timeout', udp_timeout)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"tcp_established_timeout={self.tcp_established_timeout!r}")
        parts.append(f"udp_stream_timeout={self.udp_stream_timeout!r}")
        parts.append(f"udp_timeout={self.udp_timeout!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('tcp_established_timeout', 'udp_stream_timeout', 'udp_timeout')), EqPlan(fields=('tcp_"
    "established_timeout', 'udp_stream_timeout', 'udp_timeout')), FrozenPlan(fields=('__shape__', 'tcp_established_time"
    "out', 'udp_stream_timeout', 'udp_timeout'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('tcp"
    "_established_timeout', 'udp_stream_timeout', 'udp_timeout'), cache=False), InitPlan(fields=(InitPlan.Field(name='_"
    "_shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tcp_"
    "established_timeout', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default"
    "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None), InitPlan.Field(name='udp_stream_timeout', annotation=OpRef(name='init.fields.2.annotation'), defau"
    "lt=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
    "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='udp_timeout', annotation=OpRef(name='init"
    ".fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=()"
    ", kw_only_params=('tcp_established_timeout', 'udp_stream_timeout', 'udp_timeout'), frozen=True, slots=False, post_"
    "init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='tcp_established_timeout', k"
    "w_only=True, fn=None), ReprPlan.Field(name='udp_stream_timeout', kw_only=True, fn=None), ReprPlan.Field(name='udp_"
    "timeout', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fConnectionTrackingSpecificationResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            tcp_established_timeout=self.tcp_established_timeout,
            udp_stream_timeout=self.udp_stream_timeout,
            udp_timeout=self.udp_timeout,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.tcp_established_timeout == other.tcp_established_timeout and
            self.udp_stream_timeout == other.udp_stream_timeout and
            self.udp_timeout == other.udp_timeout
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'tcp_established_timeout',
        'udp_stream_timeout',
        'udp_timeout',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'tcp_established_timeout',
        'udp_stream_timeout',
        'udp_timeout',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.tcp_established_timeout,
            self.udp_stream_timeout,
            self.udp_timeout,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        tcp_established_timeout: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        udp_stream_timeout: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        udp_timeout: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'tcp_established_timeout', tcp_established_timeout)
        __dataclass__object_setattr(self, 'udp_stream_timeout', udp_stream_timeout)
        __dataclass__object_setattr(self, 'udp_timeout', udp_timeout)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"tcp_established_timeout={self.tcp_established_timeout!r}")
        parts.append(f"udp_stream_timeout={self.udp_stream_timeout!r}")
        parts.append(f"udp_timeout={self.udp_timeout!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('core_count', 'threads_per_core', 'amd_sev_snp')), EqPlan(fields=('core_count', 'threa"
    "ds_per_core', 'amd_sev_snp')), FrozenPlan(fields=('__shape__', 'core_count', 'threads_per_core', 'amd_sev_snp'), a"
    "llow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('core_count', 'threads_per_core', 'amd_sev_snp'),"
    " cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation')"
    ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, vali"
    "date=None, check_type=None), InitPlan.Field(name='core_count', annotation=OpRef(name='init.fields.1.annotation'), "
    "default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType"
    ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='threads_per_core', annotation=OpRef("
    "name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, ov"
    "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='am"
    "d_sev_snp', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one)), self_param='self', std_params=(), kw_only_params=('core_count', 'threads_per_core', 'amd_sev_snp'), frozen="
    "True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='cor"
    "e_count', kw_only=True, fn=None), ReprPlan.Field(name='threads_per_core', kw_only=True, fn=None), ReprPlan.Field(n"
    "ame='amd_sev_snp', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fCpuOptions(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            core_count=self.core_count,
            threads_per_core=self.threads_per_core,
            amd_sev_snp=self.amd_sev_snp,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.core_count == other.core_count and
            self.threads_per_core == other.threads_per_core and
            self.amd_sev_snp == other.amd_sev_snp
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'core_count',
        'threads_per_core',
        'amd_sev_snp',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'core_count',
        'threads_per_core',
        'amd_sev_snp',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.core_count,
            self.threads_per_core,
            self.amd_sev_snp,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        core_count: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        threads_per_core: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        amd_sev_snp: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'core_count', core_count)
        __dataclass__object_setattr(self, 'threads_per_core', threads_per_core)
        __dataclass__object_setattr(self, 'amd_sev_snp', amd_sev_snp)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"core_count={self.core_count!r}")
        parts.append(f"threads_per_core={self.threads_per_core!r}")
        parts.append(f"amd_sev_snp={self.amd_sev_snp!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('core_count', 'threads_per_core', 'amd_sev_snp')), EqPlan(fields=('core_count', 'threa"
    "ds_per_core', 'amd_sev_snp')), FrozenPlan(fields=('__shape__', 'core_count', 'threads_per_core', 'amd_sev_snp'), a"
    "llow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('core_count', 'threads_per_core', 'amd_sev_snp'),"
    " cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation')"
    ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, vali"
    "date=None, check_type=None), InitPlan.Field(name='core_count', annotation=OpRef(name='init.fields.1.annotation'), "
    "default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType"
    ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='threads_per_core', annotation=OpRef("
    "name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, ov"
    "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='am"
    "d_sev_snp', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one)), self_param='self', std_params=(), kw_only_params=('core_count', 'threads_per_core', 'amd_sev_snp'), frozen="
    "True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='cor"
    "e_count', kw_only=True, fn=None), ReprPlan.Field(name='threads_per_core', kw_only=True, fn=None), ReprPlan.Field(n"
    "ame='amd_sev_snp', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fCpuOptionsRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            core_count=self.core_count,
            threads_per_core=self.threads_per_core,
            amd_sev_snp=self.amd_sev_snp,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.core_count == other.core_count and
            self.threads_per_core == other.threads_per_core and
            self.amd_sev_snp == other.amd_sev_snp
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'core_count',
        'threads_per_core',
        'amd_sev_snp',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'core_count',
        'threads_per_core',
        'amd_sev_snp',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.core_count,
            self.threads_per_core,
            self.amd_sev_snp,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        core_count: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        threads_per_core: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        amd_sev_snp: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'core_count', core_count)
        __dataclass__object_setattr(self, 'threads_per_core', threads_per_core)
        __dataclass__object_setattr(self, 'amd_sev_snp', amd_sev_snp)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"core_count={self.core_count!r}")
        parts.append(f"threads_per_core={self.threads_per_core!r}")
        parts.append(f"amd_sev_snp={self.amd_sev_snp!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('destination_prefix_list_id', 'vpc_endpoint_id', 'transit_gateway_id', 'local_gateway_"
    "id', 'carrier_gateway_id', 'core_network_arn', 'odb_network_arn', 'dry_run', 'route_table_id', 'destination_cidr_b"
    "lock', 'gateway_id', 'destination_ipv6_cidr_block', 'egress_only_internet_gateway_id', 'instance_id', 'network_int"
    "erface_id', 'vpc_peering_connection_id', 'nat_gateway_id')), EqPlan(fields=('destination_prefix_list_id', 'vpc_end"
    "point_id', 'transit_gateway_id', 'local_gateway_id', 'carrier_gateway_id', 'core_network_arn', 'odb_network_arn', "
    "'dry_run', 'route_table_id', 'destination_cidr_block', 'gateway_id', 'destination_ipv6_cidr_block', 'egress_only_i"
    "nternet_gateway_id', 'instance_id', 'network_interface_id', 'vpc_peering_connection_id', 'nat_gateway_id')), Froze"
    "nPlan(fields=('__shape__', 'destination_prefix_list_id', 'vpc_endpoint_id', 'transit_gateway_id', 'local_gateway_i"
    "d', 'carrier_gateway_id', 'core_network_arn', 'odb_network_arn', 'dry_run', 'route_table_id', 'destination_cidr_bl"
    "ock', 'gateway_id', 'destination_ipv6_cidr_block', 'egress_only_internet_gateway_id', 'instance_id', 'network_inte"
    "rface_id', 'vpc_peering_connection_id', 'nat_gateway_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add"
    "', fields=('destination_prefix_list_id', 'vpc_endpoint_id', 'transit_gateway_id', 'local_gateway_id', 'carrier_gat"
    "eway_id', 'core_network_arn', 'odb_network_arn', 'dry_run', 'route_table_id', 'destination_cidr_block', 'gateway_i"
    "d', 'destination_ipv6_cidr_block', 'egress_only_internet_gateway_id', 'instance_id', 'network_interface_id', 'vpc_"
    "peering_connection_id', 'nat_gateway_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotat"
    "ion=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='destination_prefix_lis"
    "t_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='vpc_endpoint_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='ini"
    "t.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None), InitPlan.Field(name='transit_gateway_id', annotation=OpRef(name='init.fields.3.a"
    "nnotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='local_gateway_id', anno"
    "tation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
    "ield(name='carrier_gateway_id', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields"
    ".5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None), InitPlan.Field(name='core_network_arn', annotation=OpRef(name='init.fields.6.annotation'"
    "), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='odb_network_arn', annotation=OpRe"
    "f(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "dry_run', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e), InitPlan.Field(name='route_table_id', annotation=OpRef(name='init.fields.9.annotation'), default=None, default"
    "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
    "ne), InitPlan.Field(name='destination_cidr_block', annotation=OpRef(name='init.fields.10.annotation'), default=OpR"
    "ef(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='gateway_id', annotation=OpRef(name='init.field"
    "s.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='destination_ipv6"
    "_cidr_block', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), de"
    "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='egress_only_internet_gateway_id', annotation=OpRef(name='init.fields.13.annotation'"
    "), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_id', annotation=OpRef(n"
    "ame='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='n"
    "etwork_interface_id', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.defau"
    "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
    "check_type=None), InitPlan.Field(name='vpc_peering_connection_id', annotation=OpRef(name='init.fields.16.annotatio"
    "n'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='nat_gateway_id', annotation=Op"
    "Ref(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self"
    "', std_params=(), kw_only_params=('destination_prefix_list_id', 'vpc_endpoint_id', 'transit_gateway_id', 'local_ga"
    "teway_id', 'carrier_gateway_id', 'core_network_arn', 'odb_network_arn', 'dry_run', 'route_table_id', 'destination_"
    "cidr_block', 'gateway_id', 'destination_ipv6_cidr_block', 'egress_only_internet_gateway_id', 'instance_id', 'netwo"
    "rk_interface_id', 'vpc_peering_connection_id', 'nat_gateway_id'), frozen=True, slots=False, post_init_params=None,"
    " init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='destination_prefix_list_id', kw_only=True, f"
    "n=None), ReprPlan.Field(name='vpc_endpoint_id', kw_only=True, fn=None), ReprPlan.Field(name='transit_gateway_id', "
    "kw_only=True, fn=None), ReprPlan.Field(name='local_gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='carri"
    "er_gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='core_network_arn', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='odb_network_arn', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPl"
    "an.Field(name='route_table_id', kw_only=True, fn=None), ReprPlan.Field(name='destination_cidr_block', kw_only=True"
    ", fn=None), ReprPlan.Field(name='gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='destination_ipv6_cidr_b"
    "lock', kw_only=True, fn=None), ReprPlan.Field(name='egress_only_internet_gateway_id', kw_only=True, fn=None), Repr"
    "Plan.Field(name='instance_id', kw_only=True, fn=None), ReprPlan.Field(name='network_interface_id', kw_only=True, f"
    "n=None), ReprPlan.Field(name='vpc_peering_connection_id', kw_only=True, fn=None), ReprPlan.Field(name='nat_gateway"
    "_id', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fCreateRouteRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            destination_prefix_list_id=self.destination_prefix_list_id,
            vpc_endpoint_id=self.vpc_endpoint_id,
            transit_gateway_id=self.transit_gateway_id,
            local_gateway_id=self.local_gateway_id,
            carrier_gateway_id=self.carrier_gateway_id,
            core_network_arn=self.core_network_arn,
            odb_network_arn=self.odb_network_arn,
            dry_run=self.dry_run,
            route_table_id=self.route_table_id,
            destination_cidr_block=self.destination_cidr_block,
            gateway_id=self.gateway_id,
            destination_ipv6_cidr_block=self.destination_ipv6_cidr_block,
            egress_only_internet_gateway_id=self.egress_only_internet_gateway_id,
            instance_id=self.instance_id,
            network_interface_id=self.network_interface_id,
            vpc_peering_connection_id=self.vpc_peering_connection_id,
            nat_gateway_id=self.nat_gateway_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.destination_prefix_list_id == other.destination_prefix_list_id and
            self.vpc_endpoint_id == other.vpc_endpoint_id and
            self.transit_gateway_id == other.transit_gateway_id and
            self.local_gateway_id == other.local_gateway_id and
            self.carrier_gateway_id == other.carrier_gateway_id and
            self.core_network_arn == other.core_network_arn and
            self.odb_network_arn == other.odb_network_arn and
            self.dry_run == other.dry_run and
            self.route_table_id == other.route_table_id and
            self.destination_cidr_block == other.destination_cidr_block and
            self.gateway_id == other.gateway_id and
            self.destination_ipv6_cidr_block == other.destination_ipv6_cidr_block and
            self.egress_only_internet_gateway_id == other.egress_only_internet_gateway_id and
            self.instance_id == other.instance_id and
            self.network_interface_id == other.network_interface_id and
            self.vpc_peering_connection_id == other.vpc_peering_connection_id and
            self.nat_gateway_id == other.nat_gateway_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'destination_prefix_list_id',
        'vpc_endpoint_id',
        'transit_gateway_id',
        'local_gateway_id',
        'carrier_gateway_id',
        'core_network_arn',
        'odb_network_arn',
        'dry_run',
        'route_table_id',
        'destination_cidr_block',
        'gateway_id',
        'destination_ipv6_cidr_block',
        'egress_only_internet_gateway_id',
        'instance_id',
        'network_interface_id',
        'vpc_peering_connection_id',
        'nat_gateway_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'destination_prefix_list_id',
        'vpc_endpoint_id',
        'transit_gateway_id',
        'local_gateway_id',
        'carrier_gateway_id',
        'core_network_arn',
        'odb_network_arn',
        'dry_run',
        'route_table_id',
        'destination_cidr_block',
        'gateway_id',
        'destination_ipv6_cidr_block',
        'egress_only_internet_gateway_id',
        'instance_id',
        'network_interface_id',
        'vpc_peering_connection_id',
        'nat_gateway_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.destination_prefix_list_id,
            self.vpc_endpoint_id,
            self.transit_gateway_id,
            self.local_gateway_id,
            self.carrier_gateway_id,
            self.core_network_arn,
            self.odb_network_arn,
            self.dry_run,
            self.route_table_id,
            self.destination_cidr_block,
            self.gateway_id,
            self.destination_ipv6_cidr_block,
            self.egress_only_internet_gateway_id,
            self.instance_id,
            self.network_interface_id,
            self.vpc_peering_connection_id,
            self.nat_gateway_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        destination_prefix_list_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        vpc_endpoint_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        transit_gateway_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        local_gateway_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        carrier_gateway_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        core_network_arn: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        odb_network_arn: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        dry_run: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        route_table_id: __dataclass__init__fields__9__annotation,
        destination_cidr_block: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        gateway_id: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        destination_ipv6_cidr_block: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        egress_only_internet_gateway_id: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        instance_id: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        network_interface_id: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        vpc_peering_connection_id: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        nat_gateway_id: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'destination_prefix_list_id', destination_prefix_list_id)
        __dataclass__object_setattr(self, 'vpc_endpoint_id', vpc_endpoint_id)
        __dataclass__object_setattr(self, 'transit_gateway_id', transit_gateway_id)
        __dataclass__object_setattr(self, 'local_gateway_id', local_gateway_id)
        __dataclass__object_setattr(self, 'carrier_gateway_id', carrier_gateway_id)
        __dataclass__object_setattr(self, 'core_network_arn', core_network_arn)
        __dataclass__object_setattr(self, 'odb_network_arn', odb_network_arn)
        __dataclass__object_setattr(self, 'dry_run', dry_run)
        __dataclass__object_setattr(self, 'route_table_id', route_table_id)
        __dataclass__object_setattr(self, 'destination_cidr_block', destination_cidr_block)
        __dataclass__object_setattr(self, 'gateway_id', gateway_id)
        __dataclass__object_setattr(self, 'destination_ipv6_cidr_block', destination_ipv6_cidr_block)
        __dataclass__object_setattr(self, 'egress_only_internet_gateway_id', egress_only_internet_gateway_id)
        __dataclass__object_setattr(self, 'instance_id', instance_id)
        __dataclass__object_setattr(self, 'network_interface_id', network_interface_id)
        __dataclass__object_setattr(self, 'vpc_peering_connection_id', vpc_peering_connection_id)
        __dataclass__object_setattr(self, 'nat_gateway_id', nat_gateway_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"destination_prefix_list_id={self.destination_prefix_list_id!r}")
        parts.append(f"vpc_endpoint_id={self.vpc_endpoint_id!r}")
        parts.append(f"transit_gateway_id={self.transit_gateway_id!r}")
        parts.append(f"local_gateway_id={self.local_gateway_id!r}")
        parts.append(f"carrier_gateway_id={self.carrier_gateway_id!r}")
        parts.append(f"core_network_arn={self.core_network_arn!r}")
        parts.append(f"odb_network_arn={self.odb_network_arn!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        parts.append(f"route_table_id={self.route_table_id!r}")
        parts.append(f"destination_cidr_block={self.destination_cidr_block!r}")
        parts.append(f"gateway_id={self.gateway_id!r}")
        parts.append(f"destination_ipv6_cidr_block={self.destination_ipv6_cidr_block!r}")
        parts.append(f"egress_only_internet_gateway_id={self.egress_only_internet_gateway_id!r}")
        parts.append(f"instance_id={self.instance_id!r}")
        parts.append(f"network_interface_id={self.network_interface_id!r}")
        parts.append(f"vpc_peering_connection_id={self.vpc_peering_connection_id!r}")
        parts.append(f"nat_gateway_id={self.nat_gateway_id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('return_',)), EqPlan(fields=('return_',)), FrozenPlan(fields=('__shape__', 'return_'),"
    " allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('return_',), cache=False), InitPlan(fields=(Ini"
    "tPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='return_', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None)), self_param='self', std_params=(), kw_only_params=('return_',), frozen=True, slots=False, post_"
    "init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='return_', kw_only=True, fn="
    "None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fCreateRouteResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            return_=self.return_,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.return_ == other.return_
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'return_',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'return_',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.return_,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        return_: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'return_', return_)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"return_={self.return_!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('group_id', 'tags', 'security_group_arn')), EqPlan(fields=('group_id', 'tags', 'securi"
    "ty_group_arn')), FrozenPlan(fields=('__shape__', 'group_id', 'tags', 'security_group_arn'), allow_dynamic_dunder_a"
    "ttrs=False), HashPlan(action='add', fields=('group_id', 'tags', 'security_group_arn'), cache=False), InitPlan(fiel"
    "ds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='group_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.field"
    "s.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='init.fields.2.annotation'), default="
    "OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
    "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='security_group_arn', annotation=OpRef(name='"
    "init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_param"
    "s=(), kw_only_params=('group_id', 'tags', 'security_group_arn'), frozen=True, slots=False, post_init_params=None, "
    "init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='group_id', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='tags', kw_only=True, fn=None), ReprPlan.Field(name='security_group_arn', kw_only=True, fn=None)), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fCreateSecurityGroupResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            group_id=self.group_id,
            tags=self.tags,
            security_group_arn=self.security_group_arn,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.group_id == other.group_id and
            self.tags == other.tags and
            self.security_group_arn == other.security_group_arn
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'group_id',
        'tags',
        'security_group_arn',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'group_id',
        'tags',
        'security_group_arn',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.group_id,
            self.tags,
            self.security_group_arn,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        group_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        tags: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        security_group_arn: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'group_id', group_id)
        __dataclass__object_setattr(self, 'tags', tags)
        __dataclass__object_setattr(self, 'security_group_arn', security_group_arn)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"group_id={self.group_id!r}")
        parts.append(f"tags={self.tags!r}")
        parts.append(f"security_group_arn={self.security_group_arn!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('cpu_credits',)), EqPlan(fields=('cpu_credits',)), FrozenPlan(fields=('__shape__', 'cp"
    "u_credits'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('cpu_credits',), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='cpu_credits', annotation=OpRef(name='init.fields.1.annotation'), default=None, defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None)), self_param='self', std_params=(), kw_only_params=('cpu_credits',), frozen=True, slots=False, post_init_pa"
    "rams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='cpu_credits', kw_only=True, fn=Non"
    "e),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fCreditSpecificationRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            cpu_credits=self.cpu_credits,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.cpu_credits == other.cpu_credits
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'cpu_credits',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'cpu_credits',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.cpu_credits,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        cpu_credits: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'cpu_credits', cpu_credits)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"cpu_credits={self.cpu_credits!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('destination_prefix_list_id', 'dry_run', 'route_table_id', 'destination_cidr_block', '"
    "destination_ipv6_cidr_block')), EqPlan(fields=('destination_prefix_list_id', 'dry_run', 'route_table_id', 'destina"
    "tion_cidr_block', 'destination_ipv6_cidr_block')), FrozenPlan(fields=('__shape__', 'destination_prefix_list_id', '"
    "dry_run', 'route_table_id', 'destination_cidr_block', 'destination_ipv6_cidr_block'), allow_dynamic_dunder_attrs=F"
    "alse), HashPlan(action='add', fields=('destination_prefix_list_id', 'dry_run', 'route_table_id', 'destination_cidr"
    "_block', 'destination_ipv6_cidr_block'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotatio"
    "n=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='destination_prefix_list_"
    "id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_facto"
    "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
    "nitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2"
    ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None), InitPlan.Field(name='route_table_id', annotation=OpRef(name='init.fields.3.annotation'), d"
    "efault=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='destination_cidr_block', annotation=OpRef(name='init.fields.4.annota"
    "tion'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=F"
    "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='destination_ipv6_cidr_block'"
    ", annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), sel"
    "f_param='self', std_params=(), kw_only_params=('destination_prefix_list_id', 'dry_run', 'route_table_id', 'destina"
    "tion_cidr_block', 'destination_ipv6_cidr_block'), frozen=True, slots=False, post_init_params=None, init_fns=(), va"
    "lidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='destination_prefix_list_id', kw_only=True, fn=None), ReprPla"
    "n.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='route_table_id', kw_only=True, fn=None), Repr"
    "Plan.Field(name='destination_cidr_block', kw_only=True, fn=None), ReprPlan.Field(name='destination_ipv6_cidr_block"
    "', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDeleteRouteRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            destination_prefix_list_id=self.destination_prefix_list_id,
            dry_run=self.dry_run,
            route_table_id=self.route_table_id,
            destination_cidr_block=self.destination_cidr_block,
            destination_ipv6_cidr_block=self.destination_ipv6_cidr_block,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.destination_prefix_list_id == other.destination_prefix_list_id and
            self.dry_run == other.dry_run and
            self.route_table_id == other.route_table_id and
            self.destination_cidr_block == other.destination_cidr_block and
            self.destination_ipv6_cidr_block == other.destination_ipv6_cidr_block
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'destination_prefix_list_id',
        'dry_run',
        'route_table_id',
        'destination_cidr_block',
        'destination_ipv6_cidr_block',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'destination_prefix_list_id',
        'dry_run',
        'route_table_id',
        'destination_cidr_block',
        'destination_ipv6_cidr_block',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.destination_prefix_list_id,
            self.dry_run,
            self.route_table_id,
            self.destination_cidr_block,
            self.destination_ipv6_cidr_block,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        destination_prefix_list_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        dry_run: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        route_table_id: __dataclass__init__fields__3__annotation,
        destination_cidr_block: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        destination_ipv6_cidr_block: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'destination_prefix_list_id', destination_prefix_list_id)
        __dataclass__object_setattr(self, 'dry_run', dry_run)
        __dataclass__object_setattr(self, 'route_table_id', route_table_id)
        __dataclass__object_setattr(self, 'destination_cidr_block', destination_cidr_block)
        __dataclass__object_setattr(self, 'destination_ipv6_cidr_block', destination_ipv6_cidr_block)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"destination_prefix_list_id={self.destination_prefix_list_id!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        parts.append(f"route_table_id={self.route_table_id!r}")
        parts.append(f"destination_cidr_block={self.destination_cidr_block!r}")
        parts.append(f"destination_ipv6_cidr_block={self.destination_ipv6_cidr_block!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('dry_run', 'route_table_id')), EqPlan(fields=('dry_run', 'route_table_id')), FrozenPla"
    "n(fields=('__shape__', 'dry_run', 'route_table_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fie"
    "lds=('dry_run', 'route_table_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRe"
    "f(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(nam"
    "e='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='route"
    "_table_id', annotation=OpRef(name='init.fields.2.annotation'), default=None, default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_p"
    "arams=(), kw_only_params=('dry_run', 'route_table_id'), frozen=True, slots=False, post_init_params=None, init_fns="
    "(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name="
    "'route_table_id', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDeleteRouteTableRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            dry_run=self.dry_run,
            route_table_id=self.route_table_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.dry_run == other.dry_run and
            self.route_table_id == other.route_table_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'dry_run',
        'route_table_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'dry_run',
        'route_table_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.dry_run,
            self.route_table_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        dry_run: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        route_table_id: __dataclass__init__fields__2__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'dry_run', dry_run)
        __dataclass__object_setattr(self, 'route_table_id', route_table_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"dry_run={self.dry_run!r}")
        parts.append(f"route_table_id={self.route_table_id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('group_id', 'group_name', 'dry_run')), EqPlan(fields=('group_id', 'group_name', 'dry_r"
    "un')), FrozenPlan(fields=('__shape__', 'group_id', 'group_name', 'dry_run'), allow_dynamic_dunder_attrs=False), Ha"
    "shPlan(action='add', fields=('group_id', 'group_name', 'dry_run'), cache=False), InitPlan(fields=(InitPlan.Field(n"
    "ame='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True,"
    " override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='group_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), defau"
    "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='group_name', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='in"
    "it.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
    ", validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.3.annotation'"
    "), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('gr"
    "oup_id', 'group_name', 'dry_run'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
    " ReprPlan(fields=(ReprPlan.Field(name='group_id', kw_only=True, fn=None), ReprPlan.Field(name='group_name', kw_onl"
    "y=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None)), id=False, terse=False, default_fn=None))"
    ")"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDeleteSecurityGroupRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            group_id=self.group_id,
            group_name=self.group_name,
            dry_run=self.dry_run,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.group_id == other.group_id and
            self.group_name == other.group_name and
            self.dry_run == other.dry_run
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'group_id',
        'group_name',
        'dry_run',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'group_id',
        'group_name',
        'dry_run',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.group_id,
            self.group_name,
            self.dry_run,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        group_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        group_name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        dry_run: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'group_id', group_id)
        __dataclass__object_setattr(self, 'group_name', group_name)
        __dataclass__object_setattr(self, 'dry_run', dry_run)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"group_id={self.group_id!r}")
        parts.append(f"group_name={self.group_name!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('return_', 'group_id')), EqPlan(fields=('return_', 'group_id')), FrozenPlan(fields=('_"
    "_shape__', 'return_', 'group_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('return_', 'g"
    "roup_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.an"
    "notation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='return_', annotation=OpRef(name='init.fields.1.annotat"
    "ion'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_id', annotation=OpRef(n"
    "ame='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_"
    "params=(), kw_only_params=('return_', 'group_id'), frozen=True, slots=False, post_init_params=None, init_fns=(), v"
    "alidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='return_', kw_only=True, fn=None), ReprPlan.Field(name='grou"
    "p_id', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDeleteSecurityGroupResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            return_=self.return_,
            group_id=self.group_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.return_ == other.return_ and
            self.group_id == other.group_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'return_',
        'group_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'return_',
        'group_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.return_,
            self.group_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        return_: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        group_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'return_', return_)
        __dataclass__object_setattr(self, 'group_id', group_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"return_={self.return_!r}")
        parts.append(f"group_id={self.group_id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('size_in_gb', 'count', 'type')), EqPlan(fields=('size_in_gb', 'count', 'type')), Froze"
    "nPlan(fields=('__shape__', 'size_in_gb', 'count', 'type'), allow_dynamic_dunder_attrs=False), HashPlan(action='add"
    "', fields=('size_in_gb', 'count', 'type'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotat"
    "ion=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='size_in_gb', annotatio"
    "n=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='count', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fi"
    "elds.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('size_in_gb', 'count', 'type'), f"
    "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
    "e='size_in_gb', kw_only=True, fn=None), ReprPlan.Field(name='count', kw_only=True, fn=None), ReprPlan.Field(name='"
    "type', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDiskInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            size_in_gb=self.size_in_gb,
            count=self.count,
            type=self.type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.size_in_gb == other.size_in_gb and
            self.count == other.count and
            self.type == other.type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'size_in_gb',
        'count',
        'type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'size_in_gb',
        'count',
        'type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.size_in_gb,
            self.count,
            self.type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        size_in_gb: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        count: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        type: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'size_in_gb', size_in_gb)
        __dataclass__object_setattr(self, 'count', count)
        __dataclass__object_setattr(self, 'type', type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"size_in_gb={self.size_in_gb!r}")
        parts.append(f"count={self.count!r}")
        parts.append(f"type={self.type!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('delete_on_termination', 'iops', 'snapshot_id', 'volume_size', 'volume_type', 'kms_key"
    "_id', 'throughput', 'outpost_arn', 'availability_zone', 'encrypted', 'volume_initialization_rate', 'availability_z"
    "one_id')), EqPlan(fields=('delete_on_termination', 'iops', 'snapshot_id', 'volume_size', 'volume_type', 'kms_key_i"
    "d', 'throughput', 'outpost_arn', 'availability_zone', 'encrypted', 'volume_initialization_rate', 'availability_zon"
    "e_id')), FrozenPlan(fields=('__shape__', 'delete_on_termination', 'iops', 'snapshot_id', 'volume_size', 'volume_ty"
    "pe', 'kms_key_id', 'throughput', 'outpost_arn', 'availability_zone', 'encrypted', 'volume_initialization_rate', 'a"
    "vailability_zone_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('delete_on_termination', "
    "'iops', 'snapshot_id', 'volume_size', 'volume_type', 'kms_key_id', 'throughput', 'outpost_arn', 'availability_zone"
    "', 'encrypted', 'volume_initialization_rate', 'availability_zone_id'), cache=False), InitPlan(fields=(InitPlan.Fie"
    "ld(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=T"
    "rue, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='delete_on_termination', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1"
    ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None), InitPlan.Field(name='iops', annotation=OpRef(name='init.fields.2.annotation'), default=OpR"
    "ef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None), InitPlan.Field(name='snapshot_id', annotation=OpRef(name='init.field"
    "s.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='volume_size', anno"
    "tation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
    "ield(name='volume_type', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='kms_key_id', annotation=OpRef(name='init.fields.6.annotation'), default=Op"
    "Ref(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='throughput', annotation=OpRef(name='init.field"
    "s.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='outpost_arn', anno"
    "tation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
    "ield(name='availability_zone', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields."
    "9.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='encrypted', annotation=OpRef(name='init.fields.10.annotation'), defa"
    "ult=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='volume_initialization_rate', annotation"
    "=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='availability_zone_id', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields."
    "12.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('delete_on_termination', 'iops', 'sna"
    "pshot_id', 'volume_size', 'volume_type', 'kms_key_id', 'throughput', 'outpost_arn', 'availability_zone', 'encrypte"
    "d', 'volume_initialization_rate', 'availability_zone_id'), frozen=True, slots=False, post_init_params=None, init_f"
    "ns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='delete_on_termination', kw_only=True, fn=None), Rep"
    "rPlan.Field(name='iops', kw_only=True, fn=None), ReprPlan.Field(name='snapshot_id', kw_only=True, fn=None), ReprPl"
    "an.Field(name='volume_size', kw_only=True, fn=None), ReprPlan.Field(name='volume_type', kw_only=True, fn=None), Re"
    "prPlan.Field(name='kms_key_id', kw_only=True, fn=None), ReprPlan.Field(name='throughput', kw_only=True, fn=None), "
    "ReprPlan.Field(name='outpost_arn', kw_only=True, fn=None), ReprPlan.Field(name='availability_zone', kw_only=True, "
    "fn=None), ReprPlan.Field(name='encrypted', kw_only=True, fn=None), ReprPlan.Field(name='volume_initialization_rate"
    "', kw_only=True, fn=None), ReprPlan.Field(name='availability_zone_id', kw_only=True, fn=None)), id=False, terse=Fa"
    "lse, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fEbsBlockDevice(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            delete_on_termination=self.delete_on_termination,
            iops=self.iops,
            snapshot_id=self.snapshot_id,
            volume_size=self.volume_size,
            volume_type=self.volume_type,
            kms_key_id=self.kms_key_id,
            throughput=self.throughput,
            outpost_arn=self.outpost_arn,
            availability_zone=self.availability_zone,
            encrypted=self.encrypted,
            volume_initialization_rate=self.volume_initialization_rate,
            availability_zone_id=self.availability_zone_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.delete_on_termination == other.delete_on_termination and
            self.iops == other.iops and
            self.snapshot_id == other.snapshot_id and
            self.volume_size == other.volume_size and
            self.volume_type == other.volume_type and
            self.kms_key_id == other.kms_key_id and
            self.throughput == other.throughput and
            self.outpost_arn == other.outpost_arn and
            self.availability_zone == other.availability_zone and
            self.encrypted == other.encrypted and
            self.volume_initialization_rate == other.volume_initialization_rate and
            self.availability_zone_id == other.availability_zone_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'delete_on_termination',
        'iops',
        'snapshot_id',
        'volume_size',
        'volume_type',
        'kms_key_id',
        'throughput',
        'outpost_arn',
        'availability_zone',
        'encrypted',
        'volume_initialization_rate',
        'availability_zone_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'delete_on_termination',
        'iops',
        'snapshot_id',
        'volume_size',
        'volume_type',
        'kms_key_id',
        'throughput',
        'outpost_arn',
        'availability_zone',
        'encrypted',
        'volume_initialization_rate',
        'availability_zone_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.delete_on_termination,
            self.iops,
            self.snapshot_id,
            self.volume_size,
            self.volume_type,
            self.kms_key_id,
            self.throughput,
            self.outpost_arn,
            self.availability_zone,
            self.encrypted,
            self.volume_initialization_rate,
            self.availability_zone_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        delete_on_termination: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        iops: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        snapshot_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        volume_size: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        volume_type: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        kms_key_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        throughput: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        outpost_arn: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        availability_zone: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        encrypted: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        volume_initialization_rate: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        availability_zone_id: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'delete_on_termination', delete_on_termination)
        __dataclass__object_setattr(self, 'iops', iops)
        __dataclass__object_setattr(self, 'snapshot_id', snapshot_id)
        __dataclass__object_setattr(self, 'volume_size', volume_size)
        __dataclass__object_setattr(self, 'volume_type', volume_type)
        __dataclass__object_setattr(self, 'kms_key_id', kms_key_id)
        __dataclass__object_setattr(self, 'throughput', throughput)
        __dataclass__object_setattr(self, 'outpost_arn', outpost_arn)
        __dataclass__object_setattr(self, 'availability_zone', availability_zone)
        __dataclass__object_setattr(self, 'encrypted', encrypted)
        __dataclass__object_setattr(self, 'volume_initialization_rate', volume_initialization_rate)
        __dataclass__object_setattr(self, 'availability_zone_id', availability_zone_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"delete_on_termination={self.delete_on_termination!r}")
        parts.append(f"iops={self.iops!r}")
        parts.append(f"snapshot_id={self.snapshot_id!r}")
        parts.append(f"volume_size={self.volume_size!r}")
        parts.append(f"volume_type={self.volume_type!r}")
        parts.append(f"kms_key_id={self.kms_key_id!r}")
        parts.append(f"throughput={self.throughput!r}")
        parts.append(f"outpost_arn={self.outpost_arn!r}")
        parts.append(f"availability_zone={self.availability_zone!r}")
        parts.append(f"encrypted={self.encrypted!r}")
        parts.append(f"volume_initialization_rate={self.volume_initialization_rate!r}")
        parts.append(f"availability_zone_id={self.availability_zone_id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('baseline_bandwidth_in_mbips', 'baseline_throughput_in_mbps', 'baseline_iops', 'maximu"
    "m_bandwidth_in_mbips', 'maximum_throughput_in_mbps', 'maximum_iops')), EqPlan(fields=('baseline_bandwidth_in_mbips"
    "', 'baseline_throughput_in_mbps', 'baseline_iops', 'maximum_bandwidth_in_mbips', 'maximum_throughput_in_mbps', 'ma"
    "ximum_iops')), FrozenPlan(fields=('__shape__', 'baseline_bandwidth_in_mbips', 'baseline_throughput_in_mbps', 'base"
    "line_iops', 'maximum_bandwidth_in_mbips', 'maximum_throughput_in_mbps', 'maximum_iops'), allow_dynamic_dunder_attr"
    "s=False), HashPlan(action='add', fields=('baseline_bandwidth_in_mbips', 'baseline_throughput_in_mbps', 'baseline_i"
    "ops', 'maximum_bandwidth_in_mbips', 'maximum_throughput_in_mbps', 'maximum_iops'), cache=False), InitPlan(fields=("
    "InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory="
    "None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), Ini"
    "tPlan.Field(name='baseline_bandwidth_in_mbips', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(n"
    "ame='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='baseline_throughput_in_mbps', annotation=OpRef(name"
    "='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, overri"
    "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='baseli"
    "ne_iops', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e), InitPlan.Field(name='maximum_bandwidth_in_mbips', annotation=OpRef(name='init.fields.4.annotation'), default=O"
    "pRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
    ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='maximum_throughput_in_mbps', annotation=OpRef"
    "(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='m"
    "aximum_iops', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None)), self_param='self', std_params=(), kw_only_params=('baseline_bandwidth_in_mbips', 'baseline_throughput_in_"
    "mbps', 'baseline_iops', 'maximum_bandwidth_in_mbips', 'maximum_throughput_in_mbps', 'maximum_iops'), frozen=True, "
    "slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='baseline_"
    "bandwidth_in_mbips', kw_only=True, fn=None), ReprPlan.Field(name='baseline_throughput_in_mbps', kw_only=True, fn=N"
    "one), ReprPlan.Field(name='baseline_iops', kw_only=True, fn=None), ReprPlan.Field(name='maximum_bandwidth_in_mbips"
    "', kw_only=True, fn=None), ReprPlan.Field(name='maximum_throughput_in_mbps', kw_only=True, fn=None), ReprPlan.Fiel"
    "d(name='maximum_iops', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fEbsOptimizedInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            baseline_bandwidth_in_mbips=self.baseline_bandwidth_in_mbips,
            baseline_throughput_in_mbps=self.baseline_throughput_in_mbps,
            baseline_iops=self.baseline_iops,
            maximum_bandwidth_in_mbips=self.maximum_bandwidth_in_mbips,
            maximum_throughput_in_mbps=self.maximum_throughput_in_mbps,
            maximum_iops=self.maximum_iops,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.baseline_bandwidth_in_mbips == other.baseline_bandwidth_in_mbips and
            self.baseline_throughput_in_mbps == other.baseline_throughput_in_mbps and
            self.baseline_iops == other.baseline_iops and
            self.maximum_bandwidth_in_mbips == other.maximum_bandwidth_in_mbips and
            self.maximum_throughput_in_mbps == other.maximum_throughput_in_mbps and
            self.maximum_iops == other.maximum_iops
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'baseline_bandwidth_in_mbips',
        'baseline_throughput_in_mbps',
        'baseline_iops',
        'maximum_bandwidth_in_mbips',
        'maximum_throughput_in_mbps',
        'maximum_iops',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'baseline_bandwidth_in_mbips',
        'baseline_throughput_in_mbps',
        'baseline_iops',
        'maximum_bandwidth_in_mbips',
        'maximum_throughput_in_mbps',
        'maximum_iops',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.baseline_bandwidth_in_mbips,
            self.baseline_throughput_in_mbps,
            self.baseline_iops,
            self.maximum_bandwidth_in_mbips,
            self.maximum_throughput_in_mbps,
            self.maximum_iops,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        baseline_bandwidth_in_mbips: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        baseline_throughput_in_mbps: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        baseline_iops: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        maximum_bandwidth_in_mbips: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        maximum_throughput_in_mbps: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        maximum_iops: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'baseline_bandwidth_in_mbips', baseline_bandwidth_in_mbips)
        __dataclass__object_setattr(self, 'baseline_throughput_in_mbps', baseline_throughput_in_mbps)
        __dataclass__object_setattr(self, 'baseline_iops', baseline_iops)
        __dataclass__object_setattr(self, 'maximum_bandwidth_in_mbips', maximum_bandwidth_in_mbips)
        __dataclass__object_setattr(self, 'maximum_throughput_in_mbps', maximum_throughput_in_mbps)
        __dataclass__object_setattr(self, 'maximum_iops', maximum_iops)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"baseline_bandwidth_in_mbips={self.baseline_bandwidth_in_mbips!r}")
        parts.append(f"baseline_throughput_in_mbps={self.baseline_throughput_in_mbps!r}")
        parts.append(f"baseline_iops={self.baseline_iops!r}")
        parts.append(f"maximum_bandwidth_in_mbips={self.maximum_bandwidth_in_mbips!r}")
        parts.append(f"maximum_throughput_in_mbps={self.maximum_throughput_in_mbps!r}")
        parts.append(f"maximum_iops={self.maximum_iops!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('maximum_efa_interfaces',)), EqPlan(fields=('maximum_efa_interfaces',)), FrozenPlan(fi"
    "elds=('__shape__', 'maximum_efa_interfaces'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('m"
    "aximum_efa_interfaces',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='i"
    "nit.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLA"
    "SS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maximum_efa_interfaces', annotation=OpR"
    "ef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True,"
    " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', "
    "std_params=(), kw_only_params=('maximum_efa_interfaces',), frozen=True, slots=False, post_init_params=None, init_f"
    "ns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='maximum_efa_interfaces', kw_only=True, fn=None),), "
    "id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fEfaInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            maximum_efa_interfaces=self.maximum_efa_interfaces,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.maximum_efa_interfaces == other.maximum_efa_interfaces
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'maximum_efa_interfaces',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'maximum_efa_interfaces',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.maximum_efa_interfaces,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        maximum_efa_interfaces: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'maximum_efa_interfaces', maximum_efa_interfaces)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"maximum_efa_interfaces={self.maximum_efa_interfaces!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('elastic_gpu_id', 'elastic_gpu_association_id', 'elastic_gpu_association_state', 'elas"
    "tic_gpu_association_time')), EqPlan(fields=('elastic_gpu_id', 'elastic_gpu_association_id', 'elastic_gpu_associati"
    "on_state', 'elastic_gpu_association_time')), FrozenPlan(fields=('__shape__', 'elastic_gpu_id', 'elastic_gpu_associ"
    "ation_id', 'elastic_gpu_association_state', 'elastic_gpu_association_time'), allow_dynamic_dunder_attrs=False), Ha"
    "shPlan(action='add', fields=('elastic_gpu_id', 'elastic_gpu_association_id', 'elastic_gpu_association_state', 'ela"
    "stic_gpu_association_time'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name"
    "='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType."
    "CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='elastic_gpu_id', annotation=OpRef(na"
    "me='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='elas"
    "tic_gpu_association_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='elastic_gpu_association_state', annotation=OpRef(name='init.fields.3.annot"
    "ation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type="
    "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='elastic_gpu_association_tim"
    "e', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factor"
    "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), s"
    "elf_param='self', std_params=(), kw_only_params=('elastic_gpu_id', 'elastic_gpu_association_id', 'elastic_gpu_asso"
    "ciation_state', 'elastic_gpu_association_time'), frozen=True, slots=False, post_init_params=None, init_fns=(), val"
    "idate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='elastic_gpu_id', kw_only=True, fn=None), ReprPlan.Field(name="
    "'elastic_gpu_association_id', kw_only=True, fn=None), ReprPlan.Field(name='elastic_gpu_association_state', kw_only"
    "=True, fn=None), ReprPlan.Field(name='elastic_gpu_association_time', kw_only=True, fn=None)), id=False, terse=Fals"
    "e, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fElasticGpuAssociation(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            elastic_gpu_id=self.elastic_gpu_id,
            elastic_gpu_association_id=self.elastic_gpu_association_id,
            elastic_gpu_association_state=self.elastic_gpu_association_state,
            elastic_gpu_association_time=self.elastic_gpu_association_time,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.elastic_gpu_id == other.elastic_gpu_id and
            self.elastic_gpu_association_id == other.elastic_gpu_association_id and
            self.elastic_gpu_association_state == other.elastic_gpu_association_state and
            self.elastic_gpu_association_time == other.elastic_gpu_association_time
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'elastic_gpu_id',
        'elastic_gpu_association_id',
        'elastic_gpu_association_state',
        'elastic_gpu_association_time',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'elastic_gpu_id',
        'elastic_gpu_association_id',
        'elastic_gpu_association_state',
        'elastic_gpu_association_time',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.elastic_gpu_id,
            self.elastic_gpu_association_id,
            self.elastic_gpu_association_state,
            self.elastic_gpu_association_time,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        elastic_gpu_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        elastic_gpu_association_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        elastic_gpu_association_state: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        elastic_gpu_association_time: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'elastic_gpu_id', elastic_gpu_id)
        __dataclass__object_setattr(self, 'elastic_gpu_association_id', elastic_gpu_association_id)
        __dataclass__object_setattr(self, 'elastic_gpu_association_state', elastic_gpu_association_state)
        __dataclass__object_setattr(self, 'elastic_gpu_association_time', elastic_gpu_association_time)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"elastic_gpu_id={self.elastic_gpu_id!r}")
        parts.append(f"elastic_gpu_association_id={self.elastic_gpu_association_id!r}")
        parts.append(f"elastic_gpu_association_state={self.elastic_gpu_association_state!r}")
        parts.append(f"elastic_gpu_association_time={self.elastic_gpu_association_time!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('type',)), EqPlan(fields=('type',)), FrozenPlan(fields=('__shape__', 'type'), allow_dy"
    "namic_dunder_attrs=False), HashPlan(action='add', fields=('type',), cache=False), InitPlan(fields=(InitPlan.Field("
    "name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True"
    ", override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
    "e='type', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, overri"
    "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_par"
    "ams=(), kw_only_params=('type',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), "
    "ReprPlan(fields=(ReprPlan.Field(name='type', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fElasticGpuSpecification(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            type=self.type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.type == other.type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        type: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'type', type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"type={self.type!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('type', 'count')), EqPlan(fields=('type', 'count')), FrozenPlan(fields=('__shape__', '"
    "type', 'count'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('type', 'count'), cache=False),"
    " InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None"
    ", default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, che"
    "ck_type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.1.annotation'), default=None, defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='count', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fie"
    "lds.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('type', 'count'), frozen=True, slo"
    "ts=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='type', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='count', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fElasticInferenceAccelerator(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            type=self.type,
            count=self.count,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.type == other.type and
            self.count == other.count
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'type',
        'count',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'type',
        'count',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.type,
            self.count,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        type: __dataclass__init__fields__1__annotation,
        count: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'type', type)
        __dataclass__object_setattr(self, 'count', count)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"type={self.type!r}")
        parts.append(f"count={self.count!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('elastic_inference_accelerator_arn', 'elastic_inference_accelerator_association_id', '"
    "elastic_inference_accelerator_association_state', 'elastic_inference_accelerator_association_time')), EqPlan(field"
    "s=('elastic_inference_accelerator_arn', 'elastic_inference_accelerator_association_id', 'elastic_inference_acceler"
    "ator_association_state', 'elastic_inference_accelerator_association_time')), FrozenPlan(fields=('__shape__', 'elas"
    "tic_inference_accelerator_arn', 'elastic_inference_accelerator_association_id', 'elastic_inference_accelerator_ass"
    "ociation_state', 'elastic_inference_accelerator_association_time'), allow_dynamic_dunder_attrs=False), HashPlan(ac"
    "tion='add', fields=('elastic_inference_accelerator_arn', 'elastic_inference_accelerator_association_id', 'elastic_"
    "inference_accelerator_association_state', 'elastic_inference_accelerator_association_time'), cache=False), InitPla"
    "n(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='elastic_inference_accelerator_arn', annotation=OpRef(name='init.fields.1.annotation'),"
    " default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='elastic_inference_accelerator_assoc"
    "iation_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='elastic_inference_accelerator_association_state', annotation=OpRef(name='init.fields.3."
    "annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='elastic_inference_acce"
    "lerator_association_time', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None)), self_param='self', std_params=(), kw_only_params=('elastic_inference_accelerator_arn', 'elas"
    "tic_inference_accelerator_association_id', 'elastic_inference_accelerator_association_state', 'elastic_inference_a"
    "ccelerator_association_time'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Rep"
    "rPlan(fields=(ReprPlan.Field(name='elastic_inference_accelerator_arn', kw_only=True, fn=None), ReprPlan.Field(name"
    "='elastic_inference_accelerator_association_id', kw_only=True, fn=None), ReprPlan.Field(name='elastic_inference_ac"
    "celerator_association_state', kw_only=True, fn=None), ReprPlan.Field(name='elastic_inference_accelerator_associati"
    "on_time', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fElasticInferenceAcceleratorAssociation(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            elastic_inference_accelerator_arn=self.elastic_inference_accelerator_arn,
            elastic_inference_accelerator_association_id=self.elastic_inference_accelerator_association_id,
            elastic_inference_accelerator_association_state=self.elastic_inference_accelerator_association_state,
            elastic_inference_accelerator_association_time=self.elastic_inference_accelerator_association_time,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.elastic_inference_accelerator_arn == other.elastic_inference_accelerator_arn and
            self.elastic_inference_accelerator_association_id == other.elastic_inference_accelerator_association_id and
            self.elastic_inference_accelerator_association_state == other.elastic_inference_accelerator_association_state and
            self.elastic_inference_accelerator_association_time == other.elastic_inference_accelerator_association_time
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'elastic_inference_accelerator_arn',
        'elastic_inference_accelerator_association_id',
        'elastic_inference_accelerator_association_state',
        'elastic_inference_accelerator_association_time',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'elastic_inference_accelerator_arn',
        'elastic_inference_accelerator_association_id',
        'elastic_inference_accelerator_association_state',
        'elastic_inference_accelerator_association_time',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.elastic_inference_accelerator_arn,
            self.elastic_inference_accelerator_association_id,
            self.elastic_inference_accelerator_association_state,
            self.elastic_inference_accelerator_association_time,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        elastic_inference_accelerator_arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        elastic_inference_accelerator_association_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        elastic_inference_accelerator_association_state: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        elastic_inference_accelerator_association_time: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'elastic_inference_accelerator_arn', elastic_inference_accelerator_arn)
        __dataclass__object_setattr(self, 'elastic_inference_accelerator_association_id', elastic_inference_accelerator_association_id)
        __dataclass__object_setattr(self, 'elastic_inference_accelerator_association_state', elastic_inference_accelerator_association_state)
        __dataclass__object_setattr(self, 'elastic_inference_accelerator_association_time', elastic_inference_accelerator_association_time)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"elastic_inference_accelerator_arn={self.elastic_inference_accelerator_arn!r}")
        parts.append(f"elastic_inference_accelerator_association_id={self.elastic_inference_accelerator_association_id!r}")
        parts.append(f"elastic_inference_accelerator_association_state={self.elastic_inference_accelerator_association_state!r}")
        parts.append(f"elastic_inference_accelerator_association_time={self.elastic_inference_accelerator_association_time!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ena_srd_udp_enabled',)), EqPlan(fields=('ena_srd_udp_enabled',)), FrozenPlan(fields=("
    "'__shape__', 'ena_srd_udp_enabled'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ena_srd_ud"
    "p_enabled',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0"
    ".annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='ena_srd_udp_enabled', annotation=OpRef(name='init.f"
    "ields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), "
    "kw_only_params=('ena_srd_udp_enabled',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fn"
    "s=()), ReprPlan(fields=(ReprPlan.Field(name='ena_srd_udp_enabled', kw_only=True, fn=None),), id=False, terse=False"
    ", default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fEnaSrdUdpSpecificationRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ena_srd_udp_enabled=self.ena_srd_udp_enabled,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ena_srd_udp_enabled == other.ena_srd_udp_enabled
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'ena_srd_udp_enabled',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'ena_srd_udp_enabled',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ena_srd_udp_enabled,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ena_srd_udp_enabled: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ena_srd_udp_enabled', ena_srd_udp_enabled)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ena_srd_udp_enabled={self.ena_srd_udp_enabled!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('enabled',)), EqPlan(fields=('enabled',)), FrozenPlan(fields=('__shape__', 'enabled'),"
    " allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('enabled',), cache=False), InitPlan(fields=(Ini"
    "tPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='enabled', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None)), self_param='self', std_params=(), kw_only_params=('enabled',), frozen=True, slots=False, post_"
    "init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='enabled', kw_only=True, fn="
    "None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fEnclaveOptions(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            enabled=self.enabled,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.enabled == other.enabled
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'enabled',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'enabled',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.enabled,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        enabled: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'enabled', enabled)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"enabled={self.enabled!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('enabled',)), EqPlan(fields=('enabled',)), FrozenPlan(fields=('__shape__', 'enabled'),"
    " allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('enabled',), cache=False), InitPlan(fields=(Ini"
    "tPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='enabled', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None)), self_param='self', std_params=(), kw_only_params=('enabled',), frozen=True, slots=False, post_"
    "init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='enabled', kw_only=True, fn="
    "None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fEnclaveOptionsRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            enabled=self.enabled,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.enabled == other.enabled
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'enabled',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'enabled',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.enabled,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        enabled: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'enabled', enabled)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"enabled={self.enabled!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('size_in_mi_b',)), EqPlan(fields=('size_in_mi_b',)), FrozenPlan(fields=('__shape__', '"
    "size_in_mi_b'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('size_in_mi_b',), cache=False), "
    "InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None,"
    " default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='size_in_mi_b', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef"
    "(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('size_in_mi_b',), f"
    "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
    "e='size_in_mi_b', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fFpgaDeviceMemoryInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            size_in_mi_b=self.size_in_mi_b,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.size_in_mi_b == other.size_in_mi_b
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'size_in_mi_b',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'size_in_mi_b',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.size_in_mi_b,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        size_in_mi_b: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'size_in_mi_b', size_in_mi_b)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"size_in_mi_b={self.size_in_mi_b!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('size_in_mi_b',)), EqPlan(fields=('size_in_mi_b',)), FrozenPlan(fields=('__shape__', '"
    "size_in_mi_b'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('size_in_mi_b',), cache=False), "
    "InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None,"
    " default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='size_in_mi_b', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef"
    "(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('size_in_mi_b',), f"
    "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
    "e='size_in_mi_b', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fGpuDeviceMemoryInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            size_in_mi_b=self.size_in_mi_b,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.size_in_mi_b == other.size_in_mi_b
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'size_in_mi_b',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'size_in_mi_b',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.size_in_mi_b,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        size_in_mi_b: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'size_in_mi_b', size_in_mi_b)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"size_in_mi_b={self.size_in_mi_b!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('group_id', 'group_name')), EqPlan(fields=('group_id', 'group_name')), FrozenPlan(fiel"
    "ds=('__shape__', 'group_id', 'group_name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('gro"
    "up_id', 'group_name'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init"
    ".fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_"
    "VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_id', annotation=OpRef(name='init.fie"
    "lds.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_name', ann"
    "otation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None,"
    " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_par"
    "am='self', std_params=(), kw_only_params=('group_id', 'group_name'), frozen=True, slots=False, post_init_params=No"
    "ne, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='group_id', kw_only=True, fn=None), ReprPl"
    "an.Field(name='group_name', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fGroupIdentifier(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            group_id=self.group_id,
            group_name=self.group_name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.group_id == other.group_id and
            self.group_name == other.group_name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'group_id',
        'group_name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'group_id',
        'group_name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.group_id,
            self.group_name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        group_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        group_name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'group_id', group_id)
        __dataclass__object_setattr(self, 'group_name', group_name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"group_id={self.group_id!r}")
        parts.append(f"group_name={self.group_name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('configured',)), EqPlan(fields=('configured',)), FrozenPlan(fields=('__shape__', 'conf"
    "igured'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('configured',), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default"
    "_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='configured', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='ini"
    "t.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('configured',), frozen=True, "
    "slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='configure"
    "d', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fHibernationOptions(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            configured=self.configured,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.configured == other.configured
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'configured',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'configured',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.configured,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        configured: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'configured', configured)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"configured={self.configured!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('configured',)), EqPlan(fields=('configured',)), FrozenPlan(fields=('__shape__', 'conf"
    "igured'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('configured',), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default"
    "_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='configured', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='ini"
    "t.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('configured',), frozen=True, "
    "slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='configure"
    "d', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fHibernationOptionsRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            configured=self.configured,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.configured == other.configured
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'configured',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'configured',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.configured,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        configured: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'configured', configured)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"configured={self.configured!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('arn', 'id')), EqPlan(fields=('arn', 'id')), FrozenPlan(fields=('__shape__', 'arn', 'i"
    "d'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('arn', 'id'), cache=False), InitPlan(fields"
    "=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factor"
    "y=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), I"
    "nitPlan.Field(name='arn', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
    ", check_type=None), InitPlan.Field(name='id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(nam"
    "e='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('arn', 'id'), frozen=Tr"
    "ue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='arn',"
    " kw_only=True, fn=None), ReprPlan.Field(name='id', kw_only=True, fn=None)), id=False, terse=False, default_fn=None"
    ")))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fIamInstanceProfile(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            arn=self.arn,
            id=self.id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.arn == other.arn and
            self.id == other.id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'arn',
        'id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'arn',
        'id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.arn,
            self.id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'arn', arn)
        __dataclass__object_setattr(self, 'id', id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"arn={self.arn!r}")
        parts.append(f"id={self.id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('arn', 'name')), EqPlan(fields=('arn', 'name')), FrozenPlan(fields=('__shape__', 'arn'"
    ", 'name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('arn', 'name'), cache=False), InitPla"
    "n(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='arn', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fiel"
    "ds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.2.annotation'), default"
    "=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('arn', 'name'"
    "), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field"
    "(name='arn', kw_only=True, fn=None), ReprPlan.Field(name='name', kw_only=True, fn=None)), id=False, terse=False, d"
    "efault_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fIamInstanceProfileSpecification(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            arn=self.arn,
            name=self.name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.arn == other.arn and
            self.name == other.name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'arn',
        'name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'arn',
        'name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.arn,
            self.name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'arn', arn)
        __dataclass__object_setattr(self, 'name', name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"arn={self.arn!r}")
        parts.append(f"name={self.name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('size_in_mi_b',)), EqPlan(fields=('size_in_mi_b',)), FrozenPlan(fields=('__shape__', '"
    "size_in_mi_b'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('size_in_mi_b',), cache=False), "
    "InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None,"
    " default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='size_in_mi_b', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef"
    "(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('size_in_mi_b',), f"
    "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
    "e='size_in_mi_b', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInferenceDeviceMemoryInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            size_in_mi_b=self.size_in_mi_b,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.size_in_mi_b == other.size_in_mi_b
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'size_in_mi_b',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'size_in_mi_b',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.size_in_mi_b,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        size_in_mi_b: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'size_in_mi_b', size_in_mi_b)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"size_in_mi_b={self.size_in_mi_b!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ena_srd_udp_enabled',)), EqPlan(fields=('ena_srd_udp_enabled',)), FrozenPlan(fields=("
    "'__shape__', 'ena_srd_udp_enabled'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ena_srd_ud"
    "p_enabled',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0"
    ".annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='ena_srd_udp_enabled', annotation=OpRef(name='init.f"
    "ields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), "
    "kw_only_params=('ena_srd_udp_enabled',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fn"
    "s=()), ReprPlan(fields=(ReprPlan.Field(name='ena_srd_udp_enabled', kw_only=True, fn=None),), id=False, terse=False"
    ", default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceAttachmentEnaSrdUdpSpecification(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ena_srd_udp_enabled=self.ena_srd_udp_enabled,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ena_srd_udp_enabled == other.ena_srd_udp_enabled
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'ena_srd_udp_enabled',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'ena_srd_udp_enabled',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ena_srd_udp_enabled,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ena_srd_udp_enabled: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ena_srd_udp_enabled', ena_srd_udp_enabled)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ena_srd_udp_enabled={self.ena_srd_udp_enabled!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ipv4_prefix',)), EqPlan(fields=('ipv4_prefix',)), FrozenPlan(fields=('__shape__', 'ip"
    "v4_prefix'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ipv4_prefix',), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='ipv4_prefix', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name"
    "='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('ipv4_prefix',), frozen="
    "True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ipv"
    "4_prefix', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceIpv4Prefix(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ipv4_prefix=self.ipv4_prefix,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ipv4_prefix == other.ipv4_prefix
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'ipv4_prefix',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'ipv4_prefix',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ipv4_prefix,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ipv4_prefix: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ipv4_prefix', ipv4_prefix)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ipv4_prefix={self.ipv4_prefix!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ipv6_address', 'is_primary_ipv6')), EqPlan(fields=('ipv6_address', 'is_primary_ipv6')"
    "), FrozenPlan(fields=('__shape__', 'ipv6_address', 'is_primary_ipv6'), allow_dynamic_dunder_attrs=False), HashPlan"
    "(action='add', fields=('ipv6_address', 'is_primary_ipv6'), cache=False), InitPlan(fields=(InitPlan.Field(name='__s"
    "hape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_a"
    "ddress', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='is_primary_ipv6', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='i"
    "nit.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
    "e, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('ipv6_address', 'is_primary"
    "_ipv6'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan"
    ".Field(name='ipv6_address', kw_only=True, fn=None), ReprPlan.Field(name='is_primary_ipv6', kw_only=True, fn=None))"
    ", id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceIpv6Address(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ipv6_address=self.ipv6_address,
            is_primary_ipv6=self.is_primary_ipv6,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ipv6_address == other.ipv6_address and
            self.is_primary_ipv6 == other.is_primary_ipv6
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'ipv6_address',
        'is_primary_ipv6',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'ipv6_address',
        'is_primary_ipv6',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ipv6_address,
            self.is_primary_ipv6,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ipv6_address: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        is_primary_ipv6: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ipv6_address', ipv6_address)
        __dataclass__object_setattr(self, 'is_primary_ipv6', is_primary_ipv6)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ipv6_address={self.ipv6_address!r}")
        parts.append(f"is_primary_ipv6={self.is_primary_ipv6!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ipv6_prefix',)), EqPlan(fields=('ipv6_prefix',)), FrozenPlan(fields=('__shape__', 'ip"
    "v6_prefix'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ipv6_prefix',), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='ipv6_prefix', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name"
    "='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('ipv6_prefix',), frozen="
    "True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ipv"
    "6_prefix', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceIpv6Prefix(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ipv6_prefix=self.ipv6_prefix,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ipv6_prefix == other.ipv6_prefix
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'ipv6_prefix',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'ipv6_prefix',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ipv6_prefix,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ipv6_prefix: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ipv6_prefix', ipv6_prefix)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ipv6_prefix={self.ipv6_prefix!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('auto_recovery', 'reboot_migration')), EqPlan(fields=('auto_recovery', 'reboot_migrati"
    "on')), FrozenPlan(fields=('__shape__', 'auto_recovery', 'reboot_migration'), allow_dynamic_dunder_attrs=False), Ha"
    "shPlan(action='add', fields=('auto_recovery', 'reboot_migration'), cache=False), InitPlan(fields=(InitPlan.Field(n"
    "ame='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True,"
    " override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='auto_recovery', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None), InitPlan.Field(name='reboot_migration', annotation=OpRef(name='init.fields.2.annotation'), default=OpR"
    "ef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('auto_recovery', "
    "'reboot_migration'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fiel"
    "ds=(ReprPlan.Field(name='auto_recovery', kw_only=True, fn=None), ReprPlan.Field(name='reboot_migration', kw_only=T"
    "rue, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceMaintenanceOptions(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            auto_recovery=self.auto_recovery,
            reboot_migration=self.reboot_migration,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.auto_recovery == other.auto_recovery and
            self.reboot_migration == other.reboot_migration
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'auto_recovery',
        'reboot_migration',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'auto_recovery',
        'reboot_migration',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.auto_recovery,
            self.reboot_migration,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        auto_recovery: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        reboot_migration: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'auto_recovery', auto_recovery)
        __dataclass__object_setattr(self, 'reboot_migration', reboot_migration)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"auto_recovery={self.auto_recovery!r}")
        parts.append(f"reboot_migration={self.reboot_migration!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('auto_recovery',)), EqPlan(fields=('auto_recovery',)), FrozenPlan(fields=('__shape__',"
    " 'auto_recovery'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('auto_recovery',), cache=Fals"
    "e), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=N"
    "one, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, "
    "check_type=None), InitPlan.Field(name='auto_recovery', annotation=OpRef(name='init.fields.1.annotation'), default="
    "OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
    "E, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('auto_recovery"
    "',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Fie"
    "ld(name='auto_recovery', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceMaintenanceOptionsRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            auto_recovery=self.auto_recovery,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.auto_recovery == other.auto_recovery
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'auto_recovery',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'auto_recovery',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.auto_recovery,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        auto_recovery: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'auto_recovery', auto_recovery)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"auto_recovery={self.auto_recovery!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('http_tokens', 'http_put_response_hop_limit', 'http_endpoint', 'http_protocol_ipv6', '"
    "instance_metadata_tags')), EqPlan(fields=('http_tokens', 'http_put_response_hop_limit', 'http_endpoint', 'http_pro"
    "tocol_ipv6', 'instance_metadata_tags')), FrozenPlan(fields=('__shape__', 'http_tokens', 'http_put_response_hop_lim"
    "it', 'http_endpoint', 'http_protocol_ipv6', 'instance_metadata_tags'), allow_dynamic_dunder_attrs=False), HashPlan"
    "(action='add', fields=('http_tokens', 'http_put_response_hop_limit', 'http_endpoint', 'http_protocol_ipv6', 'insta"
    "nce_metadata_tags'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.f"
    "ields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VA"
    "R, coerce=None, validate=None, check_type=None), InitPlan.Field(name='http_tokens', annotation=OpRef(name='init.fi"
    "elds.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='http_put_respon"
    "se_hop_limit', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='http_endpoint', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(nam"
    "e='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='http_protocol_ipv6', annotation=OpRef(name='init.fiel"
    "ds.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, f"
    "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_metadata"
    "_tags', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
    "), self_param='self', std_params=(), kw_only_params=('http_tokens', 'http_put_response_hop_limit', 'http_endpoint'"
    ", 'http_protocol_ipv6', 'instance_metadata_tags'), frozen=True, slots=False, post_init_params=None, init_fns=(), v"
    "alidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='http_tokens', kw_only=True, fn=None), ReprPlan.Field(name='"
    "http_put_response_hop_limit', kw_only=True, fn=None), ReprPlan.Field(name='http_endpoint', kw_only=True, fn=None),"
    " ReprPlan.Field(name='http_protocol_ipv6', kw_only=True, fn=None), ReprPlan.Field(name='instance_metadata_tags', k"
    "w_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceMetadataOptionsRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            http_tokens=self.http_tokens,
            http_put_response_hop_limit=self.http_put_response_hop_limit,
            http_endpoint=self.http_endpoint,
            http_protocol_ipv6=self.http_protocol_ipv6,
            instance_metadata_tags=self.instance_metadata_tags,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.http_tokens == other.http_tokens and
            self.http_put_response_hop_limit == other.http_put_response_hop_limit and
            self.http_endpoint == other.http_endpoint and
            self.http_protocol_ipv6 == other.http_protocol_ipv6 and
            self.instance_metadata_tags == other.instance_metadata_tags
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'http_tokens',
        'http_put_response_hop_limit',
        'http_endpoint',
        'http_protocol_ipv6',
        'instance_metadata_tags',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'http_tokens',
        'http_put_response_hop_limit',
        'http_endpoint',
        'http_protocol_ipv6',
        'instance_metadata_tags',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.http_tokens,
            self.http_put_response_hop_limit,
            self.http_endpoint,
            self.http_protocol_ipv6,
            self.instance_metadata_tags,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        http_tokens: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        http_put_response_hop_limit: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        http_endpoint: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        http_protocol_ipv6: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        instance_metadata_tags: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'http_tokens', http_tokens)
        __dataclass__object_setattr(self, 'http_put_response_hop_limit', http_put_response_hop_limit)
        __dataclass__object_setattr(self, 'http_endpoint', http_endpoint)
        __dataclass__object_setattr(self, 'http_protocol_ipv6', http_protocol_ipv6)
        __dataclass__object_setattr(self, 'instance_metadata_tags', instance_metadata_tags)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"http_tokens={self.http_tokens!r}")
        parts.append(f"http_put_response_hop_limit={self.http_put_response_hop_limit!r}")
        parts.append(f"http_endpoint={self.http_endpoint!r}")
        parts.append(f"http_protocol_ipv6={self.http_protocol_ipv6!r}")
        parts.append(f"instance_metadata_tags={self.instance_metadata_tags!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('state', 'http_tokens', 'http_put_response_hop_limit', 'http_endpoint', 'http_protocol"
    "_ipv6', 'instance_metadata_tags')), EqPlan(fields=('state', 'http_tokens', 'http_put_response_hop_limit', 'http_en"
    "dpoint', 'http_protocol_ipv6', 'instance_metadata_tags')), FrozenPlan(fields=('__shape__', 'state', 'http_tokens',"
    " 'http_put_response_hop_limit', 'http_endpoint', 'http_protocol_ipv6', 'instance_metadata_tags'), allow_dynamic_du"
    "nder_attrs=False), HashPlan(action='add', fields=('state', 'http_tokens', 'http_put_response_hop_limit', 'http_end"
    "point', 'http_protocol_ipv6', 'instance_metadata_tags'), cache=False), InitPlan(fields=(InitPlan.Field(name='__sha"
    "pe__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override="
    "False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state', "
    "annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='http_tokens', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='http_put_response_hop_limit', annotation=OpRef(name='init.fields.3.ann"
    "otation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='http_endpoint', annotatio"
    "n=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='http_protocol_ipv6', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None), InitPlan.Field(name='instance_metadata_tags', annotation=OpRef(name='init.fields.6.annotation"
    "'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('s"
    "tate', 'http_tokens', 'http_put_response_hop_limit', 'http_endpoint', 'http_protocol_ipv6', 'instance_metadata_tag"
    "s'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Fie"
    "ld(name='state', kw_only=True, fn=None), ReprPlan.Field(name='http_tokens', kw_only=True, fn=None), ReprPlan.Field"
    "(name='http_put_response_hop_limit', kw_only=True, fn=None), ReprPlan.Field(name='http_endpoint', kw_only=True, fn"
    "=None), ReprPlan.Field(name='http_protocol_ipv6', kw_only=True, fn=None), ReprPlan.Field(name='instance_metadata_t"
    "ags', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceMetadataOptionsResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            state=self.state,
            http_tokens=self.http_tokens,
            http_put_response_hop_limit=self.http_put_response_hop_limit,
            http_endpoint=self.http_endpoint,
            http_protocol_ipv6=self.http_protocol_ipv6,
            instance_metadata_tags=self.instance_metadata_tags,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.state == other.state and
            self.http_tokens == other.http_tokens and
            self.http_put_response_hop_limit == other.http_put_response_hop_limit and
            self.http_endpoint == other.http_endpoint and
            self.http_protocol_ipv6 == other.http_protocol_ipv6 and
            self.instance_metadata_tags == other.instance_metadata_tags
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'state',
        'http_tokens',
        'http_put_response_hop_limit',
        'http_endpoint',
        'http_protocol_ipv6',
        'instance_metadata_tags',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'state',
        'http_tokens',
        'http_put_response_hop_limit',
        'http_endpoint',
        'http_protocol_ipv6',
        'instance_metadata_tags',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.state,
            self.http_tokens,
            self.http_put_response_hop_limit,
            self.http_endpoint,
            self.http_protocol_ipv6,
            self.instance_metadata_tags,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        state: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        http_tokens: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        http_put_response_hop_limit: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        http_endpoint: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        http_protocol_ipv6: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        instance_metadata_tags: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'state', state)
        __dataclass__object_setattr(self, 'http_tokens', http_tokens)
        __dataclass__object_setattr(self, 'http_put_response_hop_limit', http_put_response_hop_limit)
        __dataclass__object_setattr(self, 'http_endpoint', http_endpoint)
        __dataclass__object_setattr(self, 'http_protocol_ipv6', http_protocol_ipv6)
        __dataclass__object_setattr(self, 'instance_metadata_tags', instance_metadata_tags)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"state={self.state!r}")
        parts.append(f"http_tokens={self.http_tokens!r}")
        parts.append(f"http_put_response_hop_limit={self.http_put_response_hop_limit!r}")
        parts.append(f"http_endpoint={self.http_endpoint!r}")
        parts.append(f"http_protocol_ipv6={self.http_protocol_ipv6!r}")
        parts.append(f"instance_metadata_tags={self.instance_metadata_tags!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('carrier_ip', 'customer_owned_ip', 'ip_owner_id', 'public_dns_name', 'public_ip')), Eq"
    "Plan(fields=('carrier_ip', 'customer_owned_ip', 'ip_owner_id', 'public_dns_name', 'public_ip')), FrozenPlan(fields"
    "=('__shape__', 'carrier_ip', 'customer_owned_ip', 'ip_owner_id', 'public_dns_name', 'public_ip'), allow_dynamic_du"
    "nder_attrs=False), HashPlan(action='add', fields=('carrier_ip', 'customer_owned_ip', 'ip_owner_id', 'public_dns_na"
    "me', 'public_ip'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fie"
    "lds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='carrier_ip', annotation=OpRef(name='init.field"
    "s.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='customer_owned_ip'"
    ", annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='ip_owner_id', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields."
    "3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='public_dns_name', annotation=OpRef(name='init.fields.4.annotation'),"
    " default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_ip', annotation=OpRef(name='"
    "init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_param"
    "s=(), kw_only_params=('carrier_ip', 'customer_owned_ip', 'ip_owner_id', 'public_dns_name', 'public_ip'), frozen=Tr"
    "ue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='carri"
    "er_ip', kw_only=True, fn=None), ReprPlan.Field(name='customer_owned_ip', kw_only=True, fn=None), ReprPlan.Field(na"
    "me='ip_owner_id', kw_only=True, fn=None), ReprPlan.Field(name='public_dns_name', kw_only=True, fn=None), ReprPlan."
    "Field(name='public_ip', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceNetworkInterfaceAssociation(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            carrier_ip=self.carrier_ip,
            customer_owned_ip=self.customer_owned_ip,
            ip_owner_id=self.ip_owner_id,
            public_dns_name=self.public_dns_name,
            public_ip=self.public_ip,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.carrier_ip == other.carrier_ip and
            self.customer_owned_ip == other.customer_owned_ip and
            self.ip_owner_id == other.ip_owner_id and
            self.public_dns_name == other.public_dns_name and
            self.public_ip == other.public_ip
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'carrier_ip',
        'customer_owned_ip',
        'ip_owner_id',
        'public_dns_name',
        'public_ip',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'carrier_ip',
        'customer_owned_ip',
        'ip_owner_id',
        'public_dns_name',
        'public_ip',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.carrier_ip,
            self.customer_owned_ip,
            self.ip_owner_id,
            self.public_dns_name,
            self.public_ip,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        carrier_ip: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        customer_owned_ip: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ip_owner_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        public_dns_name: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        public_ip: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'carrier_ip', carrier_ip)
        __dataclass__object_setattr(self, 'customer_owned_ip', customer_owned_ip)
        __dataclass__object_setattr(self, 'ip_owner_id', ip_owner_id)
        __dataclass__object_setattr(self, 'public_dns_name', public_dns_name)
        __dataclass__object_setattr(self, 'public_ip', public_ip)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"carrier_ip={self.carrier_ip!r}")
        parts.append(f"customer_owned_ip={self.customer_owned_ip!r}")
        parts.append(f"ip_owner_id={self.ip_owner_id!r}")
        parts.append(f"public_dns_name={self.public_dns_name!r}")
        parts.append(f"public_ip={self.public_ip!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('bandwidth_weighting',)), EqPlan(fields=('bandwidth_weighting',)), FrozenPlan(fields=("
    "'__shape__', 'bandwidth_weighting'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('bandwidth_"
    "weighting',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0"
    ".annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='bandwidth_weighting', annotation=OpRef(name='init.f"
    "ields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), "
    "kw_only_params=('bandwidth_weighting',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fn"
    "s=()), ReprPlan(fields=(ReprPlan.Field(name='bandwidth_weighting', kw_only=True, fn=None),), id=False, terse=False"
    ", default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceNetworkPerformanceOptions(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            bandwidth_weighting=self.bandwidth_weighting,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.bandwidth_weighting == other.bandwidth_weighting
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'bandwidth_weighting',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'bandwidth_weighting',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.bandwidth_weighting,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        bandwidth_weighting: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'bandwidth_weighting', bandwidth_weighting)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"bandwidth_weighting={self.bandwidth_weighting!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('bandwidth_weighting',)), EqPlan(fields=('bandwidth_weighting',)), FrozenPlan(fields=("
    "'__shape__', 'bandwidth_weighting'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('bandwidth_"
    "weighting',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0"
    ".annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='bandwidth_weighting', annotation=OpRef(name='init.f"
    "ields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), "
    "kw_only_params=('bandwidth_weighting',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fn"
    "s=()), ReprPlan(fields=(ReprPlan.Field(name='bandwidth_weighting', kw_only=True, fn=None),), id=False, terse=False"
    ", default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceNetworkPerformanceOptionsRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            bandwidth_weighting=self.bandwidth_weighting,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.bandwidth_weighting == other.bandwidth_weighting
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'bandwidth_weighting',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'bandwidth_weighting',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.bandwidth_weighting,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        bandwidth_weighting: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'bandwidth_weighting', bandwidth_weighting)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"bandwidth_weighting={self.bandwidth_weighting!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('code', 'name')), EqPlan(fields=('code', 'name')), FrozenPlan(fields=('__shape__', 'co"
    "de', 'name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('code', 'name'), cache=False), Ini"
    "tPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, de"
    "fault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_t"
    "ype=None), InitPlan.Field(name='code', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init"
    ".fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.2.annotation'), de"
    "fault=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
    "NSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('code', "
    "'name'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan"
    ".Field(name='code', kw_only=True, fn=None), ReprPlan.Field(name='name', kw_only=True, fn=None)), id=False, terse=F"
    "alse, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceState(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            code=self.code,
            name=self.name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.code == other.code and
            self.name == other.name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'code',
        'name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'code',
        'name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.code,
            self.name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        code: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'code', code)
        __dataclass__object_setattr(self, 'name', name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"code={self.code!r}")
        parts.append(f"name={self.name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('state', 'vpc_id')), EqPlan(fields=('state', 'vpc_id')), FrozenPlan(fields=('__shape__"
    "', 'state', 'vpc_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('state', 'vpc_id'), cache"
    "=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defa"
    "ult=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='state', annotation=OpRef(name='init.fields.1.annotation'), default=OpR"
    "ef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.2.a"
    "nnotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_p"
    "arams=('state', 'vpc_id'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPla"
    "n(fields=(ReprPlan.Field(name='state', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None"
    ")), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInternetGatewayAttachment(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            state=self.state,
            vpc_id=self.vpc_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.state == other.state and
            self.vpc_id == other.vpc_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'state',
        'vpc_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'state',
        'vpc_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.state,
            self.vpc_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        state: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        vpc_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'state', state)
        __dataclass__object_setattr(self, 'vpc_id', vpc_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"state={self.state!r}")
        parts.append(f"vpc_id={self.vpc_id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('description', 'cidr_ip')), EqPlan(fields=('description', 'cidr_ip')), FrozenPlan(fiel"
    "ds=('__shape__', 'description', 'cidr_ip'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('des"
    "cription', 'cidr_ip'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init"
    ".fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_"
    "VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='description', annotation=OpRef(name='init."
    "fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=Fals"
    "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cidr_ip', ann"
    "otation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None,"
    " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_par"
    "am='self', std_params=(), kw_only_params=('description', 'cidr_ip'), frozen=True, slots=False, post_init_params=No"
    "ne, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='description', kw_only=True, fn=None), Rep"
    "rPlan.Field(name='cidr_ip', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fIpRange(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            description=self.description,
            cidr_ip=self.cidr_ip,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.description == other.description and
            self.cidr_ip == other.cidr_ip
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'description',
        'cidr_ip',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'description',
        'cidr_ip',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.description,
            self.cidr_ip,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        description: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        cidr_ip: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'cidr_ip', cidr_ip)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"description={self.description!r}")
        parts.append(f"cidr_ip={self.cidr_ip!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ipv4_prefix',)), EqPlan(fields=('ipv4_prefix',)), FrozenPlan(fields=('__shape__', 'ip"
    "v4_prefix'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ipv4_prefix',), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='ipv4_prefix', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name"
    "='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('ipv4_prefix',), frozen="
    "True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ipv"
    "4_prefix', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fIpv4PrefixSpecification(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ipv4_prefix=self.ipv4_prefix,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ipv4_prefix == other.ipv4_prefix
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'ipv4_prefix',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'ipv4_prefix',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ipv4_prefix,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ipv4_prefix: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ipv4_prefix', ipv4_prefix)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ipv4_prefix={self.ipv4_prefix!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ipv4_prefix',)), EqPlan(fields=('ipv4_prefix',)), FrozenPlan(fields=('__shape__', 'ip"
    "v4_prefix'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ipv4_prefix',), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='ipv4_prefix', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name"
    "='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('ipv4_prefix',), frozen="
    "True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ipv"
    "4_prefix', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fIpv4PrefixSpecificationRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ipv4_prefix=self.ipv4_prefix,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ipv4_prefix == other.ipv4_prefix
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'ipv4_prefix',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'ipv4_prefix',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ipv4_prefix,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ipv4_prefix: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ipv4_prefix', ipv4_prefix)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ipv4_prefix={self.ipv4_prefix!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ipv6_prefix',)), EqPlan(fields=('ipv6_prefix',)), FrozenPlan(fields=('__shape__', 'ip"
    "v6_prefix'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ipv6_prefix',), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='ipv6_prefix', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name"
    "='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('ipv6_prefix',), frozen="
    "True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ipv"
    "6_prefix', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fIpv6PrefixSpecification(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ipv6_prefix=self.ipv6_prefix,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ipv6_prefix == other.ipv6_prefix
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'ipv6_prefix',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'ipv6_prefix',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ipv6_prefix,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ipv6_prefix: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ipv6_prefix', ipv6_prefix)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ipv6_prefix={self.ipv6_prefix!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ipv6_prefix',)), EqPlan(fields=('ipv6_prefix',)), FrozenPlan(fields=('__shape__', 'ip"
    "v6_prefix'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ipv6_prefix',), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='ipv6_prefix', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name"
    "='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('ipv6_prefix',), frozen="
    "True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ipv"
    "6_prefix', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fIpv6PrefixSpecificationRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ipv6_prefix=self.ipv6_prefix,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ipv6_prefix == other.ipv6_prefix
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'ipv6_prefix',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'ipv6_prefix',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ipv6_prefix,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ipv6_prefix: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ipv6_prefix', ipv6_prefix)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ipv6_prefix={self.ipv6_prefix!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('description', 'cidr_ipv6')), EqPlan(fields=('description', 'cidr_ipv6')), FrozenPlan("
    "fields=('__shape__', 'description', 'cidr_ipv6'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields"
    "=('description', 'cidr_ipv6'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(na"
    "me='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='description', annotation=OpRef(nam"
    "e='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cidr_"
    "ipv6', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None))"
    ", self_param='self', std_params=(), kw_only_params=('description', 'cidr_ipv6'), frozen=True, slots=False, post_in"
    "it_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='description', kw_only=True, f"
    "n=None), ReprPlan.Field(name='cidr_ipv6', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fIpv6Range(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            description=self.description,
            cidr_ipv6=self.cidr_ipv6,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.description == other.description and
            self.cidr_ipv6 == other.cidr_ipv6
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'description',
        'cidr_ipv6',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'description',
        'cidr_ipv6',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.description,
            self.cidr_ipv6,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        description: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        cidr_ipv6: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'cidr_ipv6', cidr_ipv6)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"description={self.description!r}")
        parts.append(f"cidr_ipv6={self.cidr_ipv6!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('key_pair_id', 'key_type', 'tags', 'public_key', 'create_time', 'key_name', 'key_finge"
    "rprint')), EqPlan(fields=('key_pair_id', 'key_type', 'tags', 'public_key', 'create_time', 'key_name', 'key_fingerp"
    "rint')), FrozenPlan(fields=('__shape__', 'key_pair_id', 'key_type', 'tags', 'public_key', 'create_time', 'key_name"
    "', 'key_fingerprint'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('key_pair_id', 'key_type'"
    ", 'tags', 'public_key', 'create_time', 'key_name', 'key_fingerprint'), cache=False), InitPlan(fields=(InitPlan.Fie"
    "ld(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=T"
    "rue, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='key_pair_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default')"
    ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='key_type', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(nam"
    "e='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='init.fields.3.annotatio"
    "n'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_key', annotation=OpRef(n"
    "ame='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cre"
    "ate_time', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default"
    "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
    "ne), InitPlan.Field(name='key_name', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.f"
    "ields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='key_fingerprint', annotation=OpRef(name='init.fields.7.annotat"
    "ion'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params="
    "('key_pair_id', 'key_type', 'tags', 'public_key', 'create_time', 'key_name', 'key_fingerprint'), frozen=True, slot"
    "s=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='key_pair_id',"
    " kw_only=True, fn=None), ReprPlan.Field(name='key_type', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='public_key', kw_only=True, fn=None), ReprPlan.Field(name='create_time', kw"
    "_only=True, fn=None), ReprPlan.Field(name='key_name', kw_only=True, fn=None), ReprPlan.Field(name='key_fingerprint"
    "', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fKeyPairInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            key_pair_id=self.key_pair_id,
            key_type=self.key_type,
            tags=self.tags,
            public_key=self.public_key,
            create_time=self.create_time,
            key_name=self.key_name,
            key_fingerprint=self.key_fingerprint,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.key_pair_id == other.key_pair_id and
            self.key_type == other.key_type and
            self.tags == other.tags and
            self.public_key == other.public_key and
            self.create_time == other.create_time and
            self.key_name == other.key_name and
            self.key_fingerprint == other.key_fingerprint
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'key_pair_id',
        'key_type',
        'tags',
        'public_key',
        'create_time',
        'key_name',
        'key_fingerprint',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'key_pair_id',
        'key_type',
        'tags',
        'public_key',
        'create_time',
        'key_name',
        'key_fingerprint',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.key_pair_id,
            self.key_type,
            self.tags,
            self.public_key,
            self.create_time,
            self.key_name,
            self.key_fingerprint,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        key_pair_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        key_type: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        tags: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        public_key: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        create_time: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        key_name: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        key_fingerprint: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'key_pair_id', key_pair_id)
        __dataclass__object_setattr(self, 'key_type', key_type)
        __dataclass__object_setattr(self, 'tags', tags)
        __dataclass__object_setattr(self, 'public_key', public_key)
        __dataclass__object_setattr(self, 'create_time', create_time)
        __dataclass__object_setattr(self, 'key_name', key_name)
        __dataclass__object_setattr(self, 'key_fingerprint', key_fingerprint)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"key_pair_id={self.key_pair_id!r}")
        parts.append(f"key_type={self.key_type!r}")
        parts.append(f"tags={self.tags!r}")
        parts.append(f"public_key={self.public_key!r}")
        parts.append(f"create_time={self.create_time!r}")
        parts.append(f"key_name={self.key_name!r}")
        parts.append(f"key_fingerprint={self.key_fingerprint!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('launch_template_id', 'launch_template_name', 'version')), EqPlan(fields=('launch_temp"
    "late_id', 'launch_template_name', 'version')), FrozenPlan(fields=('__shape__', 'launch_template_id', 'launch_templ"
    "ate_name', 'version'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('launch_template_id', 'la"
    "unch_template_name', 'version'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef("
    "name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='launch_template_id', annotation="
    "OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='launch_template_name', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None), InitPlan.Field(name='version', annotation=OpRef(name='init.fields.3.annotation'), default=OpR"
    "ef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('launch_template_"
    "id', 'launch_template_name', 'version'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fn"
    "s=()), ReprPlan(fields=(ReprPlan.Field(name='launch_template_id', kw_only=True, fn=None), ReprPlan.Field(name='lau"
    "nch_template_name', kw_only=True, fn=None), ReprPlan.Field(name='version', kw_only=True, fn=None)), id=False, ters"
    "e=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fLaunchTemplateSpecification(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            launch_template_id=self.launch_template_id,
            launch_template_name=self.launch_template_name,
            version=self.version,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.launch_template_id == other.launch_template_id and
            self.launch_template_name == other.launch_template_name and
            self.version == other.version
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'launch_template_id',
        'launch_template_name',
        'version',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'launch_template_id',
        'launch_template_name',
        'version',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.launch_template_id,
            self.launch_template_name,
            self.version,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        launch_template_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        launch_template_name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        version: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'launch_template_id', launch_template_id)
        __dataclass__object_setattr(self, 'launch_template_name', launch_template_name)
        __dataclass__object_setattr(self, 'version', version)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"launch_template_id={self.launch_template_id!r}")
        parts.append(f"launch_template_name={self.launch_template_name!r}")
        parts.append(f"version={self.version!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('license_configuration_arn',)), EqPlan(fields=('license_configuration_arn',)), FrozenP"
    "lan(fields=('__shape__', 'license_configuration_arn'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', f"
    "ields=('license_configuration_arn',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=O"
    "pRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=F"
    "ieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='license_configuration_arn',"
    " annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=N"
    "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self"
    "_param='self', std_params=(), kw_only_params=('license_configuration_arn',), frozen=True, slots=False, post_init_p"
    "arams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='license_configuration_arn', kw_on"
    "ly=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fLicenseConfiguration(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            license_configuration_arn=self.license_configuration_arn,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.license_configuration_arn == other.license_configuration_arn
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'license_configuration_arn',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'license_configuration_arn',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.license_configuration_arn,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        license_configuration_arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'license_configuration_arn', license_configuration_arn)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"license_configuration_arn={self.license_configuration_arn!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('license_configuration_arn',)), EqPlan(fields=('license_configuration_arn',)), FrozenP"
    "lan(fields=('__shape__', 'license_configuration_arn'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', f"
    "ields=('license_configuration_arn',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=O"
    "pRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=F"
    "ieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='license_configuration_arn',"
    " annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=N"
    "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self"
    "_param='self', std_params=(), kw_only_params=('license_configuration_arn',), frozen=True, slots=False, post_init_p"
    "arams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='license_configuration_arn', kw_on"
    "ly=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fLicenseConfigurationRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            license_configuration_arn=self.license_configuration_arn,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.license_configuration_arn == other.license_configuration_arn
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'license_configuration_arn',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'license_configuration_arn',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.license_configuration_arn,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        license_configuration_arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'license_configuration_arn', license_configuration_arn)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"license_configuration_arn={self.license_configuration_arn!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('size_in_mi_b',)), EqPlan(fields=('size_in_mi_b',)), FrozenPlan(fields=('__shape__', '"
    "size_in_mi_b'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('size_in_mi_b',), cache=False), "
    "InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None,"
    " default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='size_in_mi_b', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef"
    "(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('size_in_mi_b',), f"
    "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
    "e='size_in_mi_b', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fMediaDeviceMemoryInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            size_in_mi_b=self.size_in_mi_b,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.size_in_mi_b == other.size_in_mi_b
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'size_in_mi_b',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'size_in_mi_b',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.size_in_mi_b,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        size_in_mi_b: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'size_in_mi_b', size_in_mi_b)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"size_in_mi_b={self.size_in_mi_b!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('size_in_mi_b',)), EqPlan(fields=('size_in_mi_b',)), FrozenPlan(fields=('__shape__', '"
    "size_in_mi_b'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('size_in_mi_b',), cache=False), "
    "InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None,"
    " default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='size_in_mi_b', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef"
    "(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('size_in_mi_b',), f"
    "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
    "e='size_in_mi_b', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fMemoryInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            size_in_mi_b=self.size_in_mi_b,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.size_in_mi_b == other.size_in_mi_b
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'size_in_mi_b',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'size_in_mi_b',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.size_in_mi_b,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        size_in_mi_b: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'size_in_mi_b', size_in_mi_b)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"size_in_mi_b={self.size_in_mi_b!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('state',)), EqPlan(fields=('state',)), FrozenPlan(fields=('__shape__', 'state'), allow"
    "_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('state',), cache=False), InitPlan(fields=(InitPlan.Fi"
    "eld(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init="
    "True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='state', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None)), self_param='self', std_params=(), kw_only_params=('state',), frozen=True, slots=False, post_init_params="
    "None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='state', kw_only=True, fn=None),), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fMonitoring(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            state=self.state,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.state == other.state
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'state',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'state',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.state,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        state: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'state', state)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"state={self.state!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('network_card_index', 'network_performance', 'maximum_network_interfaces', 'baseline_b"
    "andwidth_in_gbips', 'peak_bandwidth_in_gbips', 'default_ena_queue_count_per_interface', 'maximum_ena_queue_count',"
    " 'maximum_ena_queue_count_per_interface')), EqPlan(fields=('network_card_index', 'network_performance', 'maximum_n"
    "etwork_interfaces', 'baseline_bandwidth_in_gbips', 'peak_bandwidth_in_gbips', 'default_ena_queue_count_per_interfa"
    "ce', 'maximum_ena_queue_count', 'maximum_ena_queue_count_per_interface')), FrozenPlan(fields=('__shape__', 'networ"
    "k_card_index', 'network_performance', 'maximum_network_interfaces', 'baseline_bandwidth_in_gbips', 'peak_bandwidth"
    "_in_gbips', 'default_ena_queue_count_per_interface', 'maximum_ena_queue_count', 'maximum_ena_queue_count_per_inter"
    "face'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('network_card_index', 'network_performan"
    "ce', 'maximum_network_interfaces', 'baseline_bandwidth_in_gbips', 'peak_bandwidth_in_gbips', 'default_ena_queue_co"
    "unt_per_interface', 'maximum_ena_queue_count', 'maximum_ena_queue_count_per_interface'), cache=False), InitPlan(fi"
    "elds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='network_card_index', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name"
    "='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='network_performance', annotation=OpRef(name='init.fiel"
    "ds.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, f"
    "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maximum_network_i"
    "nterfaces', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='baseline_bandwidth_in_gbips', annotation=OpRef(name='init.fields.4.annotation'), defaul"
    "t=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
    "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='peak_bandwidth_in_gbips', annotation=OpRef"
    "(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='d"
    "efault_ena_queue_count_per_interface', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init"
    ".fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='maximum_ena_queue_count', annotation=OpRef(name='init.fields"
    ".7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maximum_ena_queue_c"
    "ount_per_interface', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'"
    "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
    "ck_type=None)), self_param='self', std_params=(), kw_only_params=('network_card_index', 'network_performance', 'ma"
    "ximum_network_interfaces', 'baseline_bandwidth_in_gbips', 'peak_bandwidth_in_gbips', 'default_ena_queue_count_per_"
    "interface', 'maximum_ena_queue_count', 'maximum_ena_queue_count_per_interface'), frozen=True, slots=False, post_in"
    "it_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='network_card_index', kw_only="
    "True, fn=None), ReprPlan.Field(name='network_performance', kw_only=True, fn=None), ReprPlan.Field(name='maximum_ne"
    "twork_interfaces', kw_only=True, fn=None), ReprPlan.Field(name='baseline_bandwidth_in_gbips', kw_only=True, fn=Non"
    "e), ReprPlan.Field(name='peak_bandwidth_in_gbips', kw_only=True, fn=None), ReprPlan.Field(name='default_ena_queue_"
    "count_per_interface', kw_only=True, fn=None), ReprPlan.Field(name='maximum_ena_queue_count', kw_only=True, fn=None"
    "), ReprPlan.Field(name='maximum_ena_queue_count_per_interface', kw_only=True, fn=None)), id=False, terse=False, de"
    "fault_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fNetworkCardInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            network_card_index=self.network_card_index,
            network_performance=self.network_performance,
            maximum_network_interfaces=self.maximum_network_interfaces,
            baseline_bandwidth_in_gbips=self.baseline_bandwidth_in_gbips,
            peak_bandwidth_in_gbips=self.peak_bandwidth_in_gbips,
            default_ena_queue_count_per_interface=self.default_ena_queue_count_per_interface,
            maximum_ena_queue_count=self.maximum_ena_queue_count,
            maximum_ena_queue_count_per_interface=self.maximum_ena_queue_count_per_interface,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.network_card_index == other.network_card_index and
            self.network_performance == other.network_performance and
            self.maximum_network_interfaces == other.maximum_network_interfaces and
            self.baseline_bandwidth_in_gbips == other.baseline_bandwidth_in_gbips and
            self.peak_bandwidth_in_gbips == other.peak_bandwidth_in_gbips and
            self.default_ena_queue_count_per_interface == other.default_ena_queue_count_per_interface and
            self.maximum_ena_queue_count == other.maximum_ena_queue_count and
            self.maximum_ena_queue_count_per_interface == other.maximum_ena_queue_count_per_interface
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'network_card_index',
        'network_performance',
        'maximum_network_interfaces',
        'baseline_bandwidth_in_gbips',
        'peak_bandwidth_in_gbips',
        'default_ena_queue_count_per_interface',
        'maximum_ena_queue_count',
        'maximum_ena_queue_count_per_interface',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'network_card_index',
        'network_performance',
        'maximum_network_interfaces',
        'baseline_bandwidth_in_gbips',
        'peak_bandwidth_in_gbips',
        'default_ena_queue_count_per_interface',
        'maximum_ena_queue_count',
        'maximum_ena_queue_count_per_interface',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.network_card_index,
            self.network_performance,
            self.maximum_network_interfaces,
            self.baseline_bandwidth_in_gbips,
            self.peak_bandwidth_in_gbips,
            self.default_ena_queue_count_per_interface,
            self.maximum_ena_queue_count,
            self.maximum_ena_queue_count_per_interface,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        network_card_index: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        network_performance: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        maximum_network_interfaces: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        baseline_bandwidth_in_gbips: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        peak_bandwidth_in_gbips: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        default_ena_queue_count_per_interface: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        maximum_ena_queue_count: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        maximum_ena_queue_count_per_interface: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'network_card_index', network_card_index)
        __dataclass__object_setattr(self, 'network_performance', network_performance)
        __dataclass__object_setattr(self, 'maximum_network_interfaces', maximum_network_interfaces)
        __dataclass__object_setattr(self, 'baseline_bandwidth_in_gbips', baseline_bandwidth_in_gbips)
        __dataclass__object_setattr(self, 'peak_bandwidth_in_gbips', peak_bandwidth_in_gbips)
        __dataclass__object_setattr(self, 'default_ena_queue_count_per_interface', default_ena_queue_count_per_interface)
        __dataclass__object_setattr(self, 'maximum_ena_queue_count', maximum_ena_queue_count)
        __dataclass__object_setattr(self, 'maximum_ena_queue_count_per_interface', maximum_ena_queue_count_per_interface)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"network_card_index={self.network_card_index!r}")
        parts.append(f"network_performance={self.network_performance!r}")
        parts.append(f"maximum_network_interfaces={self.maximum_network_interfaces!r}")
        parts.append(f"baseline_bandwidth_in_gbips={self.baseline_bandwidth_in_gbips!r}")
        parts.append(f"peak_bandwidth_in_gbips={self.peak_bandwidth_in_gbips!r}")
        parts.append(f"default_ena_queue_count_per_interface={self.default_ena_queue_count_per_interface!r}")
        parts.append(f"maximum_ena_queue_count={self.maximum_ena_queue_count!r}")
        parts.append(f"maximum_ena_queue_count_per_interface={self.maximum_ena_queue_count_per_interface!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('allocation_id', 'association_id', 'ip_owner_id', 'public_dns_name', 'public_ip', 'cus"
    "tomer_owned_ip', 'carrier_ip')), EqPlan(fields=('allocation_id', 'association_id', 'ip_owner_id', 'public_dns_name"
    "', 'public_ip', 'customer_owned_ip', 'carrier_ip')), FrozenPlan(fields=('__shape__', 'allocation_id', 'association"
    "_id', 'ip_owner_id', 'public_dns_name', 'public_ip', 'customer_owned_ip', 'carrier_ip'), allow_dynamic_dunder_attr"
    "s=False), HashPlan(action='add', fields=('allocation_id', 'association_id', 'ip_owner_id', 'public_dns_name', 'pub"
    "lic_ip', 'customer_owned_ip', 'carrier_ip'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annot"
    "ation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field"
    "_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='allocation_id', anno"
    "tation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
    "ield(name='association_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.d"
    "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
    "ne, check_type=None), InitPlan.Field(name='ip_owner_id', annotation=OpRef(name='init.fields.3.annotation'), defaul"
    "t=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
    "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_dns_name', annotation=OpRef(name='i"
    "nit.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override="
    "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_ip"
    "', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory"
    "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
    "tPlan.Field(name='customer_owned_ip', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init."
    "fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None), InitPlan.Field(name='carrier_ip', annotation=OpRef(name='init.fields.7.annotation'"
    "), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('al"
    "location_id', 'association_id', 'ip_owner_id', 'public_dns_name', 'public_ip', 'customer_owned_ip', 'carrier_ip'),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(n"
    "ame='allocation_id', kw_only=True, fn=None), ReprPlan.Field(name='association_id', kw_only=True, fn=None), ReprPla"
    "n.Field(name='ip_owner_id', kw_only=True, fn=None), ReprPlan.Field(name='public_dns_name', kw_only=True, fn=None),"
    " ReprPlan.Field(name='public_ip', kw_only=True, fn=None), ReprPlan.Field(name='customer_owned_ip', kw_only=True, f"
    "n=None), ReprPlan.Field(name='carrier_ip', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fNetworkInterfaceAssociation(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            allocation_id=self.allocation_id,
            association_id=self.association_id,
            ip_owner_id=self.ip_owner_id,
            public_dns_name=self.public_dns_name,
            public_ip=self.public_ip,
            customer_owned_ip=self.customer_owned_ip,
            carrier_ip=self.carrier_ip,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.allocation_id == other.allocation_id and
            self.association_id == other.association_id and
            self.ip_owner_id == other.ip_owner_id and
            self.public_dns_name == other.public_dns_name and
            self.public_ip == other.public_ip and
            self.customer_owned_ip == other.customer_owned_ip and
            self.carrier_ip == other.carrier_ip
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'allocation_id',
        'association_id',
        'ip_owner_id',
        'public_dns_name',
        'public_ip',
        'customer_owned_ip',
        'carrier_ip',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'allocation_id',
        'association_id',
        'ip_owner_id',
        'public_dns_name',
        'public_ip',
        'customer_owned_ip',
        'carrier_ip',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.allocation_id,
            self.association_id,
            self.ip_owner_id,
            self.public_dns_name,
            self.public_ip,
            self.customer_owned_ip,
            self.carrier_ip,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        allocation_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        association_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ip_owner_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        public_dns_name: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        public_ip: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        customer_owned_ip: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        carrier_ip: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'allocation_id', allocation_id)
        __dataclass__object_setattr(self, 'association_id', association_id)
        __dataclass__object_setattr(self, 'ip_owner_id', ip_owner_id)
        __dataclass__object_setattr(self, 'public_dns_name', public_dns_name)
        __dataclass__object_setattr(self, 'public_ip', public_ip)
        __dataclass__object_setattr(self, 'customer_owned_ip', customer_owned_ip)
        __dataclass__object_setattr(self, 'carrier_ip', carrier_ip)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"allocation_id={self.allocation_id!r}")
        parts.append(f"association_id={self.association_id!r}")
        parts.append(f"ip_owner_id={self.ip_owner_id!r}")
        parts.append(f"public_dns_name={self.public_dns_name!r}")
        parts.append(f"public_ip={self.public_ip!r}")
        parts.append(f"customer_owned_ip={self.customer_owned_ip!r}")
        parts.append(f"carrier_ip={self.carrier_ip!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ipv6_address', 'public_ipv6_dns_name', 'is_primary_ipv6')), EqPlan(fields=('ipv6_addr"
    "ess', 'public_ipv6_dns_name', 'is_primary_ipv6')), FrozenPlan(fields=('__shape__', 'ipv6_address', 'public_ipv6_dn"
    "s_name', 'is_primary_ipv6'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ipv6_address', 'pu"
    "blic_ipv6_dns_name', 'is_primary_ipv6'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotatio"
    "n=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_address', annotatio"
    "n=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='public_ipv6_dns_name', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='is_primary_ipv6', annotation=OpRef(name='init.fields.3.annotation'), d"
    "efault=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType."
    "INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('ipv6_a"
    "ddress', 'public_ipv6_dns_name', 'is_primary_ipv6'), frozen=True, slots=False, post_init_params=None, init_fns=(),"
    " validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ipv6_address', kw_only=True, fn=None), ReprPlan.Field(nam"
    "e='public_ipv6_dns_name', kw_only=True, fn=None), ReprPlan.Field(name='is_primary_ipv6', kw_only=True, fn=None)), "
    "id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fNetworkInterfaceIpv6Address(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ipv6_address=self.ipv6_address,
            public_ipv6_dns_name=self.public_ipv6_dns_name,
            is_primary_ipv6=self.is_primary_ipv6,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ipv6_address == other.ipv6_address and
            self.public_ipv6_dns_name == other.public_ipv6_dns_name and
            self.is_primary_ipv6 == other.is_primary_ipv6
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'ipv6_address',
        'public_ipv6_dns_name',
        'is_primary_ipv6',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'ipv6_address',
        'public_ipv6_dns_name',
        'is_primary_ipv6',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ipv6_address,
            self.public_ipv6_dns_name,
            self.is_primary_ipv6,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ipv6_address: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        public_ipv6_dns_name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        is_primary_ipv6: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ipv6_address', ipv6_address)
        __dataclass__object_setattr(self, 'public_ipv6_dns_name', public_ipv6_dns_name)
        __dataclass__object_setattr(self, 'is_primary_ipv6', is_primary_ipv6)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ipv6_address={self.ipv6_address!r}")
        parts.append(f"public_ipv6_dns_name={self.public_ipv6_dns_name!r}")
        parts.append(f"is_primary_ipv6={self.is_primary_ipv6!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('count', 'version')), EqPlan(fields=('count', 'version')), FrozenPlan(fields=('__shape"
    "__', 'count', 'version'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('count', 'version'), c"
    "ache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), "
    "default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='count', annotation=OpRef(name='init.fields.1.annotation'), default"
    "=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='version', annotation=OpRef(name='init.field"
    "s.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_o"
    "nly_params=('count', 'version'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), R"
    "eprPlan(fields=(ReprPlan.Field(name='count', kw_only=True, fn=None), ReprPlan.Field(name='version', kw_only=True, "
    "fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fNeuronDeviceCoreInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            count=self.count,
            version=self.version,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.count == other.count and
            self.version == other.version
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'count',
        'version',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'count',
        'version',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.count,
            self.version,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        count: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        version: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'count', count)
        __dataclass__object_setattr(self, 'version', version)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"count={self.count!r}")
        parts.append(f"version={self.version!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('size_in_mi_b',)), EqPlan(fields=('size_in_mi_b',)), FrozenPlan(fields=('__shape__', '"
    "size_in_mi_b'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('size_in_mi_b',), cache=False), "
    "InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None,"
    " default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='size_in_mi_b', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef"
    "(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('size_in_mi_b',), f"
    "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
    "e='size_in_mi_b', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fNeuronDeviceMemoryInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            size_in_mi_b=self.size_in_mi_b,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.size_in_mi_b == other.size_in_mi_b
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'size_in_mi_b',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'size_in_mi_b',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.size_in_mi_b,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        size_in_mi_b: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'size_in_mi_b', size_in_mi_b)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"size_in_mi_b={self.size_in_mi_b!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('principal',)), EqPlan(fields=('principal',)), FrozenPlan(fields=('__shape__', 'princi"
    "pal'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('principal',), cache=False), InitPlan(fie"
    "lds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='principal', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fie"
    "lds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('principal',), frozen=True, slots="
    "False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='principal', kw_"
    "only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fOperatorRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            principal=self.principal,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.principal == other.principal
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'principal',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'principal',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.principal,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        principal: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'principal', principal)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"principal={self.principal!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('managed', 'principal')), EqPlan(fields=('managed', 'principal')), FrozenPlan(fields=("
    "'__shape__', 'managed', 'principal'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('managed',"
    " 'principal'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields."
    "0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coe"
    "rce=None, validate=None, check_type=None), InitPlan.Field(name='managed', annotation=OpRef(name='init.fields.1.ann"
    "otation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='principal', annotation=Op"
    "Ref(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True"
    ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self',"
    " std_params=(), kw_only_params=('managed', 'principal'), frozen=True, slots=False, post_init_params=None, init_fns"
    "=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='managed', kw_only=True, fn=None), ReprPlan.Field(name"
    "='principal', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fOperatorResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            managed=self.managed,
            principal=self.principal,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.managed == other.managed and
            self.principal == other.principal
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'managed',
        'principal',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'managed',
        'principal',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.managed,
            self.principal,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        managed: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        principal: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'managed', managed)
        __dataclass__object_setattr(self, 'principal', principal)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"managed={self.managed!r}")
        parts.append(f"principal={self.principal!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('availability_zone_id', 'affinity', 'group_name', 'partition_number', 'host_id', 'tena"
    "ncy', 'spread_domain', 'host_resource_group_arn', 'group_id', 'availability_zone')), EqPlan(fields=('availability_"
    "zone_id', 'affinity', 'group_name', 'partition_number', 'host_id', 'tenancy', 'spread_domain', 'host_resource_grou"
    "p_arn', 'group_id', 'availability_zone')), FrozenPlan(fields=('__shape__', 'availability_zone_id', 'affinity', 'gr"
    "oup_name', 'partition_number', 'host_id', 'tenancy', 'spread_domain', 'host_resource_group_arn', 'group_id', 'avai"
    "lability_zone'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('availability_zone_id', 'affini"
    "ty', 'group_name', 'partition_number', 'host_id', 'tenancy', 'spread_domain', 'host_resource_group_arn', 'group_id"
    "', 'availability_zone'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='in"
    "it.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLAS"
    "S_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='availability_zone_id', annotation=OpRef("
    "name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, ov"
    "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='af"
    "finity', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='group_name', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.f"
    "ields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='partition_number', annotation=OpRef(name='init.fields.4.annota"
    "tion'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=F"
    "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='host_id', annotation=OpRef(n"
    "ame='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ten"
    "ancy', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='spread_domain', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init."
    "fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None), InitPlan.Field(name='host_resource_group_arn', annotation=OpRef(name='init.fields."
    "8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_id', annotatio"
    "n=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='availability_zone', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.d"
    "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
    "ne, check_type=None)), self_param='self', std_params=(), kw_only_params=('availability_zone_id', 'affinity', 'grou"
    "p_name', 'partition_number', 'host_id', 'tenancy', 'spread_domain', 'host_resource_group_arn', 'group_id', 'availa"
    "bility_zone'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Re"
    "prPlan.Field(name='availability_zone_id', kw_only=True, fn=None), ReprPlan.Field(name='affinity', kw_only=True, fn"
    "=None), ReprPlan.Field(name='group_name', kw_only=True, fn=None), ReprPlan.Field(name='partition_number', kw_only="
    "True, fn=None), ReprPlan.Field(name='host_id', kw_only=True, fn=None), ReprPlan.Field(name='tenancy', kw_only=True"
    ", fn=None), ReprPlan.Field(name='spread_domain', kw_only=True, fn=None), ReprPlan.Field(name='host_resource_group_"
    "arn', kw_only=True, fn=None), ReprPlan.Field(name='group_id', kw_only=True, fn=None), ReprPlan.Field(name='availab"
    "ility_zone', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fPlacement(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            availability_zone_id=self.availability_zone_id,
            affinity=self.affinity,
            group_name=self.group_name,
            partition_number=self.partition_number,
            host_id=self.host_id,
            tenancy=self.tenancy,
            spread_domain=self.spread_domain,
            host_resource_group_arn=self.host_resource_group_arn,
            group_id=self.group_id,
            availability_zone=self.availability_zone,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.availability_zone_id == other.availability_zone_id and
            self.affinity == other.affinity and
            self.group_name == other.group_name and
            self.partition_number == other.partition_number and
            self.host_id == other.host_id and
            self.tenancy == other.tenancy and
            self.spread_domain == other.spread_domain and
            self.host_resource_group_arn == other.host_resource_group_arn and
            self.group_id == other.group_id and
            self.availability_zone == other.availability_zone
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'availability_zone_id',
        'affinity',
        'group_name',
        'partition_number',
        'host_id',
        'tenancy',
        'spread_domain',
        'host_resource_group_arn',
        'group_id',
        'availability_zone',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'availability_zone_id',
        'affinity',
        'group_name',
        'partition_number',
        'host_id',
        'tenancy',
        'spread_domain',
        'host_resource_group_arn',
        'group_id',
        'availability_zone',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.availability_zone_id,
            self.affinity,
            self.group_name,
            self.partition_number,
            self.host_id,
            self.tenancy,
            self.spread_domain,
            self.host_resource_group_arn,
            self.group_id,
            self.availability_zone,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        availability_zone_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        affinity: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        group_name: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        partition_number: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        host_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        tenancy: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        spread_domain: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        host_resource_group_arn: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        group_id: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        availability_zone: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'availability_zone_id', availability_zone_id)
        __dataclass__object_setattr(self, 'affinity', affinity)
        __dataclass__object_setattr(self, 'group_name', group_name)
        __dataclass__object_setattr(self, 'partition_number', partition_number)
        __dataclass__object_setattr(self, 'host_id', host_id)
        __dataclass__object_setattr(self, 'tenancy', tenancy)
        __dataclass__object_setattr(self, 'spread_domain', spread_domain)
        __dataclass__object_setattr(self, 'host_resource_group_arn', host_resource_group_arn)
        __dataclass__object_setattr(self, 'group_id', group_id)
        __dataclass__object_setattr(self, 'availability_zone', availability_zone)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"availability_zone_id={self.availability_zone_id!r}")
        parts.append(f"affinity={self.affinity!r}")
        parts.append(f"group_name={self.group_name!r}")
        parts.append(f"partition_number={self.partition_number!r}")
        parts.append(f"host_id={self.host_id!r}")
        parts.append(f"tenancy={self.tenancy!r}")
        parts.append(f"spread_domain={self.spread_domain!r}")
        parts.append(f"host_resource_group_arn={self.host_resource_group_arn!r}")
        parts.append(f"group_id={self.group_id!r}")
        parts.append(f"availability_zone={self.availability_zone!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('description', 'prefix_list_id')), EqPlan(fields=('description', 'prefix_list_id')), F"
    "rozenPlan(fields=('__shape__', 'description', 'prefix_list_id'), allow_dynamic_dunder_attrs=False), HashPlan(actio"
    "n='add', fields=('description', 'prefix_list_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__',"
    " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False,"
    " field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='description', "
    "annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='prefix_list_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields"
    ".2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('description', 'prefix_list_id'), fro"
    "zen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name="
    "'description', kw_only=True, fn=None), ReprPlan.Field(name='prefix_list_id', kw_only=True, fn=None)), id=False, te"
    "rse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fPrefixListId(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            description=self.description,
            prefix_list_id=self.prefix_list_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.description == other.description and
            self.prefix_list_id == other.prefix_list_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'description',
        'prefix_list_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'description',
        'prefix_list_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.description,
            self.prefix_list_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        description: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        prefix_list_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'prefix_list_id', prefix_list_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"description={self.description!r}")
        parts.append(f"prefix_list_id={self.prefix_list_id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('hostname_type', 'enable_resource_name_dns_a_record', 'enable_resource_name_dns_aaaa_r"
    "ecord')), EqPlan(fields=('hostname_type', 'enable_resource_name_dns_a_record', 'enable_resource_name_dns_aaaa_reco"
    "rd')), FrozenPlan(fields=('__shape__', 'hostname_type', 'enable_resource_name_dns_a_record', 'enable_resource_name"
    "_dns_aaaa_record'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('hostname_type', 'enable_res"
    "ource_name_dns_a_record', 'enable_resource_name_dns_aaaa_record'), cache=False), InitPlan(fields=(InitPlan.Field(n"
    "ame='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True,"
    " override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='hostname_type', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None), InitPlan.Field(name='enable_resource_name_dns_a_record', annotation=OpRef(name='init.fields.2.annotati"
    "on'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='enable_resource_name_dns_aaaa_"
    "record', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    ")), self_param='self', std_params=(), kw_only_params=('hostname_type', 'enable_resource_name_dns_a_record', 'enabl"
    "e_resource_name_dns_aaaa_record'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
    " ReprPlan(fields=(ReprPlan.Field(name='hostname_type', kw_only=True, fn=None), ReprPlan.Field(name='enable_resourc"
    "e_name_dns_a_record', kw_only=True, fn=None), ReprPlan.Field(name='enable_resource_name_dns_aaaa_record', kw_only="
    "True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fPrivateDnsNameOptionsOnLaunch(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            hostname_type=self.hostname_type,
            enable_resource_name_dns_a_record=self.enable_resource_name_dns_a_record,
            enable_resource_name_dns_aaaa_record=self.enable_resource_name_dns_aaaa_record,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.hostname_type == other.hostname_type and
            self.enable_resource_name_dns_a_record == other.enable_resource_name_dns_a_record and
            self.enable_resource_name_dns_aaaa_record == other.enable_resource_name_dns_aaaa_record
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'hostname_type',
        'enable_resource_name_dns_a_record',
        'enable_resource_name_dns_aaaa_record',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'hostname_type',
        'enable_resource_name_dns_a_record',
        'enable_resource_name_dns_aaaa_record',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.hostname_type,
            self.enable_resource_name_dns_a_record,
            self.enable_resource_name_dns_aaaa_record,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        hostname_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        enable_resource_name_dns_a_record: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        enable_resource_name_dns_aaaa_record: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'hostname_type', hostname_type)
        __dataclass__object_setattr(self, 'enable_resource_name_dns_a_record', enable_resource_name_dns_a_record)
        __dataclass__object_setattr(self, 'enable_resource_name_dns_aaaa_record', enable_resource_name_dns_aaaa_record)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"hostname_type={self.hostname_type!r}")
        parts.append(f"enable_resource_name_dns_a_record={self.enable_resource_name_dns_a_record!r}")
        parts.append(f"enable_resource_name_dns_aaaa_record={self.enable_resource_name_dns_aaaa_record!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('hostname_type', 'enable_resource_name_dns_a_record', 'enable_resource_name_dns_aaaa_r"
    "ecord')), EqPlan(fields=('hostname_type', 'enable_resource_name_dns_a_record', 'enable_resource_name_dns_aaaa_reco"
    "rd')), FrozenPlan(fields=('__shape__', 'hostname_type', 'enable_resource_name_dns_a_record', 'enable_resource_name"
    "_dns_aaaa_record'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('hostname_type', 'enable_res"
    "ource_name_dns_a_record', 'enable_resource_name_dns_aaaa_record'), cache=False), InitPlan(fields=(InitPlan.Field(n"
    "ame='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True,"
    " override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='hostname_type', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None), InitPlan.Field(name='enable_resource_name_dns_a_record', annotation=OpRef(name='init.fields.2.annotati"
    "on'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='enable_resource_name_dns_aaaa_"
    "record', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    ")), self_param='self', std_params=(), kw_only_params=('hostname_type', 'enable_resource_name_dns_a_record', 'enabl"
    "e_resource_name_dns_aaaa_record'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
    " ReprPlan(fields=(ReprPlan.Field(name='hostname_type', kw_only=True, fn=None), ReprPlan.Field(name='enable_resourc"
    "e_name_dns_a_record', kw_only=True, fn=None), ReprPlan.Field(name='enable_resource_name_dns_aaaa_record', kw_only="
    "True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fPrivateDnsNameOptionsRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            hostname_type=self.hostname_type,
            enable_resource_name_dns_a_record=self.enable_resource_name_dns_a_record,
            enable_resource_name_dns_aaaa_record=self.enable_resource_name_dns_aaaa_record,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.hostname_type == other.hostname_type and
            self.enable_resource_name_dns_a_record == other.enable_resource_name_dns_a_record and
            self.enable_resource_name_dns_aaaa_record == other.enable_resource_name_dns_aaaa_record
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'hostname_type',
        'enable_resource_name_dns_a_record',
        'enable_resource_name_dns_aaaa_record',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'hostname_type',
        'enable_resource_name_dns_a_record',
        'enable_resource_name_dns_aaaa_record',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.hostname_type,
            self.enable_resource_name_dns_a_record,
            self.enable_resource_name_dns_aaaa_record,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        hostname_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        enable_resource_name_dns_a_record: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        enable_resource_name_dns_aaaa_record: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'hostname_type', hostname_type)
        __dataclass__object_setattr(self, 'enable_resource_name_dns_a_record', enable_resource_name_dns_a_record)
        __dataclass__object_setattr(self, 'enable_resource_name_dns_aaaa_record', enable_resource_name_dns_aaaa_record)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"hostname_type={self.hostname_type!r}")
        parts.append(f"enable_resource_name_dns_a_record={self.enable_resource_name_dns_a_record!r}")
        parts.append(f"enable_resource_name_dns_aaaa_record={self.enable_resource_name_dns_aaaa_record!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('hostname_type', 'enable_resource_name_dns_a_record', 'enable_resource_name_dns_aaaa_r"
    "ecord')), EqPlan(fields=('hostname_type', 'enable_resource_name_dns_a_record', 'enable_resource_name_dns_aaaa_reco"
    "rd')), FrozenPlan(fields=('__shape__', 'hostname_type', 'enable_resource_name_dns_a_record', 'enable_resource_name"
    "_dns_aaaa_record'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('hostname_type', 'enable_res"
    "ource_name_dns_a_record', 'enable_resource_name_dns_aaaa_record'), cache=False), InitPlan(fields=(InitPlan.Field(n"
    "ame='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True,"
    " override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='hostname_type', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None), InitPlan.Field(name='enable_resource_name_dns_a_record', annotation=OpRef(name='init.fields.2.annotati"
    "on'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='enable_resource_name_dns_aaaa_"
    "record', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    ")), self_param='self', std_params=(), kw_only_params=('hostname_type', 'enable_resource_name_dns_a_record', 'enabl"
    "e_resource_name_dns_aaaa_record'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
    " ReprPlan(fields=(ReprPlan.Field(name='hostname_type', kw_only=True, fn=None), ReprPlan.Field(name='enable_resourc"
    "e_name_dns_a_record', kw_only=True, fn=None), ReprPlan.Field(name='enable_resource_name_dns_aaaa_record', kw_only="
    "True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fPrivateDnsNameOptionsResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            hostname_type=self.hostname_type,
            enable_resource_name_dns_a_record=self.enable_resource_name_dns_a_record,
            enable_resource_name_dns_aaaa_record=self.enable_resource_name_dns_aaaa_record,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.hostname_type == other.hostname_type and
            self.enable_resource_name_dns_a_record == other.enable_resource_name_dns_a_record and
            self.enable_resource_name_dns_aaaa_record == other.enable_resource_name_dns_aaaa_record
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'hostname_type',
        'enable_resource_name_dns_a_record',
        'enable_resource_name_dns_aaaa_record',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'hostname_type',
        'enable_resource_name_dns_a_record',
        'enable_resource_name_dns_aaaa_record',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.hostname_type,
            self.enable_resource_name_dns_a_record,
            self.enable_resource_name_dns_aaaa_record,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        hostname_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        enable_resource_name_dns_a_record: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        enable_resource_name_dns_aaaa_record: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'hostname_type', hostname_type)
        __dataclass__object_setattr(self, 'enable_resource_name_dns_a_record', enable_resource_name_dns_a_record)
        __dataclass__object_setattr(self, 'enable_resource_name_dns_aaaa_record', enable_resource_name_dns_aaaa_record)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"hostname_type={self.hostname_type!r}")
        parts.append(f"enable_resource_name_dns_a_record={self.enable_resource_name_dns_a_record!r}")
        parts.append(f"enable_resource_name_dns_aaaa_record={self.enable_resource_name_dns_aaaa_record!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('primary', 'private_ip_address')), EqPlan(fields=('primary', 'private_ip_address')), F"
    "rozenPlan(fields=('__shape__', 'primary', 'private_ip_address'), allow_dynamic_dunder_attrs=False), HashPlan(actio"
    "n='add', fields=('primary', 'private_ip_address'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__',"
    " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False,"
    " field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='primary', anno"
    "tation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
    "ield(name='private_ip_address', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields"
    ".2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('primary', 'private_ip_address'), fro"
    "zen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name="
    "'primary', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_address', kw_only=True, fn=None)), id=False, te"
    "rse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fPrivateIpAddressSpecification(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            primary=self.primary,
            private_ip_address=self.private_ip_address,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.primary == other.primary and
            self.private_ip_address == other.private_ip_address
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'primary',
        'private_ip_address',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'primary',
        'private_ip_address',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.primary,
            self.private_ip_address,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        primary: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        private_ip_address: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'primary', primary)
        __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"primary={self.primary!r}")
        parts.append(f"private_ip_address={self.private_ip_address!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('product_code_id', 'product_code_type')), EqPlan(fields=('product_code_id', 'product_c"
    "ode_type')), FrozenPlan(fields=('__shape__', 'product_code_id', 'product_code_type'), allow_dynamic_dunder_attrs=F"
    "alse), HashPlan(action='add', fields=('product_code_id', 'product_code_type'), cache=False), InitPlan(fields=(Init"
    "Plan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None"
    ", init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPla"
    "n.Field(name='product_code_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields"
    ".1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None), InitPlan.Field(name='product_code_type', annotation=OpRef(name='init.fields.2.annotation"
    "'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('p"
    "roduct_code_id', 'product_code_type'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns="
    "()), ReprPlan(fields=(ReprPlan.Field(name='product_code_id', kw_only=True, fn=None), ReprPlan.Field(name='product_"
    "code_type', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fProductCode(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            product_code_id=self.product_code_id,
            product_code_type=self.product_code_type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.product_code_id == other.product_code_id and
            self.product_code_type == other.product_code_type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'product_code_id',
        'product_code_type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'product_code_id',
        'product_code_type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.product_code_id,
            self.product_code_type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        product_code_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        product_code_type: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'product_code_id', product_code_id)
        __dataclass__object_setattr(self, 'product_code_type', product_code_type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"product_code_id={self.product_code_id!r}")
        parts.append(f"product_code_type={self.product_code_type!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('gateway_id',)), EqPlan(fields=('gateway_id',)), FrozenPlan(fields=('__shape__', 'gate"
    "way_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('gateway_id',), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default"
    "_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='gateway_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='ini"
    "t.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('gateway_id',), frozen=True, "
    "slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='gateway_i"
    "d', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fPropagatingVgw(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            gateway_id=self.gateway_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.gateway_id == other.gateway_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'gateway_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'gateway_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.gateway_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        gateway_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'gateway_id', gateway_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"gateway_id={self.gateway_id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('dns_hostname_type', 'public_ipv4_dns_name', 'public_ipv6_dns_name', 'public_dual_stac"
    "k_dns_name')), EqPlan(fields=('dns_hostname_type', 'public_ipv4_dns_name', 'public_ipv6_dns_name', 'public_dual_st"
    "ack_dns_name')), FrozenPlan(fields=('__shape__', 'dns_hostname_type', 'public_ipv4_dns_name', 'public_ipv6_dns_nam"
    "e', 'public_dual_stack_dns_name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('dns_hostname"
    "_type', 'public_ipv4_dns_name', 'public_ipv6_dns_name', 'public_dual_stack_dns_name'), cache=False), InitPlan(fiel"
    "ds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='dns_hostname_type', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='i"
    "nit.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
    "e, validate=None, check_type=None), InitPlan.Field(name='public_ipv4_dns_name', annotation=OpRef(name='init.fields"
    ".2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_ipv6_dns_nam"
    "e', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factor"
    "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
    "itPlan.Field(name='public_dual_stack_dns_name', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(n"
    "ame='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
    "ce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('dns_hostname_type', "
    "'public_ipv4_dns_name', 'public_ipv6_dns_name', 'public_dual_stack_dns_name'), frozen=True, slots=False, post_init"
    "_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='dns_hostname_type', kw_only=Tru"
    "e, fn=None), ReprPlan.Field(name='public_ipv4_dns_name', kw_only=True, fn=None), ReprPlan.Field(name='public_ipv6_"
    "dns_name', kw_only=True, fn=None), ReprPlan.Field(name='public_dual_stack_dns_name', kw_only=True, fn=None)), id=F"
    "alse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fPublicIpDnsNameOptions(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            dns_hostname_type=self.dns_hostname_type,
            public_ipv4_dns_name=self.public_ipv4_dns_name,
            public_ipv6_dns_name=self.public_ipv6_dns_name,
            public_dual_stack_dns_name=self.public_dual_stack_dns_name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.dns_hostname_type == other.dns_hostname_type and
            self.public_ipv4_dns_name == other.public_ipv4_dns_name and
            self.public_ipv6_dns_name == other.public_ipv6_dns_name and
            self.public_dual_stack_dns_name == other.public_dual_stack_dns_name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'dns_hostname_type',
        'public_ipv4_dns_name',
        'public_ipv6_dns_name',
        'public_dual_stack_dns_name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'dns_hostname_type',
        'public_ipv4_dns_name',
        'public_ipv6_dns_name',
        'public_dual_stack_dns_name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.dns_hostname_type,
            self.public_ipv4_dns_name,
            self.public_ipv6_dns_name,
            self.public_dual_stack_dns_name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        dns_hostname_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        public_ipv4_dns_name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        public_ipv6_dns_name: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        public_dual_stack_dns_name: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'dns_hostname_type', dns_hostname_type)
        __dataclass__object_setattr(self, 'public_ipv4_dns_name', public_ipv4_dns_name)
        __dataclass__object_setattr(self, 'public_ipv6_dns_name', public_ipv6_dns_name)
        __dataclass__object_setattr(self, 'public_dual_stack_dns_name', public_dual_stack_dns_name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"dns_hostname_type={self.dns_hostname_type!r}")
        parts.append(f"public_ipv4_dns_name={self.public_ipv4_dns_name!r}")
        parts.append(f"public_ipv6_dns_name={self.public_ipv6_dns_name!r}")
        parts.append(f"public_dual_stack_dns_name={self.public_dual_stack_dns_name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('destination_cidr_block', 'destination_ipv6_cidr_block', 'destination_prefix_list_id',"
    " 'egress_only_internet_gateway_id', 'gateway_id', 'instance_id', 'instance_owner_id', 'nat_gateway_id', 'transit_g"
    "ateway_id', 'local_gateway_id', 'carrier_gateway_id', 'network_interface_id', 'origin', 'state', 'vpc_peering_conn"
    "ection_id', 'core_network_arn', 'odb_network_arn', 'ip_address')), EqPlan(fields=('destination_cidr_block', 'desti"
    "nation_ipv6_cidr_block', 'destination_prefix_list_id', 'egress_only_internet_gateway_id', 'gateway_id', 'instance_"
    "id', 'instance_owner_id', 'nat_gateway_id', 'transit_gateway_id', 'local_gateway_id', 'carrier_gateway_id', 'netwo"
    "rk_interface_id', 'origin', 'state', 'vpc_peering_connection_id', 'core_network_arn', 'odb_network_arn', 'ip_addre"
    "ss')), FrozenPlan(fields=('__shape__', 'destination_cidr_block', 'destination_ipv6_cidr_block', 'destination_prefi"
    "x_list_id', 'egress_only_internet_gateway_id', 'gateway_id', 'instance_id', 'instance_owner_id', 'nat_gateway_id',"
    " 'transit_gateway_id', 'local_gateway_id', 'carrier_gateway_id', 'network_interface_id', 'origin', 'state', 'vpc_p"
    "eering_connection_id', 'core_network_arn', 'odb_network_arn', 'ip_address'), allow_dynamic_dunder_attrs=False), Ha"
    "shPlan(action='add', fields=('destination_cidr_block', 'destination_ipv6_cidr_block', 'destination_prefix_list_id'"
    ", 'egress_only_internet_gateway_id', 'gateway_id', 'instance_id', 'instance_owner_id', 'nat_gateway_id', 'transit_"
    "gateway_id', 'local_gateway_id', 'carrier_gateway_id', 'network_interface_id', 'origin', 'state', 'vpc_peering_con"
    "nection_id', 'core_network_arn', 'odb_network_arn', 'ip_address'), cache=False), InitPlan(fields=(InitPlan.Field(n"
    "ame='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True,"
    " override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='destination_cidr_block', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None), InitPlan.Field(name='destination_ipv6_cidr_block', annotation=OpRef(name='init.fields.2.annot"
    "ation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type="
    "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='destination_prefix_list_id'"
    ", annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='egress_only_internet_gateway_id', annotation=OpRef(name='init.fields.4.annotation'), default=OpRe"
    "f(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='gateway_id', annotation=OpRef(name='init.fields."
    "5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_id', annota"
    "tion=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='instance_owner_id', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='nat_gateway_id', annotation=OpRef(name='init.fields.8.annotation'), de"
    "fault=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
    "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='transit_gateway_id', annotation=OpRef("
    "name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, ov"
    "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='lo"
    "cal_gateway_id', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'),"
    " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
    "_type=None), InitPlan.Field(name='carrier_gateway_id', annotation=OpRef(name='init.fields.11.annotation'), default"
    "=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
    "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_interface_id', annotation=OpRef(na"
    "me='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True, ov"
    "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='or"
    "igin', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='state', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.field"
    "s.14.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='vpc_peering_connection_id', annotation=OpRef(name='init.fields.15"
    ".annotation'), default=OpRef(name='init.fields.15.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='core_network_arn', a"
    "nnotation=OpRef(name='init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_factory=N"
    "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
    "lan.Field(name='odb_network_arn', annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fie"
    "lds.17.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='ip_address', annotation=OpRef(name='init.fields.18.annotation')"
    ", default=OpRef(name='init.fields.18.default'), default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('de"
    "stination_cidr_block', 'destination_ipv6_cidr_block', 'destination_prefix_list_id', 'egress_only_internet_gateway_"
    "id', 'gateway_id', 'instance_id', 'instance_owner_id', 'nat_gateway_id', 'transit_gateway_id', 'local_gateway_id',"
    " 'carrier_gateway_id', 'network_interface_id', 'origin', 'state', 'vpc_peering_connection_id', 'core_network_arn',"
    " 'odb_network_arn', 'ip_address'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
    " ReprPlan(fields=(ReprPlan.Field(name='destination_cidr_block', kw_only=True, fn=None), ReprPlan.Field(name='desti"
    "nation_ipv6_cidr_block', kw_only=True, fn=None), ReprPlan.Field(name='destination_prefix_list_id', kw_only=True, f"
    "n=None), ReprPlan.Field(name='egress_only_internet_gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='gatew"
    "ay_id', kw_only=True, fn=None), ReprPlan.Field(name='instance_id', kw_only=True, fn=None), ReprPlan.Field(name='in"
    "stance_owner_id', kw_only=True, fn=None), ReprPlan.Field(name='nat_gateway_id', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='transit_gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='local_gateway_id', kw_only=True, fn=N"
    "one), ReprPlan.Field(name='carrier_gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='network_interface_id'"
    ", kw_only=True, fn=None), ReprPlan.Field(name='origin', kw_only=True, fn=None), ReprPlan.Field(name='state', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='vpc_peering_connection_id', kw_only=True, fn=None), ReprPlan.Field(name='c"
    "ore_network_arn', kw_only=True, fn=None), ReprPlan.Field(name='odb_network_arn', kw_only=True, fn=None), ReprPlan."
    "Field(name='ip_address', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fRoute(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            destination_cidr_block=self.destination_cidr_block,
            destination_ipv6_cidr_block=self.destination_ipv6_cidr_block,
            destination_prefix_list_id=self.destination_prefix_list_id,
            egress_only_internet_gateway_id=self.egress_only_internet_gateway_id,
            gateway_id=self.gateway_id,
            instance_id=self.instance_id,
            instance_owner_id=self.instance_owner_id,
            nat_gateway_id=self.nat_gateway_id,
            transit_gateway_id=self.transit_gateway_id,
            local_gateway_id=self.local_gateway_id,
            carrier_gateway_id=self.carrier_gateway_id,
            network_interface_id=self.network_interface_id,
            origin=self.origin,
            state=self.state,
            vpc_peering_connection_id=self.vpc_peering_connection_id,
            core_network_arn=self.core_network_arn,
            odb_network_arn=self.odb_network_arn,
            ip_address=self.ip_address,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.destination_cidr_block == other.destination_cidr_block and
            self.destination_ipv6_cidr_block == other.destination_ipv6_cidr_block and
            self.destination_prefix_list_id == other.destination_prefix_list_id and
            self.egress_only_internet_gateway_id == other.egress_only_internet_gateway_id and
            self.gateway_id == other.gateway_id and
            self.instance_id == other.instance_id and
            self.instance_owner_id == other.instance_owner_id and
            self.nat_gateway_id == other.nat_gateway_id and
            self.transit_gateway_id == other.transit_gateway_id and
            self.local_gateway_id == other.local_gateway_id and
            self.carrier_gateway_id == other.carrier_gateway_id and
            self.network_interface_id == other.network_interface_id and
            self.origin == other.origin and
            self.state == other.state and
            self.vpc_peering_connection_id == other.vpc_peering_connection_id and
            self.core_network_arn == other.core_network_arn and
            self.odb_network_arn == other.odb_network_arn and
            self.ip_address == other.ip_address
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'destination_cidr_block',
        'destination_ipv6_cidr_block',
        'destination_prefix_list_id',
        'egress_only_internet_gateway_id',
        'gateway_id',
        'instance_id',
        'instance_owner_id',
        'nat_gateway_id',
        'transit_gateway_id',
        'local_gateway_id',
        'carrier_gateway_id',
        'network_interface_id',
        'origin',
        'state',
        'vpc_peering_connection_id',
        'core_network_arn',
        'odb_network_arn',
        'ip_address',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'destination_cidr_block',
        'destination_ipv6_cidr_block',
        'destination_prefix_list_id',
        'egress_only_internet_gateway_id',
        'gateway_id',
        'instance_id',
        'instance_owner_id',
        'nat_gateway_id',
        'transit_gateway_id',
        'local_gateway_id',
        'carrier_gateway_id',
        'network_interface_id',
        'origin',
        'state',
        'vpc_peering_connection_id',
        'core_network_arn',
        'odb_network_arn',
        'ip_address',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.destination_cidr_block,
            self.destination_ipv6_cidr_block,
            self.destination_prefix_list_id,
            self.egress_only_internet_gateway_id,
            self.gateway_id,
            self.instance_id,
            self.instance_owner_id,
            self.nat_gateway_id,
            self.transit_gateway_id,
            self.local_gateway_id,
            self.carrier_gateway_id,
            self.network_interface_id,
            self.origin,
            self.state,
            self.vpc_peering_connection_id,
            self.core_network_arn,
            self.odb_network_arn,
            self.ip_address,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        destination_cidr_block: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        destination_ipv6_cidr_block: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        destination_prefix_list_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        egress_only_internet_gateway_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        gateway_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        instance_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        instance_owner_id: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        nat_gateway_id: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        transit_gateway_id: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        local_gateway_id: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        carrier_gateway_id: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        network_interface_id: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        origin: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        state: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        vpc_peering_connection_id: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        core_network_arn: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        odb_network_arn: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        ip_address: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'destination_cidr_block', destination_cidr_block)
        __dataclass__object_setattr(self, 'destination_ipv6_cidr_block', destination_ipv6_cidr_block)
        __dataclass__object_setattr(self, 'destination_prefix_list_id', destination_prefix_list_id)
        __dataclass__object_setattr(self, 'egress_only_internet_gateway_id', egress_only_internet_gateway_id)
        __dataclass__object_setattr(self, 'gateway_id', gateway_id)
        __dataclass__object_setattr(self, 'instance_id', instance_id)
        __dataclass__object_setattr(self, 'instance_owner_id', instance_owner_id)
        __dataclass__object_setattr(self, 'nat_gateway_id', nat_gateway_id)
        __dataclass__object_setattr(self, 'transit_gateway_id', transit_gateway_id)
        __dataclass__object_setattr(self, 'local_gateway_id', local_gateway_id)
        __dataclass__object_setattr(self, 'carrier_gateway_id', carrier_gateway_id)
        __dataclass__object_setattr(self, 'network_interface_id', network_interface_id)
        __dataclass__object_setattr(self, 'origin', origin)
        __dataclass__object_setattr(self, 'state', state)
        __dataclass__object_setattr(self, 'vpc_peering_connection_id', vpc_peering_connection_id)
        __dataclass__object_setattr(self, 'core_network_arn', core_network_arn)
        __dataclass__object_setattr(self, 'odb_network_arn', odb_network_arn)
        __dataclass__object_setattr(self, 'ip_address', ip_address)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"destination_cidr_block={self.destination_cidr_block!r}")
        parts.append(f"destination_ipv6_cidr_block={self.destination_ipv6_cidr_block!r}")
        parts.append(f"destination_prefix_list_id={self.destination_prefix_list_id!r}")
        parts.append(f"egress_only_internet_gateway_id={self.egress_only_internet_gateway_id!r}")
        parts.append(f"gateway_id={self.gateway_id!r}")
        parts.append(f"instance_id={self.instance_id!r}")
        parts.append(f"instance_owner_id={self.instance_owner_id!r}")
        parts.append(f"nat_gateway_id={self.nat_gateway_id!r}")
        parts.append(f"transit_gateway_id={self.transit_gateway_id!r}")
        parts.append(f"local_gateway_id={self.local_gateway_id!r}")
        parts.append(f"carrier_gateway_id={self.carrier_gateway_id!r}")
        parts.append(f"network_interface_id={self.network_interface_id!r}")
        parts.append(f"origin={self.origin!r}")
        parts.append(f"state={self.state!r}")
        parts.append(f"vpc_peering_connection_id={self.vpc_peering_connection_id!r}")
        parts.append(f"core_network_arn={self.core_network_arn!r}")
        parts.append(f"odb_network_arn={self.odb_network_arn!r}")
        parts.append(f"ip_address={self.ip_address!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('state', 'status_message')), EqPlan(fields=('state', 'status_message')), FrozenPlan(fi"
    "elds=('__shape__', 'state', 'status_message'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('"
    "state', 'status_message'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='"
    "init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CL"
    "ASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state', annotation=OpRef(name='init.fi"
    "elds.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='status_message'"
    ", annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), sel"
    "f_param='self', std_params=(), kw_only_params=('state', 'status_message'), frozen=True, slots=False, post_init_par"
    "ams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='state', kw_only=True, fn=None), Rep"
    "rPlan.Field(name='status_message', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fRouteTableAssociationState(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            state=self.state,
            status_message=self.status_message,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.state == other.state and
            self.status_message == other.status_message
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'state',
        'status_message',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'state',
        'status_message',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.state,
            self.status_message,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        state: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        status_message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'state', state)
        __dataclass__object_setattr(self, 'status_message', status_message)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"state={self.state!r}")
        parts.append(f"status_message={self.status_message!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('enabled',)), EqPlan(fields=('enabled',)), FrozenPlan(fields=('__shape__', 'enabled'),"
    " allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('enabled',), cache=False), InitPlan(fields=(Ini"
    "tPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='enabled', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param="
    "'self', std_params=(), kw_only_params=('enabled',), frozen=True, slots=False, post_init_params=None, init_fns=(), "
    "validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='enabled', kw_only=True, fn=None),), id=False, terse=False,"
    " default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fRunInstancesMonitoringEnabled(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            enabled=self.enabled,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.enabled == other.enabled
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'enabled',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'enabled',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.enabled,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        enabled: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'enabled', enabled)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"enabled={self.enabled!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('max_price', 'spot_instance_type', 'block_duration_minutes', 'valid_until', 'instance_"
    "interruption_behavior')), EqPlan(fields=('max_price', 'spot_instance_type', 'block_duration_minutes', 'valid_until"
    "', 'instance_interruption_behavior')), FrozenPlan(fields=('__shape__', 'max_price', 'spot_instance_type', 'block_d"
    "uration_minutes', 'valid_until', 'instance_interruption_behavior'), allow_dynamic_dunder_attrs=False), HashPlan(ac"
    "tion='add', fields=('max_price', 'spot_instance_type', 'block_duration_minutes', 'valid_until', 'instance_interrup"
    "tion_behavior'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.field"
    "s.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='max_price', annotation=OpRef(name='init.fields.1"
    ".annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field"
    "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='spot_instance_type', "
    "annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='block_duration_minutes', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='ini"
    "t.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None), InitPlan.Field(name='valid_until', annotation=OpRef(name='init.fields.4.annotati"
    "on'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_interruption_behavior"
    "', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory"
    "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), se"
    "lf_param='self', std_params=(), kw_only_params=('max_price', 'spot_instance_type', 'block_duration_minutes', 'vali"
    "d_until', 'instance_interruption_behavior'), frozen=True, slots=False, post_init_params=None, init_fns=(), validat"
    "e_fns=()), ReprPlan(fields=(ReprPlan.Field(name='max_price', kw_only=True, fn=None), ReprPlan.Field(name='spot_ins"
    "tance_type', kw_only=True, fn=None), ReprPlan.Field(name='block_duration_minutes', kw_only=True, fn=None), ReprPla"
    "n.Field(name='valid_until', kw_only=True, fn=None), ReprPlan.Field(name='instance_interruption_behavior', kw_only="
    "True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fSpotMarketOptions(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            max_price=self.max_price,
            spot_instance_type=self.spot_instance_type,
            block_duration_minutes=self.block_duration_minutes,
            valid_until=self.valid_until,
            instance_interruption_behavior=self.instance_interruption_behavior,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.max_price == other.max_price and
            self.spot_instance_type == other.spot_instance_type and
            self.block_duration_minutes == other.block_duration_minutes and
            self.valid_until == other.valid_until and
            self.instance_interruption_behavior == other.instance_interruption_behavior
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'max_price',
        'spot_instance_type',
        'block_duration_minutes',
        'valid_until',
        'instance_interruption_behavior',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'max_price',
        'spot_instance_type',
        'block_duration_minutes',
        'valid_until',
        'instance_interruption_behavior',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.max_price,
            self.spot_instance_type,
            self.block_duration_minutes,
            self.valid_until,
            self.instance_interruption_behavior,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        max_price: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        spot_instance_type: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        block_duration_minutes: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        valid_until: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        instance_interruption_behavior: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'max_price', max_price)
        __dataclass__object_setattr(self, 'spot_instance_type', spot_instance_type)
        __dataclass__object_setattr(self, 'block_duration_minutes', block_duration_minutes)
        __dataclass__object_setattr(self, 'valid_until', valid_until)
        __dataclass__object_setattr(self, 'instance_interruption_behavior', instance_interruption_behavior)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"max_price={self.max_price!r}")
        parts.append(f"spot_instance_type={self.spot_instance_type!r}")
        parts.append(f"block_duration_minutes={self.block_duration_minutes!r}")
        parts.append(f"valid_until={self.valid_until!r}")
        parts.append(f"instance_interruption_behavior={self.instance_interruption_behavior!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('code', 'message')), EqPlan(fields=('code', 'message')), FrozenPlan(fields=('__shape__"
    "', 'code', 'message'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('code', 'message'), cache"
    "=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defa"
    "ult=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='code', annotation=OpRef(name='init.fields.1.annotation'), default=OpRe"
    "f(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='message', annotation=OpRef(name='init.fields.2.a"
    "nnotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_p"
    "arams=('code', 'message'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPla"
    "n(fields=(ReprPlan.Field(name='code', kw_only=True, fn=None), ReprPlan.Field(name='message', kw_only=True, fn=None"
    ")), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fStateReason(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            code=self.code,
            message=self.message,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.code == other.code and
            self.message == other.message
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'code',
        'message',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'code',
        'message',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.code,
            self.message,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        code: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'code', code)
        __dataclass__object_setattr(self, 'message', message)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"code={self.code!r}")
        parts.append(f"message={self.message!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('state', 'status_message')), EqPlan(fields=('state', 'status_message')), FrozenPlan(fi"
    "elds=('__shape__', 'state', 'status_message'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('"
    "state', 'status_message'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='"
    "init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CL"
    "ASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state', annotation=OpRef(name='init.fi"
    "elds.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='status_message'"
    ", annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), sel"
    "f_param='self', std_params=(), kw_only_params=('state', 'status_message'), frozen=True, slots=False, post_init_par"
    "ams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='state', kw_only=True, fn=None), Rep"
    "rPlan.Field(name='status_message', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fSubnetCidrBlockState(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            state=self.state,
            status_message=self.status_message,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.state == other.state and
            self.status_message == other.status_message
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'state',
        'status_message',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'state',
        'status_message',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.state,
            self.status_message,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        state: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        status_message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'state', state)
        __dataclass__object_setattr(self, 'status_message', status_message)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"state={self.state!r}")
        parts.append(f"status_message={self.status_message!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('resource_type', 'tags')), EqPlan(fields=('resource_type', 'tags')), FrozenPlan(fields"
    "=('__shape__', 'resource_type', 'tags'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('resour"
    "ce_type', 'tags'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fie"
    "lds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='resource_type', annotation=OpRef(name='init.fi"
    "elds.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags', annotati"
    "on=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='s"
    "elf', std_params=(), kw_only_params=('resource_type', 'tags'), frozen=True, slots=False, post_init_params=None, in"
    "it_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='resource_type', kw_only=True, fn=None), ReprPla"
    "n.Field(name='tags', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fTagSpecification(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            resource_type=self.resource_type,
            tags=self.tags,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.resource_type == other.resource_type and
            self.tags == other.tags
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'resource_type',
        'tags',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'resource_type',
        'tags',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.resource_type,
            self.tags,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        resource_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        tags: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'resource_type', resource_type)
        __dataclass__object_setattr(self, 'tags', tags)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"resource_type={self.resource_type!r}")
        parts.append(f"tags={self.tags!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('description', 'user_id', 'group_name', 'group_id', 'vpc_id', 'vpc_peering_connection_"
    "id', 'peering_status')), EqPlan(fields=('description', 'user_id', 'group_name', 'group_id', 'vpc_id', 'vpc_peering"
    "_connection_id', 'peering_status')), FrozenPlan(fields=('__shape__', 'description', 'user_id', 'group_name', 'grou"
    "p_id', 'vpc_id', 'vpc_peering_connection_id', 'peering_status'), allow_dynamic_dunder_attrs=False), HashPlan(actio"
    "n='add', fields=('description', 'user_id', 'group_name', 'group_id', 'vpc_id', 'vpc_peering_connection_id', 'peeri"
    "ng_status'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0."
    "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='description', annotation=OpRef(name='init.fields.1.a"
    "nnotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='user_id', annotation=Op"
    "Ref(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True"
    ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='group_name', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='group_id', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='in"
    "it.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
    ", validate=None, check_type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.5.annotation')"
    ", default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
    "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_peering_connection_id', annota"
    "tion=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='peering_status', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
    ", check_type=None)), self_param='self', std_params=(), kw_only_params=('description', 'user_id', 'group_name', 'gr"
    "oup_id', 'vpc_id', 'vpc_peering_connection_id', 'peering_status'), frozen=True, slots=False, post_init_params=None"
    ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='description', kw_only=True, fn=None), ReprP"
    "lan.Field(name='user_id', kw_only=True, fn=None), ReprPlan.Field(name='group_name', kw_only=True, fn=None), ReprPl"
    "an.Field(name='group_id', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='vpc_peering_connection_id', kw_only=True, fn=None), ReprPlan.Field(name='peering_status', kw_only=True,"
    " fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fUserIdGroupPair(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            description=self.description,
            user_id=self.user_id,
            group_name=self.group_name,
            group_id=self.group_id,
            vpc_id=self.vpc_id,
            vpc_peering_connection_id=self.vpc_peering_connection_id,
            peering_status=self.peering_status,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.description == other.description and
            self.user_id == other.user_id and
            self.group_name == other.group_name and
            self.group_id == other.group_id and
            self.vpc_id == other.vpc_id and
            self.vpc_peering_connection_id == other.vpc_peering_connection_id and
            self.peering_status == other.peering_status
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'description',
        'user_id',
        'group_name',
        'group_id',
        'vpc_id',
        'vpc_peering_connection_id',
        'peering_status',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'description',
        'user_id',
        'group_name',
        'group_id',
        'vpc_id',
        'vpc_peering_connection_id',
        'peering_status',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.description,
            self.user_id,
            self.group_name,
            self.group_id,
            self.vpc_id,
            self.vpc_peering_connection_id,
            self.peering_status,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        description: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        user_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        group_name: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        group_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        vpc_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        vpc_peering_connection_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        peering_status: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'user_id', user_id)
        __dataclass__object_setattr(self, 'group_name', group_name)
        __dataclass__object_setattr(self, 'group_id', group_id)
        __dataclass__object_setattr(self, 'vpc_id', vpc_id)
        __dataclass__object_setattr(self, 'vpc_peering_connection_id', vpc_peering_connection_id)
        __dataclass__object_setattr(self, 'peering_status', peering_status)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"description={self.description!r}")
        parts.append(f"user_id={self.user_id!r}")
        parts.append(f"group_name={self.group_name!r}")
        parts.append(f"group_id={self.group_id!r}")
        parts.append(f"vpc_id={self.vpc_id!r}")
        parts.append(f"vpc_peering_connection_id={self.vpc_peering_connection_id!r}")
        parts.append(f"peering_status={self.peering_status!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('state', 'status_message')), EqPlan(fields=('state', 'status_message')), FrozenPlan(fi"
    "elds=('__shape__', 'state', 'status_message'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('"
    "state', 'status_message'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='"
    "init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CL"
    "ASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state', annotation=OpRef(name='init.fi"
    "elds.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='status_message'"
    ", annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), sel"
    "f_param='self', std_params=(), kw_only_params=('state', 'status_message'), frozen=True, slots=False, post_init_par"
    "ams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='state', kw_only=True, fn=None), Rep"
    "rPlan.Field(name='status_message', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fVpcCidrBlockState(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            state=self.state,
            status_message=self.status_message,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.state == other.state and
            self.status_message == other.status_message
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'state',
        'status_message',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'state',
        'status_message',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.state,
            self.status_message,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        state: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        status_message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'state', state)
        __dataclass__object_setattr(self, 'status_message', status_message)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"state={self.state!r}")
        parts.append(f"status_message={self.status_message!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('state', 'state_message')), EqPlan(fields=('state', 'state_message')), FrozenPlan(fiel"
    "ds=('__shape__', 'state', 'state_message'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('sta"
    "te', 'state_message'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init"
    ".fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_"
    "VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state', annotation=OpRef(name='init.fields"
    ".1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state_message', ann"
    "otation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None,"
    " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_par"
    "am='self', std_params=(), kw_only_params=('state', 'state_message'), frozen=True, slots=False, post_init_params=No"
    "ne, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='state', kw_only=True, fn=None), ReprPlan."
    "Field(name='state_message', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fVpcEncryptionControlExclusion(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            state=self.state,
            state_message=self.state_message,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.state == other.state and
            self.state_message == other.state_message
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'state',
        'state_message',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'state',
        'state_message',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.state,
            self.state_message,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        state: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        state_message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'state', state)
        __dataclass__object_setattr(self, 'state_message', state_message)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"state={self.state!r}")
        parts.append(f"state_message={self.state_message!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ena_srd_enabled', 'ena_srd_udp_specification')), EqPlan(fields=('ena_srd_enabled', 'e"
    "na_srd_udp_specification')), FrozenPlan(fields=('__shape__', 'ena_srd_enabled', 'ena_srd_udp_specification'), allo"
    "w_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ena_srd_enabled', 'ena_srd_udp_specification'), cac"
    "he=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), de"
    "fault=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='ena_srd_enabled', annotation=OpRef(name='init.fields.1.annotation'),"
    " default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_srd_udp_specification', annotat"
    "ion=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='"
    "self', std_params=(), kw_only_params=('ena_srd_enabled', 'ena_srd_udp_specification'), frozen=True, slots=False, p"
    "ost_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ena_srd_enabled', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='ena_srd_udp_specification', kw_only=True, fn=None)), id=False, terse=False"
    ", default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fAttachmentEnaSrdSpecification(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ena_srd_enabled=self.ena_srd_enabled,
            ena_srd_udp_specification=self.ena_srd_udp_specification,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ena_srd_enabled == other.ena_srd_enabled and
            self.ena_srd_udp_specification == other.ena_srd_udp_specification
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'ena_srd_enabled',
        'ena_srd_udp_specification',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'ena_srd_enabled',
        'ena_srd_udp_specification',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ena_srd_enabled,
            self.ena_srd_udp_specification,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ena_srd_enabled: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ena_srd_udp_specification: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ena_srd_enabled', ena_srd_enabled)
        __dataclass__object_setattr(self, 'ena_srd_udp_specification', ena_srd_udp_specification)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ena_srd_enabled={self.ena_srd_enabled!r}")
        parts.append(f"ena_srd_udp_specification={self.ena_srd_udp_specification!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ebs', 'no_device', 'device_name', 'virtual_name')), EqPlan(fields=('ebs', 'no_device'"
    ", 'device_name', 'virtual_name')), FrozenPlan(fields=('__shape__', 'ebs', 'no_device', 'device_name', 'virtual_nam"
    "e'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ebs', 'no_device', 'device_name', 'virtual"
    "_name'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.anno"
    "tation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=No"
    "ne, validate=None, check_type=None), InitPlan.Field(name='ebs', annotation=OpRef(name='init.fields.1.annotation'),"
    " default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='no_device', annotation=OpRef(name='"
    "init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='device_n"
    "ame', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
    "InitPlan.Field(name='virtual_name', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fi"
    "elds.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('ebs', 'no_device', 'device_name'"
    ", 'virtual_name'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields"
    "=(ReprPlan.Field(name='ebs', kw_only=True, fn=None), ReprPlan.Field(name='no_device', kw_only=True, fn=None), Repr"
    "Plan.Field(name='device_name', kw_only=True, fn=None), ReprPlan.Field(name='virtual_name', kw_only=True, fn=None))"
    ", id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fBlockDeviceMapping(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ebs=self.ebs,
            no_device=self.no_device,
            device_name=self.device_name,
            virtual_name=self.virtual_name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ebs == other.ebs and
            self.no_device == other.no_device and
            self.device_name == other.device_name and
            self.virtual_name == other.virtual_name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'ebs',
        'no_device',
        'device_name',
        'virtual_name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'ebs',
        'no_device',
        'device_name',
        'virtual_name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ebs,
            self.no_device,
            self.device_name,
            self.virtual_name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ebs: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        no_device: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        device_name: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        virtual_name: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ebs', ebs)
        __dataclass__object_setattr(self, 'no_device', no_device)
        __dataclass__object_setattr(self, 'device_name', device_name)
        __dataclass__object_setattr(self, 'virtual_name', virtual_name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ebs={self.ebs!r}")
        parts.append(f"no_device={self.no_device!r}")
        parts.append(f"device_name={self.device_name!r}")
        parts.append(f"virtual_name={self.virtual_name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('capacity_reservation_preference', 'capacity_reservation_target')), EqPlan(fields=('ca"
    "pacity_reservation_preference', 'capacity_reservation_target')), FrozenPlan(fields=('__shape__', 'capacity_reserva"
    "tion_preference', 'capacity_reservation_target'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields"
    "=('capacity_reservation_preference', 'capacity_reservation_target'), cache=False), InitPlan(fields=(InitPlan.Field"
    "(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=Tru"
    "e, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='capacity_reservation_preference', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init."
    "fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None), InitPlan.Field(name='capacity_reservation_target', annotation=OpRef(name='init.fie"
    "lds.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw"
    "_only_params=('capacity_reservation_preference', 'capacity_reservation_target'), frozen=True, slots=False, post_in"
    "it_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='capacity_reservation_preferen"
    "ce', kw_only=True, fn=None), ReprPlan.Field(name='capacity_reservation_target', kw_only=True, fn=None)), id=False,"
    " terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fCapacityReservationSpecification(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            capacity_reservation_preference=self.capacity_reservation_preference,
            capacity_reservation_target=self.capacity_reservation_target,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.capacity_reservation_preference == other.capacity_reservation_preference and
            self.capacity_reservation_target == other.capacity_reservation_target
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'capacity_reservation_preference',
        'capacity_reservation_target',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'capacity_reservation_preference',
        'capacity_reservation_target',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.capacity_reservation_preference,
            self.capacity_reservation_target,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        capacity_reservation_preference: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        capacity_reservation_target: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'capacity_reservation_preference', capacity_reservation_preference)
        __dataclass__object_setattr(self, 'capacity_reservation_target', capacity_reservation_target)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"capacity_reservation_preference={self.capacity_reservation_preference!r}")
        parts.append(f"capacity_reservation_target={self.capacity_reservation_target!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('capacity_reservation_preference', 'capacity_reservation_target')), EqPlan(fields=('ca"
    "pacity_reservation_preference', 'capacity_reservation_target')), FrozenPlan(fields=('__shape__', 'capacity_reserva"
    "tion_preference', 'capacity_reservation_target'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields"
    "=('capacity_reservation_preference', 'capacity_reservation_target'), cache=False), InitPlan(fields=(InitPlan.Field"
    "(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=Tru"
    "e, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='capacity_reservation_preference', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init."
    "fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None), InitPlan.Field(name='capacity_reservation_target', annotation=OpRef(name='init.fie"
    "lds.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw"
    "_only_params=('capacity_reservation_preference', 'capacity_reservation_target'), frozen=True, slots=False, post_in"
    "it_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='capacity_reservation_preferen"
    "ce', kw_only=True, fn=None), ReprPlan.Field(name='capacity_reservation_target', kw_only=True, fn=None)), id=False,"
    " terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fCapacityReservationSpecificationResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            capacity_reservation_preference=self.capacity_reservation_preference,
            capacity_reservation_target=self.capacity_reservation_target,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.capacity_reservation_preference == other.capacity_reservation_preference and
            self.capacity_reservation_target == other.capacity_reservation_target
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'capacity_reservation_preference',
        'capacity_reservation_target',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'capacity_reservation_preference',
        'capacity_reservation_target',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.capacity_reservation_preference,
            self.capacity_reservation_target,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        capacity_reservation_preference: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        capacity_reservation_target: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'capacity_reservation_preference', capacity_reservation_preference)
        __dataclass__object_setattr(self, 'capacity_reservation_target', capacity_reservation_target)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"capacity_reservation_preference={self.capacity_reservation_preference!r}")
        parts.append(f"capacity_reservation_target={self.capacity_reservation_target!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ebs_optimized_support', 'encryption_support', 'ebs_optimized_info', 'nvme_support', '"
    "maximum_ebs_attachments', 'attachment_limit_type')), EqPlan(fields=('ebs_optimized_support', 'encryption_support',"
    " 'ebs_optimized_info', 'nvme_support', 'maximum_ebs_attachments', 'attachment_limit_type')), FrozenPlan(fields=('_"
    "_shape__', 'ebs_optimized_support', 'encryption_support', 'ebs_optimized_info', 'nvme_support', 'maximum_ebs_attac"
    "hments', 'attachment_limit_type'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ebs_optimize"
    "d_support', 'encryption_support', 'ebs_optimized_info', 'nvme_support', 'maximum_ebs_attachments', 'attachment_lim"
    "it_type'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.an"
    "notation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='ebs_optimized_support', annotation=OpRef(name='init.fi"
    "elds.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='encryption_supp"
    "ort', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
    "InitPlan.Field(name='ebs_optimized_info', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='i"
    "nit.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
    "e, validate=None, check_type=None), InitPlan.Field(name='nvme_support', annotation=OpRef(name='init.fields.4.annot"
    "ation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type="
    "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maximum_ebs_attachments', a"
    "nnotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
    "n.Field(name='attachment_limit_type', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init."
    "fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('ebs_optimized_support', 'encry"
    "ption_support', 'ebs_optimized_info', 'nvme_support', 'maximum_ebs_attachments', 'attachment_limit_type'), frozen="
    "True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ebs"
    "_optimized_support', kw_only=True, fn=None), ReprPlan.Field(name='encryption_support', kw_only=True, fn=None), Rep"
    "rPlan.Field(name='ebs_optimized_info', kw_only=True, fn=None), ReprPlan.Field(name='nvme_support', kw_only=True, f"
    "n=None), ReprPlan.Field(name='maximum_ebs_attachments', kw_only=True, fn=None), ReprPlan.Field(name='attachment_li"
    "mit_type', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fEbsInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ebs_optimized_support=self.ebs_optimized_support,
            encryption_support=self.encryption_support,
            ebs_optimized_info=self.ebs_optimized_info,
            nvme_support=self.nvme_support,
            maximum_ebs_attachments=self.maximum_ebs_attachments,
            attachment_limit_type=self.attachment_limit_type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ebs_optimized_support == other.ebs_optimized_support and
            self.encryption_support == other.encryption_support and
            self.ebs_optimized_info == other.ebs_optimized_info and
            self.nvme_support == other.nvme_support and
            self.maximum_ebs_attachments == other.maximum_ebs_attachments and
            self.attachment_limit_type == other.attachment_limit_type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'ebs_optimized_support',
        'encryption_support',
        'ebs_optimized_info',
        'nvme_support',
        'maximum_ebs_attachments',
        'attachment_limit_type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'ebs_optimized_support',
        'encryption_support',
        'ebs_optimized_info',
        'nvme_support',
        'maximum_ebs_attachments',
        'attachment_limit_type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ebs_optimized_support,
            self.encryption_support,
            self.ebs_optimized_info,
            self.nvme_support,
            self.maximum_ebs_attachments,
            self.attachment_limit_type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ebs_optimized_support: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        encryption_support: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ebs_optimized_info: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        nvme_support: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        maximum_ebs_attachments: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        attachment_limit_type: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ebs_optimized_support', ebs_optimized_support)
        __dataclass__object_setattr(self, 'encryption_support', encryption_support)
        __dataclass__object_setattr(self, 'ebs_optimized_info', ebs_optimized_info)
        __dataclass__object_setattr(self, 'nvme_support', nvme_support)
        __dataclass__object_setattr(self, 'maximum_ebs_attachments', maximum_ebs_attachments)
        __dataclass__object_setattr(self, 'attachment_limit_type', attachment_limit_type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ebs_optimized_support={self.ebs_optimized_support!r}")
        parts.append(f"encryption_support={self.encryption_support!r}")
        parts.append(f"ebs_optimized_info={self.ebs_optimized_info!r}")
        parts.append(f"nvme_support={self.nvme_support!r}")
        parts.append(f"maximum_ebs_attachments={self.maximum_ebs_attachments!r}")
        parts.append(f"attachment_limit_type={self.attachment_limit_type!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('attach_time', 'delete_on_termination', 'status', 'volume_id', 'associated_resource', "
    "'volume_owner_id', 'operator')), EqPlan(fields=('attach_time', 'delete_on_termination', 'status', 'volume_id', 'as"
    "sociated_resource', 'volume_owner_id', 'operator')), FrozenPlan(fields=('__shape__', 'attach_time', 'delete_on_ter"
    "mination', 'status', 'volume_id', 'associated_resource', 'volume_owner_id', 'operator'), allow_dynamic_dunder_attr"
    "s=False), HashPlan(action='add', fields=('attach_time', 'delete_on_termination', 'status', 'volume_id', 'associate"
    "d_resource', 'volume_owner_id', 'operator'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annot"
    "ation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field"
    "_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='attach_time', annota"
    "tion=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='delete_on_termination', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.field"
    "s.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='status', annotation=OpRef(name='init.fields.3.annotation'), defaul"
    "t=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
    "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='volume_id', annotation=OpRef(name='init.fi"
    "elds.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='associated_reso"
    "urce', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='volume_owner_id', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='ini"
    "t.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None), InitPlan.Field(name='operator', annotation=OpRef(name='init.fields.7.annotation'"
    "), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('at"
    "tach_time', 'delete_on_termination', 'status', 'volume_id', 'associated_resource', 'volume_owner_id', 'operator'),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(n"
    "ame='attach_time', kw_only=True, fn=None), ReprPlan.Field(name='delete_on_termination', kw_only=True, fn=None), Re"
    "prPlan.Field(name='status', kw_only=True, fn=None), ReprPlan.Field(name='volume_id', kw_only=True, fn=None), ReprP"
    "lan.Field(name='associated_resource', kw_only=True, fn=None), ReprPlan.Field(name='volume_owner_id', kw_only=True,"
    " fn=None), ReprPlan.Field(name='operator', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fEbsInstanceBlockDevice(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            attach_time=self.attach_time,
            delete_on_termination=self.delete_on_termination,
            status=self.status,
            volume_id=self.volume_id,
            associated_resource=self.associated_resource,
            volume_owner_id=self.volume_owner_id,
            operator=self.operator,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.attach_time == other.attach_time and
            self.delete_on_termination == other.delete_on_termination and
            self.status == other.status and
            self.volume_id == other.volume_id and
            self.associated_resource == other.associated_resource and
            self.volume_owner_id == other.volume_owner_id and
            self.operator == other.operator
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'attach_time',
        'delete_on_termination',
        'status',
        'volume_id',
        'associated_resource',
        'volume_owner_id',
        'operator',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'attach_time',
        'delete_on_termination',
        'status',
        'volume_id',
        'associated_resource',
        'volume_owner_id',
        'operator',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.attach_time,
            self.delete_on_termination,
            self.status,
            self.volume_id,
            self.associated_resource,
            self.volume_owner_id,
            self.operator,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        attach_time: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        delete_on_termination: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        status: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        volume_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        associated_resource: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        volume_owner_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        operator: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'attach_time', attach_time)
        __dataclass__object_setattr(self, 'delete_on_termination', delete_on_termination)
        __dataclass__object_setattr(self, 'status', status)
        __dataclass__object_setattr(self, 'volume_id', volume_id)
        __dataclass__object_setattr(self, 'associated_resource', associated_resource)
        __dataclass__object_setattr(self, 'volume_owner_id', volume_owner_id)
        __dataclass__object_setattr(self, 'operator', operator)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"attach_time={self.attach_time!r}")
        parts.append(f"delete_on_termination={self.delete_on_termination!r}")
        parts.append(f"status={self.status!r}")
        parts.append(f"volume_id={self.volume_id!r}")
        parts.append(f"associated_resource={self.associated_resource!r}")
        parts.append(f"volume_owner_id={self.volume_owner_id!r}")
        parts.append(f"operator={self.operator!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ena_srd_enabled', 'ena_srd_udp_specification')), EqPlan(fields=('ena_srd_enabled', 'e"
    "na_srd_udp_specification')), FrozenPlan(fields=('__shape__', 'ena_srd_enabled', 'ena_srd_udp_specification'), allo"
    "w_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ena_srd_enabled', 'ena_srd_udp_specification'), cac"
    "he=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), de"
    "fault=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='ena_srd_enabled', annotation=OpRef(name='init.fields.1.annotation'),"
    " default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_srd_udp_specification', annotat"
    "ion=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='"
    "self', std_params=(), kw_only_params=('ena_srd_enabled', 'ena_srd_udp_specification'), frozen=True, slots=False, p"
    "ost_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ena_srd_enabled', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='ena_srd_udp_specification', kw_only=True, fn=None)), id=False, terse=False"
    ", default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fEnaSrdSpecificationRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ena_srd_enabled=self.ena_srd_enabled,
            ena_srd_udp_specification=self.ena_srd_udp_specification,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ena_srd_enabled == other.ena_srd_enabled and
            self.ena_srd_udp_specification == other.ena_srd_udp_specification
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'ena_srd_enabled',
        'ena_srd_udp_specification',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'ena_srd_enabled',
        'ena_srd_udp_specification',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ena_srd_enabled,
            self.ena_srd_udp_specification,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ena_srd_enabled: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ena_srd_udp_specification: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ena_srd_enabled', ena_srd_enabled)
        __dataclass__object_setattr(self, 'ena_srd_udp_specification', ena_srd_udp_specification)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ena_srd_enabled={self.ena_srd_enabled!r}")
        parts.append(f"ena_srd_udp_specification={self.ena_srd_udp_specification!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'values')), EqPlan(fields=('name', 'values')), FrozenPlan(fields=('__shape__',"
    " 'name', 'values'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'values'), cache=Fal"
    "se), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default="
    "None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(na"
    "me='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='values', annotation=OpRef(name='init.fields.2.annota"
    "tion'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=F"
    "ieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params"
    "=('name', 'values'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fiel"
    "ds=(ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='values', kw_only=True, fn=None)), id="
    "False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fFilter(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            values=self.values,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.values == other.values
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'name',
        'values',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'name',
        'values',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.values,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        values: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'values', values)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"values={self.values!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'manufacturer', 'count', 'memory_info')), EqPlan(fields=('name', 'manufacturer"
    "', 'count', 'memory_info')), FrozenPlan(fields=('__shape__', 'name', 'manufacturer', 'count', 'memory_info'), allo"
    "w_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'manufacturer', 'count', 'memory_info'), cac"
    "he=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), de"
    "fault=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation'), default=Op"
    "Ref(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='manufacturer', annotation=OpRef(name='init.fie"
    "lds.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='count', annotati"
    "on=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='memory_info', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'"
    "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
    "ck_type=None)), self_param='self', std_params=(), kw_only_params=('name', 'manufacturer', 'count', 'memory_info'),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(n"
    "ame='name', kw_only=True, fn=None), ReprPlan.Field(name='manufacturer', kw_only=True, fn=None), ReprPlan.Field(nam"
    "e='count', kw_only=True, fn=None), ReprPlan.Field(name='memory_info', kw_only=True, fn=None)), id=False, terse=Fal"
    "se, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fFpgaDeviceInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            manufacturer=self.manufacturer,
            count=self.count,
            memory_info=self.memory_info,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.manufacturer == other.manufacturer and
            self.count == other.count and
            self.memory_info == other.memory_info
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'name',
        'manufacturer',
        'count',
        'memory_info',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'name',
        'manufacturer',
        'count',
        'memory_info',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.manufacturer,
            self.count,
            self.memory_info,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        manufacturer: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        count: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        memory_info: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'manufacturer', manufacturer)
        __dataclass__object_setattr(self, 'count', count)
        __dataclass__object_setattr(self, 'memory_info', memory_info)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"manufacturer={self.manufacturer!r}")
        parts.append(f"count={self.count!r}")
        parts.append(f"memory_info={self.memory_info!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'manufacturer', 'count', 'memory_info')), EqPlan(fields=('name', 'manufacturer"
    "', 'count', 'memory_info')), FrozenPlan(fields=('__shape__', 'name', 'manufacturer', 'count', 'memory_info'), allo"
    "w_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'manufacturer', 'count', 'memory_info'), cac"
    "he=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), de"
    "fault=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation'), default=Op"
    "Ref(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='manufacturer', annotation=OpRef(name='init.fie"
    "lds.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='count', annotati"
    "on=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='memory_info', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'"
    "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
    "ck_type=None)), self_param='self', std_params=(), kw_only_params=('name', 'manufacturer', 'count', 'memory_info'),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(n"
    "ame='name', kw_only=True, fn=None), ReprPlan.Field(name='manufacturer', kw_only=True, fn=None), ReprPlan.Field(nam"
    "e='count', kw_only=True, fn=None), ReprPlan.Field(name='memory_info', kw_only=True, fn=None)), id=False, terse=Fal"
    "se, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fGpuDeviceInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            manufacturer=self.manufacturer,
            count=self.count,
            memory_info=self.memory_info,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.manufacturer == other.manufacturer and
            self.count == other.count and
            self.memory_info == other.memory_info
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'name',
        'manufacturer',
        'count',
        'memory_info',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'name',
        'manufacturer',
        'count',
        'memory_info',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.manufacturer,
            self.count,
            self.memory_info,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        manufacturer: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        count: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        memory_info: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'manufacturer', manufacturer)
        __dataclass__object_setattr(self, 'count', count)
        __dataclass__object_setattr(self, 'memory_info', memory_info)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"manufacturer={self.manufacturer!r}")
        parts.append(f"count={self.count!r}")
        parts.append(f"memory_info={self.memory_info!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('count', 'name', 'manufacturer', 'memory_info')), EqPlan(fields=('count', 'name', 'man"
    "ufacturer', 'memory_info')), FrozenPlan(fields=('__shape__', 'count', 'name', 'manufacturer', 'memory_info'), allo"
    "w_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('count', 'name', 'manufacturer', 'memory_info'), cac"
    "he=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), de"
    "fault=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='count', annotation=OpRef(name='init.fields.1.annotation'), default=O"
    "pRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
    ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.2.a"
    "nnotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='manufacturer', annotati"
    "on=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='memory_info', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'"
    "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
    "ck_type=None)), self_param='self', std_params=(), kw_only_params=('count', 'name', 'manufacturer', 'memory_info'),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(n"
    "ame='count', kw_only=True, fn=None), ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='manu"
    "facturer', kw_only=True, fn=None), ReprPlan.Field(name='memory_info', kw_only=True, fn=None)), id=False, terse=Fal"
    "se, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInferenceDeviceInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            count=self.count,
            name=self.name,
            manufacturer=self.manufacturer,
            memory_info=self.memory_info,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.count == other.count and
            self.name == other.name and
            self.manufacturer == other.manufacturer and
            self.memory_info == other.memory_info
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'count',
        'name',
        'manufacturer',
        'memory_info',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'count',
        'name',
        'manufacturer',
        'memory_info',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.count,
            self.name,
            self.manufacturer,
            self.memory_info,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        count: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        manufacturer: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        memory_info: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'count', count)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'manufacturer', manufacturer)
        __dataclass__object_setattr(self, 'memory_info', memory_info)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"count={self.count!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"manufacturer={self.manufacturer!r}")
        parts.append(f"memory_info={self.memory_info!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ena_srd_enabled', 'ena_srd_udp_specification')), EqPlan(fields=('ena_srd_enabled', 'e"
    "na_srd_udp_specification')), FrozenPlan(fields=('__shape__', 'ena_srd_enabled', 'ena_srd_udp_specification'), allo"
    "w_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ena_srd_enabled', 'ena_srd_udp_specification'), cac"
    "he=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), de"
    "fault=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='ena_srd_enabled', annotation=OpRef(name='init.fields.1.annotation'),"
    " default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_srd_udp_specification', annotat"
    "ion=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='"
    "self', std_params=(), kw_only_params=('ena_srd_enabled', 'ena_srd_udp_specification'), frozen=True, slots=False, p"
    "ost_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ena_srd_enabled', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='ena_srd_udp_specification', kw_only=True, fn=None)), id=False, terse=False"
    ", default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceAttachmentEnaSrdSpecification(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ena_srd_enabled=self.ena_srd_enabled,
            ena_srd_udp_specification=self.ena_srd_udp_specification,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ena_srd_enabled == other.ena_srd_enabled and
            self.ena_srd_udp_specification == other.ena_srd_udp_specification
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'ena_srd_enabled',
        'ena_srd_udp_specification',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'ena_srd_enabled',
        'ena_srd_udp_specification',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ena_srd_enabled,
            self.ena_srd_udp_specification,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ena_srd_enabled: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ena_srd_udp_specification: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ena_srd_enabled', ena_srd_enabled)
        __dataclass__object_setattr(self, 'ena_srd_udp_specification', ena_srd_udp_specification)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ena_srd_enabled={self.ena_srd_enabled!r}")
        parts.append(f"ena_srd_udp_specification={self.ena_srd_udp_specification!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('market_type', 'spot_options')), EqPlan(fields=('market_type', 'spot_options')), Froze"
    "nPlan(fields=('__shape__', 'market_type', 'spot_options'), allow_dynamic_dunder_attrs=False), HashPlan(action='add"
    "', fields=('market_type', 'spot_options'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotat"
    "ion=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='market_type', annotati"
    "on=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='spot_options', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default"
    "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None)), self_param='self', std_params=(), kw_only_params=('market_type', 'spot_options'), frozen=True, sl"
    "ots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='market_type"
    "', kw_only=True, fn=None), ReprPlan.Field(name='spot_options', kw_only=True, fn=None)), id=False, terse=False, def"
    "ault_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceMarketOptionsRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            market_type=self.market_type,
            spot_options=self.spot_options,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.market_type == other.market_type and
            self.spot_options == other.spot_options
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'market_type',
        'spot_options',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'market_type',
        'spot_options',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.market_type,
            self.spot_options,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        market_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        spot_options: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'market_type', market_type)
        __dataclass__object_setattr(self, 'spot_options', spot_options)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"market_type={self.market_type!r}")
        parts.append(f"spot_options={self.spot_options!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('association', 'primary', 'private_dns_name', 'private_ip_address')), EqPlan(fields=('"
    "association', 'primary', 'private_dns_name', 'private_ip_address')), FrozenPlan(fields=('__shape__', 'association'"
    ", 'primary', 'private_dns_name', 'private_ip_address'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', "
    "fields=('association', 'primary', 'private_dns_name', 'private_ip_address'), cache=False), InitPlan(fields=(InitPl"
    "an.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, "
    "init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan."
    "Field(name='association', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
    ", check_type=None), InitPlan.Field(name='primary', annotation=OpRef(name='init.fields.2.annotation'), default=OpRe"
    "f(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='private_dns_name', annotation=OpRef(name='init.f"
    "ields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='private_ip_add"
    "ress', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None))"
    ", self_param='self', std_params=(), kw_only_params=('association', 'primary', 'private_dns_name', 'private_ip_addr"
    "ess'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.F"
    "ield(name='association', kw_only=True, fn=None), ReprPlan.Field(name='primary', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='private_dns_name', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_address', kw_only=True, fn=N"
    "one)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstancePrivateIpAddress(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            association=self.association,
            primary=self.primary,
            private_dns_name=self.private_dns_name,
            private_ip_address=self.private_ip_address,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.association == other.association and
            self.primary == other.primary and
            self.private_dns_name == other.private_dns_name and
            self.private_ip_address == other.private_ip_address
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'association',
        'primary',
        'private_dns_name',
        'private_ip_address',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'association',
        'primary',
        'private_dns_name',
        'private_ip_address',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.association,
            self.primary,
            self.private_dns_name,
            self.private_ip_address,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        association: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        primary: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        private_dns_name: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        private_ip_address: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'association', association)
        __dataclass__object_setattr(self, 'primary', primary)
        __dataclass__object_setattr(self, 'private_dns_name', private_dns_name)
        __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"association={self.association!r}")
        parts.append(f"primary={self.primary!r}")
        parts.append(f"private_dns_name={self.private_dns_name!r}")
        parts.append(f"private_ip_address={self.private_ip_address!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('instance_id', 'current_state', 'previous_state')), EqPlan(fields=('instance_id', 'cur"
    "rent_state', 'previous_state')), FrozenPlan(fields=('__shape__', 'instance_id', 'current_state', 'previous_state')"
    ", allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('instance_id', 'current_state', 'previous_stat"
    "e'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotati"
    "on'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='instance_id', annotation=OpRef(name='init.fields.1.annotatio"
    "n'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='current_state', annotation=OpRe"
    "f(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "previous_state', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None)), self_param='self', std_params=(), kw_only_params=('instance_id', 'current_state', 'previous_state'), f"
    "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
    "e='instance_id', kw_only=True, fn=None), ReprPlan.Field(name='current_state', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='previous_state', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceStateChange(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            instance_id=self.instance_id,
            current_state=self.current_state,
            previous_state=self.previous_state,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.instance_id == other.instance_id and
            self.current_state == other.current_state and
            self.previous_state == other.previous_state
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'instance_id',
        'current_state',
        'previous_state',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'instance_id',
        'current_state',
        'previous_state',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.instance_id,
            self.current_state,
            self.previous_state,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        instance_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        current_state: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        previous_state: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'instance_id', instance_id)
        __dataclass__object_setattr(self, 'current_state', current_state)
        __dataclass__object_setattr(self, 'previous_state', previous_state)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"instance_id={self.instance_id!r}")
        parts.append(f"current_state={self.current_state!r}")
        parts.append(f"previous_state={self.previous_state!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('count', 'name', 'manufacturer', 'memory_info')), EqPlan(fields=('count', 'name', 'man"
    "ufacturer', 'memory_info')), FrozenPlan(fields=('__shape__', 'count', 'name', 'manufacturer', 'memory_info'), allo"
    "w_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('count', 'name', 'manufacturer', 'memory_info'), cac"
    "he=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), de"
    "fault=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='count', annotation=OpRef(name='init.fields.1.annotation'), default=O"
    "pRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
    ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.2.a"
    "nnotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='manufacturer', annotati"
    "on=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='memory_info', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'"
    "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
    "ck_type=None)), self_param='self', std_params=(), kw_only_params=('count', 'name', 'manufacturer', 'memory_info'),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(n"
    "ame='count', kw_only=True, fn=None), ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='manu"
    "facturer', kw_only=True, fn=None), ReprPlan.Field(name='memory_info', kw_only=True, fn=None)), id=False, terse=Fal"
    "se, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fMediaDeviceInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            count=self.count,
            name=self.name,
            manufacturer=self.manufacturer,
            memory_info=self.memory_info,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.count == other.count and
            self.name == other.name and
            self.manufacturer == other.manufacturer and
            self.memory_info == other.memory_info
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'count',
        'name',
        'manufacturer',
        'memory_info',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'count',
        'name',
        'manufacturer',
        'memory_info',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.count,
            self.name,
            self.manufacturer,
            self.memory_info,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        count: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        manufacturer: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        memory_info: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'count', count)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'manufacturer', manufacturer)
        __dataclass__object_setattr(self, 'memory_info', memory_info)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"count={self.count!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"manufacturer={self.manufacturer!r}")
        parts.append(f"memory_info={self.memory_info!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('association', 'primary', 'private_dns_name', 'private_ip_address')), EqPlan(fields=('"
    "association', 'primary', 'private_dns_name', 'private_ip_address')), FrozenPlan(fields=('__shape__', 'association'"
    ", 'primary', 'private_dns_name', 'private_ip_address'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', "
    "fields=('association', 'primary', 'private_dns_name', 'private_ip_address'), cache=False), InitPlan(fields=(InitPl"
    "an.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, "
    "init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan."
    "Field(name='association', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
    ", check_type=None), InitPlan.Field(name='primary', annotation=OpRef(name='init.fields.2.annotation'), default=OpRe"
    "f(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='private_dns_name', annotation=OpRef(name='init.f"
    "ields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='private_ip_add"
    "ress', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None))"
    ", self_param='self', std_params=(), kw_only_params=('association', 'primary', 'private_dns_name', 'private_ip_addr"
    "ess'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.F"
    "ield(name='association', kw_only=True, fn=None), ReprPlan.Field(name='primary', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='private_dns_name', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_address', kw_only=True, fn=N"
    "one)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fNetworkInterfacePrivateIpAddress(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            association=self.association,
            primary=self.primary,
            private_dns_name=self.private_dns_name,
            private_ip_address=self.private_ip_address,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.association == other.association and
            self.primary == other.primary and
            self.private_dns_name == other.private_dns_name and
            self.private_ip_address == other.private_ip_address
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'association',
        'primary',
        'private_dns_name',
        'private_ip_address',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'association',
        'primary',
        'private_dns_name',
        'private_ip_address',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.association,
            self.primary,
            self.private_dns_name,
            self.private_ip_address,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        association: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        primary: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        private_dns_name: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        private_ip_address: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'association', association)
        __dataclass__object_setattr(self, 'primary', primary)
        __dataclass__object_setattr(self, 'private_dns_name', private_dns_name)
        __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"association={self.association!r}")
        parts.append(f"primary={self.primary!r}")
        parts.append(f"private_dns_name={self.private_dns_name!r}")
        parts.append(f"private_ip_address={self.private_ip_address!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('count', 'name', 'core_info', 'memory_info')), EqPlan(fields=('count', 'name', 'core_i"
    "nfo', 'memory_info')), FrozenPlan(fields=('__shape__', 'count', 'name', 'core_info', 'memory_info'), allow_dynamic"
    "_dunder_attrs=False), HashPlan(action='add', fields=('count', 'name', 'core_info', 'memory_info'), cache=False), I"
    "nitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, "
    "default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check"
    "_type=None), InitPlan.Field(name='count', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='i"
    "nit.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
    "e, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.2.annotation'),"
    " default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='core_info', annotation=OpRef(name='"
    "init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='memory_i"
    "nfo', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)),"
    " self_param='self', std_params=(), kw_only_params=('count', 'name', 'core_info', 'memory_info'), frozen=True, slot"
    "s=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='count', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='core_info', kw_only=Tr"
    "ue, fn=None), ReprPlan.Field(name='memory_info', kw_only=True, fn=None)), id=False, terse=False, default_fn=None))"
    ")"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fNeuronDeviceInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            count=self.count,
            name=self.name,
            core_info=self.core_info,
            memory_info=self.memory_info,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.count == other.count and
            self.name == other.name and
            self.core_info == other.core_info and
            self.memory_info == other.memory_info
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'count',
        'name',
        'core_info',
        'memory_info',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'count',
        'name',
        'core_info',
        'memory_info',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.count,
            self.name,
            self.core_info,
            self.memory_info,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        count: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        core_info: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        memory_info: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'count', count)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'core_info', core_info)
        __dataclass__object_setattr(self, 'memory_info', memory_info)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"count={self.count!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"core_info={self.core_info!r}")
        parts.append(f"memory_info={self.memory_info!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('supported_versions',)), EqPlan(fields=('supported_versions',)), FrozenPlan(fields=('_"
    "_shape__', 'supported_versions'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('supported_ver"
    "sions',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.ann"
    "otation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=N"
    "one, validate=None, check_type=None), InitPlan.Field(name='supported_versions', annotation=OpRef(name='init.fields"
    ".1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_on"
    "ly_params=('supported_versions',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
    " ReprPlan(fields=(ReprPlan.Field(name='supported_versions', kw_only=True, fn=None),), id=False, terse=False, defau"
    "lt_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fNitroTpmInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            supported_versions=self.supported_versions,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.supported_versions == other.supported_versions
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'supported_versions',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'supported_versions',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.supported_versions,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        supported_versions: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'supported_versions', supported_versions)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"supported_versions={self.supported_versions!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('supported_strategies',)), EqPlan(fields=('supported_strategies',)), FrozenPlan(fields"
    "=('__shape__', 'supported_strategies'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('support"
    "ed_strategies',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fiel"
    "ds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, "
    "coerce=None, validate=None, check_type=None), InitPlan.Field(name='supported_strategies', annotation=OpRef(name='i"
    "nit.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override="
    "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params"
    "=(), kw_only_params=('supported_strategies',), frozen=True, slots=False, post_init_params=None, init_fns=(), valid"
    "ate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='supported_strategies', kw_only=True, fn=None),), id=False, ters"
    "e=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fPlacementGroupInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            supported_strategies=self.supported_strategies,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.supported_strategies == other.supported_strategies
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'supported_strategies',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'supported_strategies',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.supported_strategies,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        supported_strategies: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'supported_strategies', supported_strategies)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"supported_strategies={self.supported_strategies!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('supported_architectures', 'sustained_clock_speed_in_ghz', 'supported_features', 'manu"
    "facturer')), EqPlan(fields=('supported_architectures', 'sustained_clock_speed_in_ghz', 'supported_features', 'manu"
    "facturer')), FrozenPlan(fields=('__shape__', 'supported_architectures', 'sustained_clock_speed_in_ghz', 'supported"
    "_features', 'manufacturer'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('supported_architec"
    "tures', 'sustained_clock_speed_in_ghz', 'supported_features', 'manufacturer'), cache=False), InitPlan(fields=(Init"
    "Plan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None"
    ", init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPla"
    "n.Field(name='supported_architectures', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='ini"
    "t.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None), InitPlan.Field(name='sustained_clock_speed_in_ghz', annotation=OpRef(name='init."
    "fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=Fals"
    "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='supported_fea"
    "tures', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='manufacturer', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init."
    "fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('supported_architectures', 'sus"
    "tained_clock_speed_in_ghz', 'supported_features', 'manufacturer'), frozen=True, slots=False, post_init_params=None"
    ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='supported_architectures', kw_only=True, fn="
    "None), ReprPlan.Field(name='sustained_clock_speed_in_ghz', kw_only=True, fn=None), ReprPlan.Field(name='supported_"
    "features', kw_only=True, fn=None), ReprPlan.Field(name='manufacturer', kw_only=True, fn=None)), id=False, terse=Fa"
    "lse, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fProcessorInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            supported_architectures=self.supported_architectures,
            sustained_clock_speed_in_ghz=self.sustained_clock_speed_in_ghz,
            supported_features=self.supported_features,
            manufacturer=self.manufacturer,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.supported_architectures == other.supported_architectures and
            self.sustained_clock_speed_in_ghz == other.sustained_clock_speed_in_ghz and
            self.supported_features == other.supported_features and
            self.manufacturer == other.manufacturer
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'supported_architectures',
        'sustained_clock_speed_in_ghz',
        'supported_features',
        'manufacturer',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'supported_architectures',
        'sustained_clock_speed_in_ghz',
        'supported_features',
        'manufacturer',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.supported_architectures,
            self.sustained_clock_speed_in_ghz,
            self.supported_features,
            self.manufacturer,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        supported_architectures: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        sustained_clock_speed_in_ghz: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        supported_features: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        manufacturer: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'supported_architectures', supported_architectures)
        __dataclass__object_setattr(self, 'sustained_clock_speed_in_ghz', sustained_clock_speed_in_ghz)
        __dataclass__object_setattr(self, 'supported_features', supported_features)
        __dataclass__object_setattr(self, 'manufacturer', manufacturer)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"supported_architectures={self.supported_architectures!r}")
        parts.append(f"sustained_clock_speed_in_ghz={self.sustained_clock_speed_in_ghz!r}")
        parts.append(f"supported_features={self.supported_features!r}")
        parts.append(f"manufacturer={self.manufacturer!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('instance_ids', 'dry_run')), EqPlan(fields=('instance_ids', 'dry_run')), FrozenPlan(fi"
    "elds=('__shape__', 'instance_ids', 'dry_run'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('"
    "instance_ids', 'dry_run'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='"
    "init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CL"
    "ASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_ids', annotation=OpRef(name='"
    "init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.f"
    "ields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), "
    "kw_only_params=('instance_ids', 'dry_run'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate"
    "_fns=()), ReprPlan(fields=(ReprPlan.Field(name='instance_ids', kw_only=True, fn=None), ReprPlan.Field(name='dry_ru"
    "n', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fRebootInstancesRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            instance_ids=self.instance_ids,
            dry_run=self.dry_run,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.instance_ids == other.instance_ids and
            self.dry_run == other.dry_run
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'instance_ids',
        'dry_run',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'instance_ids',
        'dry_run',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.instance_ids,
            self.dry_run,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        instance_ids: __dataclass__init__fields__1__annotation,
        dry_run: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'instance_ids', instance_ids)
        __dataclass__object_setattr(self, 'dry_run', dry_run)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"instance_ids={self.instance_ids!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('main', 'route_table_association_id', 'route_table_id', 'subnet_id', 'gateway_id', 'pu"
    "blic_ipv4_pool', 'association_state')), EqPlan(fields=('main', 'route_table_association_id', 'route_table_id', 'su"
    "bnet_id', 'gateway_id', 'public_ipv4_pool', 'association_state')), FrozenPlan(fields=('__shape__', 'main', 'route_"
    "table_association_id', 'route_table_id', 'subnet_id', 'gateway_id', 'public_ipv4_pool', 'association_state'), allo"
    "w_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('main', 'route_table_association_id', 'route_table_i"
    "d', 'subnet_id', 'gateway_id', 'public_ipv4_pool', 'association_state'), cache=False), InitPlan(fields=(InitPlan.F"
    "ield(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init"
    "=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='main', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='route_table_association_id', annotation=OpRef(name='init.fields.2.annotation'), defa"
    "ult=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
    "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='route_table_id', annotation=OpRef(name='"
    "init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnet_i"
    "d', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factor"
    "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
    "itPlan.Field(name='gateway_id', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields"
    ".5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None), InitPlan.Field(name='public_ipv4_pool', annotation=OpRef(name='init.fields.6.annotation'"
    "), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='association_state', annotation=Op"
    "Ref(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True"
    ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self',"
    " std_params=(), kw_only_params=('main', 'route_table_association_id', 'route_table_id', 'subnet_id', 'gateway_id',"
    " 'public_ipv4_pool', 'association_state'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_"
    "fns=()), ReprPlan(fields=(ReprPlan.Field(name='main', kw_only=True, fn=None), ReprPlan.Field(name='route_table_ass"
    "ociation_id', kw_only=True, fn=None), ReprPlan.Field(name='route_table_id', kw_only=True, fn=None), ReprPlan.Field"
    "(name='subnet_id', kw_only=True, fn=None), ReprPlan.Field(name='gateway_id', kw_only=True, fn=None), ReprPlan.Fiel"
    "d(name='public_ipv4_pool', kw_only=True, fn=None), ReprPlan.Field(name='association_state', kw_only=True, fn=None)"
    "), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fRouteTableAssociation(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            main=self.main,
            route_table_association_id=self.route_table_association_id,
            route_table_id=self.route_table_id,
            subnet_id=self.subnet_id,
            gateway_id=self.gateway_id,
            public_ipv4_pool=self.public_ipv4_pool,
            association_state=self.association_state,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.main == other.main and
            self.route_table_association_id == other.route_table_association_id and
            self.route_table_id == other.route_table_id and
            self.subnet_id == other.subnet_id and
            self.gateway_id == other.gateway_id and
            self.public_ipv4_pool == other.public_ipv4_pool and
            self.association_state == other.association_state
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'main',
        'route_table_association_id',
        'route_table_id',
        'subnet_id',
        'gateway_id',
        'public_ipv4_pool',
        'association_state',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'main',
        'route_table_association_id',
        'route_table_id',
        'subnet_id',
        'gateway_id',
        'public_ipv4_pool',
        'association_state',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.main,
            self.route_table_association_id,
            self.route_table_id,
            self.subnet_id,
            self.gateway_id,
            self.public_ipv4_pool,
            self.association_state,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        main: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        route_table_association_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        route_table_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        subnet_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        gateway_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        public_ipv4_pool: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        association_state: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'main', main)
        __dataclass__object_setattr(self, 'route_table_association_id', route_table_association_id)
        __dataclass__object_setattr(self, 'route_table_id', route_table_id)
        __dataclass__object_setattr(self, 'subnet_id', subnet_id)
        __dataclass__object_setattr(self, 'gateway_id', gateway_id)
        __dataclass__object_setattr(self, 'public_ipv4_pool', public_ipv4_pool)
        __dataclass__object_setattr(self, 'association_state', association_state)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"main={self.main!r}")
        parts.append(f"route_table_association_id={self.route_table_association_id!r}")
        parts.append(f"route_table_id={self.route_table_id!r}")
        parts.append(f"subnet_id={self.subnet_id!r}")
        parts.append(f"gateway_id={self.gateway_id!r}")
        parts.append(f"public_ipv4_pool={self.public_ipv4_pool!r}")
        parts.append(f"association_state={self.association_state!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('instance_ids', 'additional_info', 'dry_run')), EqPlan(fields=('instance_ids', 'additi"
    "onal_info', 'dry_run')), FrozenPlan(fields=('__shape__', 'instance_ids', 'additional_info', 'dry_run'), allow_dyna"
    "mic_dunder_attrs=False), HashPlan(action='add', fields=('instance_ids', 'additional_info', 'dry_run'), cache=False"
    "), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=No"
    "ne, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='instance_ids', annotation=OpRef(name='init.fields.1.annotation'), default=No"
    "ne, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None), InitPlan.Field(name='additional_info', annotation=OpRef(name='init.fields.2.annotation'), default="
    "OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
    "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields"
    ".3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_on"
    "ly_params=('instance_ids', 'additional_info', 'dry_run'), frozen=True, slots=False, post_init_params=None, init_fn"
    "s=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='instance_ids', kw_only=True, fn=None), ReprPlan.Fiel"
    "d(name='additional_info', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None)), id=False"
    ", terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fStartInstancesRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            instance_ids=self.instance_ids,
            additional_info=self.additional_info,
            dry_run=self.dry_run,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.instance_ids == other.instance_ids and
            self.additional_info == other.additional_info and
            self.dry_run == other.dry_run
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'instance_ids',
        'additional_info',
        'dry_run',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'instance_ids',
        'additional_info',
        'dry_run',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.instance_ids,
            self.additional_info,
            self.dry_run,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        instance_ids: __dataclass__init__fields__1__annotation,
        additional_info: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        dry_run: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'instance_ids', instance_ids)
        __dataclass__object_setattr(self, 'additional_info', additional_info)
        __dataclass__object_setattr(self, 'dry_run', dry_run)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"instance_ids={self.instance_ids!r}")
        parts.append(f"additional_info={self.additional_info!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('instance_ids', 'hibernate', 'skip_os_shutdown', 'dry_run', 'force')), EqPlan(fields=("
    "'instance_ids', 'hibernate', 'skip_os_shutdown', 'dry_run', 'force')), FrozenPlan(fields=('__shape__', 'instance_i"
    "ds', 'hibernate', 'skip_os_shutdown', 'dry_run', 'force'), allow_dynamic_dunder_attrs=False), HashPlan(action='add"
    "', fields=('instance_ids', 'hibernate', 'skip_os_shutdown', 'dry_run', 'force'), cache=False), InitPlan(fields=(In"
    "itPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitP"
    "lan.Field(name='instance_ids', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='hibernate', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None), InitPlan.Field(name='skip_os_shutdown', annotation=OpRef(name='init.fields.3.annotation'), de"
    "fault=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
    "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init."
    "fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=Fals"
    "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='force', annot"
    "ation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, i"
    "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param"
    "='self', std_params=(), kw_only_params=('instance_ids', 'hibernate', 'skip_os_shutdown', 'dry_run', 'force'), froz"
    "en=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='"
    "instance_ids', kw_only=True, fn=None), ReprPlan.Field(name='hibernate', kw_only=True, fn=None), ReprPlan.Field(nam"
    "e='skip_os_shutdown', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.Fiel"
    "d(name='force', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fStopInstancesRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            instance_ids=self.instance_ids,
            hibernate=self.hibernate,
            skip_os_shutdown=self.skip_os_shutdown,
            dry_run=self.dry_run,
            force=self.force,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.instance_ids == other.instance_ids and
            self.hibernate == other.hibernate and
            self.skip_os_shutdown == other.skip_os_shutdown and
            self.dry_run == other.dry_run and
            self.force == other.force
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'instance_ids',
        'hibernate',
        'skip_os_shutdown',
        'dry_run',
        'force',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'instance_ids',
        'hibernate',
        'skip_os_shutdown',
        'dry_run',
        'force',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.instance_ids,
            self.hibernate,
            self.skip_os_shutdown,
            self.dry_run,
            self.force,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        instance_ids: __dataclass__init__fields__1__annotation,
        hibernate: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        skip_os_shutdown: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        dry_run: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        force: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'instance_ids', instance_ids)
        __dataclass__object_setattr(self, 'hibernate', hibernate)
        __dataclass__object_setattr(self, 'skip_os_shutdown', skip_os_shutdown)
        __dataclass__object_setattr(self, 'dry_run', dry_run)
        __dataclass__object_setattr(self, 'force', force)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"instance_ids={self.instance_ids!r}")
        parts.append(f"hibernate={self.hibernate!r}")
        parts.append(f"skip_os_shutdown={self.skip_os_shutdown!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        parts.append(f"force={self.force!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('association_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'ipv6_address_attribute'"
    ", 'ip_source')), EqPlan(fields=('association_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'ipv6_address_attrib"
    "ute', 'ip_source')), FrozenPlan(fields=('__shape__', 'association_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state',"
    " 'ipv6_address_attribute', 'ip_source'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('associ"
    "ation_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'ipv6_address_attribute', 'ip_source'), cache=False), InitP"
    "lan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='association_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(na"
    "me='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_cidr_block', annotation=OpRef(name='init.fields"
    ".2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_cidr_block_sta"
    "te', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_facto"
    "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
    "nitPlan.Field(name='ipv6_address_attribute', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name"
    "='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='ip_source', annotation=OpRef(name='init.fields.5.annot"
    "ation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type="
    "FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_param"
    "s=('association_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'ipv6_address_attribute', 'ip_source'), frozen=Tr"
    "ue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='assoc"
    "iation_id', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_cidr_block', kw_only=True, fn=None), ReprPlan.Field("
    "name='ipv6_cidr_block_state', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_address_attribute', kw_only=True, "
    "fn=None), ReprPlan.Field(name='ip_source', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fSubnetIpv6CidrBlockAssociation(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            association_id=self.association_id,
            ipv6_cidr_block=self.ipv6_cidr_block,
            ipv6_cidr_block_state=self.ipv6_cidr_block_state,
            ipv6_address_attribute=self.ipv6_address_attribute,
            ip_source=self.ip_source,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.association_id == other.association_id and
            self.ipv6_cidr_block == other.ipv6_cidr_block and
            self.ipv6_cidr_block_state == other.ipv6_cidr_block_state and
            self.ipv6_address_attribute == other.ipv6_address_attribute and
            self.ip_source == other.ip_source
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'association_id',
        'ipv6_cidr_block',
        'ipv6_cidr_block_state',
        'ipv6_address_attribute',
        'ip_source',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'association_id',
        'ipv6_cidr_block',
        'ipv6_cidr_block_state',
        'ipv6_address_attribute',
        'ip_source',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.association_id,
            self.ipv6_cidr_block,
            self.ipv6_cidr_block_state,
            self.ipv6_address_attribute,
            self.ip_source,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        association_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ipv6_cidr_block: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ipv6_cidr_block_state: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ipv6_address_attribute: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ip_source: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'association_id', association_id)
        __dataclass__object_setattr(self, 'ipv6_cidr_block', ipv6_cidr_block)
        __dataclass__object_setattr(self, 'ipv6_cidr_block_state', ipv6_cidr_block_state)
        __dataclass__object_setattr(self, 'ipv6_address_attribute', ipv6_address_attribute)
        __dataclass__object_setattr(self, 'ip_source', ip_source)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"association_id={self.association_id!r}")
        parts.append(f"ipv6_cidr_block={self.ipv6_cidr_block!r}")
        parts.append(f"ipv6_cidr_block_state={self.ipv6_cidr_block_state!r}")
        parts.append(f"ipv6_address_attribute={self.ipv6_address_attribute!r}")
        parts.append(f"ip_source={self.ip_source!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('instance_ids', 'force', 'skip_os_shutdown', 'dry_run')), EqPlan(fields=('instance_ids"
    "', 'force', 'skip_os_shutdown', 'dry_run')), FrozenPlan(fields=('__shape__', 'instance_ids', 'force', 'skip_os_shu"
    "tdown', 'dry_run'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('instance_ids', 'force', 'sk"
    "ip_os_shutdown', 'dry_run'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name"
    "='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType."
    "CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_ids', annotation=OpRef(name"
    "='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType."
    "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='force', annotation=OpRef(name='init.f"
    "ields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='skip_os_shutdo"
    "wn', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_facto"
    "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
    "nitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4"
    ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None)), self_param='self', std_params=(), kw_only_params=('instance_ids', 'force', 'skip_os_shutd"
    "own', 'dry_run'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields="
    "(ReprPlan.Field(name='instance_ids', kw_only=True, fn=None), ReprPlan.Field(name='force', kw_only=True, fn=None), "
    "ReprPlan.Field(name='skip_os_shutdown', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=No"
    "ne)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fTerminateInstancesRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            instance_ids=self.instance_ids,
            force=self.force,
            skip_os_shutdown=self.skip_os_shutdown,
            dry_run=self.dry_run,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.instance_ids == other.instance_ids and
            self.force == other.force and
            self.skip_os_shutdown == other.skip_os_shutdown and
            self.dry_run == other.dry_run
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'instance_ids',
        'force',
        'skip_os_shutdown',
        'dry_run',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'instance_ids',
        'force',
        'skip_os_shutdown',
        'dry_run',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.instance_ids,
            self.force,
            self.skip_os_shutdown,
            self.dry_run,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        instance_ids: __dataclass__init__fields__1__annotation,
        force: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        skip_os_shutdown: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        dry_run: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'instance_ids', instance_ids)
        __dataclass__object_setattr(self, 'force', force)
        __dataclass__object_setattr(self, 'skip_os_shutdown', skip_os_shutdown)
        __dataclass__object_setattr(self, 'dry_run', dry_run)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"instance_ids={self.instance_ids!r}")
        parts.append(f"force={self.force!r}")
        parts.append(f"skip_os_shutdown={self.skip_os_shutdown!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('default_v_cpus', 'default_cores', 'default_threads_per_core', 'valid_cores', 'valid_t"
    "hreads_per_core')), EqPlan(fields=('default_v_cpus', 'default_cores', 'default_threads_per_core', 'valid_cores', '"
    "valid_threads_per_core')), FrozenPlan(fields=('__shape__', 'default_v_cpus', 'default_cores', 'default_threads_per"
    "_core', 'valid_cores', 'valid_threads_per_core'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields"
    "=('default_v_cpus', 'default_cores', 'default_threads_per_core', 'valid_cores', 'valid_threads_per_core'), cache=F"
    "alse), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defaul"
    "t=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=Non"
    "e, check_type=None), InitPlan.Field(name='default_v_cpus', annotation=OpRef(name='init.fields.1.annotation'), defa"
    "ult=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
    "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='default_cores', annotation=OpRef(name='i"
    "nit.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override="
    "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='default_t"
    "hreads_per_core', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None), InitPlan.Field(name='valid_cores', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(na"
    "me='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='valid_threads_per_core', annotation=OpRef(name='init"
    ".fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=()"
    ", kw_only_params=('default_v_cpus', 'default_cores', 'default_threads_per_core', 'valid_cores', 'valid_threads_per"
    "_core'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan"
    ".Field(name='default_v_cpus', kw_only=True, fn=None), ReprPlan.Field(name='default_cores', kw_only=True, fn=None),"
    " ReprPlan.Field(name='default_threads_per_core', kw_only=True, fn=None), ReprPlan.Field(name='valid_cores', kw_onl"
    "y=True, fn=None), ReprPlan.Field(name='valid_threads_per_core', kw_only=True, fn=None)), id=False, terse=False, de"
    "fault_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fVCpuInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            default_v_cpus=self.default_v_cpus,
            default_cores=self.default_cores,
            default_threads_per_core=self.default_threads_per_core,
            valid_cores=self.valid_cores,
            valid_threads_per_core=self.valid_threads_per_core,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.default_v_cpus == other.default_v_cpus and
            self.default_cores == other.default_cores and
            self.default_threads_per_core == other.default_threads_per_core and
            self.valid_cores == other.valid_cores and
            self.valid_threads_per_core == other.valid_threads_per_core
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'default_v_cpus',
        'default_cores',
        'default_threads_per_core',
        'valid_cores',
        'valid_threads_per_core',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'default_v_cpus',
        'default_cores',
        'default_threads_per_core',
        'valid_cores',
        'valid_threads_per_core',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.default_v_cpus,
            self.default_cores,
            self.default_threads_per_core,
            self.valid_cores,
            self.valid_threads_per_core,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        default_v_cpus: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        default_cores: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        default_threads_per_core: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        valid_cores: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        valid_threads_per_core: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'default_v_cpus', default_v_cpus)
        __dataclass__object_setattr(self, 'default_cores', default_cores)
        __dataclass__object_setattr(self, 'default_threads_per_core', default_threads_per_core)
        __dataclass__object_setattr(self, 'valid_cores', valid_cores)
        __dataclass__object_setattr(self, 'valid_threads_per_core', valid_threads_per_core)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"default_v_cpus={self.default_v_cpus!r}")
        parts.append(f"default_cores={self.default_cores!r}")
        parts.append(f"default_threads_per_core={self.default_threads_per_core!r}")
        parts.append(f"valid_cores={self.valid_cores!r}")
        parts.append(f"valid_threads_per_core={self.valid_threads_per_core!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('association_id', 'cidr_block', 'cidr_block_state')), EqPlan(fields=('association_id',"
    " 'cidr_block', 'cidr_block_state')), FrozenPlan(fields=('__shape__', 'association_id', 'cidr_block', 'cidr_block_s"
    "tate'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('association_id', 'cidr_block', 'cidr_bl"
    "ock_state'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0."
    "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='association_id', annotation=OpRef(name='init.fields."
    "1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cidr_block', annotat"
    "ion=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='cidr_block_state', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None)), self_param='self', std_params=(), kw_only_params=('association_id', 'cidr_block', 'cidr_bloc"
    "k_state'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPl"
    "an.Field(name='association_id', kw_only=True, fn=None), ReprPlan.Field(name='cidr_block', kw_only=True, fn=None), "
    "ReprPlan.Field(name='cidr_block_state', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fVpcCidrBlockAssociation(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            association_id=self.association_id,
            cidr_block=self.cidr_block,
            cidr_block_state=self.cidr_block_state,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.association_id == other.association_id and
            self.cidr_block == other.cidr_block and
            self.cidr_block_state == other.cidr_block_state
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'association_id',
        'cidr_block',
        'cidr_block_state',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'association_id',
        'cidr_block',
        'cidr_block_state',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.association_id,
            self.cidr_block,
            self.cidr_block_state,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        association_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        cidr_block: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        cidr_block_state: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'association_id', association_id)
        __dataclass__object_setattr(self, 'cidr_block', cidr_block)
        __dataclass__object_setattr(self, 'cidr_block_state', cidr_block_state)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"association_id={self.association_id!r}")
        parts.append(f"cidr_block={self.cidr_block!r}")
        parts.append(f"cidr_block_state={self.cidr_block_state!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('internet_gateway', 'egress_only_internet_gateway', 'nat_gateway', 'virtual_private_ga"
    "teway', 'vpc_peering', 'lambda_', 'vpc_lattice', 'elastic_file_system')), EqPlan(fields=('internet_gateway', 'egre"
    "ss_only_internet_gateway', 'nat_gateway', 'virtual_private_gateway', 'vpc_peering', 'lambda_', 'vpc_lattice', 'ela"
    "stic_file_system')), FrozenPlan(fields=('__shape__', 'internet_gateway', 'egress_only_internet_gateway', 'nat_gate"
    "way', 'virtual_private_gateway', 'vpc_peering', 'lambda_', 'vpc_lattice', 'elastic_file_system'), allow_dynamic_du"
    "nder_attrs=False), HashPlan(action='add', fields=('internet_gateway', 'egress_only_internet_gateway', 'nat_gateway"
    "', 'virtual_private_gateway', 'vpc_peering', 'lambda_', 'vpc_lattice', 'elastic_file_system'), cache=False), InitP"
    "lan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='internet_gateway', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef("
    "name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
    "rce=None, validate=None, check_type=None), InitPlan.Field(name='egress_only_internet_gateway', annotation=OpRef(na"
    "me='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='nat_"
    "gateway', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e), InitPlan.Field(name='virtual_private_gateway', annotation=OpRef(name='init.fields.4.annotation'), default=OpRe"
    "f(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_peering', annotation=OpRef(name='init.fields"
    ".5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='lambda_', annotatio"
    "n=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='vpc_lattice', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default')"
    ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='elastic_file_system', annotation=OpRef(name='init.fields.8.annotation'), defaul"
    "t=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
    "NCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('internet_ga"
    "teway', 'egress_only_internet_gateway', 'nat_gateway', 'virtual_private_gateway', 'vpc_peering', 'lambda_', 'vpc_l"
    "attice', 'elastic_file_system'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), R"
    "eprPlan(fields=(ReprPlan.Field(name='internet_gateway', kw_only=True, fn=None), ReprPlan.Field(name='egress_only_i"
    "nternet_gateway', kw_only=True, fn=None), ReprPlan.Field(name='nat_gateway', kw_only=True, fn=None), ReprPlan.Fiel"
    "d(name='virtual_private_gateway', kw_only=True, fn=None), ReprPlan.Field(name='vpc_peering', kw_only=True, fn=None"
    "), ReprPlan.Field(name='lambda_', kw_only=True, fn=None), ReprPlan.Field(name='vpc_lattice', kw_only=True, fn=None"
    "), ReprPlan.Field(name='elastic_file_system', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fVpcEncryptionControlExclusions(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            internet_gateway=self.internet_gateway,
            egress_only_internet_gateway=self.egress_only_internet_gateway,
            nat_gateway=self.nat_gateway,
            virtual_private_gateway=self.virtual_private_gateway,
            vpc_peering=self.vpc_peering,
            lambda_=self.lambda_,
            vpc_lattice=self.vpc_lattice,
            elastic_file_system=self.elastic_file_system,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.internet_gateway == other.internet_gateway and
            self.egress_only_internet_gateway == other.egress_only_internet_gateway and
            self.nat_gateway == other.nat_gateway and
            self.virtual_private_gateway == other.virtual_private_gateway and
            self.vpc_peering == other.vpc_peering and
            self.lambda_ == other.lambda_ and
            self.vpc_lattice == other.vpc_lattice and
            self.elastic_file_system == other.elastic_file_system
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'internet_gateway',
        'egress_only_internet_gateway',
        'nat_gateway',
        'virtual_private_gateway',
        'vpc_peering',
        'lambda_',
        'vpc_lattice',
        'elastic_file_system',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'internet_gateway',
        'egress_only_internet_gateway',
        'nat_gateway',
        'virtual_private_gateway',
        'vpc_peering',
        'lambda_',
        'vpc_lattice',
        'elastic_file_system',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.internet_gateway,
            self.egress_only_internet_gateway,
            self.nat_gateway,
            self.virtual_private_gateway,
            self.vpc_peering,
            self.lambda_,
            self.vpc_lattice,
            self.elastic_file_system,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        internet_gateway: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        egress_only_internet_gateway: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        nat_gateway: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        virtual_private_gateway: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        vpc_peering: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        lambda_: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        vpc_lattice: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        elastic_file_system: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'internet_gateway', internet_gateway)
        __dataclass__object_setattr(self, 'egress_only_internet_gateway', egress_only_internet_gateway)
        __dataclass__object_setattr(self, 'nat_gateway', nat_gateway)
        __dataclass__object_setattr(self, 'virtual_private_gateway', virtual_private_gateway)
        __dataclass__object_setattr(self, 'vpc_peering', vpc_peering)
        __dataclass__object_setattr(self, 'lambda_', lambda_)
        __dataclass__object_setattr(self, 'vpc_lattice', vpc_lattice)
        __dataclass__object_setattr(self, 'elastic_file_system', elastic_file_system)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"internet_gateway={self.internet_gateway!r}")
        parts.append(f"egress_only_internet_gateway={self.egress_only_internet_gateway!r}")
        parts.append(f"nat_gateway={self.nat_gateway!r}")
        parts.append(f"virtual_private_gateway={self.virtual_private_gateway!r}")
        parts.append(f"vpc_peering={self.vpc_peering!r}")
        parts.append(f"lambda_={self.lambda_!r}")
        parts.append(f"vpc_lattice={self.vpc_lattice!r}")
        parts.append(f"elastic_file_system={self.elastic_file_system!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('association_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'network_border_group', "
    "'ipv6_pool', 'ipv6_address_attribute', 'ip_source')), EqPlan(fields=('association_id', 'ipv6_cidr_block', 'ipv6_ci"
    "dr_block_state', 'network_border_group', 'ipv6_pool', 'ipv6_address_attribute', 'ip_source')), FrozenPlan(fields=("
    "'__shape__', 'association_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'network_border_group', 'ipv6_pool', 'i"
    "pv6_address_attribute', 'ip_source'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('associati"
    "on_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'network_border_group', 'ipv6_pool', 'ipv6_address_attribute',"
    " 'ip_source'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields."
    "0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coe"
    "rce=None, validate=None, check_type=None), InitPlan.Field(name='association_id', annotation=OpRef(name='init.field"
    "s.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_cidr_block', "
    "annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='ipv6_cidr_block_state', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init"
    ".fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='network_border_group', annotation=OpRef(name='init.fields.4."
    "annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_pool', annotation"
    "=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=T"
    "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
    "ame='ipv6_address_attribute', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6"
    ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None), InitPlan.Field(name='ip_source', annotation=OpRef(name='init.fields.7.annotation'), defaul"
    "t=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
    "NCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('association"
    "_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'network_border_group', 'ipv6_pool', 'ipv6_address_attribute', '"
    "ip_source'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Repr"
    "Plan.Field(name='association_id', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_cidr_block', kw_only=True, fn="
    "None), ReprPlan.Field(name='ipv6_cidr_block_state', kw_only=True, fn=None), ReprPlan.Field(name='network_border_gr"
    "oup', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_pool', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_a"
    "ddress_attribute', kw_only=True, fn=None), ReprPlan.Field(name='ip_source', kw_only=True, fn=None)), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fVpcIpv6CidrBlockAssociation(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            association_id=self.association_id,
            ipv6_cidr_block=self.ipv6_cidr_block,
            ipv6_cidr_block_state=self.ipv6_cidr_block_state,
            network_border_group=self.network_border_group,
            ipv6_pool=self.ipv6_pool,
            ipv6_address_attribute=self.ipv6_address_attribute,
            ip_source=self.ip_source,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.association_id == other.association_id and
            self.ipv6_cidr_block == other.ipv6_cidr_block and
            self.ipv6_cidr_block_state == other.ipv6_cidr_block_state and
            self.network_border_group == other.network_border_group and
            self.ipv6_pool == other.ipv6_pool and
            self.ipv6_address_attribute == other.ipv6_address_attribute and
            self.ip_source == other.ip_source
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'association_id',
        'ipv6_cidr_block',
        'ipv6_cidr_block_state',
        'network_border_group',
        'ipv6_pool',
        'ipv6_address_attribute',
        'ip_source',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'association_id',
        'ipv6_cidr_block',
        'ipv6_cidr_block_state',
        'network_border_group',
        'ipv6_pool',
        'ipv6_address_attribute',
        'ip_source',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.association_id,
            self.ipv6_cidr_block,
            self.ipv6_cidr_block_state,
            self.network_border_group,
            self.ipv6_pool,
            self.ipv6_address_attribute,
            self.ip_source,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        association_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ipv6_cidr_block: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ipv6_cidr_block_state: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        network_border_group: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ipv6_pool: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ipv6_address_attribute: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        ip_source: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'association_id', association_id)
        __dataclass__object_setattr(self, 'ipv6_cidr_block', ipv6_cidr_block)
        __dataclass__object_setattr(self, 'ipv6_cidr_block_state', ipv6_cidr_block_state)
        __dataclass__object_setattr(self, 'network_border_group', network_border_group)
        __dataclass__object_setattr(self, 'ipv6_pool', ipv6_pool)
        __dataclass__object_setattr(self, 'ipv6_address_attribute', ipv6_address_attribute)
        __dataclass__object_setattr(self, 'ip_source', ip_source)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"association_id={self.association_id!r}")
        parts.append(f"ipv6_cidr_block={self.ipv6_cidr_block!r}")
        parts.append(f"ipv6_cidr_block_state={self.ipv6_cidr_block_state!r}")
        parts.append(f"network_border_group={self.network_border_group!r}")
        parts.append(f"ipv6_pool={self.ipv6_pool!r}")
        parts.append(f"ipv6_address_attribute={self.ipv6_address_attribute!r}")
        parts.append(f"ip_source={self.ip_source!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('tag_specifications', 'client_token', 'dry_run', 'vpc_id')), EqPlan(fields=('tag_speci"
    "fications', 'client_token', 'dry_run', 'vpc_id')), FrozenPlan(fields=('__shape__', 'tag_specifications', 'client_t"
    "oken', 'dry_run', 'vpc_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('tag_specifications"
    "', 'client_token', 'dry_run', 'vpc_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotatio"
    "n=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tag_specifications', ann"
    "otation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None,"
    " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
    "Field(name='client_token', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.3.annotation'), default=OpR"
    "ef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.4.a"
    "nnotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('tag_specifications', 'c"
    "lient_token', 'dry_run', 'vpc_id'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=())"
    ", ReprPlan(fields=(ReprPlan.Field(name='tag_specifications', kw_only=True, fn=None), ReprPlan.Field(name='client_t"
    "oken', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id'"
    ", kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fCreateRouteTableRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            tag_specifications=self.tag_specifications,
            client_token=self.client_token,
            dry_run=self.dry_run,
            vpc_id=self.vpc_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.tag_specifications == other.tag_specifications and
            self.client_token == other.client_token and
            self.dry_run == other.dry_run and
            self.vpc_id == other.vpc_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'tag_specifications',
        'client_token',
        'dry_run',
        'vpc_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'tag_specifications',
        'client_token',
        'dry_run',
        'vpc_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.tag_specifications,
            self.client_token,
            self.dry_run,
            self.vpc_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        tag_specifications: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        client_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        dry_run: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        vpc_id: __dataclass__init__fields__4__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'tag_specifications', tag_specifications)
        __dataclass__object_setattr(self, 'client_token', client_token)
        __dataclass__object_setattr(self, 'dry_run', dry_run)
        __dataclass__object_setattr(self, 'vpc_id', vpc_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"tag_specifications={self.tag_specifications!r}")
        parts.append(f"client_token={self.client_token!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        parts.append(f"vpc_id={self.vpc_id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('description', 'group_name', 'vpc_id', 'tag_specifications', 'dry_run')), EqPlan(field"
    "s=('description', 'group_name', 'vpc_id', 'tag_specifications', 'dry_run')), FrozenPlan(fields=('__shape__', 'desc"
    "ription', 'group_name', 'vpc_id', 'tag_specifications', 'dry_run'), allow_dynamic_dunder_attrs=False), HashPlan(ac"
    "tion='add', fields=('description', 'group_name', 'vpc_id', 'tag_specifications', 'dry_run'), cache=False), InitPla"
    "n(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='description', annotation=OpRef(name='init.fields.1.annotation'), default=None, default"
    "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
    "ne), InitPlan.Field(name='group_name', annotation=OpRef(name='init.fields.2.annotation'), default=None, default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields"
    ".3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None), InitPlan.Field(name='tag_specifications', annotation=OpRef(name='init.fields.4.annotatio"
    "n'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name"
    "='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, overri"
    "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_par"
    "ams=(), kw_only_params=('description', 'group_name', 'vpc_id', 'tag_specifications', 'dry_run'), frozen=True, slot"
    "s=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='description',"
    " kw_only=True, fn=None), ReprPlan.Field(name='group_name', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', k"
    "w_only=True, fn=None), ReprPlan.Field(name='tag_specifications', kw_only=True, fn=None), ReprPlan.Field(name='dry_"
    "run', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fCreateSecurityGroupRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            description=self.description,
            group_name=self.group_name,
            vpc_id=self.vpc_id,
            tag_specifications=self.tag_specifications,
            dry_run=self.dry_run,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.description == other.description and
            self.group_name == other.group_name and
            self.vpc_id == other.vpc_id and
            self.tag_specifications == other.tag_specifications and
            self.dry_run == other.dry_run
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'description',
        'group_name',
        'vpc_id',
        'tag_specifications',
        'dry_run',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'description',
        'group_name',
        'vpc_id',
        'tag_specifications',
        'dry_run',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.description,
            self.group_name,
            self.vpc_id,
            self.tag_specifications,
            self.dry_run,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        description: __dataclass__init__fields__1__annotation,
        group_name: __dataclass__init__fields__2__annotation,
        vpc_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        tag_specifications: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        dry_run: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'group_name', group_name)
        __dataclass__object_setattr(self, 'vpc_id', vpc_id)
        __dataclass__object_setattr(self, 'tag_specifications', tag_specifications)
        __dataclass__object_setattr(self, 'dry_run', dry_run)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"description={self.description!r}")
        parts.append(f"group_name={self.group_name!r}")
        parts.append(f"vpc_id={self.vpc_id!r}")
        parts.append(f"tag_specifications={self.tag_specifications!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('addresses',)), EqPlan(fields=('addresses',)), FrozenPlan(fields=('__shape__', 'addres"
    "ses'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('addresses',), cache=False), InitPlan(fie"
    "lds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='addresses', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fie"
    "lds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('addresses',), frozen=True, slots="
    "False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='addresses', kw_"
    "only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeAddressesResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            addresses=self.addresses,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.addresses == other.addresses
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'addresses',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'addresses',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.addresses,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        addresses: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'addresses', addresses)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"addresses={self.addresses!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('key_pairs',)), EqPlan(fields=('key_pairs',)), FrozenPlan(fields=('__shape__', 'key_pa"
    "irs'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('key_pairs',), cache=False), InitPlan(fie"
    "lds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='key_pairs', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fie"
    "lds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('key_pairs',), frozen=True, slots="
    "False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='key_pairs', kw_"
    "only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeKeyPairsResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            key_pairs=self.key_pairs,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.key_pairs == other.key_pairs
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'key_pairs',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'key_pairs',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.key_pairs,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        key_pairs: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'key_pairs', key_pairs)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"key_pairs={self.key_pairs!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('device_name', 'ebs')), EqPlan(fields=('device_name', 'ebs')), FrozenPlan(fields=('__s"
    "hape__', 'device_name', 'ebs'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('device_name', '"
    "ebs'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annota"
    "tion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None"
    ", validate=None, check_type=None), InitPlan.Field(name='device_name', annotation=OpRef(name='init.fields.1.annotat"
    "ion'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ebs', annotation=OpRef(name='"
    "init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_param"
    "s=(), kw_only_params=('device_name', 'ebs'), frozen=True, slots=False, post_init_params=None, init_fns=(), validat"
    "e_fns=()), ReprPlan(fields=(ReprPlan.Field(name='device_name', kw_only=True, fn=None), ReprPlan.Field(name='ebs', "
    "kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceBlockDeviceMapping(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            device_name=self.device_name,
            ebs=self.ebs,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.device_name == other.device_name and
            self.ebs == other.ebs
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'device_name',
        'ebs',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'device_name',
        'ebs',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.device_name,
            self.ebs,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        device_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ebs: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'device_name', device_name)
        __dataclass__object_setattr(self, 'ebs', ebs)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"device_name={self.device_name!r}")
        parts.append(f"ebs={self.ebs!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('attach_time', 'attachment_id', 'delete_on_termination', 'device_index', 'status', 'ne"
    "twork_card_index', 'ena_srd_specification', 'ena_queue_count')), EqPlan(fields=('attach_time', 'attachment_id', 'd"
    "elete_on_termination', 'device_index', 'status', 'network_card_index', 'ena_srd_specification', 'ena_queue_count')"
    "), FrozenPlan(fields=('__shape__', 'attach_time', 'attachment_id', 'delete_on_termination', 'device_index', 'statu"
    "s', 'network_card_index', 'ena_srd_specification', 'ena_queue_count'), allow_dynamic_dunder_attrs=False), HashPlan"
    "(action='add', fields=('attach_time', 'attachment_id', 'delete_on_termination', 'device_index', 'status', 'network"
    "_card_index', 'ena_srd_specification', 'ena_queue_count'), cache=False), InitPlan(fields=(InitPlan.Field(name='__s"
    "hape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='attach"
    "_time', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='attachment_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init"
    ".fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='delete_on_termination', annotation=OpRef(name='init.fields.3"
    ".annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field"
    "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='device_index', annota"
    "tion=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='status', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None), InitPlan.Field(name='network_card_index', annotation=OpRef(name='init.fields.6.annotation'), default=O"
    "pRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
    ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_srd_specification', annotation=OpRef(name"
    "='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, overri"
    "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_qu"
    "eue_count', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one)), self_param='self', std_params=(), kw_only_params=('attach_time', 'attachment_id', 'delete_on_termination', "
    "'device_index', 'status', 'network_card_index', 'ena_srd_specification', 'ena_queue_count'), frozen=True, slots=Fa"
    "lse, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='attach_time', kw_"
    "only=True, fn=None), ReprPlan.Field(name='attachment_id', kw_only=True, fn=None), ReprPlan.Field(name='delete_on_t"
    "ermination', kw_only=True, fn=None), ReprPlan.Field(name='device_index', kw_only=True, fn=None), ReprPlan.Field(na"
    "me='status', kw_only=True, fn=None), ReprPlan.Field(name='network_card_index', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='ena_srd_specification', kw_only=True, fn=None), ReprPlan.Field(name='ena_queue_count', kw_only=True, fn="
    "None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceNetworkInterfaceAttachment(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            attach_time=self.attach_time,
            attachment_id=self.attachment_id,
            delete_on_termination=self.delete_on_termination,
            device_index=self.device_index,
            status=self.status,
            network_card_index=self.network_card_index,
            ena_srd_specification=self.ena_srd_specification,
            ena_queue_count=self.ena_queue_count,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.attach_time == other.attach_time and
            self.attachment_id == other.attachment_id and
            self.delete_on_termination == other.delete_on_termination and
            self.device_index == other.device_index and
            self.status == other.status and
            self.network_card_index == other.network_card_index and
            self.ena_srd_specification == other.ena_srd_specification and
            self.ena_queue_count == other.ena_queue_count
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'attach_time',
        'attachment_id',
        'delete_on_termination',
        'device_index',
        'status',
        'network_card_index',
        'ena_srd_specification',
        'ena_queue_count',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'attach_time',
        'attachment_id',
        'delete_on_termination',
        'device_index',
        'status',
        'network_card_index',
        'ena_srd_specification',
        'ena_queue_count',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.attach_time,
            self.attachment_id,
            self.delete_on_termination,
            self.device_index,
            self.status,
            self.network_card_index,
            self.ena_srd_specification,
            self.ena_queue_count,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        attach_time: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        attachment_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        delete_on_termination: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        device_index: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        status: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        network_card_index: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        ena_srd_specification: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ena_queue_count: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'attach_time', attach_time)
        __dataclass__object_setattr(self, 'attachment_id', attachment_id)
        __dataclass__object_setattr(self, 'delete_on_termination', delete_on_termination)
        __dataclass__object_setattr(self, 'device_index', device_index)
        __dataclass__object_setattr(self, 'status', status)
        __dataclass__object_setattr(self, 'network_card_index', network_card_index)
        __dataclass__object_setattr(self, 'ena_srd_specification', ena_srd_specification)
        __dataclass__object_setattr(self, 'ena_queue_count', ena_queue_count)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"attach_time={self.attach_time!r}")
        parts.append(f"attachment_id={self.attachment_id!r}")
        parts.append(f"delete_on_termination={self.delete_on_termination!r}")
        parts.append(f"device_index={self.device_index!r}")
        parts.append(f"status={self.status!r}")
        parts.append(f"network_card_index={self.network_card_index!r}")
        parts.append(f"ena_srd_specification={self.ena_srd_specification!r}")
        parts.append(f"ena_queue_count={self.ena_queue_count!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('associate_public_ip_address', 'delete_on_termination', 'description', 'device_index',"
    " 'groups', 'ipv6_address_count', 'ipv6_addresses', 'network_interface_id', 'private_ip_address', 'private_ip_addre"
    "sses', 'secondary_private_ip_address_count', 'subnet_id', 'associate_carrier_ip_address', 'interface_type', 'netwo"
    "rk_card_index', 'ipv4_prefixes', 'ipv4_prefix_count', 'ipv6_prefixes', 'ipv6_prefix_count', 'primary_ipv6', 'ena_s"
    "rd_specification', 'connection_tracking_specification', 'ena_queue_count')), EqPlan(fields=('associate_public_ip_a"
    "ddress', 'delete_on_termination', 'description', 'device_index', 'groups', 'ipv6_address_count', 'ipv6_addresses',"
    " 'network_interface_id', 'private_ip_address', 'private_ip_addresses', 'secondary_private_ip_address_count', 'subn"
    "et_id', 'associate_carrier_ip_address', 'interface_type', 'network_card_index', 'ipv4_prefixes', 'ipv4_prefix_coun"
    "t', 'ipv6_prefixes', 'ipv6_prefix_count', 'primary_ipv6', 'ena_srd_specification', 'connection_tracking_specificat"
    "ion', 'ena_queue_count')), FrozenPlan(fields=('__shape__', 'associate_public_ip_address', 'delete_on_termination',"
    " 'description', 'device_index', 'groups', 'ipv6_address_count', 'ipv6_addresses', 'network_interface_id', 'private"
    "_ip_address', 'private_ip_addresses', 'secondary_private_ip_address_count', 'subnet_id', 'associate_carrier_ip_add"
    "ress', 'interface_type', 'network_card_index', 'ipv4_prefixes', 'ipv4_prefix_count', 'ipv6_prefixes', 'ipv6_prefix"
    "_count', 'primary_ipv6', 'ena_srd_specification', 'connection_tracking_specification', 'ena_queue_count'), allow_d"
    "ynamic_dunder_attrs=False), HashPlan(action='add', fields=('associate_public_ip_address', 'delete_on_termination',"
    " 'description', 'device_index', 'groups', 'ipv6_address_count', 'ipv6_addresses', 'network_interface_id', 'private"
    "_ip_address', 'private_ip_addresses', 'secondary_private_ip_address_count', 'subnet_id', 'associate_carrier_ip_add"
    "ress', 'interface_type', 'network_card_index', 'ipv4_prefixes', 'ipv4_prefix_count', 'ipv6_prefixes', 'ipv6_prefix"
    "_count', 'primary_ipv6', 'ena_srd_specification', 'connection_tracking_specification', 'ena_queue_count'), cache=F"
    "alse), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defaul"
    "t=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=Non"
    "e, check_type=None), InitPlan.Field(name='associate_public_ip_address', annotation=OpRef(name='init.fields.1.annot"
    "ation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type="
    "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='delete_on_termination', ann"
    "otation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None,"
    " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
    "Field(name='description', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
    ", check_type=None), InitPlan.Field(name='device_index', annotation=OpRef(name='init.fields.4.annotation'), default"
    "=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='groups', annotation=OpRef(name='init.fields"
    ".5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_address_count'"
    ", annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='ipv6_addresses', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fiel"
    "ds.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='network_interface_id', annotation=OpRef(name='init.fields.8.annot"
    "ation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type="
    "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='private_ip_address', annota"
    "tion=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='private_ip_addresses', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.field"
    "s.10.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='secondary_private_ip_address_count', annotation=OpRef(name='init."
    "fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=Fa"
    "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnet_id',"
    " annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory"
    "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
    "tPlan.Field(name='associate_carrier_ip_address', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef"
    "(name='init.fields.13.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='interface_type', annotation=OpRef(name='init.fie"
    "lds.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_card_i"
    "ndex', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='ipv4_prefixes', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef(name='in"
    "it.fields.16.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
    "e, validate=None, check_type=None), InitPlan.Field(name='ipv4_prefix_count', annotation=OpRef(name='init.fields.17"
    ".annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_prefixes', anno"
    "tation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.18.default'), default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
    ".Field(name='ipv6_prefix_count', annotation=OpRef(name='init.fields.19.annotation'), default=OpRef(name='init.fiel"
    "ds.19.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None), InitPlan.Field(name='primary_ipv6', annotation=OpRef(name='init.fields.20.annotation'"
    "), default=OpRef(name='init.fields.20.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_srd_specification', annotati"
    "on=OpRef(name='init.fields.21.annotation'), default=OpRef(name='init.fields.21.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='connection_tracking_specification', annotation=OpRef(name='init.fields.22.annotation'), default=OpRef(nam"
    "e='init.fields.22.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='ena_queue_count', annotation=OpRef(name='init.fields"
    ".23.annotation'), default=OpRef(name='init.fields.23.default'), default_factory=None, init=True, override=False, f"
    "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_"
    "only_params=('associate_public_ip_address', 'delete_on_termination', 'description', 'device_index', 'groups', 'ipv"
    "6_address_count', 'ipv6_addresses', 'network_interface_id', 'private_ip_address', 'private_ip_addresses', 'seconda"
    "ry_private_ip_address_count', 'subnet_id', 'associate_carrier_ip_address', 'interface_type', 'network_card_index',"
    " 'ipv4_prefixes', 'ipv4_prefix_count', 'ipv6_prefixes', 'ipv6_prefix_count', 'primary_ipv6', 'ena_srd_specificatio"
    "n', 'connection_tracking_specification', 'ena_queue_count'), frozen=True, slots=False, post_init_params=None, init"
    "_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='associate_public_ip_address', kw_only=True, fn=No"
    "ne), ReprPlan.Field(name='delete_on_termination', kw_only=True, fn=None), ReprPlan.Field(name='description', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='device_index', kw_only=True, fn=None), ReprPlan.Field(name='groups', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='ipv6_address_count', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_add"
    "resses', kw_only=True, fn=None), ReprPlan.Field(name='network_interface_id', kw_only=True, fn=None), ReprPlan.Fiel"
    "d(name='private_ip_address', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_addresses', kw_only=True, fn="
    "None), ReprPlan.Field(name='secondary_private_ip_address_count', kw_only=True, fn=None), ReprPlan.Field(name='subn"
    "et_id', kw_only=True, fn=None), ReprPlan.Field(name='associate_carrier_ip_address', kw_only=True, fn=None), ReprPl"
    "an.Field(name='interface_type', kw_only=True, fn=None), ReprPlan.Field(name='network_card_index', kw_only=True, fn"
    "=None), ReprPlan.Field(name='ipv4_prefixes', kw_only=True, fn=None), ReprPlan.Field(name='ipv4_prefix_count', kw_o"
    "nly=True, fn=None), ReprPlan.Field(name='ipv6_prefixes', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_prefix_"
    "count', kw_only=True, fn=None), ReprPlan.Field(name='primary_ipv6', kw_only=True, fn=None), ReprPlan.Field(name='e"
    "na_srd_specification', kw_only=True, fn=None), ReprPlan.Field(name='connection_tracking_specification', kw_only=Tr"
    "ue, fn=None), ReprPlan.Field(name='ena_queue_count', kw_only=True, fn=None)), id=False, terse=False, default_fn=No"
    "ne)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceNetworkInterfaceSpecification(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__21__annotation,
    __dataclass__init__fields__21__default,
    __dataclass__init__fields__22__annotation,
    __dataclass__init__fields__22__default,
    __dataclass__init__fields__23__annotation,
    __dataclass__init__fields__23__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            associate_public_ip_address=self.associate_public_ip_address,
            delete_on_termination=self.delete_on_termination,
            description=self.description,
            device_index=self.device_index,
            groups=self.groups,
            ipv6_address_count=self.ipv6_address_count,
            ipv6_addresses=self.ipv6_addresses,
            network_interface_id=self.network_interface_id,
            private_ip_address=self.private_ip_address,
            private_ip_addresses=self.private_ip_addresses,
            secondary_private_ip_address_count=self.secondary_private_ip_address_count,
            subnet_id=self.subnet_id,
            associate_carrier_ip_address=self.associate_carrier_ip_address,
            interface_type=self.interface_type,
            network_card_index=self.network_card_index,
            ipv4_prefixes=self.ipv4_prefixes,
            ipv4_prefix_count=self.ipv4_prefix_count,
            ipv6_prefixes=self.ipv6_prefixes,
            ipv6_prefix_count=self.ipv6_prefix_count,
            primary_ipv6=self.primary_ipv6,
            ena_srd_specification=self.ena_srd_specification,
            connection_tracking_specification=self.connection_tracking_specification,
            ena_queue_count=self.ena_queue_count,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.associate_public_ip_address == other.associate_public_ip_address and
            self.delete_on_termination == other.delete_on_termination and
            self.description == other.description and
            self.device_index == other.device_index and
            self.groups == other.groups and
            self.ipv6_address_count == other.ipv6_address_count and
            self.ipv6_addresses == other.ipv6_addresses and
            self.network_interface_id == other.network_interface_id and
            self.private_ip_address == other.private_ip_address and
            self.private_ip_addresses == other.private_ip_addresses and
            self.secondary_private_ip_address_count == other.secondary_private_ip_address_count and
            self.subnet_id == other.subnet_id and
            self.associate_carrier_ip_address == other.associate_carrier_ip_address and
            self.interface_type == other.interface_type and
            self.network_card_index == other.network_card_index and
            self.ipv4_prefixes == other.ipv4_prefixes and
            self.ipv4_prefix_count == other.ipv4_prefix_count and
            self.ipv6_prefixes == other.ipv6_prefixes and
            self.ipv6_prefix_count == other.ipv6_prefix_count and
            self.primary_ipv6 == other.primary_ipv6 and
            self.ena_srd_specification == other.ena_srd_specification and
            self.connection_tracking_specification == other.connection_tracking_specification and
            self.ena_queue_count == other.ena_queue_count
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'associate_public_ip_address',
        'delete_on_termination',
        'description',
        'device_index',
        'groups',
        'ipv6_address_count',
        'ipv6_addresses',
        'network_interface_id',
        'private_ip_address',
        'private_ip_addresses',
        'secondary_private_ip_address_count',
        'subnet_id',
        'associate_carrier_ip_address',
        'interface_type',
        'network_card_index',
        'ipv4_prefixes',
        'ipv4_prefix_count',
        'ipv6_prefixes',
        'ipv6_prefix_count',
        'primary_ipv6',
        'ena_srd_specification',
        'connection_tracking_specification',
        'ena_queue_count',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'associate_public_ip_address',
        'delete_on_termination',
        'description',
        'device_index',
        'groups',
        'ipv6_address_count',
        'ipv6_addresses',
        'network_interface_id',
        'private_ip_address',
        'private_ip_addresses',
        'secondary_private_ip_address_count',
        'subnet_id',
        'associate_carrier_ip_address',
        'interface_type',
        'network_card_index',
        'ipv4_prefixes',
        'ipv4_prefix_count',
        'ipv6_prefixes',
        'ipv6_prefix_count',
        'primary_ipv6',
        'ena_srd_specification',
        'connection_tracking_specification',
        'ena_queue_count',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.associate_public_ip_address,
            self.delete_on_termination,
            self.description,
            self.device_index,
            self.groups,
            self.ipv6_address_count,
            self.ipv6_addresses,
            self.network_interface_id,
            self.private_ip_address,
            self.private_ip_addresses,
            self.secondary_private_ip_address_count,
            self.subnet_id,
            self.associate_carrier_ip_address,
            self.interface_type,
            self.network_card_index,
            self.ipv4_prefixes,
            self.ipv4_prefix_count,
            self.ipv6_prefixes,
            self.ipv6_prefix_count,
            self.primary_ipv6,
            self.ena_srd_specification,
            self.connection_tracking_specification,
            self.ena_queue_count,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        associate_public_ip_address: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        delete_on_termination: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        description: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        device_index: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        groups: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ipv6_address_count: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        ipv6_addresses: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        network_interface_id: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        private_ip_address: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        private_ip_addresses: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        secondary_private_ip_address_count: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        subnet_id: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        associate_carrier_ip_address: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        interface_type: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        network_card_index: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        ipv4_prefixes: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        ipv4_prefix_count: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        ipv6_prefixes: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        ipv6_prefix_count: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        primary_ipv6: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        ena_srd_specification: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
        connection_tracking_specification: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
        ena_queue_count: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'associate_public_ip_address', associate_public_ip_address)
        __dataclass__object_setattr(self, 'delete_on_termination', delete_on_termination)
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'device_index', device_index)
        __dataclass__object_setattr(self, 'groups', groups)
        __dataclass__object_setattr(self, 'ipv6_address_count', ipv6_address_count)
        __dataclass__object_setattr(self, 'ipv6_addresses', ipv6_addresses)
        __dataclass__object_setattr(self, 'network_interface_id', network_interface_id)
        __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)
        __dataclass__object_setattr(self, 'private_ip_addresses', private_ip_addresses)
        __dataclass__object_setattr(self, 'secondary_private_ip_address_count', secondary_private_ip_address_count)
        __dataclass__object_setattr(self, 'subnet_id', subnet_id)
        __dataclass__object_setattr(self, 'associate_carrier_ip_address', associate_carrier_ip_address)
        __dataclass__object_setattr(self, 'interface_type', interface_type)
        __dataclass__object_setattr(self, 'network_card_index', network_card_index)
        __dataclass__object_setattr(self, 'ipv4_prefixes', ipv4_prefixes)
        __dataclass__object_setattr(self, 'ipv4_prefix_count', ipv4_prefix_count)
        __dataclass__object_setattr(self, 'ipv6_prefixes', ipv6_prefixes)
        __dataclass__object_setattr(self, 'ipv6_prefix_count', ipv6_prefix_count)
        __dataclass__object_setattr(self, 'primary_ipv6', primary_ipv6)
        __dataclass__object_setattr(self, 'ena_srd_specification', ena_srd_specification)
        __dataclass__object_setattr(self, 'connection_tracking_specification', connection_tracking_specification)
        __dataclass__object_setattr(self, 'ena_queue_count', ena_queue_count)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"associate_public_ip_address={self.associate_public_ip_address!r}")
        parts.append(f"delete_on_termination={self.delete_on_termination!r}")
        parts.append(f"description={self.description!r}")
        parts.append(f"device_index={self.device_index!r}")
        parts.append(f"groups={self.groups!r}")
        parts.append(f"ipv6_address_count={self.ipv6_address_count!r}")
        parts.append(f"ipv6_addresses={self.ipv6_addresses!r}")
        parts.append(f"network_interface_id={self.network_interface_id!r}")
        parts.append(f"private_ip_address={self.private_ip_address!r}")
        parts.append(f"private_ip_addresses={self.private_ip_addresses!r}")
        parts.append(f"secondary_private_ip_address_count={self.secondary_private_ip_address_count!r}")
        parts.append(f"subnet_id={self.subnet_id!r}")
        parts.append(f"associate_carrier_ip_address={self.associate_carrier_ip_address!r}")
        parts.append(f"interface_type={self.interface_type!r}")
        parts.append(f"network_card_index={self.network_card_index!r}")
        parts.append(f"ipv4_prefixes={self.ipv4_prefixes!r}")
        parts.append(f"ipv4_prefix_count={self.ipv4_prefix_count!r}")
        parts.append(f"ipv6_prefixes={self.ipv6_prefixes!r}")
        parts.append(f"ipv6_prefix_count={self.ipv6_prefix_count!r}")
        parts.append(f"primary_ipv6={self.primary_ipv6!r}")
        parts.append(f"ena_srd_specification={self.ena_srd_specification!r}")
        parts.append(f"connection_tracking_specification={self.connection_tracking_specification!r}")
        parts.append(f"ena_queue_count={self.ena_queue_count!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('total_size_in_gb', 'disks', 'nvme_support', 'encryption_support')), EqPlan(fields=('t"
    "otal_size_in_gb', 'disks', 'nvme_support', 'encryption_support')), FrozenPlan(fields=('__shape__', 'total_size_in_"
    "gb', 'disks', 'nvme_support', 'encryption_support'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fie"
    "lds=('total_size_in_gb', 'disks', 'nvme_support', 'encryption_support'), cache=False), InitPlan(fields=(InitPlan.F"
    "ield(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init"
    "=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='total_size_in_gb', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None), InitPlan.Field(name='disks', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef"
    "(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None), InitPlan.Field(name='nvme_support', annotation=OpRef(name='init.fields"
    ".3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='encryption_support'"
    ", annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), sel"
    "f_param='self', std_params=(), kw_only_params=('total_size_in_gb', 'disks', 'nvme_support', 'encryption_support'),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(n"
    "ame='total_size_in_gb', kw_only=True, fn=None), ReprPlan.Field(name='disks', kw_only=True, fn=None), ReprPlan.Fiel"
    "d(name='nvme_support', kw_only=True, fn=None), ReprPlan.Field(name='encryption_support', kw_only=True, fn=None)), "
    "id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceStorageInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            total_size_in_gb=self.total_size_in_gb,
            disks=self.disks,
            nvme_support=self.nvme_support,
            encryption_support=self.encryption_support,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.total_size_in_gb == other.total_size_in_gb and
            self.disks == other.disks and
            self.nvme_support == other.nvme_support and
            self.encryption_support == other.encryption_support
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'total_size_in_gb',
        'disks',
        'nvme_support',
        'encryption_support',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'total_size_in_gb',
        'disks',
        'nvme_support',
        'encryption_support',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.total_size_in_gb,
            self.disks,
            self.nvme_support,
            self.encryption_support,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        total_size_in_gb: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        disks: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        nvme_support: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        encryption_support: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'total_size_in_gb', total_size_in_gb)
        __dataclass__object_setattr(self, 'disks', disks)
        __dataclass__object_setattr(self, 'nvme_support', nvme_support)
        __dataclass__object_setattr(self, 'encryption_support', encryption_support)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"total_size_in_gb={self.total_size_in_gb!r}")
        parts.append(f"disks={self.disks!r}")
        parts.append(f"nvme_support={self.nvme_support!r}")
        parts.append(f"encryption_support={self.encryption_support!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('attachments', 'internet_gateway_id', 'owner_id', 'tags')), EqPlan(fields=('attachment"
    "s', 'internet_gateway_id', 'owner_id', 'tags')), FrozenPlan(fields=('__shape__', 'attachments', 'internet_gateway_"
    "id', 'owner_id', 'tags'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('attachments', 'intern"
    "et_gateway_id', 'owner_id', 'tags'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=Op"
    "Ref(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='attachments', annotation=OpR"
    "ef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True,"
    " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
    "'internet_gateway_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defaul"
    "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='owner_id', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef("
    "name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
    "rce=None, validate=None, check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='init.fields.4.annota"
    "tion'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=F"
    "ieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params"
    "=('attachments', 'internet_gateway_id', 'owner_id', 'tags'), frozen=True, slots=False, post_init_params=None, init"
    "_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='attachments', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='internet_gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='owner_id', kw_only=True, fn=None), Re"
    "prPlan.Field(name='tags', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInternetGateway(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            attachments=self.attachments,
            internet_gateway_id=self.internet_gateway_id,
            owner_id=self.owner_id,
            tags=self.tags,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.attachments == other.attachments and
            self.internet_gateway_id == other.internet_gateway_id and
            self.owner_id == other.owner_id and
            self.tags == other.tags
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'attachments',
        'internet_gateway_id',
        'owner_id',
        'tags',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'attachments',
        'internet_gateway_id',
        'owner_id',
        'tags',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.attachments,
            self.internet_gateway_id,
            self.owner_id,
            self.tags,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        attachments: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        internet_gateway_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        owner_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        tags: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'attachments', attachments)
        __dataclass__object_setattr(self, 'internet_gateway_id', internet_gateway_id)
        __dataclass__object_setattr(self, 'owner_id', owner_id)
        __dataclass__object_setattr(self, 'tags', tags)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"attachments={self.attachments!r}")
        parts.append(f"internet_gateway_id={self.internet_gateway_id!r}")
        parts.append(f"owner_id={self.owner_id!r}")
        parts.append(f"tags={self.tags!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ip_protocol', 'from_port', 'to_port', 'user_id_group_pairs', 'ip_ranges', 'ipv6_range"
    "s', 'prefix_list_ids')), EqPlan(fields=('ip_protocol', 'from_port', 'to_port', 'user_id_group_pairs', 'ip_ranges',"
    " 'ipv6_ranges', 'prefix_list_ids')), FrozenPlan(fields=('__shape__', 'ip_protocol', 'from_port', 'to_port', 'user_"
    "id_group_pairs', 'ip_ranges', 'ipv6_ranges', 'prefix_list_ids'), allow_dynamic_dunder_attrs=False), HashPlan(actio"
    "n='add', fields=('ip_protocol', 'from_port', 'to_port', 'user_id_group_pairs', 'ip_ranges', 'ipv6_ranges', 'prefix"
    "_list_ids'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0."
    "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='ip_protocol', annotation=OpRef(name='init.fields.1.a"
    "nnotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='from_port', annotation="
    "OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='to_port', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='user_id_group_pairs', annotation=OpRef(name='init.fields.4.annotation'), default=OpRe"
    "f(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='ip_ranges', annotation=OpRef(name='init.fields.5"
    ".annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field"
    "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_ranges', annotat"
    "ion=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='prefix_list_ids', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
    ", check_type=None)), self_param='self', std_params=(), kw_only_params=('ip_protocol', 'from_port', 'to_port', 'use"
    "r_id_group_pairs', 'ip_ranges', 'ipv6_ranges', 'prefix_list_ids'), frozen=True, slots=False, post_init_params=None"
    ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ip_protocol', kw_only=True, fn=None), ReprP"
    "lan.Field(name='from_port', kw_only=True, fn=None), ReprPlan.Field(name='to_port', kw_only=True, fn=None), ReprPla"
    "n.Field(name='user_id_group_pairs', kw_only=True, fn=None), ReprPlan.Field(name='ip_ranges', kw_only=True, fn=None"
    "), ReprPlan.Field(name='ipv6_ranges', kw_only=True, fn=None), ReprPlan.Field(name='prefix_list_ids', kw_only=True,"
    " fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fIpPermission(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ip_protocol=self.ip_protocol,
            from_port=self.from_port,
            to_port=self.to_port,
            user_id_group_pairs=self.user_id_group_pairs,
            ip_ranges=self.ip_ranges,
            ipv6_ranges=self.ipv6_ranges,
            prefix_list_ids=self.prefix_list_ids,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ip_protocol == other.ip_protocol and
            self.from_port == other.from_port and
            self.to_port == other.to_port and
            self.user_id_group_pairs == other.user_id_group_pairs and
            self.ip_ranges == other.ip_ranges and
            self.ipv6_ranges == other.ipv6_ranges and
            self.prefix_list_ids == other.prefix_list_ids
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'ip_protocol',
        'from_port',
        'to_port',
        'user_id_group_pairs',
        'ip_ranges',
        'ipv6_ranges',
        'prefix_list_ids',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'ip_protocol',
        'from_port',
        'to_port',
        'user_id_group_pairs',
        'ip_ranges',
        'ipv6_ranges',
        'prefix_list_ids',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ip_protocol,
            self.from_port,
            self.to_port,
            self.user_id_group_pairs,
            self.ip_ranges,
            self.ipv6_ranges,
            self.prefix_list_ids,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ip_protocol: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        from_port: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        to_port: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        user_id_group_pairs: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ip_ranges: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ipv6_ranges: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        prefix_list_ids: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ip_protocol', ip_protocol)
        __dataclass__object_setattr(self, 'from_port', from_port)
        __dataclass__object_setattr(self, 'to_port', to_port)
        __dataclass__object_setattr(self, 'user_id_group_pairs', user_id_group_pairs)
        __dataclass__object_setattr(self, 'ip_ranges', ip_ranges)
        __dataclass__object_setattr(self, 'ipv6_ranges', ipv6_ranges)
        __dataclass__object_setattr(self, 'prefix_list_ids', prefix_list_ids)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ip_protocol={self.ip_protocol!r}")
        parts.append(f"from_port={self.from_port!r}")
        parts.append(f"to_port={self.to_port!r}")
        parts.append(f"user_id_group_pairs={self.user_id_group_pairs!r}")
        parts.append(f"ip_ranges={self.ip_ranges!r}")
        parts.append(f"ipv6_ranges={self.ipv6_ranges!r}")
        parts.append(f"prefix_list_ids={self.prefix_list_ids!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('network_performance', 'maximum_network_interfaces', 'maximum_network_cards', 'default"
    "_network_card_index', 'network_cards', 'ipv4_addresses_per_interface', 'ipv6_addresses_per_interface', 'ipv6_suppo"
    "rted', 'ena_support', 'efa_supported', 'efa_info', 'encryption_in_transit_supported', 'ena_srd_supported', 'bandwi"
    "dth_weightings', 'flexible_ena_queues_support')), EqPlan(fields=('network_performance', 'maximum_network_interface"
    "s', 'maximum_network_cards', 'default_network_card_index', 'network_cards', 'ipv4_addresses_per_interface', 'ipv6_"
    "addresses_per_interface', 'ipv6_supported', 'ena_support', 'efa_supported', 'efa_info', 'encryption_in_transit_sup"
    "ported', 'ena_srd_supported', 'bandwidth_weightings', 'flexible_ena_queues_support')), FrozenPlan(fields=('__shape"
    "__', 'network_performance', 'maximum_network_interfaces', 'maximum_network_cards', 'default_network_card_index', '"
    "network_cards', 'ipv4_addresses_per_interface', 'ipv6_addresses_per_interface', 'ipv6_supported', 'ena_support', '"
    "efa_supported', 'efa_info', 'encryption_in_transit_supported', 'ena_srd_supported', 'bandwidth_weightings', 'flexi"
    "ble_ena_queues_support'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('network_performance',"
    " 'maximum_network_interfaces', 'maximum_network_cards', 'default_network_card_index', 'network_cards', 'ipv4_addre"
    "sses_per_interface', 'ipv6_addresses_per_interface', 'ipv6_supported', 'ena_support', 'efa_supported', 'efa_info',"
    " 'encryption_in_transit_supported', 'ena_srd_supported', 'bandwidth_weightings', 'flexible_ena_queues_support'), c"
    "ache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), "
    "default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='network_performance', annotation=OpRef(name='init.fields.1.annotat"
    "ion'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maximum_network_interfaces', "
    "annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='maximum_network_cards', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init"
    ".fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='default_network_card_index', annotation=OpRef(name='init.fie"
    "lds.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_cards', "
    "annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='ipv4_addresses_per_interface', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(nam"
    "e='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_addresses_per_interface', annotation=OpRef(name="
    "'init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_su"
    "pported', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e), InitPlan.Field(name='ena_support', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init"
    ".fields.9.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='efa_supported', annotation=OpRef(name='init.fields.10.annota"
    "tion'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_type="
    "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='efa_info', annotation=OpRef"
    "(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True,"
    " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
    "'encryption_in_transit_supported', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fi"
    "elds.12.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='ena_srd_supported', annotation=OpRef(name='init.fields.13.anno"
    "tation'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='bandwidth_weightings', an"
    "notation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='flexible_ena_queues_support', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(nam"
    "e='init.fields.15.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
    "e=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('network_performance',"
    " 'maximum_network_interfaces', 'maximum_network_cards', 'default_network_card_index', 'network_cards', 'ipv4_addre"
    "sses_per_interface', 'ipv6_addresses_per_interface', 'ipv6_supported', 'ena_support', 'efa_supported', 'efa_info',"
    " 'encryption_in_transit_supported', 'ena_srd_supported', 'bandwidth_weightings', 'flexible_ena_queues_support'), f"
    "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
    "e='network_performance', kw_only=True, fn=None), ReprPlan.Field(name='maximum_network_interfaces', kw_only=True, f"
    "n=None), ReprPlan.Field(name='maximum_network_cards', kw_only=True, fn=None), ReprPlan.Field(name='default_network"
    "_card_index', kw_only=True, fn=None), ReprPlan.Field(name='network_cards', kw_only=True, fn=None), ReprPlan.Field("
    "name='ipv4_addresses_per_interface', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_addresses_per_interface', k"
    "w_only=True, fn=None), ReprPlan.Field(name='ipv6_supported', kw_only=True, fn=None), ReprPlan.Field(name='ena_supp"
    "ort', kw_only=True, fn=None), ReprPlan.Field(name='efa_supported', kw_only=True, fn=None), ReprPlan.Field(name='ef"
    "a_info', kw_only=True, fn=None), ReprPlan.Field(name='encryption_in_transit_supported', kw_only=True, fn=None), Re"
    "prPlan.Field(name='ena_srd_supported', kw_only=True, fn=None), ReprPlan.Field(name='bandwidth_weightings', kw_only"
    "=True, fn=None), ReprPlan.Field(name='flexible_ena_queues_support', kw_only=True, fn=None)), id=False, terse=False"
    ", default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fNetworkInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            network_performance=self.network_performance,
            maximum_network_interfaces=self.maximum_network_interfaces,
            maximum_network_cards=self.maximum_network_cards,
            default_network_card_index=self.default_network_card_index,
            network_cards=self.network_cards,
            ipv4_addresses_per_interface=self.ipv4_addresses_per_interface,
            ipv6_addresses_per_interface=self.ipv6_addresses_per_interface,
            ipv6_supported=self.ipv6_supported,
            ena_support=self.ena_support,
            efa_supported=self.efa_supported,
            efa_info=self.efa_info,
            encryption_in_transit_supported=self.encryption_in_transit_supported,
            ena_srd_supported=self.ena_srd_supported,
            bandwidth_weightings=self.bandwidth_weightings,
            flexible_ena_queues_support=self.flexible_ena_queues_support,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.network_performance == other.network_performance and
            self.maximum_network_interfaces == other.maximum_network_interfaces and
            self.maximum_network_cards == other.maximum_network_cards and
            self.default_network_card_index == other.default_network_card_index and
            self.network_cards == other.network_cards and
            self.ipv4_addresses_per_interface == other.ipv4_addresses_per_interface and
            self.ipv6_addresses_per_interface == other.ipv6_addresses_per_interface and
            self.ipv6_supported == other.ipv6_supported and
            self.ena_support == other.ena_support and
            self.efa_supported == other.efa_supported and
            self.efa_info == other.efa_info and
            self.encryption_in_transit_supported == other.encryption_in_transit_supported and
            self.ena_srd_supported == other.ena_srd_supported and
            self.bandwidth_weightings == other.bandwidth_weightings and
            self.flexible_ena_queues_support == other.flexible_ena_queues_support
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'network_performance',
        'maximum_network_interfaces',
        'maximum_network_cards',
        'default_network_card_index',
        'network_cards',
        'ipv4_addresses_per_interface',
        'ipv6_addresses_per_interface',
        'ipv6_supported',
        'ena_support',
        'efa_supported',
        'efa_info',
        'encryption_in_transit_supported',
        'ena_srd_supported',
        'bandwidth_weightings',
        'flexible_ena_queues_support',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'network_performance',
        'maximum_network_interfaces',
        'maximum_network_cards',
        'default_network_card_index',
        'network_cards',
        'ipv4_addresses_per_interface',
        'ipv6_addresses_per_interface',
        'ipv6_supported',
        'ena_support',
        'efa_supported',
        'efa_info',
        'encryption_in_transit_supported',
        'ena_srd_supported',
        'bandwidth_weightings',
        'flexible_ena_queues_support',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.network_performance,
            self.maximum_network_interfaces,
            self.maximum_network_cards,
            self.default_network_card_index,
            self.network_cards,
            self.ipv4_addresses_per_interface,
            self.ipv6_addresses_per_interface,
            self.ipv6_supported,
            self.ena_support,
            self.efa_supported,
            self.efa_info,
            self.encryption_in_transit_supported,
            self.ena_srd_supported,
            self.bandwidth_weightings,
            self.flexible_ena_queues_support,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        network_performance: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        maximum_network_interfaces: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        maximum_network_cards: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        default_network_card_index: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        network_cards: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ipv4_addresses_per_interface: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        ipv6_addresses_per_interface: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ipv6_supported: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        ena_support: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        efa_supported: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        efa_info: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        encryption_in_transit_supported: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        ena_srd_supported: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        bandwidth_weightings: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        flexible_ena_queues_support: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'network_performance', network_performance)
        __dataclass__object_setattr(self, 'maximum_network_interfaces', maximum_network_interfaces)
        __dataclass__object_setattr(self, 'maximum_network_cards', maximum_network_cards)
        __dataclass__object_setattr(self, 'default_network_card_index', default_network_card_index)
        __dataclass__object_setattr(self, 'network_cards', network_cards)
        __dataclass__object_setattr(self, 'ipv4_addresses_per_interface', ipv4_addresses_per_interface)
        __dataclass__object_setattr(self, 'ipv6_addresses_per_interface', ipv6_addresses_per_interface)
        __dataclass__object_setattr(self, 'ipv6_supported', ipv6_supported)
        __dataclass__object_setattr(self, 'ena_support', ena_support)
        __dataclass__object_setattr(self, 'efa_supported', efa_supported)
        __dataclass__object_setattr(self, 'efa_info', efa_info)
        __dataclass__object_setattr(self, 'encryption_in_transit_supported', encryption_in_transit_supported)
        __dataclass__object_setattr(self, 'ena_srd_supported', ena_srd_supported)
        __dataclass__object_setattr(self, 'bandwidth_weightings', bandwidth_weightings)
        __dataclass__object_setattr(self, 'flexible_ena_queues_support', flexible_ena_queues_support)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"network_performance={self.network_performance!r}")
        parts.append(f"maximum_network_interfaces={self.maximum_network_interfaces!r}")
        parts.append(f"maximum_network_cards={self.maximum_network_cards!r}")
        parts.append(f"default_network_card_index={self.default_network_card_index!r}")
        parts.append(f"network_cards={self.network_cards!r}")
        parts.append(f"ipv4_addresses_per_interface={self.ipv4_addresses_per_interface!r}")
        parts.append(f"ipv6_addresses_per_interface={self.ipv6_addresses_per_interface!r}")
        parts.append(f"ipv6_supported={self.ipv6_supported!r}")
        parts.append(f"ena_support={self.ena_support!r}")
        parts.append(f"efa_supported={self.efa_supported!r}")
        parts.append(f"efa_info={self.efa_info!r}")
        parts.append(f"encryption_in_transit_supported={self.encryption_in_transit_supported!r}")
        parts.append(f"ena_srd_supported={self.ena_srd_supported!r}")
        parts.append(f"bandwidth_weightings={self.bandwidth_weightings!r}")
        parts.append(f"flexible_ena_queues_support={self.flexible_ena_queues_support!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('attach_time', 'attachment_id', 'delete_on_termination', 'device_index', 'network_card"
    "_index', 'instance_id', 'instance_owner_id', 'status', 'ena_srd_specification', 'ena_queue_count')), EqPlan(fields"
    "=('attach_time', 'attachment_id', 'delete_on_termination', 'device_index', 'network_card_index', 'instance_id', 'i"
    "nstance_owner_id', 'status', 'ena_srd_specification', 'ena_queue_count')), FrozenPlan(fields=('__shape__', 'attach"
    "_time', 'attachment_id', 'delete_on_termination', 'device_index', 'network_card_index', 'instance_id', 'instance_o"
    "wner_id', 'status', 'ena_srd_specification', 'ena_queue_count'), allow_dynamic_dunder_attrs=False), HashPlan(actio"
    "n='add', fields=('attach_time', 'attachment_id', 'delete_on_termination', 'device_index', 'network_card_index', 'i"
    "nstance_id', 'instance_owner_id', 'status', 'ena_srd_specification', 'ena_queue_count'), cache=False), InitPlan(fi"
    "elds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='attach_time', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init."
    "fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None), InitPlan.Field(name='attachment_id', annotation=OpRef(name='init.fields.2.annotati"
    "on'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='delete_on_termination', annota"
    "tion=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='device_index', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.defau"
    "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
    "check_type=None), InitPlan.Field(name='network_card_index', annotation=OpRef(name='init.fields.5.annotation'), def"
    "ault=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_id', annotation=OpRef(name='in"
    "it.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_o"
    "wner_id', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e), InitPlan.Field(name='status', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fiel"
    "ds.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='ena_srd_specification', annotation=OpRef(name='init.fields.9.anno"
    "tation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_type"
    "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_queue_count', annotati"
    "on=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param="
    "'self', std_params=(), kw_only_params=('attach_time', 'attachment_id', 'delete_on_termination', 'device_index', 'n"
    "etwork_card_index', 'instance_id', 'instance_owner_id', 'status', 'ena_srd_specification', 'ena_queue_count'), fro"
    "zen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name="
    "'attach_time', kw_only=True, fn=None), ReprPlan.Field(name='attachment_id', kw_only=True, fn=None), ReprPlan.Field"
    "(name='delete_on_termination', kw_only=True, fn=None), ReprPlan.Field(name='device_index', kw_only=True, fn=None),"
    " ReprPlan.Field(name='network_card_index', kw_only=True, fn=None), ReprPlan.Field(name='instance_id', kw_only=True"
    ", fn=None), ReprPlan.Field(name='instance_owner_id', kw_only=True, fn=None), ReprPlan.Field(name='status', kw_only"
    "=True, fn=None), ReprPlan.Field(name='ena_srd_specification', kw_only=True, fn=None), ReprPlan.Field(name='ena_que"
    "ue_count', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fNetworkInterfaceAttachment(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            attach_time=self.attach_time,
            attachment_id=self.attachment_id,
            delete_on_termination=self.delete_on_termination,
            device_index=self.device_index,
            network_card_index=self.network_card_index,
            instance_id=self.instance_id,
            instance_owner_id=self.instance_owner_id,
            status=self.status,
            ena_srd_specification=self.ena_srd_specification,
            ena_queue_count=self.ena_queue_count,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.attach_time == other.attach_time and
            self.attachment_id == other.attachment_id and
            self.delete_on_termination == other.delete_on_termination and
            self.device_index == other.device_index and
            self.network_card_index == other.network_card_index and
            self.instance_id == other.instance_id and
            self.instance_owner_id == other.instance_owner_id and
            self.status == other.status and
            self.ena_srd_specification == other.ena_srd_specification and
            self.ena_queue_count == other.ena_queue_count
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'attach_time',
        'attachment_id',
        'delete_on_termination',
        'device_index',
        'network_card_index',
        'instance_id',
        'instance_owner_id',
        'status',
        'ena_srd_specification',
        'ena_queue_count',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'attach_time',
        'attachment_id',
        'delete_on_termination',
        'device_index',
        'network_card_index',
        'instance_id',
        'instance_owner_id',
        'status',
        'ena_srd_specification',
        'ena_queue_count',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.attach_time,
            self.attachment_id,
            self.delete_on_termination,
            self.device_index,
            self.network_card_index,
            self.instance_id,
            self.instance_owner_id,
            self.status,
            self.ena_srd_specification,
            self.ena_queue_count,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        attach_time: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        attachment_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        delete_on_termination: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        device_index: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        network_card_index: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        instance_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        instance_owner_id: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        status: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        ena_srd_specification: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        ena_queue_count: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'attach_time', attach_time)
        __dataclass__object_setattr(self, 'attachment_id', attachment_id)
        __dataclass__object_setattr(self, 'delete_on_termination', delete_on_termination)
        __dataclass__object_setattr(self, 'device_index', device_index)
        __dataclass__object_setattr(self, 'network_card_index', network_card_index)
        __dataclass__object_setattr(self, 'instance_id', instance_id)
        __dataclass__object_setattr(self, 'instance_owner_id', instance_owner_id)
        __dataclass__object_setattr(self, 'status', status)
        __dataclass__object_setattr(self, 'ena_srd_specification', ena_srd_specification)
        __dataclass__object_setattr(self, 'ena_queue_count', ena_queue_count)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"attach_time={self.attach_time!r}")
        parts.append(f"attachment_id={self.attachment_id!r}")
        parts.append(f"delete_on_termination={self.delete_on_termination!r}")
        parts.append(f"device_index={self.device_index!r}")
        parts.append(f"network_card_index={self.network_card_index!r}")
        parts.append(f"instance_id={self.instance_id!r}")
        parts.append(f"instance_owner_id={self.instance_owner_id!r}")
        parts.append(f"status={self.status!r}")
        parts.append(f"ena_srd_specification={self.ena_srd_specification!r}")
        parts.append(f"ena_queue_count={self.ena_queue_count!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('vpc_id', 'vpc_encryption_control_id', 'mode', 'state', 'state_message', 'resource_exc"
    "lusions', 'tags')), EqPlan(fields=('vpc_id', 'vpc_encryption_control_id', 'mode', 'state', 'state_message', 'resou"
    "rce_exclusions', 'tags')), FrozenPlan(fields=('__shape__', 'vpc_id', 'vpc_encryption_control_id', 'mode', 'state',"
    " 'state_message', 'resource_exclusions', 'tags'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields"
    "=('vpc_id', 'vpc_encryption_control_id', 'mode', 'state', 'state_message', 'resource_exclusions', 'tags'), cache=F"
    "alse), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defaul"
    "t=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=Non"
    "e, check_type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRe"
    "f(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_encryption_control_id', annotation=OpRef(nam"
    "e='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='mode'"
    ", annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='state', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='state_message', annotation=OpRef(name='init.fields.5.annotation'), default"
    "=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='resource_exclusions', annotation=OpRef(name"
    "='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, overri"
    "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags',"
    " annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=N"
    "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self"
    "_param='self', std_params=(), kw_only_params=('vpc_id', 'vpc_encryption_control_id', 'mode', 'state', 'state_messa"
    "ge', 'resource_exclusions', 'tags'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()"
    "), ReprPlan(fields=(ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPlan.Field(name='vpc_encryption_cont"
    "rol_id', kw_only=True, fn=None), ReprPlan.Field(name='mode', kw_only=True, fn=None), ReprPlan.Field(name='state', "
    "kw_only=True, fn=None), ReprPlan.Field(name='state_message', kw_only=True, fn=None), ReprPlan.Field(name='resource"
    "_exclusions', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=True, fn=None)), id=False, terse=False, "
    "default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fVpcEncryptionControl(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            vpc_id=self.vpc_id,
            vpc_encryption_control_id=self.vpc_encryption_control_id,
            mode=self.mode,
            state=self.state,
            state_message=self.state_message,
            resource_exclusions=self.resource_exclusions,
            tags=self.tags,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.vpc_id == other.vpc_id and
            self.vpc_encryption_control_id == other.vpc_encryption_control_id and
            self.mode == other.mode and
            self.state == other.state and
            self.state_message == other.state_message and
            self.resource_exclusions == other.resource_exclusions and
            self.tags == other.tags
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'vpc_id',
        'vpc_encryption_control_id',
        'mode',
        'state',
        'state_message',
        'resource_exclusions',
        'tags',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'vpc_id',
        'vpc_encryption_control_id',
        'mode',
        'state',
        'state_message',
        'resource_exclusions',
        'tags',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.vpc_id,
            self.vpc_encryption_control_id,
            self.mode,
            self.state,
            self.state_message,
            self.resource_exclusions,
            self.tags,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        vpc_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        vpc_encryption_control_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        mode: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        state: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        state_message: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        resource_exclusions: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        tags: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'vpc_id', vpc_id)
        __dataclass__object_setattr(self, 'vpc_encryption_control_id', vpc_encryption_control_id)
        __dataclass__object_setattr(self, 'mode', mode)
        __dataclass__object_setattr(self, 'state', state)
        __dataclass__object_setattr(self, 'state_message', state_message)
        __dataclass__object_setattr(self, 'resource_exclusions', resource_exclusions)
        __dataclass__object_setattr(self, 'tags', tags)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"vpc_id={self.vpc_id!r}")
        parts.append(f"vpc_encryption_control_id={self.vpc_encryption_control_id!r}")
        parts.append(f"mode={self.mode!r}")
        parts.append(f"state={self.state!r}")
        parts.append(f"state_message={self.state_message!r}")
        parts.append(f"resource_exclusions={self.resource_exclusions!r}")
        parts.append(f"tags={self.tags!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('public_ips', 'dry_run', 'filters', 'allocation_ids')), EqPlan(fields=('public_ips', '"
    "dry_run', 'filters', 'allocation_ids')), FrozenPlan(fields=('__shape__', 'public_ips', 'dry_run', 'filters', 'allo"
    "cation_ids'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('public_ips', 'dry_run', 'filters'"
    ", 'allocation_ids'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.f"
    "ields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VA"
    "R, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_ips', annotation=OpRef(name='init.fie"
    "lds.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annota"
    "tion=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='filters', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'),"
    " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
    "_type=None), InitPlan.Field(name='allocation_ids', annotation=OpRef(name='init.fields.4.annotation'), default=OpRe"
    "f(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('public_ips', 'dry"
    "_run', 'filters', 'allocation_ids'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()"
    "), ReprPlan(fields=(ReprPlan.Field(name='public_ips', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn=None), ReprPlan.Field(name='allocation_ids', kw"
    "_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeAddressesRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            public_ips=self.public_ips,
            dry_run=self.dry_run,
            filters=self.filters,
            allocation_ids=self.allocation_ids,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.public_ips == other.public_ips and
            self.dry_run == other.dry_run and
            self.filters == other.filters and
            self.allocation_ids == other.allocation_ids
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'public_ips',
        'dry_run',
        'filters',
        'allocation_ids',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'public_ips',
        'dry_run',
        'filters',
        'allocation_ids',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.public_ips,
            self.dry_run,
            self.filters,
            self.allocation_ids,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        public_ips: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        dry_run: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        filters: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        allocation_ids: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'public_ips', public_ips)
        __dataclass__object_setattr(self, 'dry_run', dry_run)
        __dataclass__object_setattr(self, 'filters', filters)
        __dataclass__object_setattr(self, 'allocation_ids', allocation_ids)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"public_ips={self.public_ips!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        parts.append(f"filters={self.filters!r}")
        parts.append(f"allocation_ids={self.allocation_ids!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('executable_users', 'image_ids', 'owners', 'include_deprecated', 'include_disabled', '"
    "max_results', 'next_token', 'dry_run', 'filters')), EqPlan(fields=('executable_users', 'image_ids', 'owners', 'inc"
    "lude_deprecated', 'include_disabled', 'max_results', 'next_token', 'dry_run', 'filters')), FrozenPlan(fields=('__s"
    "hape__', 'executable_users', 'image_ids', 'owners', 'include_deprecated', 'include_disabled', 'max_results', 'next"
    "_token', 'dry_run', 'filters'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('executable_user"
    "s', 'image_ids', 'owners', 'include_deprecated', 'include_disabled', 'max_results', 'next_token', 'dry_run', 'filt"
    "ers'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annota"
    "tion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None"
    ", validate=None, check_type=None), InitPlan.Field(name='executable_users', annotation=OpRef(name='init.fields.1.an"
    "notation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_ty"
    "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='image_ids', annotation=O"
    "pRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=Tru"
    "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
    "e='owners', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='include_deprecated', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(n"
    "ame='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='include_disabled', annotation=OpRef(name='init.fiel"
    "ds.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, f"
    "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_results', ann"
    "otation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None,"
    " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
    "Field(name='next_token', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef"
    "(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None), InitPlan.Field(name='filters', annotation=OpRef(name='init.fields.9.an"
    "notation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_ty"
    "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_pa"
    "rams=('executable_users', 'image_ids', 'owners', 'include_deprecated', 'include_disabled', 'max_results', 'next_to"
    "ken', 'dry_run', 'filters'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
    "lan(fields=(ReprPlan.Field(name='executable_users', kw_only=True, fn=None), ReprPlan.Field(name='image_ids', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='owners', kw_only=True, fn=None), ReprPlan.Field(name='include_deprecated',"
    " kw_only=True, fn=None), ReprPlan.Field(name='include_disabled', kw_only=True, fn=None), ReprPlan.Field(name='max_"
    "results', kw_only=True, fn=None), ReprPlan.Field(name='next_token', kw_only=True, fn=None), ReprPlan.Field(name='d"
    "ry_run', kw_only=True, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn=None)), id=False, terse=False, de"
    "fault_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeImagesRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            executable_users=self.executable_users,
            image_ids=self.image_ids,
            owners=self.owners,
            include_deprecated=self.include_deprecated,
            include_disabled=self.include_disabled,
            max_results=self.max_results,
            next_token=self.next_token,
            dry_run=self.dry_run,
            filters=self.filters,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.executable_users == other.executable_users and
            self.image_ids == other.image_ids and
            self.owners == other.owners and
            self.include_deprecated == other.include_deprecated and
            self.include_disabled == other.include_disabled and
            self.max_results == other.max_results and
            self.next_token == other.next_token and
            self.dry_run == other.dry_run and
            self.filters == other.filters
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'executable_users',
        'image_ids',
        'owners',
        'include_deprecated',
        'include_disabled',
        'max_results',
        'next_token',
        'dry_run',
        'filters',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'executable_users',
        'image_ids',
        'owners',
        'include_deprecated',
        'include_disabled',
        'max_results',
        'next_token',
        'dry_run',
        'filters',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.executable_users,
            self.image_ids,
            self.owners,
            self.include_deprecated,
            self.include_disabled,
            self.max_results,
            self.next_token,
            self.dry_run,
            self.filters,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        executable_users: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        image_ids: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        owners: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        include_deprecated: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        include_disabled: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        max_results: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        next_token: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        dry_run: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        filters: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'executable_users', executable_users)
        __dataclass__object_setattr(self, 'image_ids', image_ids)
        __dataclass__object_setattr(self, 'owners', owners)
        __dataclass__object_setattr(self, 'include_deprecated', include_deprecated)
        __dataclass__object_setattr(self, 'include_disabled', include_disabled)
        __dataclass__object_setattr(self, 'max_results', max_results)
        __dataclass__object_setattr(self, 'next_token', next_token)
        __dataclass__object_setattr(self, 'dry_run', dry_run)
        __dataclass__object_setattr(self, 'filters', filters)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"executable_users={self.executable_users!r}")
        parts.append(f"image_ids={self.image_ids!r}")
        parts.append(f"owners={self.owners!r}")
        parts.append(f"include_deprecated={self.include_deprecated!r}")
        parts.append(f"include_disabled={self.include_disabled!r}")
        parts.append(f"max_results={self.max_results!r}")
        parts.append(f"next_token={self.next_token!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        parts.append(f"filters={self.filters!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('dry_run', 'instance_types', 'filters', 'max_results', 'next_token')), EqPlan(fields=("
    "'dry_run', 'instance_types', 'filters', 'max_results', 'next_token')), FrozenPlan(fields=('__shape__', 'dry_run', "
    "'instance_types', 'filters', 'max_results', 'next_token'), allow_dynamic_dunder_attrs=False), HashPlan(action='add"
    "', fields=('dry_run', 'instance_types', 'filters', 'max_results', 'next_token'), cache=False), InitPlan(fields=(In"
    "itPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitP"
    "lan.Field(name='dry_run', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
    ", check_type=None), InitPlan.Field(name='instance_types', annotation=OpRef(name='init.fields.2.annotation'), defau"
    "lt=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
    "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='filters', annotation=OpRef(name='init.fie"
    "lds.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_results', an"
    "notation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
    ".Field(name='next_token', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
    ", check_type=None)), self_param='self', std_params=(), kw_only_params=('dry_run', 'instance_types', 'filters', 'ma"
    "x_results', 'next_token'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPla"
    "n(fields=(ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='instance_types', kw_only=Tru"
    "e, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn=None), ReprPlan.Field(name='max_results', kw_only=Tru"
    "e, fn=None), ReprPlan.Field(name='next_token', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeInstanceTypesRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            dry_run=self.dry_run,
            instance_types=self.instance_types,
            filters=self.filters,
            max_results=self.max_results,
            next_token=self.next_token,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.dry_run == other.dry_run and
            self.instance_types == other.instance_types and
            self.filters == other.filters and
            self.max_results == other.max_results and
            self.next_token == other.next_token
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'dry_run',
        'instance_types',
        'filters',
        'max_results',
        'next_token',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'dry_run',
        'instance_types',
        'filters',
        'max_results',
        'next_token',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.dry_run,
            self.instance_types,
            self.filters,
            self.max_results,
            self.next_token,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        dry_run: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        instance_types: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        filters: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        max_results: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        next_token: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'dry_run', dry_run)
        __dataclass__object_setattr(self, 'instance_types', instance_types)
        __dataclass__object_setattr(self, 'filters', filters)
        __dataclass__object_setattr(self, 'max_results', max_results)
        __dataclass__object_setattr(self, 'next_token', next_token)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"dry_run={self.dry_run!r}")
        parts.append(f"instance_types={self.instance_types!r}")
        parts.append(f"filters={self.filters!r}")
        parts.append(f"max_results={self.max_results!r}")
        parts.append(f"next_token={self.next_token!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('instance_ids', 'dry_run', 'filters', 'next_token', 'max_results')), EqPlan(fields=('i"
    "nstance_ids', 'dry_run', 'filters', 'next_token', 'max_results')), FrozenPlan(fields=('__shape__', 'instance_ids',"
    " 'dry_run', 'filters', 'next_token', 'max_results'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fie"
    "lds=('instance_ids', 'dry_run', 'filters', 'next_token', 'max_results'), cache=False), InitPlan(fields=(InitPlan.F"
    "ield(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init"
    "=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='instance_ids', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defaul"
    "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(n"
    "ame='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='filters', annotation=OpRef(name='init.fields.3.anno"
    "tation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type"
    "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=Op"
    "Ref(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True"
    ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='max_results', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), de"
    "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
    "pe=None)), self_param='self', std_params=(), kw_only_params=('instance_ids', 'dry_run', 'filters', 'next_token', '"
    "max_results'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Re"
    "prPlan.Field(name='instance_ids', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), R"
    "eprPlan.Field(name='filters', kw_only=True, fn=None), ReprPlan.Field(name='next_token', kw_only=True, fn=None), Re"
    "prPlan.Field(name='max_results', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeInstancesRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            instance_ids=self.instance_ids,
            dry_run=self.dry_run,
            filters=self.filters,
            next_token=self.next_token,
            max_results=self.max_results,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.instance_ids == other.instance_ids and
            self.dry_run == other.dry_run and
            self.filters == other.filters and
            self.next_token == other.next_token and
            self.max_results == other.max_results
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'instance_ids',
        'dry_run',
        'filters',
        'next_token',
        'max_results',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'instance_ids',
        'dry_run',
        'filters',
        'next_token',
        'max_results',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.instance_ids,
            self.dry_run,
            self.filters,
            self.next_token,
            self.max_results,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        instance_ids: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        dry_run: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        filters: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        next_token: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        max_results: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'instance_ids', instance_ids)
        __dataclass__object_setattr(self, 'dry_run', dry_run)
        __dataclass__object_setattr(self, 'filters', filters)
        __dataclass__object_setattr(self, 'next_token', next_token)
        __dataclass__object_setattr(self, 'max_results', max_results)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"instance_ids={self.instance_ids!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        parts.append(f"filters={self.filters!r}")
        parts.append(f"next_token={self.next_token!r}")
        parts.append(f"max_results={self.max_results!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('next_token', 'max_results', 'dry_run', 'internet_gateway_ids', 'filters')), EqPlan(fi"
    "elds=('next_token', 'max_results', 'dry_run', 'internet_gateway_ids', 'filters')), FrozenPlan(fields=('__shape__',"
    " 'next_token', 'max_results', 'dry_run', 'internet_gateway_ids', 'filters'), allow_dynamic_dunder_attrs=False), Ha"
    "shPlan(action='add', fields=('next_token', 'max_results', 'dry_run', 'internet_gateway_ids', 'filters'), cache=Fal"
    "se), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default="
    "None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.1.annotation'), default=Op"
    "Ref(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_results', annotation=OpRef(name='init.fiel"
    "ds.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, f"
    "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotat"
    "ion=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='internet_gateway_ids', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields."
    "4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='filters', annotation=OpRef(name='init.fields.5.annotation'), default"
    "=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('next_token',"
    " 'max_results', 'dry_run', 'internet_gateway_ids', 'filters'), frozen=True, slots=False, post_init_params=None, in"
    "it_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='next_token', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='max_results', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='internet_gateway_ids', kw_only=True, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn=None)), "
    "id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeInternetGatewaysRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            next_token=self.next_token,
            max_results=self.max_results,
            dry_run=self.dry_run,
            internet_gateway_ids=self.internet_gateway_ids,
            filters=self.filters,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.next_token == other.next_token and
            self.max_results == other.max_results and
            self.dry_run == other.dry_run and
            self.internet_gateway_ids == other.internet_gateway_ids and
            self.filters == other.filters
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'next_token',
        'max_results',
        'dry_run',
        'internet_gateway_ids',
        'filters',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'next_token',
        'max_results',
        'dry_run',
        'internet_gateway_ids',
        'filters',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.next_token,
            self.max_results,
            self.dry_run,
            self.internet_gateway_ids,
            self.filters,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        max_results: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        dry_run: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        internet_gateway_ids: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        filters: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'next_token', next_token)
        __dataclass__object_setattr(self, 'max_results', max_results)
        __dataclass__object_setattr(self, 'dry_run', dry_run)
        __dataclass__object_setattr(self, 'internet_gateway_ids', internet_gateway_ids)
        __dataclass__object_setattr(self, 'filters', filters)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"next_token={self.next_token!r}")
        parts.append(f"max_results={self.max_results!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        parts.append(f"internet_gateway_ids={self.internet_gateway_ids!r}")
        parts.append(f"filters={self.filters!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('key_names', 'key_pair_ids', 'include_public_key', 'dry_run', 'filters')), EqPlan(fiel"
    "ds=('key_names', 'key_pair_ids', 'include_public_key', 'dry_run', 'filters')), FrozenPlan(fields=('__shape__', 'ke"
    "y_names', 'key_pair_ids', 'include_public_key', 'dry_run', 'filters'), allow_dynamic_dunder_attrs=False), HashPlan"
    "(action='add', fields=('key_names', 'key_pair_ids', 'include_public_key', 'dry_run', 'filters'), cache=False), Ini"
    "tPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, de"
    "fault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_t"
    "ype=None), InitPlan.Field(name='key_names', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name="
    "'init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
    "one, validate=None, check_type=None), InitPlan.Field(name='key_pair_ids', annotation=OpRef(name='init.fields.2.ann"
    "otation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='include_public_key', anno"
    "tation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
    "ield(name='dry_run', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'"
    "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
    "ck_type=None), InitPlan.Field(name='filters', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(nam"
    "e='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('key_names', 'key_pair_"
    "ids', 'include_public_key', 'dry_run', 'filters'), frozen=True, slots=False, post_init_params=None, init_fns=(), v"
    "alidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='key_names', kw_only=True, fn=None), ReprPlan.Field(name='ke"
    "y_pair_ids', kw_only=True, fn=None), ReprPlan.Field(name='include_public_key', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn=None)), id=False, ters"
    "e=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeKeyPairsRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            key_names=self.key_names,
            key_pair_ids=self.key_pair_ids,
            include_public_key=self.include_public_key,
            dry_run=self.dry_run,
            filters=self.filters,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.key_names == other.key_names and
            self.key_pair_ids == other.key_pair_ids and
            self.include_public_key == other.include_public_key and
            self.dry_run == other.dry_run and
            self.filters == other.filters
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'key_names',
        'key_pair_ids',
        'include_public_key',
        'dry_run',
        'filters',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'key_names',
        'key_pair_ids',
        'include_public_key',
        'dry_run',
        'filters',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.key_names,
            self.key_pair_ids,
            self.include_public_key,
            self.dry_run,
            self.filters,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        key_names: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        key_pair_ids: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        include_public_key: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        dry_run: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        filters: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'key_names', key_names)
        __dataclass__object_setattr(self, 'key_pair_ids', key_pair_ids)
        __dataclass__object_setattr(self, 'include_public_key', include_public_key)
        __dataclass__object_setattr(self, 'dry_run', dry_run)
        __dataclass__object_setattr(self, 'filters', filters)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"key_names={self.key_names!r}")
        parts.append(f"key_pair_ids={self.key_pair_ids!r}")
        parts.append(f"include_public_key={self.include_public_key!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        parts.append(f"filters={self.filters!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('next_token', 'max_results', 'dry_run', 'network_interface_ids', 'filters')), EqPlan(f"
    "ields=('next_token', 'max_results', 'dry_run', 'network_interface_ids', 'filters')), FrozenPlan(fields=('__shape__"
    "', 'next_token', 'max_results', 'dry_run', 'network_interface_ids', 'filters'), allow_dynamic_dunder_attrs=False),"
    " HashPlan(action='add', fields=('next_token', 'max_results', 'dry_run', 'network_interface_ids', 'filters'), cache"
    "=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defa"
    "ult=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.1.annotation'), defaul"
    "t=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
    "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_results', annotation=OpRef(name='init."
    "fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=Fals"
    "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', ann"
    "otation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None,"
    " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
    "Field(name='network_interface_ids', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fi"
    "elds.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='filters', annotation=OpRef(name='init.fields.5.annotation'), de"
    "fault=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
    "NSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('next_to"
    "ken', 'max_results', 'dry_run', 'network_interface_ids', 'filters'), frozen=True, slots=False, post_init_params=No"
    "ne, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='next_token', kw_only=True, fn=None), Repr"
    "Plan.Field(name='max_results', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), Repr"
    "Plan.Field(name='network_interface_ids', kw_only=True, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn=N"
    "one)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeNetworkInterfacesRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            next_token=self.next_token,
            max_results=self.max_results,
            dry_run=self.dry_run,
            network_interface_ids=self.network_interface_ids,
            filters=self.filters,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.next_token == other.next_token and
            self.max_results == other.max_results and
            self.dry_run == other.dry_run and
            self.network_interface_ids == other.network_interface_ids and
            self.filters == other.filters
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'next_token',
        'max_results',
        'dry_run',
        'network_interface_ids',
        'filters',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'next_token',
        'max_results',
        'dry_run',
        'network_interface_ids',
        'filters',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.next_token,
            self.max_results,
            self.dry_run,
            self.network_interface_ids,
            self.filters,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        max_results: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        dry_run: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        network_interface_ids: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        filters: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'next_token', next_token)
        __dataclass__object_setattr(self, 'max_results', max_results)
        __dataclass__object_setattr(self, 'dry_run', dry_run)
        __dataclass__object_setattr(self, 'network_interface_ids', network_interface_ids)
        __dataclass__object_setattr(self, 'filters', filters)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"next_token={self.next_token!r}")
        parts.append(f"max_results={self.max_results!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        parts.append(f"network_interface_ids={self.network_interface_ids!r}")
        parts.append(f"filters={self.filters!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('next_token', 'max_results', 'dry_run', 'route_table_ids', 'filters')), EqPlan(fields="
    "('next_token', 'max_results', 'dry_run', 'route_table_ids', 'filters')), FrozenPlan(fields=('__shape__', 'next_tok"
    "en', 'max_results', 'dry_run', 'route_table_ids', 'filters'), allow_dynamic_dunder_attrs=False), HashPlan(action='"
    "add', fields=('next_token', 'max_results', 'dry_run', 'route_table_ids', 'filters'), cache=False), InitPlan(fields"
    "=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factor"
    "y=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), I"
    "nitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.field"
    "s.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='max_results', annotation=OpRef(name='init.fields.2.annotation'), d"
    "efault=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType."
    "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init"
    ".fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='route_table_"
    "ids', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
    "InitPlan.Field(name='filters', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields."
    "5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('next_token', 'max_results', 'dry_run'"
    ", 'route_table_ids', 'filters'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), R"
    "eprPlan(fields=(ReprPlan.Field(name='next_token', kw_only=True, fn=None), ReprPlan.Field(name='max_results', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='route_table_ids', k"
    "w_only=True, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn=None)), id=False, terse=False, default_fn=N"
    "one)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeRouteTablesRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            next_token=self.next_token,
            max_results=self.max_results,
            dry_run=self.dry_run,
            route_table_ids=self.route_table_ids,
            filters=self.filters,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.next_token == other.next_token and
            self.max_results == other.max_results and
            self.dry_run == other.dry_run and
            self.route_table_ids == other.route_table_ids and
            self.filters == other.filters
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'next_token',
        'max_results',
        'dry_run',
        'route_table_ids',
        'filters',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'next_token',
        'max_results',
        'dry_run',
        'route_table_ids',
        'filters',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.next_token,
            self.max_results,
            self.dry_run,
            self.route_table_ids,
            self.filters,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        max_results: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        dry_run: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        route_table_ids: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        filters: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'next_token', next_token)
        __dataclass__object_setattr(self, 'max_results', max_results)
        __dataclass__object_setattr(self, 'dry_run', dry_run)
        __dataclass__object_setattr(self, 'route_table_ids', route_table_ids)
        __dataclass__object_setattr(self, 'filters', filters)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"next_token={self.next_token!r}")
        parts.append(f"max_results={self.max_results!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        parts.append(f"route_table_ids={self.route_table_ids!r}")
        parts.append(f"filters={self.filters!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('group_ids', 'group_names', 'next_token', 'max_results', 'dry_run', 'filters')), EqPla"
    "n(fields=('group_ids', 'group_names', 'next_token', 'max_results', 'dry_run', 'filters')), FrozenPlan(fields=('__s"
    "hape__', 'group_ids', 'group_names', 'next_token', 'max_results', 'dry_run', 'filters'), allow_dynamic_dunder_attr"
    "s=False), HashPlan(action='add', fields=('group_ids', 'group_names', 'next_token', 'max_results', 'dry_run', 'filt"
    "ers'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annota"
    "tion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None"
    ", validate=None, check_type=None), InitPlan.Field(name='group_ids', annotation=OpRef(name='init.fields.1.annotatio"
    "n'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_names', annotation=OpRef("
    "name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, ov"
    "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ne"
    "xt_token', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default"
    "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
    "ne), InitPlan.Field(name='max_results', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='ini"
    "t.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.5.annotation')"
    ", default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
    "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='filters', annotation=OpRef(name='i"
    "nit.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override="
    "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params"
    "=(), kw_only_params=('group_ids', 'group_names', 'next_token', 'max_results', 'dry_run', 'filters'), frozen=True, "
    "slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='group_ids"
    "', kw_only=True, fn=None), ReprPlan.Field(name='group_names', kw_only=True, fn=None), ReprPlan.Field(name='next_to"
    "ken', kw_only=True, fn=None), ReprPlan.Field(name='max_results', kw_only=True, fn=None), ReprPlan.Field(name='dry_"
    "run', kw_only=True, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn=None)), id=False, terse=False, defau"
    "lt_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeSecurityGroupsRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            group_ids=self.group_ids,
            group_names=self.group_names,
            next_token=self.next_token,
            max_results=self.max_results,
            dry_run=self.dry_run,
            filters=self.filters,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.group_ids == other.group_ids and
            self.group_names == other.group_names and
            self.next_token == other.next_token and
            self.max_results == other.max_results and
            self.dry_run == other.dry_run and
            self.filters == other.filters
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'group_ids',
        'group_names',
        'next_token',
        'max_results',
        'dry_run',
        'filters',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'group_ids',
        'group_names',
        'next_token',
        'max_results',
        'dry_run',
        'filters',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.group_ids,
            self.group_names,
            self.next_token,
            self.max_results,
            self.dry_run,
            self.filters,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        group_ids: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        group_names: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        next_token: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        max_results: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        dry_run: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        filters: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'group_ids', group_ids)
        __dataclass__object_setattr(self, 'group_names', group_names)
        __dataclass__object_setattr(self, 'next_token', next_token)
        __dataclass__object_setattr(self, 'max_results', max_results)
        __dataclass__object_setattr(self, 'dry_run', dry_run)
        __dataclass__object_setattr(self, 'filters', filters)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"group_ids={self.group_ids!r}")
        parts.append(f"group_names={self.group_names!r}")
        parts.append(f"next_token={self.next_token!r}")
        parts.append(f"max_results={self.max_results!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        parts.append(f"filters={self.filters!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('filters', 'subnet_ids', 'next_token', 'max_results', 'dry_run')), EqPlan(fields=('fil"
    "ters', 'subnet_ids', 'next_token', 'max_results', 'dry_run')), FrozenPlan(fields=('__shape__', 'filters', 'subnet_"
    "ids', 'next_token', 'max_results', 'dry_run'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('"
    "filters', 'subnet_ids', 'next_token', 'max_results', 'dry_run'), cache=False), InitPlan(fields=(InitPlan.Field(nam"
    "e='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "filters', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e), InitPlan.Field(name='subnet_ids', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init."
    "fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.3.annotation'"
    "), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_results', annotation=OpRef(na"
    "me='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_"
    "run', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)),"
    " self_param='self', std_params=(), kw_only_params=('filters', 'subnet_ids', 'next_token', 'max_results', 'dry_run'"
    "), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field"
    "(name='filters', kw_only=True, fn=None), ReprPlan.Field(name='subnet_ids', kw_only=True, fn=None), ReprPlan.Field("
    "name='next_token', kw_only=True, fn=None), ReprPlan.Field(name='max_results', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='dry_run', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeSubnetsRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            filters=self.filters,
            subnet_ids=self.subnet_ids,
            next_token=self.next_token,
            max_results=self.max_results,
            dry_run=self.dry_run,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.filters == other.filters and
            self.subnet_ids == other.subnet_ids and
            self.next_token == other.next_token and
            self.max_results == other.max_results and
            self.dry_run == other.dry_run
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'filters',
        'subnet_ids',
        'next_token',
        'max_results',
        'dry_run',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'filters',
        'subnet_ids',
        'next_token',
        'max_results',
        'dry_run',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.filters,
            self.subnet_ids,
            self.next_token,
            self.max_results,
            self.dry_run,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        filters: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        subnet_ids: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        next_token: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        max_results: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        dry_run: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'filters', filters)
        __dataclass__object_setattr(self, 'subnet_ids', subnet_ids)
        __dataclass__object_setattr(self, 'next_token', next_token)
        __dataclass__object_setattr(self, 'max_results', max_results)
        __dataclass__object_setattr(self, 'dry_run', dry_run)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"filters={self.filters!r}")
        parts.append(f"subnet_ids={self.subnet_ids!r}")
        parts.append(f"next_token={self.next_token!r}")
        parts.append(f"max_results={self.max_results!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('filters', 'vpc_ids', 'next_token', 'max_results', 'dry_run')), EqPlan(fields=('filter"
    "s', 'vpc_ids', 'next_token', 'max_results', 'dry_run')), FrozenPlan(fields=('__shape__', 'filters', 'vpc_ids', 'ne"
    "xt_token', 'max_results', 'dry_run'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('filters',"
    " 'vpc_ids', 'next_token', 'max_results', 'dry_run'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__"
    "', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=Fals"
    "e, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='filters', an"
    "notation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
    ".Field(name='vpc_ids', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defaul"
    "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.3.annotation'), default=OpRe"
    "f(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='max_results', annotation=OpRef(name='init.fields"
    ".4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotatio"
    "n=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='se"
    "lf', std_params=(), kw_only_params=('filters', 'vpc_ids', 'next_token', 'max_results', 'dry_run'), frozen=True, sl"
    "ots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='filters', k"
    "w_only=True, fn=None), ReprPlan.Field(name='vpc_ids', kw_only=True, fn=None), ReprPlan.Field(name='next_token', kw"
    "_only=True, fn=None), ReprPlan.Field(name='max_results', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw"
    "_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeVpcsRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            filters=self.filters,
            vpc_ids=self.vpc_ids,
            next_token=self.next_token,
            max_results=self.max_results,
            dry_run=self.dry_run,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.filters == other.filters and
            self.vpc_ids == other.vpc_ids and
            self.next_token == other.next_token and
            self.max_results == other.max_results and
            self.dry_run == other.dry_run
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'filters',
        'vpc_ids',
        'next_token',
        'max_results',
        'dry_run',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'filters',
        'vpc_ids',
        'next_token',
        'max_results',
        'dry_run',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.filters,
            self.vpc_ids,
            self.next_token,
            self.max_results,
            self.dry_run,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        filters: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        vpc_ids: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        next_token: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        max_results: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        dry_run: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'filters', filters)
        __dataclass__object_setattr(self, 'vpc_ids', vpc_ids)
        __dataclass__object_setattr(self, 'next_token', next_token)
        __dataclass__object_setattr(self, 'max_results', max_results)
        __dataclass__object_setattr(self, 'dry_run', dry_run)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"filters={self.filters!r}")
        parts.append(f"vpc_ids={self.vpc_ids!r}")
        parts.append(f"next_token={self.next_token!r}")
        parts.append(f"max_results={self.max_results!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('fpgas', 'total_fpga_memory_in_mi_b')), EqPlan(fields=('fpgas', 'total_fpga_memory_in_"
    "mi_b')), FrozenPlan(fields=('__shape__', 'fpgas', 'total_fpga_memory_in_mi_b'), allow_dynamic_dunder_attrs=False),"
    " HashPlan(action='add', fields=('fpgas', 'total_fpga_memory_in_mi_b'), cache=False), InitPlan(fields=(InitPlan.Fie"
    "ld(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=T"
    "rue, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='fpgas', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='total_fpga_memory_in_mi_b', annotation=OpRef(name='init.fields.2.annotation'), defaul"
    "t=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
    "NCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('fpgas', 'to"
    "tal_fpga_memory_in_mi_b'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPla"
    "n(fields=(ReprPlan.Field(name='fpgas', kw_only=True, fn=None), ReprPlan.Field(name='total_fpga_memory_in_mi_b', kw"
    "_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fFpgaInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            fpgas=self.fpgas,
            total_fpga_memory_in_mi_b=self.total_fpga_memory_in_mi_b,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.fpgas == other.fpgas and
            self.total_fpga_memory_in_mi_b == other.total_fpga_memory_in_mi_b
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'fpgas',
        'total_fpga_memory_in_mi_b',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'fpgas',
        'total_fpga_memory_in_mi_b',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.fpgas,
            self.total_fpga_memory_in_mi_b,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        fpgas: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        total_fpga_memory_in_mi_b: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'fpgas', fpgas)
        __dataclass__object_setattr(self, 'total_fpga_memory_in_mi_b', total_fpga_memory_in_mi_b)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"fpgas={self.fpgas!r}")
        parts.append(f"total_fpga_memory_in_mi_b={self.total_fpga_memory_in_mi_b!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('gpus', 'total_gpu_memory_in_mi_b')), EqPlan(fields=('gpus', 'total_gpu_memory_in_mi_b"
    "')), FrozenPlan(fields=('__shape__', 'gpus', 'total_gpu_memory_in_mi_b'), allow_dynamic_dunder_attrs=False), HashP"
    "lan(action='add', fields=('gpus', 'total_gpu_memory_in_mi_b'), cache=False), InitPlan(fields=(InitPlan.Field(name="
    "'__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='gp"
    "us', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_facto"
    "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
    "nitPlan.Field(name='total_gpu_memory_in_mi_b', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(na"
    "me='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
    "e=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('gpus', 'total_gpu_mem"
    "ory_in_mi_b'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Re"
    "prPlan.Field(name='gpus', kw_only=True, fn=None), ReprPlan.Field(name='total_gpu_memory_in_mi_b', kw_only=True, fn"
    "=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fGpuInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            gpus=self.gpus,
            total_gpu_memory_in_mi_b=self.total_gpu_memory_in_mi_b,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.gpus == other.gpus and
            self.total_gpu_memory_in_mi_b == other.total_gpu_memory_in_mi_b
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'gpus',
        'total_gpu_memory_in_mi_b',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'gpus',
        'total_gpu_memory_in_mi_b',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.gpus,
            self.total_gpu_memory_in_mi_b,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        gpus: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        total_gpu_memory_in_mi_b: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'gpus', gpus)
        __dataclass__object_setattr(self, 'total_gpu_memory_in_mi_b', total_gpu_memory_in_mi_b)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"gpus={self.gpus!r}")
        parts.append(f"total_gpu_memory_in_mi_b={self.total_gpu_memory_in_mi_b!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('platform_details', 'usage_operation', 'block_device_mappings', 'description', 'ena_su"
    "pport', 'hypervisor', 'image_owner_alias', 'name', 'root_device_name', 'root_device_type', 'sriov_net_support', 's"
    "tate_reason', 'tags', 'virtualization_type', 'boot_mode', 'tpm_support', 'deprecation_time', 'imds_support', 'sour"
    "ce_instance_id', 'deregistration_protection', 'last_launched_time', 'image_allowed', 'source_image_id', 'source_im"
    "age_region', 'free_tier_eligible', 'image_id', 'image_location', 'state', 'owner_id', 'creation_date', 'public', '"
    "product_codes', 'architecture', 'image_type', 'kernel_id', 'ramdisk_id', 'platform')), EqPlan(fields=('platform_de"
    "tails', 'usage_operation', 'block_device_mappings', 'description', 'ena_support', 'hypervisor', 'image_owner_alias"
    "', 'name', 'root_device_name', 'root_device_type', 'sriov_net_support', 'state_reason', 'tags', 'virtualization_ty"
    "pe', 'boot_mode', 'tpm_support', 'deprecation_time', 'imds_support', 'source_instance_id', 'deregistration_protect"
    "ion', 'last_launched_time', 'image_allowed', 'source_image_id', 'source_image_region', 'free_tier_eligible', 'imag"
    "e_id', 'image_location', 'state', 'owner_id', 'creation_date', 'public', 'product_codes', 'architecture', 'image_t"
    "ype', 'kernel_id', 'ramdisk_id', 'platform')), FrozenPlan(fields=('__shape__', 'platform_details', 'usage_operatio"
    "n', 'block_device_mappings', 'description', 'ena_support', 'hypervisor', 'image_owner_alias', 'name', 'root_device"
    "_name', 'root_device_type', 'sriov_net_support', 'state_reason', 'tags', 'virtualization_type', 'boot_mode', 'tpm_"
    "support', 'deprecation_time', 'imds_support', 'source_instance_id', 'deregistration_protection', 'last_launched_ti"
    "me', 'image_allowed', 'source_image_id', 'source_image_region', 'free_tier_eligible', 'image_id', 'image_location'"
    ", 'state', 'owner_id', 'creation_date', 'public', 'product_codes', 'architecture', 'image_type', 'kernel_id', 'ram"
    "disk_id', 'platform'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('platform_details', 'usag"
    "e_operation', 'block_device_mappings', 'description', 'ena_support', 'hypervisor', 'image_owner_alias', 'name', 'r"
    "oot_device_name', 'root_device_type', 'sriov_net_support', 'state_reason', 'tags', 'virtualization_type', 'boot_mo"
    "de', 'tpm_support', 'deprecation_time', 'imds_support', 'source_instance_id', 'deregistration_protection', 'last_l"
    "aunched_time', 'image_allowed', 'source_image_id', 'source_image_region', 'free_tier_eligible', 'image_id', 'image"
    "_location', 'state', 'owner_id', 'creation_date', 'public', 'product_codes', 'architecture', 'image_type', 'kernel"
    "_id', 'ramdisk_id', 'platform'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef("
    "name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='platform_details', annotation=Op"
    "Ref(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True"
    ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='usage_operation', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default')"
    ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='block_device_mappings', annotation=OpRef(name='init.fields.3.annotation'), defa"
    "ult=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
    "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='description', annotation=OpRef(name='ini"
    "t.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=Fa"
    "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_support"
    "', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory"
    "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
    "tPlan.Field(name='hypervisor', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields."
    "6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='image_owner_alias', annotation=OpRef(name='init.fields.7.annotation'"
    "), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='ini"
    "t.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=Fa"
    "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='root_device"
    "_name', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='root_device_type', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='"
    "init.fields.10.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
    "one, validate=None, check_type=None), InitPlan.Field(name='sriov_net_support', annotation=OpRef(name='init.fields."
    "11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state_reason', ann"
    "otation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
    "n.Field(name='tags', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13.defaul"
    "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='virtualization_type', annotation=OpRef(name='init.fields.14.annotation'), de"
    "fault=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=False, field_type=FieldType."
    "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='boot_mode', annotation=OpRef(name='in"
    "it.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tpm_supp"
    "ort', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='deprecation_time', annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='"
    "init.fields.17.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
    "one, validate=None, check_type=None), InitPlan.Field(name='imds_support', annotation=OpRef(name='init.fields.18.an"
    "notation'), default=OpRef(name='init.fields.18.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='source_instance_id', an"
    "notation=OpRef(name='init.fields.19.annotation'), default=OpRef(name='init.fields.19.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='deregistration_protection', annotation=OpRef(name='init.fields.20.annotation'), default=OpRef(name="
    "'init.fields.20.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='last_launched_time', annotation=OpRef(name='init.field"
    "s.21.annotation'), default=OpRef(name='init.fields.21.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='image_allowed', "
    "annotation=OpRef(name='init.fields.22.annotation'), default=OpRef(name='init.fields.22.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='source_image_id', annotation=OpRef(name='init.fields.23.annotation'), default=OpRef(name='init.fi"
    "elds.23.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='source_image_region', annotation=OpRef(name='init.fields.24.an"
    "notation'), default=OpRef(name='init.fields.24.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='free_tier_eligible', an"
    "notation=OpRef(name='init.fields.25.annotation'), default=OpRef(name='init.fields.25.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='image_id', annotation=OpRef(name='init.fields.26.annotation'), default=OpRef(name='init.fields.26.d"
    "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
    "ne, check_type=None), InitPlan.Field(name='image_location', annotation=OpRef(name='init.fields.27.annotation'), de"
    "fault=OpRef(name='init.fields.27.default'), default_factory=None, init=True, override=False, field_type=FieldType."
    "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state', annotation=OpRef(name='init.f"
    "ields.28.annotation'), default=OpRef(name='init.fields.28.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='owner_id', a"
    "nnotation=OpRef(name='init.fields.29.annotation'), default=OpRef(name='init.fields.29.default'), default_factory=N"
    "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
    "lan.Field(name='creation_date', annotation=OpRef(name='init.fields.30.annotation'), default=OpRef(name='init.field"
    "s.30.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='public', annotation=OpRef(name='init.fields.31.annotation'), defa"
    "ult=OpRef(name='init.fields.31.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='product_codes', annotation=OpRef(name='"
    "init.fields.32.annotation'), default=OpRef(name='init.fields.32.default'), default_factory=None, init=True, overri"
    "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='archit"
    "ecture', annotation=OpRef(name='init.fields.33.annotation'), default=OpRef(name='init.fields.33.default'), default"
    "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
    "ne), InitPlan.Field(name='image_type', annotation=OpRef(name='init.fields.34.annotation'), default=OpRef(name='ini"
    "t.fields.34.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
    ", validate=None, check_type=None), InitPlan.Field(name='kernel_id', annotation=OpRef(name='init.fields.35.annotati"
    "on'), default=OpRef(name='init.fields.35.default'), default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ramdisk_id', annotation=OpRef"
    "(name='init.fields.36.annotation'), default=OpRef(name='init.fields.36.default'), default_factory=None, init=True,"
    " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
    "'platform', annotation=OpRef(name='init.fields.37.annotation'), default=OpRef(name='init.fields.37.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None)), self_param='self', std_params=(), kw_only_params=('platform_details', 'usage_operation', 'block_device_ma"
    "ppings', 'description', 'ena_support', 'hypervisor', 'image_owner_alias', 'name', 'root_device_name', 'root_device"
    "_type', 'sriov_net_support', 'state_reason', 'tags', 'virtualization_type', 'boot_mode', 'tpm_support', 'deprecati"
    "on_time', 'imds_support', 'source_instance_id', 'deregistration_protection', 'last_launched_time', 'image_allowed'"
    ", 'source_image_id', 'source_image_region', 'free_tier_eligible', 'image_id', 'image_location', 'state', 'owner_id"
    "', 'creation_date', 'public', 'product_codes', 'architecture', 'image_type', 'kernel_id', 'ramdisk_id', 'platform'"
    "), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field"
    "(name='platform_details', kw_only=True, fn=None), ReprPlan.Field(name='usage_operation', kw_only=True, fn=None), R"
    "eprPlan.Field(name='block_device_mappings', kw_only=True, fn=None), ReprPlan.Field(name='description', kw_only=Tru"
    "e, fn=None), ReprPlan.Field(name='ena_support', kw_only=True, fn=None), ReprPlan.Field(name='hypervisor', kw_only="
    "True, fn=None), ReprPlan.Field(name='image_owner_alias', kw_only=True, fn=None), ReprPlan.Field(name='name', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='root_device_name', kw_only=True, fn=None), ReprPlan.Field(name='root_devic"
    "e_type', kw_only=True, fn=None), ReprPlan.Field(name='sriov_net_support', kw_only=True, fn=None), ReprPlan.Field(n"
    "ame='state_reason', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=True, fn=None), ReprPlan.Field(nam"
    "e='virtualization_type', kw_only=True, fn=None), ReprPlan.Field(name='boot_mode', kw_only=True, fn=None), ReprPlan"
    ".Field(name='tpm_support', kw_only=True, fn=None), ReprPlan.Field(name='deprecation_time', kw_only=True, fn=None),"
    " ReprPlan.Field(name='imds_support', kw_only=True, fn=None), ReprPlan.Field(name='source_instance_id', kw_only=Tru"
    "e, fn=None), ReprPlan.Field(name='deregistration_protection', kw_only=True, fn=None), ReprPlan.Field(name='last_la"
    "unched_time', kw_only=True, fn=None), ReprPlan.Field(name='image_allowed', kw_only=True, fn=None), ReprPlan.Field("
    "name='source_image_id', kw_only=True, fn=None), ReprPlan.Field(name='source_image_region', kw_only=True, fn=None),"
    " ReprPlan.Field(name='free_tier_eligible', kw_only=True, fn=None), ReprPlan.Field(name='image_id', kw_only=True, f"
    "n=None), ReprPlan.Field(name='image_location', kw_only=True, fn=None), ReprPlan.Field(name='state', kw_only=True, "
    "fn=None), ReprPlan.Field(name='owner_id', kw_only=True, fn=None), ReprPlan.Field(name='creation_date', kw_only=Tru"
    "e, fn=None), ReprPlan.Field(name='public', kw_only=True, fn=None), ReprPlan.Field(name='product_codes', kw_only=Tr"
    "ue, fn=None), ReprPlan.Field(name='architecture', kw_only=True, fn=None), ReprPlan.Field(name='image_type', kw_onl"
    "y=True, fn=None), ReprPlan.Field(name='kernel_id', kw_only=True, fn=None), ReprPlan.Field(name='ramdisk_id', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='platform', kw_only=True, fn=None)), id=False, terse=False, default_fn=None"
    ")))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fImage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__21__annotation,
    __dataclass__init__fields__21__default,
    __dataclass__init__fields__22__annotation,
    __dataclass__init__fields__22__default,
    __dataclass__init__fields__23__annotation,
    __dataclass__init__fields__23__default,
    __dataclass__init__fields__24__annotation,
    __dataclass__init__fields__24__default,
    __dataclass__init__fields__25__annotation,
    __dataclass__init__fields__25__default,
    __dataclass__init__fields__26__annotation,
    __dataclass__init__fields__26__default,
    __dataclass__init__fields__27__annotation,
    __dataclass__init__fields__27__default,
    __dataclass__init__fields__28__annotation,
    __dataclass__init__fields__28__default,
    __dataclass__init__fields__29__annotation,
    __dataclass__init__fields__29__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__30__annotation,
    __dataclass__init__fields__30__default,
    __dataclass__init__fields__31__annotation,
    __dataclass__init__fields__31__default,
    __dataclass__init__fields__32__annotation,
    __dataclass__init__fields__32__default,
    __dataclass__init__fields__33__annotation,
    __dataclass__init__fields__33__default,
    __dataclass__init__fields__34__annotation,
    __dataclass__init__fields__34__default,
    __dataclass__init__fields__35__annotation,
    __dataclass__init__fields__35__default,
    __dataclass__init__fields__36__annotation,
    __dataclass__init__fields__36__default,
    __dataclass__init__fields__37__annotation,
    __dataclass__init__fields__37__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            platform_details=self.platform_details,
            usage_operation=self.usage_operation,
            block_device_mappings=self.block_device_mappings,
            description=self.description,
            ena_support=self.ena_support,
            hypervisor=self.hypervisor,
            image_owner_alias=self.image_owner_alias,
            name=self.name,
            root_device_name=self.root_device_name,
            root_device_type=self.root_device_type,
            sriov_net_support=self.sriov_net_support,
            state_reason=self.state_reason,
            tags=self.tags,
            virtualization_type=self.virtualization_type,
            boot_mode=self.boot_mode,
            tpm_support=self.tpm_support,
            deprecation_time=self.deprecation_time,
            imds_support=self.imds_support,
            source_instance_id=self.source_instance_id,
            deregistration_protection=self.deregistration_protection,
            last_launched_time=self.last_launched_time,
            image_allowed=self.image_allowed,
            source_image_id=self.source_image_id,
            source_image_region=self.source_image_region,
            free_tier_eligible=self.free_tier_eligible,
            image_id=self.image_id,
            image_location=self.image_location,
            state=self.state,
            owner_id=self.owner_id,
            creation_date=self.creation_date,
            public=self.public,
            product_codes=self.product_codes,
            architecture=self.architecture,
            image_type=self.image_type,
            kernel_id=self.kernel_id,
            ramdisk_id=self.ramdisk_id,
            platform=self.platform,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.platform_details == other.platform_details and
            self.usage_operation == other.usage_operation and
            self.block_device_mappings == other.block_device_mappings and
            self.description == other.description and
            self.ena_support == other.ena_support and
            self.hypervisor == other.hypervisor and
            self.image_owner_alias == other.image_owner_alias and
            self.name == other.name and
            self.root_device_name == other.root_device_name and
            self.root_device_type == other.root_device_type and
            self.sriov_net_support == other.sriov_net_support and
            self.state_reason == other.state_reason and
            self.tags == other.tags and
            self.virtualization_type == other.virtualization_type and
            self.boot_mode == other.boot_mode and
            self.tpm_support == other.tpm_support and
            self.deprecation_time == other.deprecation_time and
            self.imds_support == other.imds_support and
            self.source_instance_id == other.source_instance_id and
            self.deregistration_protection == other.deregistration_protection and
            self.last_launched_time == other.last_launched_time and
            self.image_allowed == other.image_allowed and
            self.source_image_id == other.source_image_id and
            self.source_image_region == other.source_image_region and
            self.free_tier_eligible == other.free_tier_eligible and
            self.image_id == other.image_id and
            self.image_location == other.image_location and
            self.state == other.state and
            self.owner_id == other.owner_id and
            self.creation_date == other.creation_date and
            self.public == other.public and
            self.product_codes == other.product_codes and
            self.architecture == other.architecture and
            self.image_type == other.image_type and
            self.kernel_id == other.kernel_id and
            self.ramdisk_id == other.ramdisk_id and
            self.platform == other.platform
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'platform_details',
        'usage_operation',
        'block_device_mappings',
        'description',
        'ena_support',
        'hypervisor',
        'image_owner_alias',
        'name',
        'root_device_name',
        'root_device_type',
        'sriov_net_support',
        'state_reason',
        'tags',
        'virtualization_type',
        'boot_mode',
        'tpm_support',
        'deprecation_time',
        'imds_support',
        'source_instance_id',
        'deregistration_protection',
        'last_launched_time',
        'image_allowed',
        'source_image_id',
        'source_image_region',
        'free_tier_eligible',
        'image_id',
        'image_location',
        'state',
        'owner_id',
        'creation_date',
        'public',
        'product_codes',
        'architecture',
        'image_type',
        'kernel_id',
        'ramdisk_id',
        'platform',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'platform_details',
        'usage_operation',
        'block_device_mappings',
        'description',
        'ena_support',
        'hypervisor',
        'image_owner_alias',
        'name',
        'root_device_name',
        'root_device_type',
        'sriov_net_support',
        'state_reason',
        'tags',
        'virtualization_type',
        'boot_mode',
        'tpm_support',
        'deprecation_time',
        'imds_support',
        'source_instance_id',
        'deregistration_protection',
        'last_launched_time',
        'image_allowed',
        'source_image_id',
        'source_image_region',
        'free_tier_eligible',
        'image_id',
        'image_location',
        'state',
        'owner_id',
        'creation_date',
        'public',
        'product_codes',
        'architecture',
        'image_type',
        'kernel_id',
        'ramdisk_id',
        'platform',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.platform_details,
            self.usage_operation,
            self.block_device_mappings,
            self.description,
            self.ena_support,
            self.hypervisor,
            self.image_owner_alias,
            self.name,
            self.root_device_name,
            self.root_device_type,
            self.sriov_net_support,
            self.state_reason,
            self.tags,
            self.virtualization_type,
            self.boot_mode,
            self.tpm_support,
            self.deprecation_time,
            self.imds_support,
            self.source_instance_id,
            self.deregistration_protection,
            self.last_launched_time,
            self.image_allowed,
            self.source_image_id,
            self.source_image_region,
            self.free_tier_eligible,
            self.image_id,
            self.image_location,
            self.state,
            self.owner_id,
            self.creation_date,
            self.public,
            self.product_codes,
            self.architecture,
            self.image_type,
            self.kernel_id,
            self.ramdisk_id,
            self.platform,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        platform_details: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        usage_operation: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        block_device_mappings: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        description: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ena_support: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        hypervisor: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        image_owner_alias: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        name: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        root_device_name: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        root_device_type: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        sriov_net_support: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        state_reason: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        tags: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        virtualization_type: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        boot_mode: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        tpm_support: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        deprecation_time: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        imds_support: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        source_instance_id: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        deregistration_protection: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        last_launched_time: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
        image_allowed: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
        source_image_id: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
        source_image_region: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
        free_tier_eligible: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
        image_id: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
        image_location: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
        state: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
        owner_id: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
        creation_date: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
        public: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
        product_codes: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
        architecture: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
        image_type: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
        kernel_id: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
        ramdisk_id: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
        platform: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'platform_details', platform_details)
        __dataclass__object_setattr(self, 'usage_operation', usage_operation)
        __dataclass__object_setattr(self, 'block_device_mappings', block_device_mappings)
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'ena_support', ena_support)
        __dataclass__object_setattr(self, 'hypervisor', hypervisor)
        __dataclass__object_setattr(self, 'image_owner_alias', image_owner_alias)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'root_device_name', root_device_name)
        __dataclass__object_setattr(self, 'root_device_type', root_device_type)
        __dataclass__object_setattr(self, 'sriov_net_support', sriov_net_support)
        __dataclass__object_setattr(self, 'state_reason', state_reason)
        __dataclass__object_setattr(self, 'tags', tags)
        __dataclass__object_setattr(self, 'virtualization_type', virtualization_type)
        __dataclass__object_setattr(self, 'boot_mode', boot_mode)
        __dataclass__object_setattr(self, 'tpm_support', tpm_support)
        __dataclass__object_setattr(self, 'deprecation_time', deprecation_time)
        __dataclass__object_setattr(self, 'imds_support', imds_support)
        __dataclass__object_setattr(self, 'source_instance_id', source_instance_id)
        __dataclass__object_setattr(self, 'deregistration_protection', deregistration_protection)
        __dataclass__object_setattr(self, 'last_launched_time', last_launched_time)
        __dataclass__object_setattr(self, 'image_allowed', image_allowed)
        __dataclass__object_setattr(self, 'source_image_id', source_image_id)
        __dataclass__object_setattr(self, 'source_image_region', source_image_region)
        __dataclass__object_setattr(self, 'free_tier_eligible', free_tier_eligible)
        __dataclass__object_setattr(self, 'image_id', image_id)
        __dataclass__object_setattr(self, 'image_location', image_location)
        __dataclass__object_setattr(self, 'state', state)
        __dataclass__object_setattr(self, 'owner_id', owner_id)
        __dataclass__object_setattr(self, 'creation_date', creation_date)
        __dataclass__object_setattr(self, 'public', public)
        __dataclass__object_setattr(self, 'product_codes', product_codes)
        __dataclass__object_setattr(self, 'architecture', architecture)
        __dataclass__object_setattr(self, 'image_type', image_type)
        __dataclass__object_setattr(self, 'kernel_id', kernel_id)
        __dataclass__object_setattr(self, 'ramdisk_id', ramdisk_id)
        __dataclass__object_setattr(self, 'platform', platform)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"platform_details={self.platform_details!r}")
        parts.append(f"usage_operation={self.usage_operation!r}")
        parts.append(f"block_device_mappings={self.block_device_mappings!r}")
        parts.append(f"description={self.description!r}")
        parts.append(f"ena_support={self.ena_support!r}")
        parts.append(f"hypervisor={self.hypervisor!r}")
        parts.append(f"image_owner_alias={self.image_owner_alias!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"root_device_name={self.root_device_name!r}")
        parts.append(f"root_device_type={self.root_device_type!r}")
        parts.append(f"sriov_net_support={self.sriov_net_support!r}")
        parts.append(f"state_reason={self.state_reason!r}")
        parts.append(f"tags={self.tags!r}")
        parts.append(f"virtualization_type={self.virtualization_type!r}")
        parts.append(f"boot_mode={self.boot_mode!r}")
        parts.append(f"tpm_support={self.tpm_support!r}")
        parts.append(f"deprecation_time={self.deprecation_time!r}")
        parts.append(f"imds_support={self.imds_support!r}")
        parts.append(f"source_instance_id={self.source_instance_id!r}")
        parts.append(f"deregistration_protection={self.deregistration_protection!r}")
        parts.append(f"last_launched_time={self.last_launched_time!r}")
        parts.append(f"image_allowed={self.image_allowed!r}")
        parts.append(f"source_image_id={self.source_image_id!r}")
        parts.append(f"source_image_region={self.source_image_region!r}")
        parts.append(f"free_tier_eligible={self.free_tier_eligible!r}")
        parts.append(f"image_id={self.image_id!r}")
        parts.append(f"image_location={self.image_location!r}")
        parts.append(f"state={self.state!r}")
        parts.append(f"owner_id={self.owner_id!r}")
        parts.append(f"creation_date={self.creation_date!r}")
        parts.append(f"public={self.public!r}")
        parts.append(f"product_codes={self.product_codes!r}")
        parts.append(f"architecture={self.architecture!r}")
        parts.append(f"image_type={self.image_type!r}")
        parts.append(f"kernel_id={self.kernel_id!r}")
        parts.append(f"ramdisk_id={self.ramdisk_id!r}")
        parts.append(f"platform={self.platform!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('accelerators', 'total_inference_memory_in_mi_b')), EqPlan(fields=('accelerators', 'to"
    "tal_inference_memory_in_mi_b')), FrozenPlan(fields=('__shape__', 'accelerators', 'total_inference_memory_in_mi_b')"
    ", allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('accelerators', 'total_inference_memory_in_mi_"
    "b'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotati"
    "on'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='accelerators', annotation=OpRef(name='init.fields.1.annotati"
    "on'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='total_inference_memory_in_mi_b"
    "', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory"
    "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), se"
    "lf_param='self', std_params=(), kw_only_params=('accelerators', 'total_inference_memory_in_mi_b'), frozen=True, sl"
    "ots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='accelerator"
    "s', kw_only=True, fn=None), ReprPlan.Field(name='total_inference_memory_in_mi_b', kw_only=True, fn=None)), id=Fals"
    "e, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInferenceAcceleratorInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            accelerators=self.accelerators,
            total_inference_memory_in_mi_b=self.total_inference_memory_in_mi_b,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.accelerators == other.accelerators and
            self.total_inference_memory_in_mi_b == other.total_inference_memory_in_mi_b
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'accelerators',
        'total_inference_memory_in_mi_b',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'accelerators',
        'total_inference_memory_in_mi_b',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.accelerators,
            self.total_inference_memory_in_mi_b,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        accelerators: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        total_inference_memory_in_mi_b: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'accelerators', accelerators)
        __dataclass__object_setattr(self, 'total_inference_memory_in_mi_b', total_inference_memory_in_mi_b)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"accelerators={self.accelerators!r}")
        parts.append(f"total_inference_memory_in_mi_b={self.total_inference_memory_in_mi_b!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('association', 'attachment', 'description', 'groups', 'ipv6_addresses', 'mac_address',"
    " 'network_interface_id', 'owner_id', 'private_dns_name', 'private_ip_address', 'private_ip_addresses', 'source_des"
    "t_check', 'status', 'subnet_id', 'vpc_id', 'interface_type', 'ipv4_prefixes', 'ipv6_prefixes', 'connection_trackin"
    "g_configuration', 'operator')), EqPlan(fields=('association', 'attachment', 'description', 'groups', 'ipv6_address"
    "es', 'mac_address', 'network_interface_id', 'owner_id', 'private_dns_name', 'private_ip_address', 'private_ip_addr"
    "esses', 'source_dest_check', 'status', 'subnet_id', 'vpc_id', 'interface_type', 'ipv4_prefixes', 'ipv6_prefixes', "
    "'connection_tracking_configuration', 'operator')), FrozenPlan(fields=('__shape__', 'association', 'attachment', 'd"
    "escription', 'groups', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'owner_id', 'private_dns_name', 'p"
    "rivate_ip_address', 'private_ip_addresses', 'source_dest_check', 'status', 'subnet_id', 'vpc_id', 'interface_type'"
    ", 'ipv4_prefixes', 'ipv6_prefixes', 'connection_tracking_configuration', 'operator'), allow_dynamic_dunder_attrs=F"
    "alse), HashPlan(action='add', fields=('association', 'attachment', 'description', 'groups', 'ipv6_addresses', 'mac"
    "_address', 'network_interface_id', 'owner_id', 'private_dns_name', 'private_ip_address', 'private_ip_addresses', '"
    "source_dest_check', 'status', 'subnet_id', 'vpc_id', 'interface_type', 'ipv4_prefixes', 'ipv6_prefixes', 'connecti"
    "on_tracking_configuration', 'operator'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotatio"
    "n=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='association', annotation"
    "=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=T"
    "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
    "ame='attachment', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None), InitPlan.Field(name='description', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(na"
    "me='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='groups', annotation=OpRef(name='init.fields.4.annota"
    "tion'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=F"
    "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_addresses', annotation="
    "OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='mac_address', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None), InitPlan.Field(name='network_interface_id', annotation=OpRef(name='init.fields.7.annotation'), default"
    "=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='owner_id', annotation=OpRef(name='init.fiel"
    "ds.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, f"
    "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='private_dns_name'"
    ", annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='private_ip_address', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init"
    ".fields.10.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None), InitPlan.Field(name='private_ip_addresses', annotation=OpRef(name='init.fields.1"
    "1.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='source_dest_check',"
    " annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory"
    "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
    "tPlan.Field(name='status', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='subnet_id', annotation=OpRef(name='init.fields.14.annotation'), defaul"
    "t=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
    "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fiel"
    "ds.15.annotation'), default=OpRef(name='init.fields.15.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='interface_type'"
    ", annotation=OpRef(name='init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_factor"
    "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
    "itPlan.Field(name='ipv4_prefixes', annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fi"
    "elds.17.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='ipv6_prefixes', annotation=OpRef(name='init.fields.18.annotati"
    "on'), default=OpRef(name='init.fields.18.default'), default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='connection_tracking_configura"
    "tion', annotation=OpRef(name='init.fields.19.annotation'), default=OpRef(name='init.fields.19.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='operator', annotation=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.fi"
    "elds.20.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('association', 'attachment', 'de"
    "scription', 'groups', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'owner_id', 'private_dns_name', 'pr"
    "ivate_ip_address', 'private_ip_addresses', 'source_dest_check', 'status', 'subnet_id', 'vpc_id', 'interface_type',"
    " 'ipv4_prefixes', 'ipv6_prefixes', 'connection_tracking_configuration', 'operator'), frozen=True, slots=False, pos"
    "t_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='association', kw_only=Tru"
    "e, fn=None), ReprPlan.Field(name='attachment', kw_only=True, fn=None), ReprPlan.Field(name='description', kw_only="
    "True, fn=None), ReprPlan.Field(name='groups', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_addresses', kw_onl"
    "y=True, fn=None), ReprPlan.Field(name='mac_address', kw_only=True, fn=None), ReprPlan.Field(name='network_interfac"
    "e_id', kw_only=True, fn=None), ReprPlan.Field(name='owner_id', kw_only=True, fn=None), ReprPlan.Field(name='privat"
    "e_dns_name', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_address', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='private_ip_addresses', kw_only=True, fn=None), ReprPlan.Field(name='source_dest_check', kw_only=True, fn"
    "=None), ReprPlan.Field(name='status', kw_only=True, fn=None), ReprPlan.Field(name='subnet_id', kw_only=True, fn=No"
    "ne), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPlan.Field(name='interface_type', kw_only=True, fn="
    "None), ReprPlan.Field(name='ipv4_prefixes', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_prefixes', kw_only=T"
    "rue, fn=None), ReprPlan.Field(name='connection_tracking_configuration', kw_only=True, fn=None), ReprPlan.Field(nam"
    "e='operator', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceNetworkInterface(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            association=self.association,
            attachment=self.attachment,
            description=self.description,
            groups=self.groups,
            ipv6_addresses=self.ipv6_addresses,
            mac_address=self.mac_address,
            network_interface_id=self.network_interface_id,
            owner_id=self.owner_id,
            private_dns_name=self.private_dns_name,
            private_ip_address=self.private_ip_address,
            private_ip_addresses=self.private_ip_addresses,
            source_dest_check=self.source_dest_check,
            status=self.status,
            subnet_id=self.subnet_id,
            vpc_id=self.vpc_id,
            interface_type=self.interface_type,
            ipv4_prefixes=self.ipv4_prefixes,
            ipv6_prefixes=self.ipv6_prefixes,
            connection_tracking_configuration=self.connection_tracking_configuration,
            operator=self.operator,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.association == other.association and
            self.attachment == other.attachment and
            self.description == other.description and
            self.groups == other.groups and
            self.ipv6_addresses == other.ipv6_addresses and
            self.mac_address == other.mac_address and
            self.network_interface_id == other.network_interface_id and
            self.owner_id == other.owner_id and
            self.private_dns_name == other.private_dns_name and
            self.private_ip_address == other.private_ip_address and
            self.private_ip_addresses == other.private_ip_addresses and
            self.source_dest_check == other.source_dest_check and
            self.status == other.status and
            self.subnet_id == other.subnet_id and
            self.vpc_id == other.vpc_id and
            self.interface_type == other.interface_type and
            self.ipv4_prefixes == other.ipv4_prefixes and
            self.ipv6_prefixes == other.ipv6_prefixes and
            self.connection_tracking_configuration == other.connection_tracking_configuration and
            self.operator == other.operator
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'association',
        'attachment',
        'description',
        'groups',
        'ipv6_addresses',
        'mac_address',
        'network_interface_id',
        'owner_id',
        'private_dns_name',
        'private_ip_address',
        'private_ip_addresses',
        'source_dest_check',
        'status',
        'subnet_id',
        'vpc_id',
        'interface_type',
        'ipv4_prefixes',
        'ipv6_prefixes',
        'connection_tracking_configuration',
        'operator',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'association',
        'attachment',
        'description',
        'groups',
        'ipv6_addresses',
        'mac_address',
        'network_interface_id',
        'owner_id',
        'private_dns_name',
        'private_ip_address',
        'private_ip_addresses',
        'source_dest_check',
        'status',
        'subnet_id',
        'vpc_id',
        'interface_type',
        'ipv4_prefixes',
        'ipv6_prefixes',
        'connection_tracking_configuration',
        'operator',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.association,
            self.attachment,
            self.description,
            self.groups,
            self.ipv6_addresses,
            self.mac_address,
            self.network_interface_id,
            self.owner_id,
            self.private_dns_name,
            self.private_ip_address,
            self.private_ip_addresses,
            self.source_dest_check,
            self.status,
            self.subnet_id,
            self.vpc_id,
            self.interface_type,
            self.ipv4_prefixes,
            self.ipv6_prefixes,
            self.connection_tracking_configuration,
            self.operator,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        association: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        attachment: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        description: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        groups: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ipv6_addresses: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        mac_address: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        network_interface_id: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        owner_id: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        private_dns_name: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        private_ip_address: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        private_ip_addresses: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        source_dest_check: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        status: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        subnet_id: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        vpc_id: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        interface_type: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        ipv4_prefixes: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        ipv6_prefixes: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        connection_tracking_configuration: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        operator: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'association', association)
        __dataclass__object_setattr(self, 'attachment', attachment)
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'groups', groups)
        __dataclass__object_setattr(self, 'ipv6_addresses', ipv6_addresses)
        __dataclass__object_setattr(self, 'mac_address', mac_address)
        __dataclass__object_setattr(self, 'network_interface_id', network_interface_id)
        __dataclass__object_setattr(self, 'owner_id', owner_id)
        __dataclass__object_setattr(self, 'private_dns_name', private_dns_name)
        __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)
        __dataclass__object_setattr(self, 'private_ip_addresses', private_ip_addresses)
        __dataclass__object_setattr(self, 'source_dest_check', source_dest_check)
        __dataclass__object_setattr(self, 'status', status)
        __dataclass__object_setattr(self, 'subnet_id', subnet_id)
        __dataclass__object_setattr(self, 'vpc_id', vpc_id)
        __dataclass__object_setattr(self, 'interface_type', interface_type)
        __dataclass__object_setattr(self, 'ipv4_prefixes', ipv4_prefixes)
        __dataclass__object_setattr(self, 'ipv6_prefixes', ipv6_prefixes)
        __dataclass__object_setattr(self, 'connection_tracking_configuration', connection_tracking_configuration)
        __dataclass__object_setattr(self, 'operator', operator)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"association={self.association!r}")
        parts.append(f"attachment={self.attachment!r}")
        parts.append(f"description={self.description!r}")
        parts.append(f"groups={self.groups!r}")
        parts.append(f"ipv6_addresses={self.ipv6_addresses!r}")
        parts.append(f"mac_address={self.mac_address!r}")
        parts.append(f"network_interface_id={self.network_interface_id!r}")
        parts.append(f"owner_id={self.owner_id!r}")
        parts.append(f"private_dns_name={self.private_dns_name!r}")
        parts.append(f"private_ip_address={self.private_ip_address!r}")
        parts.append(f"private_ip_addresses={self.private_ip_addresses!r}")
        parts.append(f"source_dest_check={self.source_dest_check!r}")
        parts.append(f"status={self.status!r}")
        parts.append(f"subnet_id={self.subnet_id!r}")
        parts.append(f"vpc_id={self.vpc_id!r}")
        parts.append(f"interface_type={self.interface_type!r}")
        parts.append(f"ipv4_prefixes={self.ipv4_prefixes!r}")
        parts.append(f"ipv6_prefixes={self.ipv6_prefixes!r}")
        parts.append(f"connection_tracking_configuration={self.connection_tracking_configuration!r}")
        parts.append(f"operator={self.operator!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('accelerators', 'total_media_memory_in_mi_b')), EqPlan(fields=('accelerators', 'total_"
    "media_memory_in_mi_b')), FrozenPlan(fields=('__shape__', 'accelerators', 'total_media_memory_in_mi_b'), allow_dyna"
    "mic_dunder_attrs=False), HashPlan(action='add', fields=('accelerators', 'total_media_memory_in_mi_b'), cache=False"
    "), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=No"
    "ne, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='accelerators', annotation=OpRef(name='init.fields.1.annotation'), default=Op"
    "Ref(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='total_media_memory_in_mi_b', annotation=OpRef("
    "name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, ov"
    "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std"
    "_params=(), kw_only_params=('accelerators', 'total_media_memory_in_mi_b'), frozen=True, slots=False, post_init_par"
    "ams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='accelerators', kw_only=True, fn=Non"
    "e), ReprPlan.Field(name='total_media_memory_in_mi_b', kw_only=True, fn=None)), id=False, terse=False, default_fn=N"
    "one)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fMediaAcceleratorInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            accelerators=self.accelerators,
            total_media_memory_in_mi_b=self.total_media_memory_in_mi_b,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.accelerators == other.accelerators and
            self.total_media_memory_in_mi_b == other.total_media_memory_in_mi_b
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'accelerators',
        'total_media_memory_in_mi_b',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'accelerators',
        'total_media_memory_in_mi_b',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.accelerators,
            self.total_media_memory_in_mi_b,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        accelerators: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        total_media_memory_in_mi_b: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'accelerators', accelerators)
        __dataclass__object_setattr(self, 'total_media_memory_in_mi_b', total_media_memory_in_mi_b)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"accelerators={self.accelerators!r}")
        parts.append(f"total_media_memory_in_mi_b={self.total_media_memory_in_mi_b!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('association', 'attachment', 'availability_zone', 'connection_tracking_configuration',"
    " 'description', 'groups', 'interface_type', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'outpost_arn'"
    ", 'owner_id', 'private_dns_name', 'public_dns_name', 'public_ip_dns_name_options', 'private_ip_address', 'private_"
    "ip_addresses', 'ipv4_prefixes', 'ipv6_prefixes', 'requester_id', 'requester_managed', 'source_dest_check', 'status"
    "', 'subnet_id', 'tag_set', 'vpc_id', 'deny_all_igw_traffic', 'ipv6_native', 'ipv6_address', 'operator', 'associate"
    "d_subnets', 'availability_zone_id')), EqPlan(fields=('association', 'attachment', 'availability_zone', 'connection"
    "_tracking_configuration', 'description', 'groups', 'interface_type', 'ipv6_addresses', 'mac_address', 'network_int"
    "erface_id', 'outpost_arn', 'owner_id', 'private_dns_name', 'public_dns_name', 'public_ip_dns_name_options', 'priva"
    "te_ip_address', 'private_ip_addresses', 'ipv4_prefixes', 'ipv6_prefixes', 'requester_id', 'requester_managed', 'so"
    "urce_dest_check', 'status', 'subnet_id', 'tag_set', 'vpc_id', 'deny_all_igw_traffic', 'ipv6_native', 'ipv6_address"
    "', 'operator', 'associated_subnets', 'availability_zone_id')), FrozenPlan(fields=('__shape__', 'association', 'att"
    "achment', 'availability_zone', 'connection_tracking_configuration', 'description', 'groups', 'interface_type', 'ip"
    "v6_addresses', 'mac_address', 'network_interface_id', 'outpost_arn', 'owner_id', 'private_dns_name', 'public_dns_n"
    "ame', 'public_ip_dns_name_options', 'private_ip_address', 'private_ip_addresses', 'ipv4_prefixes', 'ipv6_prefixes'"
    ", 'requester_id', 'requester_managed', 'source_dest_check', 'status', 'subnet_id', 'tag_set', 'vpc_id', 'deny_all_"
    "igw_traffic', 'ipv6_native', 'ipv6_address', 'operator', 'associated_subnets', 'availability_zone_id'), allow_dyna"
    "mic_dunder_attrs=False), HashPlan(action='add', fields=('association', 'attachment', 'availability_zone', 'connect"
    "ion_tracking_configuration', 'description', 'groups', 'interface_type', 'ipv6_addresses', 'mac_address', 'network_"
    "interface_id', 'outpost_arn', 'owner_id', 'private_dns_name', 'public_dns_name', 'public_ip_dns_name_options', 'pr"
    "ivate_ip_address', 'private_ip_addresses', 'ipv4_prefixes', 'ipv6_prefixes', 'requester_id', 'requester_managed', "
    "'source_dest_check', 'status', 'subnet_id', 'tag_set', 'vpc_id', 'deny_all_igw_traffic', 'ipv6_native', 'ipv6_addr"
    "ess', 'operator', 'associated_subnets', 'availability_zone_id'), cache=False), InitPlan(fields=(InitPlan.Field(nam"
    "e='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "association', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='attachment', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='i"
    "nit.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
    "e, validate=None, check_type=None), InitPlan.Field(name='availability_zone', annotation=OpRef(name='init.fields.3."
    "annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='connection_tracking_co"
    "nfiguration', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='description', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='"
    "init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
    "ne, validate=None, check_type=None), InitPlan.Field(name='groups', annotation=OpRef(name='init.fields.6.annotation"
    "'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='interface_type', annotation=OpRe"
    "f(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "ipv6_addresses', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None), InitPlan.Field(name='mac_address', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(nam"
    "e='init.fields.9.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='network_interface_id', annotation=OpRef(name='init.fi"
    "elds.10.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=Fals"
    "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='outpost_arn',"
    " annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory"
    "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
    "tPlan.Field(name='owner_id', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.1"
    "2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='private_dns_name', annotation=OpRef(name='init.fields.13.annotation'"
    "), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_dns_name', annotation=OpR"
    "ef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=Tru"
    "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
    "e='public_ip_dns_name_options', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.field"
    "s.15.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='private_ip_address', annotation=OpRef(name='init.fields.16.annota"
    "tion'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=True, override=False, field_type="
    "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='private_ip_addresses', anno"
    "tation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
    ".Field(name='ipv4_prefixes', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.1"
    "8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='ipv6_prefixes', annotation=OpRef(name='init.fields.19.annotation'), "
    "default=OpRef(name='init.fields.19.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='requester_id', annotation=OpRef(nam"
    "e='init.fields.20.annotation'), default=OpRef(name='init.fields.20.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='req"
    "uester_managed', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='init.fields.21.default'),"
    " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
    "_type=None), InitPlan.Field(name='source_dest_check', annotation=OpRef(name='init.fields.22.annotation'), default="
    "OpRef(name='init.fields.22.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='status', annotation=OpRef(name='init.fields"
    ".23.annotation'), default=OpRef(name='init.fields.23.default'), default_factory=None, init=True, override=False, f"
    "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnet_id', annot"
    "ation=OpRef(name='init.fields.24.annotation'), default=OpRef(name='init.fields.24.default'), default_factory=None,"
    " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
    "Field(name='tag_set', annotation=OpRef(name='init.fields.25.annotation'), default=OpRef(name='init.fields.25.defau"
    "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
    "check_type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.26.annotation'), default=OpRef("
    "name='init.fields.26.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None), InitPlan.Field(name='deny_all_igw_traffic', annotation=OpRef(name='ini"
    "t.fields.27.annotation'), default=OpRef(name='init.fields.27.default'), default_factory=None, init=True, override="
    "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_nati"
    "ve', annotation=OpRef(name='init.fields.28.annotation'), default=OpRef(name='init.fields.28.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='ipv6_address', annotation=OpRef(name='init.fields.29.annotation'), default=OpRef(name='init."
    "fields.29.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='operator', annotation=OpRef(name='init.fields.30.annotation'"
    "), default=OpRef(name='init.fields.30.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='associated_subnets', annotation="
    "OpRef(name='init.fields.31.annotation'), default=OpRef(name='init.fields.31.default'), default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='availability_zone_id', annotation=OpRef(name='init.fields.32.annotation'), default=OpRef(name='init.fields.3"
    "2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('association', 'attachment', 'availabi"
    "lity_zone', 'connection_tracking_configuration', 'description', 'groups', 'interface_type', 'ipv6_addresses', 'mac"
    "_address', 'network_interface_id', 'outpost_arn', 'owner_id', 'private_dns_name', 'public_dns_name', 'public_ip_dn"
    "s_name_options', 'private_ip_address', 'private_ip_addresses', 'ipv4_prefixes', 'ipv6_prefixes', 'requester_id', '"
    "requester_managed', 'source_dest_check', 'status', 'subnet_id', 'tag_set', 'vpc_id', 'deny_all_igw_traffic', 'ipv6"
    "_native', 'ipv6_address', 'operator', 'associated_subnets', 'availability_zone_id'), frozen=True, slots=False, pos"
    "t_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='association', kw_only=Tru"
    "e, fn=None), ReprPlan.Field(name='attachment', kw_only=True, fn=None), ReprPlan.Field(name='availability_zone', kw"
    "_only=True, fn=None), ReprPlan.Field(name='connection_tracking_configuration', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='description', kw_only=True, fn=None), ReprPlan.Field(name='groups', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='interface_type', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_addresses', kw_only=True, fn=None), Re"
    "prPlan.Field(name='mac_address', kw_only=True, fn=None), ReprPlan.Field(name='network_interface_id', kw_only=True,"
    " fn=None), ReprPlan.Field(name='outpost_arn', kw_only=True, fn=None), ReprPlan.Field(name='owner_id', kw_only=True"
    ", fn=None), ReprPlan.Field(name='private_dns_name', kw_only=True, fn=None), ReprPlan.Field(name='public_dns_name',"
    " kw_only=True, fn=None), ReprPlan.Field(name='public_ip_dns_name_options', kw_only=True, fn=None), ReprPlan.Field("
    "name='private_ip_address', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_addresses', kw_only=True, fn=No"
    "ne), ReprPlan.Field(name='ipv4_prefixes', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_prefixes', kw_only=Tru"
    "e, fn=None), ReprPlan.Field(name='requester_id', kw_only=True, fn=None), ReprPlan.Field(name='requester_managed', "
    "kw_only=True, fn=None), ReprPlan.Field(name='source_dest_check', kw_only=True, fn=None), ReprPlan.Field(name='stat"
    "us', kw_only=True, fn=None), ReprPlan.Field(name='subnet_id', kw_only=True, fn=None), ReprPlan.Field(name='tag_set"
    "', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPlan.Field(name='deny_all_igw"
    "_traffic', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_native', kw_only=True, fn=None), ReprPlan.Field(name="
    "'ipv6_address', kw_only=True, fn=None), ReprPlan.Field(name='operator', kw_only=True, fn=None), ReprPlan.Field(nam"
    "e='associated_subnets', kw_only=True, fn=None), ReprPlan.Field(name='availability_zone_id', kw_only=True, fn=None)"
    "), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fNetworkInterface(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__21__annotation,
    __dataclass__init__fields__21__default,
    __dataclass__init__fields__22__annotation,
    __dataclass__init__fields__22__default,
    __dataclass__init__fields__23__annotation,
    __dataclass__init__fields__23__default,
    __dataclass__init__fields__24__annotation,
    __dataclass__init__fields__24__default,
    __dataclass__init__fields__25__annotation,
    __dataclass__init__fields__25__default,
    __dataclass__init__fields__26__annotation,
    __dataclass__init__fields__26__default,
    __dataclass__init__fields__27__annotation,
    __dataclass__init__fields__27__default,
    __dataclass__init__fields__28__annotation,
    __dataclass__init__fields__28__default,
    __dataclass__init__fields__29__annotation,
    __dataclass__init__fields__29__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__30__annotation,
    __dataclass__init__fields__30__default,
    __dataclass__init__fields__31__annotation,
    __dataclass__init__fields__31__default,
    __dataclass__init__fields__32__annotation,
    __dataclass__init__fields__32__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            association=self.association,
            attachment=self.attachment,
            availability_zone=self.availability_zone,
            connection_tracking_configuration=self.connection_tracking_configuration,
            description=self.description,
            groups=self.groups,
            interface_type=self.interface_type,
            ipv6_addresses=self.ipv6_addresses,
            mac_address=self.mac_address,
            network_interface_id=self.network_interface_id,
            outpost_arn=self.outpost_arn,
            owner_id=self.owner_id,
            private_dns_name=self.private_dns_name,
            public_dns_name=self.public_dns_name,
            public_ip_dns_name_options=self.public_ip_dns_name_options,
            private_ip_address=self.private_ip_address,
            private_ip_addresses=self.private_ip_addresses,
            ipv4_prefixes=self.ipv4_prefixes,
            ipv6_prefixes=self.ipv6_prefixes,
            requester_id=self.requester_id,
            requester_managed=self.requester_managed,
            source_dest_check=self.source_dest_check,
            status=self.status,
            subnet_id=self.subnet_id,
            tag_set=self.tag_set,
            vpc_id=self.vpc_id,
            deny_all_igw_traffic=self.deny_all_igw_traffic,
            ipv6_native=self.ipv6_native,
            ipv6_address=self.ipv6_address,
            operator=self.operator,
            associated_subnets=self.associated_subnets,
            availability_zone_id=self.availability_zone_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.association == other.association and
            self.attachment == other.attachment and
            self.availability_zone == other.availability_zone and
            self.connection_tracking_configuration == other.connection_tracking_configuration and
            self.description == other.description and
            self.groups == other.groups and
            self.interface_type == other.interface_type and
            self.ipv6_addresses == other.ipv6_addresses and
            self.mac_address == other.mac_address and
            self.network_interface_id == other.network_interface_id and
            self.outpost_arn == other.outpost_arn and
            self.owner_id == other.owner_id and
            self.private_dns_name == other.private_dns_name and
            self.public_dns_name == other.public_dns_name and
            self.public_ip_dns_name_options == other.public_ip_dns_name_options and
            self.private_ip_address == other.private_ip_address and
            self.private_ip_addresses == other.private_ip_addresses and
            self.ipv4_prefixes == other.ipv4_prefixes and
            self.ipv6_prefixes == other.ipv6_prefixes and
            self.requester_id == other.requester_id and
            self.requester_managed == other.requester_managed and
            self.source_dest_check == other.source_dest_check and
            self.status == other.status and
            self.subnet_id == other.subnet_id and
            self.tag_set == other.tag_set and
            self.vpc_id == other.vpc_id and
            self.deny_all_igw_traffic == other.deny_all_igw_traffic and
            self.ipv6_native == other.ipv6_native and
            self.ipv6_address == other.ipv6_address and
            self.operator == other.operator and
            self.associated_subnets == other.associated_subnets and
            self.availability_zone_id == other.availability_zone_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'association',
        'attachment',
        'availability_zone',
        'connection_tracking_configuration',
        'description',
        'groups',
        'interface_type',
        'ipv6_addresses',
        'mac_address',
        'network_interface_id',
        'outpost_arn',
        'owner_id',
        'private_dns_name',
        'public_dns_name',
        'public_ip_dns_name_options',
        'private_ip_address',
        'private_ip_addresses',
        'ipv4_prefixes',
        'ipv6_prefixes',
        'requester_id',
        'requester_managed',
        'source_dest_check',
        'status',
        'subnet_id',
        'tag_set',
        'vpc_id',
        'deny_all_igw_traffic',
        'ipv6_native',
        'ipv6_address',
        'operator',
        'associated_subnets',
        'availability_zone_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'association',
        'attachment',
        'availability_zone',
        'connection_tracking_configuration',
        'description',
        'groups',
        'interface_type',
        'ipv6_addresses',
        'mac_address',
        'network_interface_id',
        'outpost_arn',
        'owner_id',
        'private_dns_name',
        'public_dns_name',
        'public_ip_dns_name_options',
        'private_ip_address',
        'private_ip_addresses',
        'ipv4_prefixes',
        'ipv6_prefixes',
        'requester_id',
        'requester_managed',
        'source_dest_check',
        'status',
        'subnet_id',
        'tag_set',
        'vpc_id',
        'deny_all_igw_traffic',
        'ipv6_native',
        'ipv6_address',
        'operator',
        'associated_subnets',
        'availability_zone_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.association,
            self.attachment,
            self.availability_zone,
            self.connection_tracking_configuration,
            self.description,
            self.groups,
            self.interface_type,
            self.ipv6_addresses,
            self.mac_address,
            self.network_interface_id,
            self.outpost_arn,
            self.owner_id,
            self.private_dns_name,
            self.public_dns_name,
            self.public_ip_dns_name_options,
            self.private_ip_address,
            self.private_ip_addresses,
            self.ipv4_prefixes,
            self.ipv6_prefixes,
            self.requester_id,
            self.requester_managed,
            self.source_dest_check,
            self.status,
            self.subnet_id,
            self.tag_set,
            self.vpc_id,
            self.deny_all_igw_traffic,
            self.ipv6_native,
            self.ipv6_address,
            self.operator,
            self.associated_subnets,
            self.availability_zone_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        association: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        attachment: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        availability_zone: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        connection_tracking_configuration: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        description: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        groups: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        interface_type: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ipv6_addresses: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        mac_address: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        network_interface_id: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        outpost_arn: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        owner_id: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        private_dns_name: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        public_dns_name: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        public_ip_dns_name_options: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        private_ip_address: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        private_ip_addresses: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        ipv4_prefixes: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        ipv6_prefixes: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        requester_id: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        requester_managed: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
        source_dest_check: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
        status: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
        subnet_id: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
        tag_set: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
        vpc_id: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
        deny_all_igw_traffic: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
        ipv6_native: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
        ipv6_address: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
        operator: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
        associated_subnets: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
        availability_zone_id: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'association', association)
        __dataclass__object_setattr(self, 'attachment', attachment)
        __dataclass__object_setattr(self, 'availability_zone', availability_zone)
        __dataclass__object_setattr(self, 'connection_tracking_configuration', connection_tracking_configuration)
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'groups', groups)
        __dataclass__object_setattr(self, 'interface_type', interface_type)
        __dataclass__object_setattr(self, 'ipv6_addresses', ipv6_addresses)
        __dataclass__object_setattr(self, 'mac_address', mac_address)
        __dataclass__object_setattr(self, 'network_interface_id', network_interface_id)
        __dataclass__object_setattr(self, 'outpost_arn', outpost_arn)
        __dataclass__object_setattr(self, 'owner_id', owner_id)
        __dataclass__object_setattr(self, 'private_dns_name', private_dns_name)
        __dataclass__object_setattr(self, 'public_dns_name', public_dns_name)
        __dataclass__object_setattr(self, 'public_ip_dns_name_options', public_ip_dns_name_options)
        __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)
        __dataclass__object_setattr(self, 'private_ip_addresses', private_ip_addresses)
        __dataclass__object_setattr(self, 'ipv4_prefixes', ipv4_prefixes)
        __dataclass__object_setattr(self, 'ipv6_prefixes', ipv6_prefixes)
        __dataclass__object_setattr(self, 'requester_id', requester_id)
        __dataclass__object_setattr(self, 'requester_managed', requester_managed)
        __dataclass__object_setattr(self, 'source_dest_check', source_dest_check)
        __dataclass__object_setattr(self, 'status', status)
        __dataclass__object_setattr(self, 'subnet_id', subnet_id)
        __dataclass__object_setattr(self, 'tag_set', tag_set)
        __dataclass__object_setattr(self, 'vpc_id', vpc_id)
        __dataclass__object_setattr(self, 'deny_all_igw_traffic', deny_all_igw_traffic)
        __dataclass__object_setattr(self, 'ipv6_native', ipv6_native)
        __dataclass__object_setattr(self, 'ipv6_address', ipv6_address)
        __dataclass__object_setattr(self, 'operator', operator)
        __dataclass__object_setattr(self, 'associated_subnets', associated_subnets)
        __dataclass__object_setattr(self, 'availability_zone_id', availability_zone_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"association={self.association!r}")
        parts.append(f"attachment={self.attachment!r}")
        parts.append(f"availability_zone={self.availability_zone!r}")
        parts.append(f"connection_tracking_configuration={self.connection_tracking_configuration!r}")
        parts.append(f"description={self.description!r}")
        parts.append(f"groups={self.groups!r}")
        parts.append(f"interface_type={self.interface_type!r}")
        parts.append(f"ipv6_addresses={self.ipv6_addresses!r}")
        parts.append(f"mac_address={self.mac_address!r}")
        parts.append(f"network_interface_id={self.network_interface_id!r}")
        parts.append(f"outpost_arn={self.outpost_arn!r}")
        parts.append(f"owner_id={self.owner_id!r}")
        parts.append(f"private_dns_name={self.private_dns_name!r}")
        parts.append(f"public_dns_name={self.public_dns_name!r}")
        parts.append(f"public_ip_dns_name_options={self.public_ip_dns_name_options!r}")
        parts.append(f"private_ip_address={self.private_ip_address!r}")
        parts.append(f"private_ip_addresses={self.private_ip_addresses!r}")
        parts.append(f"ipv4_prefixes={self.ipv4_prefixes!r}")
        parts.append(f"ipv6_prefixes={self.ipv6_prefixes!r}")
        parts.append(f"requester_id={self.requester_id!r}")
        parts.append(f"requester_managed={self.requester_managed!r}")
        parts.append(f"source_dest_check={self.source_dest_check!r}")
        parts.append(f"status={self.status!r}")
        parts.append(f"subnet_id={self.subnet_id!r}")
        parts.append(f"tag_set={self.tag_set!r}")
        parts.append(f"vpc_id={self.vpc_id!r}")
        parts.append(f"deny_all_igw_traffic={self.deny_all_igw_traffic!r}")
        parts.append(f"ipv6_native={self.ipv6_native!r}")
        parts.append(f"ipv6_address={self.ipv6_address!r}")
        parts.append(f"operator={self.operator!r}")
        parts.append(f"associated_subnets={self.associated_subnets!r}")
        parts.append(f"availability_zone_id={self.availability_zone_id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('neuron_devices', 'total_neuron_device_memory_in_mi_b')), EqPlan(fields=('neuron_devic"
    "es', 'total_neuron_device_memory_in_mi_b')), FrozenPlan(fields=('__shape__', 'neuron_devices', 'total_neuron_devic"
    "e_memory_in_mi_b'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('neuron_devices', 'total_neu"
    "ron_device_memory_in_mi_b'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name"
    "='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType."
    "CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='neuron_devices', annotation=OpRef(na"
    "me='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tota"
    "l_neuron_device_memory_in_mi_b', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.field"
    "s.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('neuron_devices', 'total_neuron_devi"
    "ce_memory_in_mi_b'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fiel"
    "ds=(ReprPlan.Field(name='neuron_devices', kw_only=True, fn=None), ReprPlan.Field(name='total_neuron_device_memory_"
    "in_mi_b', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fNeuronInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            neuron_devices=self.neuron_devices,
            total_neuron_device_memory_in_mi_b=self.total_neuron_device_memory_in_mi_b,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.neuron_devices == other.neuron_devices and
            self.total_neuron_device_memory_in_mi_b == other.total_neuron_device_memory_in_mi_b
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'neuron_devices',
        'total_neuron_device_memory_in_mi_b',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'neuron_devices',
        'total_neuron_device_memory_in_mi_b',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.neuron_devices,
            self.total_neuron_device_memory_in_mi_b,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        neuron_devices: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        total_neuron_device_memory_in_mi_b: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'neuron_devices', neuron_devices)
        __dataclass__object_setattr(self, 'total_neuron_device_memory_in_mi_b', total_neuron_device_memory_in_mi_b)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"neuron_devices={self.neuron_devices!r}")
        parts.append(f"total_neuron_device_memory_in_mi_b={self.total_neuron_device_memory_in_mi_b!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('associations', 'propagating_vgws', 'route_table_id', 'routes', 'tags', 'vpc_id', 'own"
    "er_id')), EqPlan(fields=('associations', 'propagating_vgws', 'route_table_id', 'routes', 'tags', 'vpc_id', 'owner_"
    "id')), FrozenPlan(fields=('__shape__', 'associations', 'propagating_vgws', 'route_table_id', 'routes', 'tags', 'vp"
    "c_id', 'owner_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('associations', 'propagating"
    "_vgws', 'route_table_id', 'routes', 'tags', 'vpc_id', 'owner_id'), cache=False), InitPlan(fields=(InitPlan.Field(n"
    "ame='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True,"
    " override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='associations', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None), InitPlan.Field(name='propagating_vgws', annotation=OpRef(name='init.fields.2.annotation'), default=OpRe"
    "f(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='route_table_id', annotation=OpRef(name='init.fie"
    "lds.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='routes', annotat"
    "ion=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='tags', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init"
    ".fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='owner_id', annotation=OpRef(name='init.fields.7.annotation')"
    ", default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
    "pe.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('ass"
    "ociations', 'propagating_vgws', 'route_table_id', 'routes', 'tags', 'vpc_id', 'owner_id'), frozen=True, slots=Fals"
    "e, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='associations', kw_o"
    "nly=True, fn=None), ReprPlan.Field(name='propagating_vgws', kw_only=True, fn=None), ReprPlan.Field(name='route_tab"
    "le_id', kw_only=True, fn=None), ReprPlan.Field(name='routes', kw_only=True, fn=None), ReprPlan.Field(name='tags', "
    "kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPlan.Field(name='owner_id', kw_o"
    "nly=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fRouteTable(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            associations=self.associations,
            propagating_vgws=self.propagating_vgws,
            route_table_id=self.route_table_id,
            routes=self.routes,
            tags=self.tags,
            vpc_id=self.vpc_id,
            owner_id=self.owner_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.associations == other.associations and
            self.propagating_vgws == other.propagating_vgws and
            self.route_table_id == other.route_table_id and
            self.routes == other.routes and
            self.tags == other.tags and
            self.vpc_id == other.vpc_id and
            self.owner_id == other.owner_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'associations',
        'propagating_vgws',
        'route_table_id',
        'routes',
        'tags',
        'vpc_id',
        'owner_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'associations',
        'propagating_vgws',
        'route_table_id',
        'routes',
        'tags',
        'vpc_id',
        'owner_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.associations,
            self.propagating_vgws,
            self.route_table_id,
            self.routes,
            self.tags,
            self.vpc_id,
            self.owner_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        associations: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        propagating_vgws: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        route_table_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        routes: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        tags: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        vpc_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        owner_id: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'associations', associations)
        __dataclass__object_setattr(self, 'propagating_vgws', propagating_vgws)
        __dataclass__object_setattr(self, 'route_table_id', route_table_id)
        __dataclass__object_setattr(self, 'routes', routes)
        __dataclass__object_setattr(self, 'tags', tags)
        __dataclass__object_setattr(self, 'vpc_id', vpc_id)
        __dataclass__object_setattr(self, 'owner_id', owner_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"associations={self.associations!r}")
        parts.append(f"propagating_vgws={self.propagating_vgws!r}")
        parts.append(f"route_table_id={self.route_table_id!r}")
        parts.append(f"routes={self.routes!r}")
        parts.append(f"tags={self.tags!r}")
        parts.append(f"vpc_id={self.vpc_id!r}")
        parts.append(f"owner_id={self.owner_id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('starting_instances',)), EqPlan(fields=('starting_instances',)), FrozenPlan(fields=('_"
    "_shape__', 'starting_instances'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('starting_inst"
    "ances',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.ann"
    "otation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=N"
    "one, validate=None, check_type=None), InitPlan.Field(name='starting_instances', annotation=OpRef(name='init.fields"
    ".1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_on"
    "ly_params=('starting_instances',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
    " ReprPlan(fields=(ReprPlan.Field(name='starting_instances', kw_only=True, fn=None),), id=False, terse=False, defau"
    "lt_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fStartInstancesResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            starting_instances=self.starting_instances,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.starting_instances == other.starting_instances
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'starting_instances',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'starting_instances',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.starting_instances,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        starting_instances: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'starting_instances', starting_instances)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"starting_instances={self.starting_instances!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('stopping_instances',)), EqPlan(fields=('stopping_instances',)), FrozenPlan(fields=('_"
    "_shape__', 'stopping_instances'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('stopping_inst"
    "ances',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.ann"
    "otation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=N"
    "one, validate=None, check_type=None), InitPlan.Field(name='stopping_instances', annotation=OpRef(name='init.fields"
    ".1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_on"
    "ly_params=('stopping_instances',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
    " ReprPlan(fields=(ReprPlan.Field(name='stopping_instances', kw_only=True, fn=None),), id=False, terse=False, defau"
    "lt_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fStopInstancesResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            stopping_instances=self.stopping_instances,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.stopping_instances == other.stopping_instances
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'stopping_instances',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'stopping_instances',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.stopping_instances,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        stopping_instances: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'stopping_instances', stopping_instances)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"stopping_instances={self.stopping_instances!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('availability_zone_id', 'enable_lni_at_device_index', 'map_customer_owned_ip_on_launch"
    "', 'customer_owned_ipv4_pool', 'owner_id', 'assign_ipv6_address_on_creation', 'ipv6_cidr_block_association_set', '"
    "tags', 'subnet_arn', 'outpost_arn', 'enable_dns64', 'ipv6_native', 'private_dns_name_options_on_launch', 'block_pu"
    "blic_access_states', 'type', 'subnet_id', 'state', 'vpc_id', 'cidr_block', 'available_ip_address_count', 'availabi"
    "lity_zone', 'default_for_az', 'map_public_ip_on_launch')), EqPlan(fields=('availability_zone_id', 'enable_lni_at_d"
    "evice_index', 'map_customer_owned_ip_on_launch', 'customer_owned_ipv4_pool', 'owner_id', 'assign_ipv6_address_on_c"
    "reation', 'ipv6_cidr_block_association_set', 'tags', 'subnet_arn', 'outpost_arn', 'enable_dns64', 'ipv6_native', '"
    "private_dns_name_options_on_launch', 'block_public_access_states', 'type', 'subnet_id', 'state', 'vpc_id', 'cidr_b"
    "lock', 'available_ip_address_count', 'availability_zone', 'default_for_az', 'map_public_ip_on_launch')), FrozenPla"
    "n(fields=('__shape__', 'availability_zone_id', 'enable_lni_at_device_index', 'map_customer_owned_ip_on_launch', 'c"
    "ustomer_owned_ipv4_pool', 'owner_id', 'assign_ipv6_address_on_creation', 'ipv6_cidr_block_association_set', 'tags'"
    ", 'subnet_arn', 'outpost_arn', 'enable_dns64', 'ipv6_native', 'private_dns_name_options_on_launch', 'block_public_"
    "access_states', 'type', 'subnet_id', 'state', 'vpc_id', 'cidr_block', 'available_ip_address_count', 'availability_"
    "zone', 'default_for_az', 'map_public_ip_on_launch'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fie"
    "lds=('availability_zone_id', 'enable_lni_at_device_index', 'map_customer_owned_ip_on_launch', 'customer_owned_ipv4"
    "_pool', 'owner_id', 'assign_ipv6_address_on_creation', 'ipv6_cidr_block_association_set', 'tags', 'subnet_arn', 'o"
    "utpost_arn', 'enable_dns64', 'ipv6_native', 'private_dns_name_options_on_launch', 'block_public_access_states', 't"
    "ype', 'subnet_id', 'state', 'vpc_id', 'cidr_block', 'available_ip_address_count', 'availability_zone', 'default_fo"
    "r_az', 'map_public_ip_on_launch'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRe"
    "f(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='availability_zone_id', annotat"
    "ion=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='enable_lni_at_device_index', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.f"
    "ields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='map_customer_owned_ip_on_launch', annotation=OpRef(name='init."
    "fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=Fals"
    "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='customer_owne"
    "d_ipv4_pool', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='owner_id', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='ini"
    "t.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None), InitPlan.Field(name='assign_ipv6_address_on_creation', annotation=OpRef(name='in"
    "it.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_cidr_"
    "block_association_set', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.defau"
    "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
    "check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(nam"
    "e='init.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='subnet_arn', annotation=OpRef(name='init.fields.9.ann"
    "otation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='outpost_arn', annotation="
    "OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='enable_dns64', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.defaul"
    "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='ipv6_native', annotation=OpRef(name='init.fields.12.annotation'), default=Op"
    "Ref(name='init.fields.12.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
    ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='private_dns_name_options_on_launch', annotati"
    "on=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='block_public_access_states', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init"
    ".fields.14.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.15.annotation'), "
    "default=OpRef(name='init.fields.15.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnet_id', annotation=OpRef(name='"
    "init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=True, overri"
    "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state'"
    ", annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factor"
    "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
    "itPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.18"
    ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None), InitPlan.Field(name='cidr_block', annotation=OpRef(name='init.fields.19.annotation'), defa"
    "ult=OpRef(name='init.fields.19.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='available_ip_address_count', annotation"
    "=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.fields.20.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='availability_zone', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='init.fields.21."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='default_for_az', annotation=OpRef(name='init.fields.22.annotation'), d"
    "efault=OpRef(name='init.fields.22.default'), default_factory=None, init=True, override=False, field_type=FieldType"
    ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='map_public_ip_on_launch', annotation"
    "=OpRef(name='init.fields.23.annotation'), default=OpRef(name='init.fields.23.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='s"
    "elf', std_params=(), kw_only_params=('availability_zone_id', 'enable_lni_at_device_index', 'map_customer_owned_ip_"
    "on_launch', 'customer_owned_ipv4_pool', 'owner_id', 'assign_ipv6_address_on_creation', 'ipv6_cidr_block_associatio"
    "n_set', 'tags', 'subnet_arn', 'outpost_arn', 'enable_dns64', 'ipv6_native', 'private_dns_name_options_on_launch', "
    "'block_public_access_states', 'type', 'subnet_id', 'state', 'vpc_id', 'cidr_block', 'available_ip_address_count', "
    "'availability_zone', 'default_for_az', 'map_public_ip_on_launch'), frozen=True, slots=False, post_init_params=None"
    ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='availability_zone_id', kw_only=True, fn=Non"
    "e), ReprPlan.Field(name='enable_lni_at_device_index', kw_only=True, fn=None), ReprPlan.Field(name='map_customer_ow"
    "ned_ip_on_launch', kw_only=True, fn=None), ReprPlan.Field(name='customer_owned_ipv4_pool', kw_only=True, fn=None),"
    " ReprPlan.Field(name='owner_id', kw_only=True, fn=None), ReprPlan.Field(name='assign_ipv6_address_on_creation', kw"
    "_only=True, fn=None), ReprPlan.Field(name='ipv6_cidr_block_association_set', kw_only=True, fn=None), ReprPlan.Fiel"
    "d(name='tags', kw_only=True, fn=None), ReprPlan.Field(name='subnet_arn', kw_only=True, fn=None), ReprPlan.Field(na"
    "me='outpost_arn', kw_only=True, fn=None), ReprPlan.Field(name='enable_dns64', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='ipv6_native', kw_only=True, fn=None), ReprPlan.Field(name='private_dns_name_options_on_launch', kw_only=T"
    "rue, fn=None), ReprPlan.Field(name='block_public_access_states', kw_only=True, fn=None), ReprPlan.Field(name='type"
    "', kw_only=True, fn=None), ReprPlan.Field(name='subnet_id', kw_only=True, fn=None), ReprPlan.Field(name='state', k"
    "w_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPlan.Field(name='cidr_block', kw_"
    "only=True, fn=None), ReprPlan.Field(name='available_ip_address_count', kw_only=True, fn=None), ReprPlan.Field(name"
    "='availability_zone', kw_only=True, fn=None), ReprPlan.Field(name='default_for_az', kw_only=True, fn=None), ReprPl"
    "an.Field(name='map_public_ip_on_launch', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fSubnet(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__21__annotation,
    __dataclass__init__fields__21__default,
    __dataclass__init__fields__22__annotation,
    __dataclass__init__fields__22__default,
    __dataclass__init__fields__23__annotation,
    __dataclass__init__fields__23__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            availability_zone_id=self.availability_zone_id,
            enable_lni_at_device_index=self.enable_lni_at_device_index,
            map_customer_owned_ip_on_launch=self.map_customer_owned_ip_on_launch,
            customer_owned_ipv4_pool=self.customer_owned_ipv4_pool,
            owner_id=self.owner_id,
            assign_ipv6_address_on_creation=self.assign_ipv6_address_on_creation,
            ipv6_cidr_block_association_set=self.ipv6_cidr_block_association_set,
            tags=self.tags,
            subnet_arn=self.subnet_arn,
            outpost_arn=self.outpost_arn,
            enable_dns64=self.enable_dns64,
            ipv6_native=self.ipv6_native,
            private_dns_name_options_on_launch=self.private_dns_name_options_on_launch,
            block_public_access_states=self.block_public_access_states,
            type=self.type,
            subnet_id=self.subnet_id,
            state=self.state,
            vpc_id=self.vpc_id,
            cidr_block=self.cidr_block,
            available_ip_address_count=self.available_ip_address_count,
            availability_zone=self.availability_zone,
            default_for_az=self.default_for_az,
            map_public_ip_on_launch=self.map_public_ip_on_launch,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.availability_zone_id == other.availability_zone_id and
            self.enable_lni_at_device_index == other.enable_lni_at_device_index and
            self.map_customer_owned_ip_on_launch == other.map_customer_owned_ip_on_launch and
            self.customer_owned_ipv4_pool == other.customer_owned_ipv4_pool and
            self.owner_id == other.owner_id and
            self.assign_ipv6_address_on_creation == other.assign_ipv6_address_on_creation and
            self.ipv6_cidr_block_association_set == other.ipv6_cidr_block_association_set and
            self.tags == other.tags and
            self.subnet_arn == other.subnet_arn and
            self.outpost_arn == other.outpost_arn and
            self.enable_dns64 == other.enable_dns64 and
            self.ipv6_native == other.ipv6_native and
            self.private_dns_name_options_on_launch == other.private_dns_name_options_on_launch and
            self.block_public_access_states == other.block_public_access_states and
            self.type == other.type and
            self.subnet_id == other.subnet_id and
            self.state == other.state and
            self.vpc_id == other.vpc_id and
            self.cidr_block == other.cidr_block and
            self.available_ip_address_count == other.available_ip_address_count and
            self.availability_zone == other.availability_zone and
            self.default_for_az == other.default_for_az and
            self.map_public_ip_on_launch == other.map_public_ip_on_launch
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'availability_zone_id',
        'enable_lni_at_device_index',
        'map_customer_owned_ip_on_launch',
        'customer_owned_ipv4_pool',
        'owner_id',
        'assign_ipv6_address_on_creation',
        'ipv6_cidr_block_association_set',
        'tags',
        'subnet_arn',
        'outpost_arn',
        'enable_dns64',
        'ipv6_native',
        'private_dns_name_options_on_launch',
        'block_public_access_states',
        'type',
        'subnet_id',
        'state',
        'vpc_id',
        'cidr_block',
        'available_ip_address_count',
        'availability_zone',
        'default_for_az',
        'map_public_ip_on_launch',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'availability_zone_id',
        'enable_lni_at_device_index',
        'map_customer_owned_ip_on_launch',
        'customer_owned_ipv4_pool',
        'owner_id',
        'assign_ipv6_address_on_creation',
        'ipv6_cidr_block_association_set',
        'tags',
        'subnet_arn',
        'outpost_arn',
        'enable_dns64',
        'ipv6_native',
        'private_dns_name_options_on_launch',
        'block_public_access_states',
        'type',
        'subnet_id',
        'state',
        'vpc_id',
        'cidr_block',
        'available_ip_address_count',
        'availability_zone',
        'default_for_az',
        'map_public_ip_on_launch',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.availability_zone_id,
            self.enable_lni_at_device_index,
            self.map_customer_owned_ip_on_launch,
            self.customer_owned_ipv4_pool,
            self.owner_id,
            self.assign_ipv6_address_on_creation,
            self.ipv6_cidr_block_association_set,
            self.tags,
            self.subnet_arn,
            self.outpost_arn,
            self.enable_dns64,
            self.ipv6_native,
            self.private_dns_name_options_on_launch,
            self.block_public_access_states,
            self.type,
            self.subnet_id,
            self.state,
            self.vpc_id,
            self.cidr_block,
            self.available_ip_address_count,
            self.availability_zone,
            self.default_for_az,
            self.map_public_ip_on_launch,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        availability_zone_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        enable_lni_at_device_index: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        map_customer_owned_ip_on_launch: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        customer_owned_ipv4_pool: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        owner_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        assign_ipv6_address_on_creation: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        ipv6_cidr_block_association_set: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        tags: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        subnet_arn: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        outpost_arn: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        enable_dns64: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        ipv6_native: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        private_dns_name_options_on_launch: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        block_public_access_states: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        type: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        subnet_id: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        state: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        vpc_id: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        cidr_block: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        available_ip_address_count: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        availability_zone: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
        default_for_az: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
        map_public_ip_on_launch: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'availability_zone_id', availability_zone_id)
        __dataclass__object_setattr(self, 'enable_lni_at_device_index', enable_lni_at_device_index)
        __dataclass__object_setattr(self, 'map_customer_owned_ip_on_launch', map_customer_owned_ip_on_launch)
        __dataclass__object_setattr(self, 'customer_owned_ipv4_pool', customer_owned_ipv4_pool)
        __dataclass__object_setattr(self, 'owner_id', owner_id)
        __dataclass__object_setattr(self, 'assign_ipv6_address_on_creation', assign_ipv6_address_on_creation)
        __dataclass__object_setattr(self, 'ipv6_cidr_block_association_set', ipv6_cidr_block_association_set)
        __dataclass__object_setattr(self, 'tags', tags)
        __dataclass__object_setattr(self, 'subnet_arn', subnet_arn)
        __dataclass__object_setattr(self, 'outpost_arn', outpost_arn)
        __dataclass__object_setattr(self, 'enable_dns64', enable_dns64)
        __dataclass__object_setattr(self, 'ipv6_native', ipv6_native)
        __dataclass__object_setattr(self, 'private_dns_name_options_on_launch', private_dns_name_options_on_launch)
        __dataclass__object_setattr(self, 'block_public_access_states', block_public_access_states)
        __dataclass__object_setattr(self, 'type', type)
        __dataclass__object_setattr(self, 'subnet_id', subnet_id)
        __dataclass__object_setattr(self, 'state', state)
        __dataclass__object_setattr(self, 'vpc_id', vpc_id)
        __dataclass__object_setattr(self, 'cidr_block', cidr_block)
        __dataclass__object_setattr(self, 'available_ip_address_count', available_ip_address_count)
        __dataclass__object_setattr(self, 'availability_zone', availability_zone)
        __dataclass__object_setattr(self, 'default_for_az', default_for_az)
        __dataclass__object_setattr(self, 'map_public_ip_on_launch', map_public_ip_on_launch)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"availability_zone_id={self.availability_zone_id!r}")
        parts.append(f"enable_lni_at_device_index={self.enable_lni_at_device_index!r}")
        parts.append(f"map_customer_owned_ip_on_launch={self.map_customer_owned_ip_on_launch!r}")
        parts.append(f"customer_owned_ipv4_pool={self.customer_owned_ipv4_pool!r}")
        parts.append(f"owner_id={self.owner_id!r}")
        parts.append(f"assign_ipv6_address_on_creation={self.assign_ipv6_address_on_creation!r}")
        parts.append(f"ipv6_cidr_block_association_set={self.ipv6_cidr_block_association_set!r}")
        parts.append(f"tags={self.tags!r}")
        parts.append(f"subnet_arn={self.subnet_arn!r}")
        parts.append(f"outpost_arn={self.outpost_arn!r}")
        parts.append(f"enable_dns64={self.enable_dns64!r}")
        parts.append(f"ipv6_native={self.ipv6_native!r}")
        parts.append(f"private_dns_name_options_on_launch={self.private_dns_name_options_on_launch!r}")
        parts.append(f"block_public_access_states={self.block_public_access_states!r}")
        parts.append(f"type={self.type!r}")
        parts.append(f"subnet_id={self.subnet_id!r}")
        parts.append(f"state={self.state!r}")
        parts.append(f"vpc_id={self.vpc_id!r}")
        parts.append(f"cidr_block={self.cidr_block!r}")
        parts.append(f"available_ip_address_count={self.available_ip_address_count!r}")
        parts.append(f"availability_zone={self.availability_zone!r}")
        parts.append(f"default_for_az={self.default_for_az!r}")
        parts.append(f"map_public_ip_on_launch={self.map_public_ip_on_launch!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('terminating_instances',)), EqPlan(fields=('terminating_instances',)), FrozenPlan(fiel"
    "ds=('__shape__', 'terminating_instances'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('term"
    "inating_instances',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init."
    "fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_V"
    "AR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='terminating_instances', annotation=OpRef(na"
    "me='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_p"
    "arams=(), kw_only_params=('terminating_instances',), frozen=True, slots=False, post_init_params=None, init_fns=(),"
    " validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='terminating_instances', kw_only=True, fn=None),), id=Fals"
    "e, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fTerminateInstancesResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            terminating_instances=self.terminating_instances,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.terminating_instances == other.terminating_instances
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'terminating_instances',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'terminating_instances',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.terminating_instances,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        terminating_instances: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'terminating_instances', terminating_instances)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"terminating_instances={self.terminating_instances!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('owner_id', 'instance_tenancy', 'ipv6_cidr_block_association_set', 'cidr_block_associa"
    "tion_set', 'is_default', 'encryption_control', 'tags', 'block_public_access_states', 'vpc_id', 'state', 'cidr_bloc"
    "k', 'dhcp_options_id')), EqPlan(fields=('owner_id', 'instance_tenancy', 'ipv6_cidr_block_association_set', 'cidr_b"
    "lock_association_set', 'is_default', 'encryption_control', 'tags', 'block_public_access_states', 'vpc_id', 'state'"
    ", 'cidr_block', 'dhcp_options_id')), FrozenPlan(fields=('__shape__', 'owner_id', 'instance_tenancy', 'ipv6_cidr_bl"
    "ock_association_set', 'cidr_block_association_set', 'is_default', 'encryption_control', 'tags', 'block_public_acce"
    "ss_states', 'vpc_id', 'state', 'cidr_block', 'dhcp_options_id'), allow_dynamic_dunder_attrs=False), HashPlan(actio"
    "n='add', fields=('owner_id', 'instance_tenancy', 'ipv6_cidr_block_association_set', 'cidr_block_association_set', "
    "'is_default', 'encryption_control', 'tags', 'block_public_access_states', 'vpc_id', 'state', 'cidr_block', 'dhcp_o"
    "ptions_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0."
    "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='owner_id', annotation=OpRef(name='init.fields.1.anno"
    "tation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type"
    "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_tenancy', annotat"
    "ion=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='ipv6_cidr_block_association_set', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='i"
    "nit.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
    "e, validate=None, check_type=None), InitPlan.Field(name='cidr_block_association_set', annotation=OpRef(name='init."
    "fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=Fals"
    "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='is_default', "
    "annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='encryption_control', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fi"
    "elds.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='init.fields.7.annotation'), defau"
    "lt=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
    "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='block_public_access_states', annotation=O"
    "pRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=Tru"
    "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
    "e='vpc_id', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='state', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fi"
    "elds.10.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='cidr_block', annotation=OpRef(name='init.fields.11.annotation'"
    "), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dhcp_options_id', annotation=OpR"
    "ef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=Tru"
    "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self'"
    ", std_params=(), kw_only_params=('owner_id', 'instance_tenancy', 'ipv6_cidr_block_association_set', 'cidr_block_as"
    "sociation_set', 'is_default', 'encryption_control', 'tags', 'block_public_access_states', 'vpc_id', 'state', 'cidr"
    "_block', 'dhcp_options_id'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
    "lan(fields=(ReprPlan.Field(name='owner_id', kw_only=True, fn=None), ReprPlan.Field(name='instance_tenancy', kw_onl"
    "y=True, fn=None), ReprPlan.Field(name='ipv6_cidr_block_association_set', kw_only=True, fn=None), ReprPlan.Field(na"
    "me='cidr_block_association_set', kw_only=True, fn=None), ReprPlan.Field(name='is_default', kw_only=True, fn=None),"
    " ReprPlan.Field(name='encryption_control', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=True, fn=No"
    "ne), ReprPlan.Field(name='block_public_access_states', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='state', kw_only=True, fn=None), ReprPlan.Field(name='cidr_block', kw_only="
    "True, fn=None), ReprPlan.Field(name='dhcp_options_id', kw_only=True, fn=None)), id=False, terse=False, default_fn="
    "None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fVpc(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            owner_id=self.owner_id,
            instance_tenancy=self.instance_tenancy,
            ipv6_cidr_block_association_set=self.ipv6_cidr_block_association_set,
            cidr_block_association_set=self.cidr_block_association_set,
            is_default=self.is_default,
            encryption_control=self.encryption_control,
            tags=self.tags,
            block_public_access_states=self.block_public_access_states,
            vpc_id=self.vpc_id,
            state=self.state,
            cidr_block=self.cidr_block,
            dhcp_options_id=self.dhcp_options_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.owner_id == other.owner_id and
            self.instance_tenancy == other.instance_tenancy and
            self.ipv6_cidr_block_association_set == other.ipv6_cidr_block_association_set and
            self.cidr_block_association_set == other.cidr_block_association_set and
            self.is_default == other.is_default and
            self.encryption_control == other.encryption_control and
            self.tags == other.tags and
            self.block_public_access_states == other.block_public_access_states and
            self.vpc_id == other.vpc_id and
            self.state == other.state and
            self.cidr_block == other.cidr_block and
            self.dhcp_options_id == other.dhcp_options_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'owner_id',
        'instance_tenancy',
        'ipv6_cidr_block_association_set',
        'cidr_block_association_set',
        'is_default',
        'encryption_control',
        'tags',
        'block_public_access_states',
        'vpc_id',
        'state',
        'cidr_block',
        'dhcp_options_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'owner_id',
        'instance_tenancy',
        'ipv6_cidr_block_association_set',
        'cidr_block_association_set',
        'is_default',
        'encryption_control',
        'tags',
        'block_public_access_states',
        'vpc_id',
        'state',
        'cidr_block',
        'dhcp_options_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.owner_id,
            self.instance_tenancy,
            self.ipv6_cidr_block_association_set,
            self.cidr_block_association_set,
            self.is_default,
            self.encryption_control,
            self.tags,
            self.block_public_access_states,
            self.vpc_id,
            self.state,
            self.cidr_block,
            self.dhcp_options_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        owner_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        instance_tenancy: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ipv6_cidr_block_association_set: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        cidr_block_association_set: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        is_default: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        encryption_control: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        tags: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        block_public_access_states: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        vpc_id: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        state: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        cidr_block: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        dhcp_options_id: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'owner_id', owner_id)
        __dataclass__object_setattr(self, 'instance_tenancy', instance_tenancy)
        __dataclass__object_setattr(self, 'ipv6_cidr_block_association_set', ipv6_cidr_block_association_set)
        __dataclass__object_setattr(self, 'cidr_block_association_set', cidr_block_association_set)
        __dataclass__object_setattr(self, 'is_default', is_default)
        __dataclass__object_setattr(self, 'encryption_control', encryption_control)
        __dataclass__object_setattr(self, 'tags', tags)
        __dataclass__object_setattr(self, 'block_public_access_states', block_public_access_states)
        __dataclass__object_setattr(self, 'vpc_id', vpc_id)
        __dataclass__object_setattr(self, 'state', state)
        __dataclass__object_setattr(self, 'cidr_block', cidr_block)
        __dataclass__object_setattr(self, 'dhcp_options_id', dhcp_options_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"owner_id={self.owner_id!r}")
        parts.append(f"instance_tenancy={self.instance_tenancy!r}")
        parts.append(f"ipv6_cidr_block_association_set={self.ipv6_cidr_block_association_set!r}")
        parts.append(f"cidr_block_association_set={self.cidr_block_association_set!r}")
        parts.append(f"is_default={self.is_default!r}")
        parts.append(f"encryption_control={self.encryption_control!r}")
        parts.append(f"tags={self.tags!r}")
        parts.append(f"block_public_access_states={self.block_public_access_states!r}")
        parts.append(f"vpc_id={self.vpc_id!r}")
        parts.append(f"state={self.state!r}")
        parts.append(f"cidr_block={self.cidr_block!r}")
        parts.append(f"dhcp_options_id={self.dhcp_options_id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('route_table', 'client_token')), EqPlan(fields=('route_table', 'client_token')), Froze"
    "nPlan(fields=('__shape__', 'route_table', 'client_token'), allow_dynamic_dunder_attrs=False), HashPlan(action='add"
    "', fields=('route_table', 'client_token'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotat"
    "ion=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='route_table', annotati"
    "on=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='client_token', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default"
    "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None)), self_param='self', std_params=(), kw_only_params=('route_table', 'client_token'), frozen=True, sl"
    "ots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='route_table"
    "', kw_only=True, fn=None), ReprPlan.Field(name='client_token', kw_only=True, fn=None)), id=False, terse=False, def"
    "ault_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fCreateRouteTableResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            route_table=self.route_table,
            client_token=self.client_token,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.route_table == other.route_table and
            self.client_token == other.client_token
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'route_table',
        'client_token',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'route_table',
        'client_token',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.route_table,
            self.client_token,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        route_table: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        client_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'route_table', route_table)
        __dataclass__object_setattr(self, 'client_token', client_token)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"route_table={self.route_table!r}")
        parts.append(f"client_token={self.client_token!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('internet_gateways', 'next_token')), EqPlan(fields=('internet_gateways', 'next_token')"
    "), FrozenPlan(fields=('__shape__', 'internet_gateways', 'next_token'), allow_dynamic_dunder_attrs=False), HashPlan"
    "(action='add', fields=('internet_gateways', 'next_token'), cache=False), InitPlan(fields=(InitPlan.Field(name='__s"
    "hape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='intern"
    "et_gateways', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='i"
    "nit.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
    "e, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('internet_gateways', 'next_"
    "token'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan"
    ".Field(name='internet_gateways', kw_only=True, fn=None), ReprPlan.Field(name='next_token', kw_only=True, fn=None))"
    ", id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeInternetGatewaysResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            internet_gateways=self.internet_gateways,
            next_token=self.next_token,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.internet_gateways == other.internet_gateways and
            self.next_token == other.next_token
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'internet_gateways',
        'next_token',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'internet_gateways',
        'next_token',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.internet_gateways,
            self.next_token,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        internet_gateways: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        next_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'internet_gateways', internet_gateways)
        __dataclass__object_setattr(self, 'next_token', next_token)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"internet_gateways={self.internet_gateways!r}")
        parts.append(f"next_token={self.next_token!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('instance_type', 'current_generation', 'free_tier_eligible', 'supported_usage_classes'"
    ", 'supported_root_device_types', 'supported_virtualization_types', 'bare_metal', 'hypervisor', 'processor_info', '"
    "v_cpu_info', 'memory_info', 'instance_storage_supported', 'instance_storage_info', 'ebs_info', 'network_info', 'gp"
    "u_info', 'fpga_info', 'placement_group_info', 'inference_accelerator_info', 'hibernation_supported', 'burstable_pe"
    "rformance_supported', 'dedicated_hosts_supported', 'auto_recovery_supported', 'supported_boot_modes', 'nitro_encla"
    "ves_support', 'nitro_tpm_support', 'nitro_tpm_info', 'media_accelerator_info', 'neuron_info', 'phc_support', 'rebo"
    "ot_migration_support')), EqPlan(fields=('instance_type', 'current_generation', 'free_tier_eligible', 'supported_us"
    "age_classes', 'supported_root_device_types', 'supported_virtualization_types', 'bare_metal', 'hypervisor', 'proces"
    "sor_info', 'v_cpu_info', 'memory_info', 'instance_storage_supported', 'instance_storage_info', 'ebs_info', 'networ"
    "k_info', 'gpu_info', 'fpga_info', 'placement_group_info', 'inference_accelerator_info', 'hibernation_supported', '"
    "burstable_performance_supported', 'dedicated_hosts_supported', 'auto_recovery_supported', 'supported_boot_modes', "
    "'nitro_enclaves_support', 'nitro_tpm_support', 'nitro_tpm_info', 'media_accelerator_info', 'neuron_info', 'phc_sup"
    "port', 'reboot_migration_support')), FrozenPlan(fields=('__shape__', 'instance_type', 'current_generation', 'free_"
    "tier_eligible', 'supported_usage_classes', 'supported_root_device_types', 'supported_virtualization_types', 'bare_"
    "metal', 'hypervisor', 'processor_info', 'v_cpu_info', 'memory_info', 'instance_storage_supported', 'instance_stora"
    "ge_info', 'ebs_info', 'network_info', 'gpu_info', 'fpga_info', 'placement_group_info', 'inference_accelerator_info"
    "', 'hibernation_supported', 'burstable_performance_supported', 'dedicated_hosts_supported', 'auto_recovery_support"
    "ed', 'supported_boot_modes', 'nitro_enclaves_support', 'nitro_tpm_support', 'nitro_tpm_info', 'media_accelerator_i"
    "nfo', 'neuron_info', 'phc_support', 'reboot_migration_support'), allow_dynamic_dunder_attrs=False), HashPlan(actio"
    "n='add', fields=('instance_type', 'current_generation', 'free_tier_eligible', 'supported_usage_classes', 'supporte"
    "d_root_device_types', 'supported_virtualization_types', 'bare_metal', 'hypervisor', 'processor_info', 'v_cpu_info'"
    ", 'memory_info', 'instance_storage_supported', 'instance_storage_info', 'ebs_info', 'network_info', 'gpu_info', 'f"
    "pga_info', 'placement_group_info', 'inference_accelerator_info', 'hibernation_supported', 'burstable_performance_s"
    "upported', 'dedicated_hosts_supported', 'auto_recovery_supported', 'supported_boot_modes', 'nitro_enclaves_support"
    "', 'nitro_tpm_support', 'nitro_tpm_info', 'media_accelerator_info', 'neuron_info', 'phc_support', 'reboot_migratio"
    "n_support'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0."
    "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='instance_type', annotation=OpRef(name='init.fields.1"
    ".annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field"
    "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='current_generation', "
    "annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='free_tier_eligible', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fi"
    "elds.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='supported_usage_classes', annotation=OpRef(name='init.fields.4."
    "annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='supported_root_device_"
    "types', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='supported_virtualization_types', annotation=OpRef(name='init.fields.6.annotation'), default"
    "=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='bare_metal', annotation=OpRef(name='init.fi"
    "elds.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='hypervisor', an"
    "notation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
    ".Field(name='processor_info', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9"
    ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None), InitPlan.Field(name='v_cpu_info', annotation=OpRef(name='init.fields.10.annotation'), defa"
    "ult=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='memory_info', annotation=OpRef(name='in"
    "it.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance"
    "_storage_supported', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.defaul"
    "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='instance_storage_info', annotation=OpRef(name='init.fields.13.annotation'), "
    "default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ebs_info', annotation=OpRef(name='i"
    "nit.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network"
    "_info', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e), InitPlan.Field(name='gpu_info', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef(name='init.f"
    "ields.16.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None), InitPlan.Field(name='fpga_info', annotation=OpRef(name='init.fields.17.annotation'"
    "), default=OpRef(name='init.fields.17.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='placement_group_info', annotatio"
    "n=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.18.default'), default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='inference_accelerator_info', annotation=OpRef(name='init.fields.19.annotation'), default=OpRef(name='init."
    "fields.19.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='hibernation_supported', annotation=OpRef(name='init.fields.2"
    "0.annotation'), default=OpRef(name='init.fields.20.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='burstable_performan"
    "ce_supported', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='init.fields.21.default'), d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None), InitPlan.Field(name='dedicated_hosts_supported', annotation=OpRef(name='init.fields.22.annotation'), de"
    "fault=OpRef(name='init.fields.22.default'), default_factory=None, init=True, override=False, field_type=FieldType."
    "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='auto_recovery_supported', annotation="
    "OpRef(name='init.fields.23.annotation'), default=OpRef(name='init.fields.23.default'), default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='supported_boot_modes', annotation=OpRef(name='init.fields.24.annotation'), default=OpRef(name='init.fields.2"
    "4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='nitro_enclaves_support', annotation=OpRef(name='init.fields.25.annot"
    "ation'), default=OpRef(name='init.fields.25.default'), default_factory=None, init=True, override=False, field_type"
    "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='nitro_tpm_support', annota"
    "tion=OpRef(name='init.fields.26.annotation'), default=OpRef(name='init.fields.26.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
    "ield(name='nitro_tpm_info', annotation=OpRef(name='init.fields.27.annotation'), default=OpRef(name='init.fields.27"
    ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None), InitPlan.Field(name='media_accelerator_info', annotation=OpRef(name='init.fields.28.annota"
    "tion'), default=OpRef(name='init.fields.28.default'), default_factory=None, init=True, override=False, field_type="
    "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='neuron_info', annotation=Op"
    "Ref(name='init.fields.29.annotation'), default=OpRef(name='init.fields.29.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='phc_support', annotation=OpRef(name='init.fields.30.annotation'), default=OpRef(name='init.fields.30.default')"
    ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='reboot_migration_support', annotation=OpRef(name='init.fields.31.annotation'), "
    "default=OpRef(name='init.fields.31.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('inst"
    "ance_type', 'current_generation', 'free_tier_eligible', 'supported_usage_classes', 'supported_root_device_types', "
    "'supported_virtualization_types', 'bare_metal', 'hypervisor', 'processor_info', 'v_cpu_info', 'memory_info', 'inst"
    "ance_storage_supported', 'instance_storage_info', 'ebs_info', 'network_info', 'gpu_info', 'fpga_info', 'placement_"
    "group_info', 'inference_accelerator_info', 'hibernation_supported', 'burstable_performance_supported', 'dedicated_"
    "hosts_supported', 'auto_recovery_supported', 'supported_boot_modes', 'nitro_enclaves_support', 'nitro_tpm_support'"
    ", 'nitro_tpm_info', 'media_accelerator_info', 'neuron_info', 'phc_support', 'reboot_migration_support'), frozen=Tr"
    "ue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='insta"
    "nce_type', kw_only=True, fn=None), ReprPlan.Field(name='current_generation', kw_only=True, fn=None), ReprPlan.Fiel"
    "d(name='free_tier_eligible', kw_only=True, fn=None), ReprPlan.Field(name='supported_usage_classes', kw_only=True, "
    "fn=None), ReprPlan.Field(name='supported_root_device_types', kw_only=True, fn=None), ReprPlan.Field(name='supporte"
    "d_virtualization_types', kw_only=True, fn=None), ReprPlan.Field(name='bare_metal', kw_only=True, fn=None), ReprPla"
    "n.Field(name='hypervisor', kw_only=True, fn=None), ReprPlan.Field(name='processor_info', kw_only=True, fn=None), R"
    "eprPlan.Field(name='v_cpu_info', kw_only=True, fn=None), ReprPlan.Field(name='memory_info', kw_only=True, fn=None)"
    ", ReprPlan.Field(name='instance_storage_supported', kw_only=True, fn=None), ReprPlan.Field(name='instance_storage_"
    "info', kw_only=True, fn=None), ReprPlan.Field(name='ebs_info', kw_only=True, fn=None), ReprPlan.Field(name='networ"
    "k_info', kw_only=True, fn=None), ReprPlan.Field(name='gpu_info', kw_only=True, fn=None), ReprPlan.Field(name='fpga"
    "_info', kw_only=True, fn=None), ReprPlan.Field(name='placement_group_info', kw_only=True, fn=None), ReprPlan.Field"
    "(name='inference_accelerator_info', kw_only=True, fn=None), ReprPlan.Field(name='hibernation_supported', kw_only=T"
    "rue, fn=None), ReprPlan.Field(name='burstable_performance_supported', kw_only=True, fn=None), ReprPlan.Field(name="
    "'dedicated_hosts_supported', kw_only=True, fn=None), ReprPlan.Field(name='auto_recovery_supported', kw_only=True, "
    "fn=None), ReprPlan.Field(name='supported_boot_modes', kw_only=True, fn=None), ReprPlan.Field(name='nitro_enclaves_"
    "support', kw_only=True, fn=None), ReprPlan.Field(name='nitro_tpm_support', kw_only=True, fn=None), ReprPlan.Field("
    "name='nitro_tpm_info', kw_only=True, fn=None), ReprPlan.Field(name='media_accelerator_info', kw_only=True, fn=None"
    "), ReprPlan.Field(name='neuron_info', kw_only=True, fn=None), ReprPlan.Field(name='phc_support', kw_only=True, fn="
    "None), ReprPlan.Field(name='reboot_migration_support', kw_only=True, fn=None)), id=False, terse=False, default_fn="
    "None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstanceTypeInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__21__annotation,
    __dataclass__init__fields__21__default,
    __dataclass__init__fields__22__annotation,
    __dataclass__init__fields__22__default,
    __dataclass__init__fields__23__annotation,
    __dataclass__init__fields__23__default,
    __dataclass__init__fields__24__annotation,
    __dataclass__init__fields__24__default,
    __dataclass__init__fields__25__annotation,
    __dataclass__init__fields__25__default,
    __dataclass__init__fields__26__annotation,
    __dataclass__init__fields__26__default,
    __dataclass__init__fields__27__annotation,
    __dataclass__init__fields__27__default,
    __dataclass__init__fields__28__annotation,
    __dataclass__init__fields__28__default,
    __dataclass__init__fields__29__annotation,
    __dataclass__init__fields__29__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__30__annotation,
    __dataclass__init__fields__30__default,
    __dataclass__init__fields__31__annotation,
    __dataclass__init__fields__31__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            instance_type=self.instance_type,
            current_generation=self.current_generation,
            free_tier_eligible=self.free_tier_eligible,
            supported_usage_classes=self.supported_usage_classes,
            supported_root_device_types=self.supported_root_device_types,
            supported_virtualization_types=self.supported_virtualization_types,
            bare_metal=self.bare_metal,
            hypervisor=self.hypervisor,
            processor_info=self.processor_info,
            v_cpu_info=self.v_cpu_info,
            memory_info=self.memory_info,
            instance_storage_supported=self.instance_storage_supported,
            instance_storage_info=self.instance_storage_info,
            ebs_info=self.ebs_info,
            network_info=self.network_info,
            gpu_info=self.gpu_info,
            fpga_info=self.fpga_info,
            placement_group_info=self.placement_group_info,
            inference_accelerator_info=self.inference_accelerator_info,
            hibernation_supported=self.hibernation_supported,
            burstable_performance_supported=self.burstable_performance_supported,
            dedicated_hosts_supported=self.dedicated_hosts_supported,
            auto_recovery_supported=self.auto_recovery_supported,
            supported_boot_modes=self.supported_boot_modes,
            nitro_enclaves_support=self.nitro_enclaves_support,
            nitro_tpm_support=self.nitro_tpm_support,
            nitro_tpm_info=self.nitro_tpm_info,
            media_accelerator_info=self.media_accelerator_info,
            neuron_info=self.neuron_info,
            phc_support=self.phc_support,
            reboot_migration_support=self.reboot_migration_support,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.instance_type == other.instance_type and
            self.current_generation == other.current_generation and
            self.free_tier_eligible == other.free_tier_eligible and
            self.supported_usage_classes == other.supported_usage_classes and
            self.supported_root_device_types == other.supported_root_device_types and
            self.supported_virtualization_types == other.supported_virtualization_types and
            self.bare_metal == other.bare_metal and
            self.hypervisor == other.hypervisor and
            self.processor_info == other.processor_info and
            self.v_cpu_info == other.v_cpu_info and
            self.memory_info == other.memory_info and
            self.instance_storage_supported == other.instance_storage_supported and
            self.instance_storage_info == other.instance_storage_info and
            self.ebs_info == other.ebs_info and
            self.network_info == other.network_info and
            self.gpu_info == other.gpu_info and
            self.fpga_info == other.fpga_info and
            self.placement_group_info == other.placement_group_info and
            self.inference_accelerator_info == other.inference_accelerator_info and
            self.hibernation_supported == other.hibernation_supported and
            self.burstable_performance_supported == other.burstable_performance_supported and
            self.dedicated_hosts_supported == other.dedicated_hosts_supported and
            self.auto_recovery_supported == other.auto_recovery_supported and
            self.supported_boot_modes == other.supported_boot_modes and
            self.nitro_enclaves_support == other.nitro_enclaves_support and
            self.nitro_tpm_support == other.nitro_tpm_support and
            self.nitro_tpm_info == other.nitro_tpm_info and
            self.media_accelerator_info == other.media_accelerator_info and
            self.neuron_info == other.neuron_info and
            self.phc_support == other.phc_support and
            self.reboot_migration_support == other.reboot_migration_support
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'instance_type',
        'current_generation',
        'free_tier_eligible',
        'supported_usage_classes',
        'supported_root_device_types',
        'supported_virtualization_types',
        'bare_metal',
        'hypervisor',
        'processor_info',
        'v_cpu_info',
        'memory_info',
        'instance_storage_supported',
        'instance_storage_info',
        'ebs_info',
        'network_info',
        'gpu_info',
        'fpga_info',
        'placement_group_info',
        'inference_accelerator_info',
        'hibernation_supported',
        'burstable_performance_supported',
        'dedicated_hosts_supported',
        'auto_recovery_supported',
        'supported_boot_modes',
        'nitro_enclaves_support',
        'nitro_tpm_support',
        'nitro_tpm_info',
        'media_accelerator_info',
        'neuron_info',
        'phc_support',
        'reboot_migration_support',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'instance_type',
        'current_generation',
        'free_tier_eligible',
        'supported_usage_classes',
        'supported_root_device_types',
        'supported_virtualization_types',
        'bare_metal',
        'hypervisor',
        'processor_info',
        'v_cpu_info',
        'memory_info',
        'instance_storage_supported',
        'instance_storage_info',
        'ebs_info',
        'network_info',
        'gpu_info',
        'fpga_info',
        'placement_group_info',
        'inference_accelerator_info',
        'hibernation_supported',
        'burstable_performance_supported',
        'dedicated_hosts_supported',
        'auto_recovery_supported',
        'supported_boot_modes',
        'nitro_enclaves_support',
        'nitro_tpm_support',
        'nitro_tpm_info',
        'media_accelerator_info',
        'neuron_info',
        'phc_support',
        'reboot_migration_support',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.instance_type,
            self.current_generation,
            self.free_tier_eligible,
            self.supported_usage_classes,
            self.supported_root_device_types,
            self.supported_virtualization_types,
            self.bare_metal,
            self.hypervisor,
            self.processor_info,
            self.v_cpu_info,
            self.memory_info,
            self.instance_storage_supported,
            self.instance_storage_info,
            self.ebs_info,
            self.network_info,
            self.gpu_info,
            self.fpga_info,
            self.placement_group_info,
            self.inference_accelerator_info,
            self.hibernation_supported,
            self.burstable_performance_supported,
            self.dedicated_hosts_supported,
            self.auto_recovery_supported,
            self.supported_boot_modes,
            self.nitro_enclaves_support,
            self.nitro_tpm_support,
            self.nitro_tpm_info,
            self.media_accelerator_info,
            self.neuron_info,
            self.phc_support,
            self.reboot_migration_support,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        instance_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        current_generation: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        free_tier_eligible: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        supported_usage_classes: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        supported_root_device_types: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        supported_virtualization_types: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        bare_metal: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        hypervisor: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        processor_info: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        v_cpu_info: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        memory_info: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        instance_storage_supported: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        instance_storage_info: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        ebs_info: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        network_info: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        gpu_info: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        fpga_info: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        placement_group_info: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        inference_accelerator_info: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        hibernation_supported: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        burstable_performance_supported: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
        dedicated_hosts_supported: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
        auto_recovery_supported: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
        supported_boot_modes: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
        nitro_enclaves_support: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
        nitro_tpm_support: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
        nitro_tpm_info: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
        media_accelerator_info: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
        neuron_info: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
        phc_support: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
        reboot_migration_support: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'instance_type', instance_type)
        __dataclass__object_setattr(self, 'current_generation', current_generation)
        __dataclass__object_setattr(self, 'free_tier_eligible', free_tier_eligible)
        __dataclass__object_setattr(self, 'supported_usage_classes', supported_usage_classes)
        __dataclass__object_setattr(self, 'supported_root_device_types', supported_root_device_types)
        __dataclass__object_setattr(self, 'supported_virtualization_types', supported_virtualization_types)
        __dataclass__object_setattr(self, 'bare_metal', bare_metal)
        __dataclass__object_setattr(self, 'hypervisor', hypervisor)
        __dataclass__object_setattr(self, 'processor_info', processor_info)
        __dataclass__object_setattr(self, 'v_cpu_info', v_cpu_info)
        __dataclass__object_setattr(self, 'memory_info', memory_info)
        __dataclass__object_setattr(self, 'instance_storage_supported', instance_storage_supported)
        __dataclass__object_setattr(self, 'instance_storage_info', instance_storage_info)
        __dataclass__object_setattr(self, 'ebs_info', ebs_info)
        __dataclass__object_setattr(self, 'network_info', network_info)
        __dataclass__object_setattr(self, 'gpu_info', gpu_info)
        __dataclass__object_setattr(self, 'fpga_info', fpga_info)
        __dataclass__object_setattr(self, 'placement_group_info', placement_group_info)
        __dataclass__object_setattr(self, 'inference_accelerator_info', inference_accelerator_info)
        __dataclass__object_setattr(self, 'hibernation_supported', hibernation_supported)
        __dataclass__object_setattr(self, 'burstable_performance_supported', burstable_performance_supported)
        __dataclass__object_setattr(self, 'dedicated_hosts_supported', dedicated_hosts_supported)
        __dataclass__object_setattr(self, 'auto_recovery_supported', auto_recovery_supported)
        __dataclass__object_setattr(self, 'supported_boot_modes', supported_boot_modes)
        __dataclass__object_setattr(self, 'nitro_enclaves_support', nitro_enclaves_support)
        __dataclass__object_setattr(self, 'nitro_tpm_support', nitro_tpm_support)
        __dataclass__object_setattr(self, 'nitro_tpm_info', nitro_tpm_info)
        __dataclass__object_setattr(self, 'media_accelerator_info', media_accelerator_info)
        __dataclass__object_setattr(self, 'neuron_info', neuron_info)
        __dataclass__object_setattr(self, 'phc_support', phc_support)
        __dataclass__object_setattr(self, 'reboot_migration_support', reboot_migration_support)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"instance_type={self.instance_type!r}")
        parts.append(f"current_generation={self.current_generation!r}")
        parts.append(f"free_tier_eligible={self.free_tier_eligible!r}")
        parts.append(f"supported_usage_classes={self.supported_usage_classes!r}")
        parts.append(f"supported_root_device_types={self.supported_root_device_types!r}")
        parts.append(f"supported_virtualization_types={self.supported_virtualization_types!r}")
        parts.append(f"bare_metal={self.bare_metal!r}")
        parts.append(f"hypervisor={self.hypervisor!r}")
        parts.append(f"processor_info={self.processor_info!r}")
        parts.append(f"v_cpu_info={self.v_cpu_info!r}")
        parts.append(f"memory_info={self.memory_info!r}")
        parts.append(f"instance_storage_supported={self.instance_storage_supported!r}")
        parts.append(f"instance_storage_info={self.instance_storage_info!r}")
        parts.append(f"ebs_info={self.ebs_info!r}")
        parts.append(f"network_info={self.network_info!r}")
        parts.append(f"gpu_info={self.gpu_info!r}")
        parts.append(f"fpga_info={self.fpga_info!r}")
        parts.append(f"placement_group_info={self.placement_group_info!r}")
        parts.append(f"inference_accelerator_info={self.inference_accelerator_info!r}")
        parts.append(f"hibernation_supported={self.hibernation_supported!r}")
        parts.append(f"burstable_performance_supported={self.burstable_performance_supported!r}")
        parts.append(f"dedicated_hosts_supported={self.dedicated_hosts_supported!r}")
        parts.append(f"auto_recovery_supported={self.auto_recovery_supported!r}")
        parts.append(f"supported_boot_modes={self.supported_boot_modes!r}")
        parts.append(f"nitro_enclaves_support={self.nitro_enclaves_support!r}")
        parts.append(f"nitro_tpm_support={self.nitro_tpm_support!r}")
        parts.append(f"nitro_tpm_info={self.nitro_tpm_info!r}")
        parts.append(f"media_accelerator_info={self.media_accelerator_info!r}")
        parts.append(f"neuron_info={self.neuron_info!r}")
        parts.append(f"phc_support={self.phc_support!r}")
        parts.append(f"reboot_migration_support={self.reboot_migration_support!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('block_device_mappings', 'image_id', 'instance_type', 'ipv6_address_count', 'ipv6_addr"
    "esses', 'kernel_id', 'key_name', 'max_count', 'min_count', 'monitoring', 'placement', 'ramdisk_id', 'security_grou"
    "p_ids', 'security_groups', 'subnet_id', 'user_data', 'elastic_gpu_specification', 'elastic_inference_accelerators'"
    ", 'tag_specifications', 'launch_template', 'instance_market_options', 'credit_specification', 'cpu_options', 'capa"
    "city_reservation_specification', 'hibernation_options', 'license_specifications', 'metadata_options', 'enclave_opt"
    "ions', 'private_dns_name_options', 'maintenance_options', 'disable_api_stop', 'enable_primary_ipv6', 'network_perf"
    "ormance_options', 'operator', 'dry_run', 'disable_api_termination', 'instance_initiated_shutdown_behavior', 'priva"
    "te_ip_address', 'client_token', 'additional_info', 'network_interfaces', 'iam_instance_profile', 'ebs_optimized'))"
    ", EqPlan(fields=('block_device_mappings', 'image_id', 'instance_type', 'ipv6_address_count', 'ipv6_addresses', 'ke"
    "rnel_id', 'key_name', 'max_count', 'min_count', 'monitoring', 'placement', 'ramdisk_id', 'security_group_ids', 'se"
    "curity_groups', 'subnet_id', 'user_data', 'elastic_gpu_specification', 'elastic_inference_accelerators', 'tag_spec"
    "ifications', 'launch_template', 'instance_market_options', 'credit_specification', 'cpu_options', 'capacity_reserv"
    "ation_specification', 'hibernation_options', 'license_specifications', 'metadata_options', 'enclave_options', 'pri"
    "vate_dns_name_options', 'maintenance_options', 'disable_api_stop', 'enable_primary_ipv6', 'network_performance_opt"
    "ions', 'operator', 'dry_run', 'disable_api_termination', 'instance_initiated_shutdown_behavior', 'private_ip_addre"
    "ss', 'client_token', 'additional_info', 'network_interfaces', 'iam_instance_profile', 'ebs_optimized')), FrozenPla"
    "n(fields=('__shape__', 'block_device_mappings', 'image_id', 'instance_type', 'ipv6_address_count', 'ipv6_addresses"
    "', 'kernel_id', 'key_name', 'max_count', 'min_count', 'monitoring', 'placement', 'ramdisk_id', 'security_group_ids"
    "', 'security_groups', 'subnet_id', 'user_data', 'elastic_gpu_specification', 'elastic_inference_accelerators', 'ta"
    "g_specifications', 'launch_template', 'instance_market_options', 'credit_specification', 'cpu_options', 'capacity_"
    "reservation_specification', 'hibernation_options', 'license_specifications', 'metadata_options', 'enclave_options'"
    ", 'private_dns_name_options', 'maintenance_options', 'disable_api_stop', 'enable_primary_ipv6', 'network_performan"
    "ce_options', 'operator', 'dry_run', 'disable_api_termination', 'instance_initiated_shutdown_behavior', 'private_ip"
    "_address', 'client_token', 'additional_info', 'network_interfaces', 'iam_instance_profile', 'ebs_optimized'), allo"
    "w_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('block_device_mappings', 'image_id', 'instance_type'"
    ", 'ipv6_address_count', 'ipv6_addresses', 'kernel_id', 'key_name', 'max_count', 'min_count', 'monitoring', 'placem"
    "ent', 'ramdisk_id', 'security_group_ids', 'security_groups', 'subnet_id', 'user_data', 'elastic_gpu_specification'"
    ", 'elastic_inference_accelerators', 'tag_specifications', 'launch_template', 'instance_market_options', 'credit_sp"
    "ecification', 'cpu_options', 'capacity_reservation_specification', 'hibernation_options', 'license_specifications'"
    ", 'metadata_options', 'enclave_options', 'private_dns_name_options', 'maintenance_options', 'disable_api_stop', 'e"
    "nable_primary_ipv6', 'network_performance_options', 'operator', 'dry_run', 'disable_api_termination', 'instance_in"
    "itiated_shutdown_behavior', 'private_ip_address', 'client_token', 'additional_info', 'network_interfaces', 'iam_in"
    "stance_profile', 'ebs_optimized'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRe"
    "f(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='block_device_mappings', annota"
    "tion=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='image_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default')"
    ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='instance_type', annotation=OpRef(name='init.fields.3.annotation'), default=OpRe"
    "f(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_address_count', annotation=OpRef(name='init"
    ".fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_address"
    "es', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_facto"
    "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
    "nitPlan.Field(name='kernel_id', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields"
    ".6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None), InitPlan.Field(name='key_name', annotation=OpRef(name='init.fields.7.annotation'), defau"
    "lt=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
    "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_count', annotation=OpRef(name='init.f"
    "ields.8.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
    ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='min_count', annotation=OpRef(name='init.field"
    "s.9.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None), InitPlan.Field(name='monitoring', annotation=OpRef(name='init.fields.1"
    "0.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='placement', annotat"
    "ion=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, i"
    "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
    "eld(name='ramdisk_id', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='security_group_ids', annotation=OpRef(name='init.fields.13.annotation'), d"
    "efault=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=False, field_type=FieldType"
    ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='security_groups', annotation=OpRef(n"
    "ame='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='s"
    "ubnet_id', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), defau"
    "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='user_data', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef(name='in"
    "it.fields.16.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
    "e, validate=None, check_type=None), InitPlan.Field(name='elastic_gpu_specification', annotation=OpRef(name='init.f"
    "ields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='elastic_infe"
    "rence_accelerators', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.18.defaul"
    "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='tag_specifications', annotation=OpRef(name='init.fields.19.annotation'), def"
    "ault=OpRef(name='init.fields.19.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
    "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='launch_template', annotation=OpRef(nam"
    "e='init.fields.20.annotation'), default=OpRef(name='init.fields.20.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ins"
    "tance_market_options', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='init.fields.21.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='credit_specification', annotation=OpRef(name='init.fields.22.annotation'),"
    " default=OpRef(name='init.fields.22.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
    "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cpu_options', annotation=OpRef(nam"
    "e='init.fields.23.annotation'), default=OpRef(name='init.fields.23.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cap"
    "acity_reservation_specification', annotation=OpRef(name='init.fields.24.annotation'), default=OpRef(name='init.fie"
    "lds.24.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='hibernation_options', annotation=OpRef(name='init.fields.25.ann"
    "otation'), default=OpRef(name='init.fields.25.default'), default_factory=None, init=True, override=False, field_ty"
    "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='license_specifications',"
    " annotation=OpRef(name='init.fields.26.annotation'), default=OpRef(name='init.fields.26.default'), default_factory"
    "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
    "tPlan.Field(name='metadata_options', annotation=OpRef(name='init.fields.27.annotation'), default=OpRef(name='init."
    "fields.27.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='enclave_options', annotation=OpRef(name='init.fields.28.anno"
    "tation'), default=OpRef(name='init.fields.28.default'), default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='private_dns_name_options'"
    ", annotation=OpRef(name='init.fields.29.annotation'), default=OpRef(name='init.fields.29.default'), default_factor"
    "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
    "itPlan.Field(name='maintenance_options', annotation=OpRef(name='init.fields.30.annotation'), default=OpRef(name='i"
    "nit.fields.30.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
    "ne, validate=None, check_type=None), InitPlan.Field(name='disable_api_stop', annotation=OpRef(name='init.fields.31"
    ".annotation'), default=OpRef(name='init.fields.31.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='enable_primary_ipv6'"
    ", annotation=OpRef(name='init.fields.32.annotation'), default=OpRef(name='init.fields.32.default'), default_factor"
    "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
    "itPlan.Field(name='network_performance_options', annotation=OpRef(name='init.fields.33.annotation'), default=OpRef"
    "(name='init.fields.33.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='operator', annotation=OpRef(name='init.fields.34"
    ".annotation'), default=OpRef(name='init.fields.34.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation"
    "=OpRef(name='init.fields.35.annotation'), default=OpRef(name='init.fields.35.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='disable_api_termination', annotation=OpRef(name='init.fields.36.annotation'), default=OpRef(name='init.fiel"
    "ds.36.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None), InitPlan.Field(name='instance_initiated_shutdown_behavior', annotation=OpRef(name='in"
    "it.fields.37.annotation'), default=OpRef(name='init.fields.37.default'), default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='private_"
    "ip_address', annotation=OpRef(name='init.fields.38.annotation'), default=OpRef(name='init.fields.38.default'), def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='client_token', annotation=OpRef(name='init.fields.39.annotation'), default=OpRef(nam"
    "e='init.fields.39.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='additional_info', annotation=OpRef(name='init.fields"
    ".40.annotation'), default=OpRef(name='init.fields.40.default'), default_factory=None, init=True, override=False, f"
    "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_interface"
    "s', annotation=OpRef(name='init.fields.41.annotation'), default=OpRef(name='init.fields.41.default'), default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
    "InitPlan.Field(name='iam_instance_profile', annotation=OpRef(name='init.fields.42.annotation'), default=OpRef(name"
    "='init.fields.42.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='ebs_optimized', annotation=OpRef(name='init.fields.43"
    ".annotation'), default=OpRef(name='init.fields.43.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_onl"
    "y_params=('block_device_mappings', 'image_id', 'instance_type', 'ipv6_address_count', 'ipv6_addresses', 'kernel_id"
    "', 'key_name', 'max_count', 'min_count', 'monitoring', 'placement', 'ramdisk_id', 'security_group_ids', 'security_"
    "groups', 'subnet_id', 'user_data', 'elastic_gpu_specification', 'elastic_inference_accelerators', 'tag_specificati"
    "ons', 'launch_template', 'instance_market_options', 'credit_specification', 'cpu_options', 'capacity_reservation_s"
    "pecification', 'hibernation_options', 'license_specifications', 'metadata_options', 'enclave_options', 'private_dn"
    "s_name_options', 'maintenance_options', 'disable_api_stop', 'enable_primary_ipv6', 'network_performance_options', "
    "'operator', 'dry_run', 'disable_api_termination', 'instance_initiated_shutdown_behavior', 'private_ip_address', 'c"
    "lient_token', 'additional_info', 'network_interfaces', 'iam_instance_profile', 'ebs_optimized'), frozen=True, slot"
    "s=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='block_device_"
    "mappings', kw_only=True, fn=None), ReprPlan.Field(name='image_id', kw_only=True, fn=None), ReprPlan.Field(name='in"
    "stance_type', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_address_count', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='ipv6_addresses', kw_only=True, fn=None), ReprPlan.Field(name='kernel_id', kw_only=True, fn=None), ReprP"
    "lan.Field(name='key_name', kw_only=True, fn=None), ReprPlan.Field(name='max_count', kw_only=True, fn=None), ReprPl"
    "an.Field(name='min_count', kw_only=True, fn=None), ReprPlan.Field(name='monitoring', kw_only=True, fn=None), ReprP"
    "lan.Field(name='placement', kw_only=True, fn=None), ReprPlan.Field(name='ramdisk_id', kw_only=True, fn=None), Repr"
    "Plan.Field(name='security_group_ids', kw_only=True, fn=None), ReprPlan.Field(name='security_groups', kw_only=True,"
    " fn=None), ReprPlan.Field(name='subnet_id', kw_only=True, fn=None), ReprPlan.Field(name='user_data', kw_only=True,"
    " fn=None), ReprPlan.Field(name='elastic_gpu_specification', kw_only=True, fn=None), ReprPlan.Field(name='elastic_i"
    "nference_accelerators', kw_only=True, fn=None), ReprPlan.Field(name='tag_specifications', kw_only=True, fn=None), "
    "ReprPlan.Field(name='launch_template', kw_only=True, fn=None), ReprPlan.Field(name='instance_market_options', kw_o"
    "nly=True, fn=None), ReprPlan.Field(name='credit_specification', kw_only=True, fn=None), ReprPlan.Field(name='cpu_o"
    "ptions', kw_only=True, fn=None), ReprPlan.Field(name='capacity_reservation_specification', kw_only=True, fn=None),"
    " ReprPlan.Field(name='hibernation_options', kw_only=True, fn=None), ReprPlan.Field(name='license_specifications', "
    "kw_only=True, fn=None), ReprPlan.Field(name='metadata_options', kw_only=True, fn=None), ReprPlan.Field(name='encla"
    "ve_options', kw_only=True, fn=None), ReprPlan.Field(name='private_dns_name_options', kw_only=True, fn=None), ReprP"
    "lan.Field(name='maintenance_options', kw_only=True, fn=None), ReprPlan.Field(name='disable_api_stop', kw_only=True"
    ", fn=None), ReprPlan.Field(name='enable_primary_ipv6', kw_only=True, fn=None), ReprPlan.Field(name='network_perfor"
    "mance_options', kw_only=True, fn=None), ReprPlan.Field(name='operator', kw_only=True, fn=None), ReprPlan.Field(nam"
    "e='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='disable_api_termination', kw_only=True, fn=None), ReprPl"
    "an.Field(name='instance_initiated_shutdown_behavior', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_addr"
    "ess', kw_only=True, fn=None), ReprPlan.Field(name='client_token', kw_only=True, fn=None), ReprPlan.Field(name='add"
    "itional_info', kw_only=True, fn=None), ReprPlan.Field(name='network_interfaces', kw_only=True, fn=None), ReprPlan."
    "Field(name='iam_instance_profile', kw_only=True, fn=None), ReprPlan.Field(name='ebs_optimized', kw_only=True, fn=N"
    "one)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fRunInstancesRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__21__annotation,
    __dataclass__init__fields__21__default,
    __dataclass__init__fields__22__annotation,
    __dataclass__init__fields__22__default,
    __dataclass__init__fields__23__annotation,
    __dataclass__init__fields__23__default,
    __dataclass__init__fields__24__annotation,
    __dataclass__init__fields__24__default,
    __dataclass__init__fields__25__annotation,
    __dataclass__init__fields__25__default,
    __dataclass__init__fields__26__annotation,
    __dataclass__init__fields__26__default,
    __dataclass__init__fields__27__annotation,
    __dataclass__init__fields__27__default,
    __dataclass__init__fields__28__annotation,
    __dataclass__init__fields__28__default,
    __dataclass__init__fields__29__annotation,
    __dataclass__init__fields__29__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__30__annotation,
    __dataclass__init__fields__30__default,
    __dataclass__init__fields__31__annotation,
    __dataclass__init__fields__31__default,
    __dataclass__init__fields__32__annotation,
    __dataclass__init__fields__32__default,
    __dataclass__init__fields__33__annotation,
    __dataclass__init__fields__33__default,
    __dataclass__init__fields__34__annotation,
    __dataclass__init__fields__34__default,
    __dataclass__init__fields__35__annotation,
    __dataclass__init__fields__35__default,
    __dataclass__init__fields__36__annotation,
    __dataclass__init__fields__36__default,
    __dataclass__init__fields__37__annotation,
    __dataclass__init__fields__37__default,
    __dataclass__init__fields__38__annotation,
    __dataclass__init__fields__38__default,
    __dataclass__init__fields__39__annotation,
    __dataclass__init__fields__39__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__40__annotation,
    __dataclass__init__fields__40__default,
    __dataclass__init__fields__41__annotation,
    __dataclass__init__fields__41__default,
    __dataclass__init__fields__42__annotation,
    __dataclass__init__fields__42__default,
    __dataclass__init__fields__43__annotation,
    __dataclass__init__fields__43__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__9__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            block_device_mappings=self.block_device_mappings,
            image_id=self.image_id,
            instance_type=self.instance_type,
            ipv6_address_count=self.ipv6_address_count,
            ipv6_addresses=self.ipv6_addresses,
            kernel_id=self.kernel_id,
            key_name=self.key_name,
            max_count=self.max_count,
            min_count=self.min_count,
            monitoring=self.monitoring,
            placement=self.placement,
            ramdisk_id=self.ramdisk_id,
            security_group_ids=self.security_group_ids,
            security_groups=self.security_groups,
            subnet_id=self.subnet_id,
            user_data=self.user_data,
            elastic_gpu_specification=self.elastic_gpu_specification,
            elastic_inference_accelerators=self.elastic_inference_accelerators,
            tag_specifications=self.tag_specifications,
            launch_template=self.launch_template,
            instance_market_options=self.instance_market_options,
            credit_specification=self.credit_specification,
            cpu_options=self.cpu_options,
            capacity_reservation_specification=self.capacity_reservation_specification,
            hibernation_options=self.hibernation_options,
            license_specifications=self.license_specifications,
            metadata_options=self.metadata_options,
            enclave_options=self.enclave_options,
            private_dns_name_options=self.private_dns_name_options,
            maintenance_options=self.maintenance_options,
            disable_api_stop=self.disable_api_stop,
            enable_primary_ipv6=self.enable_primary_ipv6,
            network_performance_options=self.network_performance_options,
            operator=self.operator,
            dry_run=self.dry_run,
            disable_api_termination=self.disable_api_termination,
            instance_initiated_shutdown_behavior=self.instance_initiated_shutdown_behavior,
            private_ip_address=self.private_ip_address,
            client_token=self.client_token,
            additional_info=self.additional_info,
            network_interfaces=self.network_interfaces,
            iam_instance_profile=self.iam_instance_profile,
            ebs_optimized=self.ebs_optimized,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.block_device_mappings == other.block_device_mappings and
            self.image_id == other.image_id and
            self.instance_type == other.instance_type and
            self.ipv6_address_count == other.ipv6_address_count and
            self.ipv6_addresses == other.ipv6_addresses and
            self.kernel_id == other.kernel_id and
            self.key_name == other.key_name and
            self.max_count == other.max_count and
            self.min_count == other.min_count and
            self.monitoring == other.monitoring and
            self.placement == other.placement and
            self.ramdisk_id == other.ramdisk_id and
            self.security_group_ids == other.security_group_ids and
            self.security_groups == other.security_groups and
            self.subnet_id == other.subnet_id and
            self.user_data == other.user_data and
            self.elastic_gpu_specification == other.elastic_gpu_specification and
            self.elastic_inference_accelerators == other.elastic_inference_accelerators and
            self.tag_specifications == other.tag_specifications and
            self.launch_template == other.launch_template and
            self.instance_market_options == other.instance_market_options and
            self.credit_specification == other.credit_specification and
            self.cpu_options == other.cpu_options and
            self.capacity_reservation_specification == other.capacity_reservation_specification and
            self.hibernation_options == other.hibernation_options and
            self.license_specifications == other.license_specifications and
            self.metadata_options == other.metadata_options and
            self.enclave_options == other.enclave_options and
            self.private_dns_name_options == other.private_dns_name_options and
            self.maintenance_options == other.maintenance_options and
            self.disable_api_stop == other.disable_api_stop and
            self.enable_primary_ipv6 == other.enable_primary_ipv6 and
            self.network_performance_options == other.network_performance_options and
            self.operator == other.operator and
            self.dry_run == other.dry_run and
            self.disable_api_termination == other.disable_api_termination and
            self.instance_initiated_shutdown_behavior == other.instance_initiated_shutdown_behavior and
            self.private_ip_address == other.private_ip_address and
            self.client_token == other.client_token and
            self.additional_info == other.additional_info and
            self.network_interfaces == other.network_interfaces and
            self.iam_instance_profile == other.iam_instance_profile and
            self.ebs_optimized == other.ebs_optimized
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'block_device_mappings',
        'image_id',
        'instance_type',
        'ipv6_address_count',
        'ipv6_addresses',
        'kernel_id',
        'key_name',
        'max_count',
        'min_count',
        'monitoring',
        'placement',
        'ramdisk_id',
        'security_group_ids',
        'security_groups',
        'subnet_id',
        'user_data',
        'elastic_gpu_specification',
        'elastic_inference_accelerators',
        'tag_specifications',
        'launch_template',
        'instance_market_options',
        'credit_specification',
        'cpu_options',
        'capacity_reservation_specification',
        'hibernation_options',
        'license_specifications',
        'metadata_options',
        'enclave_options',
        'private_dns_name_options',
        'maintenance_options',
        'disable_api_stop',
        'enable_primary_ipv6',
        'network_performance_options',
        'operator',
        'dry_run',
        'disable_api_termination',
        'instance_initiated_shutdown_behavior',
        'private_ip_address',
        'client_token',
        'additional_info',
        'network_interfaces',
        'iam_instance_profile',
        'ebs_optimized',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'block_device_mappings',
        'image_id',
        'instance_type',
        'ipv6_address_count',
        'ipv6_addresses',
        'kernel_id',
        'key_name',
        'max_count',
        'min_count',
        'monitoring',
        'placement',
        'ramdisk_id',
        'security_group_ids',
        'security_groups',
        'subnet_id',
        'user_data',
        'elastic_gpu_specification',
        'elastic_inference_accelerators',
        'tag_specifications',
        'launch_template',
        'instance_market_options',
        'credit_specification',
        'cpu_options',
        'capacity_reservation_specification',
        'hibernation_options',
        'license_specifications',
        'metadata_options',
        'enclave_options',
        'private_dns_name_options',
        'maintenance_options',
        'disable_api_stop',
        'enable_primary_ipv6',
        'network_performance_options',
        'operator',
        'dry_run',
        'disable_api_termination',
        'instance_initiated_shutdown_behavior',
        'private_ip_address',
        'client_token',
        'additional_info',
        'network_interfaces',
        'iam_instance_profile',
        'ebs_optimized',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.block_device_mappings,
            self.image_id,
            self.instance_type,
            self.ipv6_address_count,
            self.ipv6_addresses,
            self.kernel_id,
            self.key_name,
            self.max_count,
            self.min_count,
            self.monitoring,
            self.placement,
            self.ramdisk_id,
            self.security_group_ids,
            self.security_groups,
            self.subnet_id,
            self.user_data,
            self.elastic_gpu_specification,
            self.elastic_inference_accelerators,
            self.tag_specifications,
            self.launch_template,
            self.instance_market_options,
            self.credit_specification,
            self.cpu_options,
            self.capacity_reservation_specification,
            self.hibernation_options,
            self.license_specifications,
            self.metadata_options,
            self.enclave_options,
            self.private_dns_name_options,
            self.maintenance_options,
            self.disable_api_stop,
            self.enable_primary_ipv6,
            self.network_performance_options,
            self.operator,
            self.dry_run,
            self.disable_api_termination,
            self.instance_initiated_shutdown_behavior,
            self.private_ip_address,
            self.client_token,
            self.additional_info,
            self.network_interfaces,
            self.iam_instance_profile,
            self.ebs_optimized,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        block_device_mappings: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        image_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        instance_type: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ipv6_address_count: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ipv6_addresses: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        kernel_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        key_name: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        max_count: __dataclass__init__fields__8__annotation,
        min_count: __dataclass__init__fields__9__annotation,
        monitoring: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        placement: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        ramdisk_id: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        security_group_ids: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        security_groups: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        subnet_id: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        user_data: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        elastic_gpu_specification: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        elastic_inference_accelerators: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        tag_specifications: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        launch_template: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        instance_market_options: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
        credit_specification: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
        cpu_options: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
        capacity_reservation_specification: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
        hibernation_options: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
        license_specifications: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
        metadata_options: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
        enclave_options: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
        private_dns_name_options: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
        maintenance_options: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
        disable_api_stop: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
        enable_primary_ipv6: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
        network_performance_options: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
        operator: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
        dry_run: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
        disable_api_termination: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
        instance_initiated_shutdown_behavior: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
        private_ip_address: __dataclass__init__fields__38__annotation = __dataclass__init__fields__38__default,
        client_token: __dataclass__init__fields__39__annotation = __dataclass__init__fields__39__default,
        additional_info: __dataclass__init__fields__40__annotation = __dataclass__init__fields__40__default,
        network_interfaces: __dataclass__init__fields__41__annotation = __dataclass__init__fields__41__default,
        iam_instance_profile: __dataclass__init__fields__42__annotation = __dataclass__init__fields__42__default,
        ebs_optimized: __dataclass__init__fields__43__annotation = __dataclass__init__fields__43__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'block_device_mappings', block_device_mappings)
        __dataclass__object_setattr(self, 'image_id', image_id)
        __dataclass__object_setattr(self, 'instance_type', instance_type)
        __dataclass__object_setattr(self, 'ipv6_address_count', ipv6_address_count)
        __dataclass__object_setattr(self, 'ipv6_addresses', ipv6_addresses)
        __dataclass__object_setattr(self, 'kernel_id', kernel_id)
        __dataclass__object_setattr(self, 'key_name', key_name)
        __dataclass__object_setattr(self, 'max_count', max_count)
        __dataclass__object_setattr(self, 'min_count', min_count)
        __dataclass__object_setattr(self, 'monitoring', monitoring)
        __dataclass__object_setattr(self, 'placement', placement)
        __dataclass__object_setattr(self, 'ramdisk_id', ramdisk_id)
        __dataclass__object_setattr(self, 'security_group_ids', security_group_ids)
        __dataclass__object_setattr(self, 'security_groups', security_groups)
        __dataclass__object_setattr(self, 'subnet_id', subnet_id)
        __dataclass__object_setattr(self, 'user_data', user_data)
        __dataclass__object_setattr(self, 'elastic_gpu_specification', elastic_gpu_specification)
        __dataclass__object_setattr(self, 'elastic_inference_accelerators', elastic_inference_accelerators)
        __dataclass__object_setattr(self, 'tag_specifications', tag_specifications)
        __dataclass__object_setattr(self, 'launch_template', launch_template)
        __dataclass__object_setattr(self, 'instance_market_options', instance_market_options)
        __dataclass__object_setattr(self, 'credit_specification', credit_specification)
        __dataclass__object_setattr(self, 'cpu_options', cpu_options)
        __dataclass__object_setattr(self, 'capacity_reservation_specification', capacity_reservation_specification)
        __dataclass__object_setattr(self, 'hibernation_options', hibernation_options)
        __dataclass__object_setattr(self, 'license_specifications', license_specifications)
        __dataclass__object_setattr(self, 'metadata_options', metadata_options)
        __dataclass__object_setattr(self, 'enclave_options', enclave_options)
        __dataclass__object_setattr(self, 'private_dns_name_options', private_dns_name_options)
        __dataclass__object_setattr(self, 'maintenance_options', maintenance_options)
        __dataclass__object_setattr(self, 'disable_api_stop', disable_api_stop)
        __dataclass__object_setattr(self, 'enable_primary_ipv6', enable_primary_ipv6)
        __dataclass__object_setattr(self, 'network_performance_options', network_performance_options)
        __dataclass__object_setattr(self, 'operator', operator)
        __dataclass__object_setattr(self, 'dry_run', dry_run)
        __dataclass__object_setattr(self, 'disable_api_termination', disable_api_termination)
        __dataclass__object_setattr(self, 'instance_initiated_shutdown_behavior', instance_initiated_shutdown_behavior)
        __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)
        __dataclass__object_setattr(self, 'client_token', client_token)
        __dataclass__object_setattr(self, 'additional_info', additional_info)
        __dataclass__object_setattr(self, 'network_interfaces', network_interfaces)
        __dataclass__object_setattr(self, 'iam_instance_profile', iam_instance_profile)
        __dataclass__object_setattr(self, 'ebs_optimized', ebs_optimized)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"block_device_mappings={self.block_device_mappings!r}")
        parts.append(f"image_id={self.image_id!r}")
        parts.append(f"instance_type={self.instance_type!r}")
        parts.append(f"ipv6_address_count={self.ipv6_address_count!r}")
        parts.append(f"ipv6_addresses={self.ipv6_addresses!r}")
        parts.append(f"kernel_id={self.kernel_id!r}")
        parts.append(f"key_name={self.key_name!r}")
        parts.append(f"max_count={self.max_count!r}")
        parts.append(f"min_count={self.min_count!r}")
        parts.append(f"monitoring={self.monitoring!r}")
        parts.append(f"placement={self.placement!r}")
        parts.append(f"ramdisk_id={self.ramdisk_id!r}")
        parts.append(f"security_group_ids={self.security_group_ids!r}")
        parts.append(f"security_groups={self.security_groups!r}")
        parts.append(f"subnet_id={self.subnet_id!r}")
        parts.append(f"user_data={self.user_data!r}")
        parts.append(f"elastic_gpu_specification={self.elastic_gpu_specification!r}")
        parts.append(f"elastic_inference_accelerators={self.elastic_inference_accelerators!r}")
        parts.append(f"tag_specifications={self.tag_specifications!r}")
        parts.append(f"launch_template={self.launch_template!r}")
        parts.append(f"instance_market_options={self.instance_market_options!r}")
        parts.append(f"credit_specification={self.credit_specification!r}")
        parts.append(f"cpu_options={self.cpu_options!r}")
        parts.append(f"capacity_reservation_specification={self.capacity_reservation_specification!r}")
        parts.append(f"hibernation_options={self.hibernation_options!r}")
        parts.append(f"license_specifications={self.license_specifications!r}")
        parts.append(f"metadata_options={self.metadata_options!r}")
        parts.append(f"enclave_options={self.enclave_options!r}")
        parts.append(f"private_dns_name_options={self.private_dns_name_options!r}")
        parts.append(f"maintenance_options={self.maintenance_options!r}")
        parts.append(f"disable_api_stop={self.disable_api_stop!r}")
        parts.append(f"enable_primary_ipv6={self.enable_primary_ipv6!r}")
        parts.append(f"network_performance_options={self.network_performance_options!r}")
        parts.append(f"operator={self.operator!r}")
        parts.append(f"dry_run={self.dry_run!r}")
        parts.append(f"disable_api_termination={self.disable_api_termination!r}")
        parts.append(f"instance_initiated_shutdown_behavior={self.instance_initiated_shutdown_behavior!r}")
        parts.append(f"private_ip_address={self.private_ip_address!r}")
        parts.append(f"client_token={self.client_token!r}")
        parts.append(f"additional_info={self.additional_info!r}")
        parts.append(f"network_interfaces={self.network_interfaces!r}")
        parts.append(f"iam_instance_profile={self.iam_instance_profile!r}")
        parts.append(f"ebs_optimized={self.ebs_optimized!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('group_id', 'ip_permissions_egress', 'tags', 'vpc_id', 'security_group_arn', 'owner_id"
    "', 'group_name', 'description', 'ip_permissions')), EqPlan(fields=('group_id', 'ip_permissions_egress', 'tags', 'v"
    "pc_id', 'security_group_arn', 'owner_id', 'group_name', 'description', 'ip_permissions')), FrozenPlan(fields=('__s"
    "hape__', 'group_id', 'ip_permissions_egress', 'tags', 'vpc_id', 'security_group_arn', 'owner_id', 'group_name', 'd"
    "escription', 'ip_permissions'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('group_id', 'ip_"
    "permissions_egress', 'tags', 'vpc_id', 'security_group_arn', 'owner_id', 'group_name', 'description', 'ip_permissi"
    "ons'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annota"
    "tion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None"
    ", validate=None, check_type=None), InitPlan.Field(name='group_id', annotation=OpRef(name='init.fields.1.annotation"
    "'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ip_permissions_egress', annotati"
    "on=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='tags', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init."
    "fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None), InitPlan.Field(name='security_group_arn', annotation=OpRef(name='init.fields.5.ann"
    "otation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='owner_id', annotation=OpR"
    "ef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True,"
    " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
    "'group_name', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='description', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='"
    "init.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
    "ne, validate=None, check_type=None), InitPlan.Field(name='ip_permissions', annotation=OpRef(name='init.fields.9.an"
    "notation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_ty"
    "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_pa"
    "rams=('group_id', 'ip_permissions_egress', 'tags', 'vpc_id', 'security_group_arn', 'owner_id', 'group_name', 'desc"
    "ription', 'ip_permissions'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
    "lan(fields=(ReprPlan.Field(name='group_id', kw_only=True, fn=None), ReprPlan.Field(name='ip_permissions_egress', k"
    "w_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=T"
    "rue, fn=None), ReprPlan.Field(name='security_group_arn', kw_only=True, fn=None), ReprPlan.Field(name='owner_id', k"
    "w_only=True, fn=None), ReprPlan.Field(name='group_name', kw_only=True, fn=None), ReprPlan.Field(name='description'"
    ", kw_only=True, fn=None), ReprPlan.Field(name='ip_permissions', kw_only=True, fn=None)), id=False, terse=False, de"
    "fault_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fSecurityGroup(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            group_id=self.group_id,
            ip_permissions_egress=self.ip_permissions_egress,
            tags=self.tags,
            vpc_id=self.vpc_id,
            security_group_arn=self.security_group_arn,
            owner_id=self.owner_id,
            group_name=self.group_name,
            description=self.description,
            ip_permissions=self.ip_permissions,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.group_id == other.group_id and
            self.ip_permissions_egress == other.ip_permissions_egress and
            self.tags == other.tags and
            self.vpc_id == other.vpc_id and
            self.security_group_arn == other.security_group_arn and
            self.owner_id == other.owner_id and
            self.group_name == other.group_name and
            self.description == other.description and
            self.ip_permissions == other.ip_permissions
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'group_id',
        'ip_permissions_egress',
        'tags',
        'vpc_id',
        'security_group_arn',
        'owner_id',
        'group_name',
        'description',
        'ip_permissions',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'group_id',
        'ip_permissions_egress',
        'tags',
        'vpc_id',
        'security_group_arn',
        'owner_id',
        'group_name',
        'description',
        'ip_permissions',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.group_id,
            self.ip_permissions_egress,
            self.tags,
            self.vpc_id,
            self.security_group_arn,
            self.owner_id,
            self.group_name,
            self.description,
            self.ip_permissions,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        group_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ip_permissions_egress: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        tags: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        vpc_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        security_group_arn: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        owner_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        group_name: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        description: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        ip_permissions: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'group_id', group_id)
        __dataclass__object_setattr(self, 'ip_permissions_egress', ip_permissions_egress)
        __dataclass__object_setattr(self, 'tags', tags)
        __dataclass__object_setattr(self, 'vpc_id', vpc_id)
        __dataclass__object_setattr(self, 'security_group_arn', security_group_arn)
        __dataclass__object_setattr(self, 'owner_id', owner_id)
        __dataclass__object_setattr(self, 'group_name', group_name)
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'ip_permissions', ip_permissions)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"group_id={self.group_id!r}")
        parts.append(f"ip_permissions_egress={self.ip_permissions_egress!r}")
        parts.append(f"tags={self.tags!r}")
        parts.append(f"vpc_id={self.vpc_id!r}")
        parts.append(f"security_group_arn={self.security_group_arn!r}")
        parts.append(f"owner_id={self.owner_id!r}")
        parts.append(f"group_name={self.group_name!r}")
        parts.append(f"description={self.description!r}")
        parts.append(f"ip_permissions={self.ip_permissions!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('next_token', 'images')), EqPlan(fields=('next_token', 'images')), FrozenPlan(fields=("
    "'__shape__', 'next_token', 'images'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('next_toke"
    "n', 'images'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields."
    "0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coe"
    "rce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.1."
    "annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='images', annotation=Op"
    "Ref(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True"
    ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self',"
    " std_params=(), kw_only_params=('next_token', 'images'), frozen=True, slots=False, post_init_params=None, init_fns"
    "=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='next_token', kw_only=True, fn=None), ReprPlan.Field(n"
    "ame='images', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeImagesResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            next_token=self.next_token,
            images=self.images,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.next_token == other.next_token and
            self.images == other.images
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'next_token',
        'images',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'next_token',
        'images',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.next_token,
            self.images,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        images: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'next_token', next_token)
        __dataclass__object_setattr(self, 'images', images)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"next_token={self.next_token!r}")
        parts.append(f"images={self.images!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('network_interfaces', 'next_token')), EqPlan(fields=('network_interfaces', 'next_token"
    "')), FrozenPlan(fields=('__shape__', 'network_interfaces', 'next_token'), allow_dynamic_dunder_attrs=False), HashP"
    "lan(action='add', fields=('network_interfaces', 'next_token'), cache=False), InitPlan(fields=(InitPlan.Field(name="
    "'__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ne"
    "twork_interfaces', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'),"
    " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
    "_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(na"
    "me='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
    "e=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('network_interfaces', "
    "'next_token'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Re"
    "prPlan.Field(name='network_interfaces', kw_only=True, fn=None), ReprPlan.Field(name='next_token', kw_only=True, fn"
    "=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeNetworkInterfacesResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            network_interfaces=self.network_interfaces,
            next_token=self.next_token,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.network_interfaces == other.network_interfaces and
            self.next_token == other.next_token
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'network_interfaces',
        'next_token',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'network_interfaces',
        'next_token',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.network_interfaces,
            self.next_token,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        network_interfaces: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        next_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'network_interfaces', network_interfaces)
        __dataclass__object_setattr(self, 'next_token', next_token)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"network_interfaces={self.network_interfaces!r}")
        parts.append(f"next_token={self.next_token!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('route_tables', 'next_token')), EqPlan(fields=('route_tables', 'next_token')), FrozenP"
    "lan(fields=('__shape__', 'route_tables', 'next_token'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', "
    "fields=('route_tables', 'next_token'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation="
    "OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type="
    "FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='route_tables', annotation="
    "OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='next_token', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None)), self_param='self', std_params=(), kw_only_params=('route_tables', 'next_token'), frozen=True, slots=Fa"
    "lse, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='route_tables', kw"
    "_only=True, fn=None), ReprPlan.Field(name='next_token', kw_only=True, fn=None)), id=False, terse=False, default_fn"
    "=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeRouteTablesResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            route_tables=self.route_tables,
            next_token=self.next_token,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.route_tables == other.route_tables and
            self.next_token == other.next_token
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'route_tables',
        'next_token',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'route_tables',
        'next_token',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.route_tables,
            self.next_token,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        route_tables: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        next_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'route_tables', route_tables)
        __dataclass__object_setattr(self, 'next_token', next_token)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"route_tables={self.route_tables!r}")
        parts.append(f"next_token={self.next_token!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('next_token', 'subnets')), EqPlan(fields=('next_token', 'subnets')), FrozenPlan(fields"
    "=('__shape__', 'next_token', 'subnets'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('next_t"
    "oken', 'subnets'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fie"
    "lds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.field"
    "s.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnets', annotati"
    "on=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='s"
    "elf', std_params=(), kw_only_params=('next_token', 'subnets'), frozen=True, slots=False, post_init_params=None, in"
    "it_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='next_token', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='subnets', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeSubnetsResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            next_token=self.next_token,
            subnets=self.subnets,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.next_token == other.next_token and
            self.subnets == other.subnets
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'next_token',
        'subnets',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'next_token',
        'subnets',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.next_token,
            self.subnets,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        subnets: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'next_token', next_token)
        __dataclass__object_setattr(self, 'subnets', subnets)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"next_token={self.next_token!r}")
        parts.append(f"subnets={self.subnets!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('next_token', 'vpcs')), EqPlan(fields=('next_token', 'vpcs')), FrozenPlan(fields=('__s"
    "hape__', 'next_token', 'vpcs'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('next_token', 'v"
    "pcs'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annota"
    "tion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None"
    ", validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.1.annotati"
    "on'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpcs', annotation=OpRef(name='"
    "init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_param"
    "s=(), kw_only_params=('next_token', 'vpcs'), frozen=True, slots=False, post_init_params=None, init_fns=(), validat"
    "e_fns=()), ReprPlan(fields=(ReprPlan.Field(name='next_token', kw_only=True, fn=None), ReprPlan.Field(name='vpcs', "
    "kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeVpcsResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            next_token=self.next_token,
            vpcs=self.vpcs,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.next_token == other.next_token and
            self.vpcs == other.vpcs
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'next_token',
        'vpcs',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'next_token',
        'vpcs',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.next_token,
            self.vpcs,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        vpcs: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'next_token', next_token)
        __dataclass__object_setattr(self, 'vpcs', vpcs)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"next_token={self.next_token!r}")
        parts.append(f"vpcs={self.vpcs!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('architecture', 'block_device_mappings', 'client_token', 'ebs_optimized', 'ena_support"
    "', 'hypervisor', 'iam_instance_profile', 'instance_lifecycle', 'elastic_gpu_associations', 'elastic_inference_acce"
    "lerator_associations', 'network_interfaces', 'outpost_arn', 'root_device_name', 'root_device_type', 'security_grou"
    "ps', 'source_dest_check', 'spot_instance_request_id', 'sriov_net_support', 'state_reason', 'tags', 'virtualization"
    "_type', 'cpu_options', 'capacity_block_id', 'capacity_reservation_id', 'capacity_reservation_specification', 'hibe"
    "rnation_options', 'licenses', 'metadata_options', 'enclave_options', 'boot_mode', 'platform_details', 'usage_opera"
    "tion', 'usage_operation_update_time', 'private_dns_name_options', 'ipv6_address', 'tpm_support', 'maintenance_opti"
    "ons', 'current_instance_boot_mode', 'network_performance_options', 'operator', 'instance_id', 'image_id', 'state',"
    " 'private_dns_name', 'public_dns_name', 'state_transition_reason', 'key_name', 'ami_launch_index', 'product_codes'"
    ", 'instance_type', 'launch_time', 'placement', 'kernel_id', 'ramdisk_id', 'platform', 'monitoring', 'subnet_id', '"
    "vpc_id', 'private_ip_address', 'public_ip_address')), EqPlan(fields=('architecture', 'block_device_mappings', 'cli"
    "ent_token', 'ebs_optimized', 'ena_support', 'hypervisor', 'iam_instance_profile', 'instance_lifecycle', 'elastic_g"
    "pu_associations', 'elastic_inference_accelerator_associations', 'network_interfaces', 'outpost_arn', 'root_device_"
    "name', 'root_device_type', 'security_groups', 'source_dest_check', 'spot_instance_request_id', 'sriov_net_support'"
    ", 'state_reason', 'tags', 'virtualization_type', 'cpu_options', 'capacity_block_id', 'capacity_reservation_id', 'c"
    "apacity_reservation_specification', 'hibernation_options', 'licenses', 'metadata_options', 'enclave_options', 'boo"
    "t_mode', 'platform_details', 'usage_operation', 'usage_operation_update_time', 'private_dns_name_options', 'ipv6_a"
    "ddress', 'tpm_support', 'maintenance_options', 'current_instance_boot_mode', 'network_performance_options', 'opera"
    "tor', 'instance_id', 'image_id', 'state', 'private_dns_name', 'public_dns_name', 'state_transition_reason', 'key_n"
    "ame', 'ami_launch_index', 'product_codes', 'instance_type', 'launch_time', 'placement', 'kernel_id', 'ramdisk_id',"
    " 'platform', 'monitoring', 'subnet_id', 'vpc_id', 'private_ip_address', 'public_ip_address')), FrozenPlan(fields=("
    "'__shape__', 'architecture', 'block_device_mappings', 'client_token', 'ebs_optimized', 'ena_support', 'hypervisor'"
    ", 'iam_instance_profile', 'instance_lifecycle', 'elastic_gpu_associations', 'elastic_inference_accelerator_associa"
    "tions', 'network_interfaces', 'outpost_arn', 'root_device_name', 'root_device_type', 'security_groups', 'source_de"
    "st_check', 'spot_instance_request_id', 'sriov_net_support', 'state_reason', 'tags', 'virtualization_type', 'cpu_op"
    "tions', 'capacity_block_id', 'capacity_reservation_id', 'capacity_reservation_specification', 'hibernation_options"
    "', 'licenses', 'metadata_options', 'enclave_options', 'boot_mode', 'platform_details', 'usage_operation', 'usage_o"
    "peration_update_time', 'private_dns_name_options', 'ipv6_address', 'tpm_support', 'maintenance_options', 'current_"
    "instance_boot_mode', 'network_performance_options', 'operator', 'instance_id', 'image_id', 'state', 'private_dns_n"
    "ame', 'public_dns_name', 'state_transition_reason', 'key_name', 'ami_launch_index', 'product_codes', 'instance_typ"
    "e', 'launch_time', 'placement', 'kernel_id', 'ramdisk_id', 'platform', 'monitoring', 'subnet_id', 'vpc_id', 'priva"
    "te_ip_address', 'public_ip_address'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('architect"
    "ure', 'block_device_mappings', 'client_token', 'ebs_optimized', 'ena_support', 'hypervisor', 'iam_instance_profile"
    "', 'instance_lifecycle', 'elastic_gpu_associations', 'elastic_inference_accelerator_associations', 'network_interf"
    "aces', 'outpost_arn', 'root_device_name', 'root_device_type', 'security_groups', 'source_dest_check', 'spot_instan"
    "ce_request_id', 'sriov_net_support', 'state_reason', 'tags', 'virtualization_type', 'cpu_options', 'capacity_block"
    "_id', 'capacity_reservation_id', 'capacity_reservation_specification', 'hibernation_options', 'licenses', 'metadat"
    "a_options', 'enclave_options', 'boot_mode', 'platform_details', 'usage_operation', 'usage_operation_update_time', "
    "'private_dns_name_options', 'ipv6_address', 'tpm_support', 'maintenance_options', 'current_instance_boot_mode', 'n"
    "etwork_performance_options', 'operator', 'instance_id', 'image_id', 'state', 'private_dns_name', 'public_dns_name'"
    ", 'state_transition_reason', 'key_name', 'ami_launch_index', 'product_codes', 'instance_type', 'launch_time', 'pla"
    "cement', 'kernel_id', 'ramdisk_id', 'platform', 'monitoring', 'subnet_id', 'vpc_id', 'private_ip_address', 'public"
    "_ip_address'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields."
    "0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coe"
    "rce=None, validate=None, check_type=None), InitPlan.Field(name='architecture', annotation=OpRef(name='init.fields."
    "1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='block_device_mapping"
    "s', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factor"
    "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
    "itPlan.Field(name='client_token', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fiel"
    "ds.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='ebs_optimized', annotation=OpRef(name='init.fields.4.annotation')"
    ", default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
    "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_support', annotation=OpRef(nam"
    "e='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='hyper"
    "visor', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='iam_instance_profile', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(nam"
    "e='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='instance_lifecycle', annotation=OpRef(name='init.fiel"
    "ds.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, f"
    "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='elastic_gpu_assoc"
    "iations', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e), InitPlan.Field(name='elastic_inference_accelerator_associations', annotation=OpRef(name='init.fields.10.annota"
    "tion'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_type="
    "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_interfaces', annota"
    "tion=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
    "ield(name='outpost_arn', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None), InitPlan.Field(name='root_device_name', annotation=OpRef(name='init.fields.13.annotation'), d"
    "efault=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=False, field_type=FieldType"
    ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='root_device_type', annotation=OpRef("
    "name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "security_groups', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default')"
    ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='source_dest_check', annotation=OpRef(name='init.fields.16.annotation'), default"
    "=OpRef(name='init.fields.16.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
    "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='spot_instance_request_id', annotation=OpRe"
    "f(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=True"
    ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='sriov_net_support', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.18.defau"
    "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
    "check_type=None), InitPlan.Field(name='state_reason', annotation=OpRef(name='init.fields.19.annotation'), default="
    "OpRef(name='init.fields.19.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='init.fields.2"
    "0.annotation'), default=OpRef(name='init.fields.20.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='virtualization_type"
    "', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='init.fields.21.default'), default_facto"
    "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
    "nitPlan.Field(name='cpu_options', annotation=OpRef(name='init.fields.22.annotation'), default=OpRef(name='init.fie"
    "lds.22.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='capacity_block_id', annotation=OpRef(name='init.fields.23.annot"
    "ation'), default=OpRef(name='init.fields.23.default'), default_factory=None, init=True, override=False, field_type"
    "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='capacity_reservation_id', "
    "annotation=OpRef(name='init.fields.24.annotation'), default=OpRef(name='init.fields.24.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='capacity_reservation_specification', annotation=OpRef(name='init.fields.25.annotation'), default="
    "OpRef(name='init.fields.25.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='hibernation_options', annotation=OpRef(name"
    "='init.fields.26.annotation'), default=OpRef(name='init.fields.26.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='lice"
    "nses', annotation=OpRef(name='init.fields.27.annotation'), default=OpRef(name='init.fields.27.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='metadata_options', annotation=OpRef(name='init.fields.28.annotation'), default=OpRef(name="
    "'init.fields.28.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='enclave_options', annotation=OpRef(name='init.fields.2"
    "9.annotation'), default=OpRef(name='init.fields.29.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='boot_mode', annotat"
    "ion=OpRef(name='init.fields.30.annotation'), default=OpRef(name='init.fields.30.default'), default_factory=None, i"
    "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
    "eld(name='platform_details', annotation=OpRef(name='init.fields.31.annotation'), default=OpRef(name='init.fields.3"
    "1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='usage_operation', annotation=OpRef(name='init.fields.32.annotation')"
    ", default=OpRef(name='init.fields.32.default'), default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='usage_operation_update_time', ann"
    "otation=OpRef(name='init.fields.33.annotation'), default=OpRef(name='init.fields.33.default'), default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
    "n.Field(name='private_dns_name_options', annotation=OpRef(name='init.fields.34.annotation'), default=OpRef(name='i"
    "nit.fields.34.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
    "ne, validate=None, check_type=None), InitPlan.Field(name='ipv6_address', annotation=OpRef(name='init.fields.35.ann"
    "otation'), default=OpRef(name='init.fields.35.default'), default_factory=None, init=True, override=False, field_ty"
    "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tpm_support', annotation"
    "=OpRef(name='init.fields.36.annotation'), default=OpRef(name='init.fields.36.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='maintenance_options', annotation=OpRef(name='init.fields.37.annotation'), default=OpRef(name='init.fields.3"
    "7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='current_instance_boot_mode', annotation=OpRef(name='init.fields.38.a"
    "nnotation'), default=OpRef(name='init.fields.38.default'), default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_performance_op"
    "tions', annotation=OpRef(name='init.fields.39.annotation'), default=OpRef(name='init.fields.39.default'), default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e), InitPlan.Field(name='operator', annotation=OpRef(name='init.fields.40.annotation'), default=OpRef(name='init.f"
    "ields.40.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None), InitPlan.Field(name='instance_id', annotation=OpRef(name='init.fields.41.annotatio"
    "n'), default=OpRef(name='init.fields.41.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='image_id', annotation=OpRef(na"
    "me='init.fields.42.annotation'), default=OpRef(name='init.fields.42.default'), default_factory=None, init=True, ov"
    "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='st"
    "ate', annotation=OpRef(name='init.fields.43.annotation'), default=OpRef(name='init.fields.43.default'), default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='private_dns_name', annotation=OpRef(name='init.fields.44.annotation'), default=OpRef(name='"
    "init.fields.44.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
    "one, validate=None, check_type=None), InitPlan.Field(name='public_dns_name', annotation=OpRef(name='init.fields.45"
    ".annotation'), default=OpRef(name='init.fields.45.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state_transition_rea"
    "son', annotation=OpRef(name='init.fields.46.annotation'), default=OpRef(name='init.fields.46.default'), default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='key_name', annotation=OpRef(name='init.fields.47.annotation'), default=OpRef(name='init.fie"
    "lds.47.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='ami_launch_index', annotation=OpRef(name='init.fields.48.annota"
    "tion'), default=OpRef(name='init.fields.48.default'), default_factory=None, init=True, override=False, field_type="
    "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='product_codes', annotation="
    "OpRef(name='init.fields.49.annotation'), default=OpRef(name='init.fields.49.default'), default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='instance_type', annotation=OpRef(name='init.fields.50.annotation'), default=OpRef(name='init.fields.50.defau"
    "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
    "check_type=None), InitPlan.Field(name='launch_time', annotation=OpRef(name='init.fields.51.annotation'), default=O"
    "pRef(name='init.fields.51.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
    "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='placement', annotation=OpRef(name='init.fiel"
    "ds.52.annotation'), default=OpRef(name='init.fields.52.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='kernel_id', ann"
    "otation=OpRef(name='init.fields.53.annotation'), default=OpRef(name='init.fields.53.default'), default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
    "n.Field(name='ramdisk_id', annotation=OpRef(name='init.fields.54.annotation'), default=OpRef(name='init.fields.54."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='platform', annotation=OpRef(name='init.fields.55.annotation'), default"
    "=OpRef(name='init.fields.55.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
    "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='monitoring', annotation=OpRef(name='init.f"
    "ields.56.annotation'), default=OpRef(name='init.fields.56.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnet_id', "
    "annotation=OpRef(name='init.fields.57.annotation'), default=OpRef(name='init.fields.57.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='vpc_id', annotation=OpRef(name='init.fields.58.annotation'), default=OpRef(name='init.fields.58.d"
    "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
    "ne, check_type=None), InitPlan.Field(name='private_ip_address', annotation=OpRef(name='init.fields.59.annotation')"
    ", default=OpRef(name='init.fields.59.default'), default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_ip_address', annotation=Op"
    "Ref(name='init.fields.60.annotation'), default=OpRef(name='init.fields.60.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self"
    "', std_params=(), kw_only_params=('architecture', 'block_device_mappings', 'client_token', 'ebs_optimized', 'ena_s"
    "upport', 'hypervisor', 'iam_instance_profile', 'instance_lifecycle', 'elastic_gpu_associations', 'elastic_inferenc"
    "e_accelerator_associations', 'network_interfaces', 'outpost_arn', 'root_device_name', 'root_device_type', 'securit"
    "y_groups', 'source_dest_check', 'spot_instance_request_id', 'sriov_net_support', 'state_reason', 'tags', 'virtuali"
    "zation_type', 'cpu_options', 'capacity_block_id', 'capacity_reservation_id', 'capacity_reservation_specification',"
    " 'hibernation_options', 'licenses', 'metadata_options', 'enclave_options', 'boot_mode', 'platform_details', 'usage"
    "_operation', 'usage_operation_update_time', 'private_dns_name_options', 'ipv6_address', 'tpm_support', 'maintenanc"
    "e_options', 'current_instance_boot_mode', 'network_performance_options', 'operator', 'instance_id', 'image_id', 's"
    "tate', 'private_dns_name', 'public_dns_name', 'state_transition_reason', 'key_name', 'ami_launch_index', 'product_"
    "codes', 'instance_type', 'launch_time', 'placement', 'kernel_id', 'ramdisk_id', 'platform', 'monitoring', 'subnet_"
    "id', 'vpc_id', 'private_ip_address', 'public_ip_address'), frozen=True, slots=False, post_init_params=None, init_f"
    "ns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='architecture', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='block_device_mappings', kw_only=True, fn=None), ReprPlan.Field(name='client_token', kw_only=True, fn=None"
    "), ReprPlan.Field(name='ebs_optimized', kw_only=True, fn=None), ReprPlan.Field(name='ena_support', kw_only=True, f"
    "n=None), ReprPlan.Field(name='hypervisor', kw_only=True, fn=None), ReprPlan.Field(name='iam_instance_profile', kw_"
    "only=True, fn=None), ReprPlan.Field(name='instance_lifecycle', kw_only=True, fn=None), ReprPlan.Field(name='elasti"
    "c_gpu_associations', kw_only=True, fn=None), ReprPlan.Field(name='elastic_inference_accelerator_associations', kw_"
    "only=True, fn=None), ReprPlan.Field(name='network_interfaces', kw_only=True, fn=None), ReprPlan.Field(name='outpos"
    "t_arn', kw_only=True, fn=None), ReprPlan.Field(name='root_device_name', kw_only=True, fn=None), ReprPlan.Field(nam"
    "e='root_device_type', kw_only=True, fn=None), ReprPlan.Field(name='security_groups', kw_only=True, fn=None), ReprP"
    "lan.Field(name='source_dest_check', kw_only=True, fn=None), ReprPlan.Field(name='spot_instance_request_id', kw_onl"
    "y=True, fn=None), ReprPlan.Field(name='sriov_net_support', kw_only=True, fn=None), ReprPlan.Field(name='state_reas"
    "on', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=True, fn=None), ReprPlan.Field(name='virtualizati"
    "on_type', kw_only=True, fn=None), ReprPlan.Field(name='cpu_options', kw_only=True, fn=None), ReprPlan.Field(name='"
    "capacity_block_id', kw_only=True, fn=None), ReprPlan.Field(name='capacity_reservation_id', kw_only=True, fn=None),"
    " ReprPlan.Field(name='capacity_reservation_specification', kw_only=True, fn=None), ReprPlan.Field(name='hibernatio"
    "n_options', kw_only=True, fn=None), ReprPlan.Field(name='licenses', kw_only=True, fn=None), ReprPlan.Field(name='m"
    "etadata_options', kw_only=True, fn=None), ReprPlan.Field(name='enclave_options', kw_only=True, fn=None), ReprPlan."
    "Field(name='boot_mode', kw_only=True, fn=None), ReprPlan.Field(name='platform_details', kw_only=True, fn=None), Re"
    "prPlan.Field(name='usage_operation', kw_only=True, fn=None), ReprPlan.Field(name='usage_operation_update_time', kw"
    "_only=True, fn=None), ReprPlan.Field(name='private_dns_name_options', kw_only=True, fn=None), ReprPlan.Field(name="
    "'ipv6_address', kw_only=True, fn=None), ReprPlan.Field(name='tpm_support', kw_only=True, fn=None), ReprPlan.Field("
    "name='maintenance_options', kw_only=True, fn=None), ReprPlan.Field(name='current_instance_boot_mode', kw_only=True"
    ", fn=None), ReprPlan.Field(name='network_performance_options', kw_only=True, fn=None), ReprPlan.Field(name='operat"
    "or', kw_only=True, fn=None), ReprPlan.Field(name='instance_id', kw_only=True, fn=None), ReprPlan.Field(name='image"
    "_id', kw_only=True, fn=None), ReprPlan.Field(name='state', kw_only=True, fn=None), ReprPlan.Field(name='private_dn"
    "s_name', kw_only=True, fn=None), ReprPlan.Field(name='public_dns_name', kw_only=True, fn=None), ReprPlan.Field(nam"
    "e='state_transition_reason', kw_only=True, fn=None), ReprPlan.Field(name='key_name', kw_only=True, fn=None), ReprP"
    "lan.Field(name='ami_launch_index', kw_only=True, fn=None), ReprPlan.Field(name='product_codes', kw_only=True, fn=N"
    "one), ReprPlan.Field(name='instance_type', kw_only=True, fn=None), ReprPlan.Field(name='launch_time', kw_only=True"
    ", fn=None), ReprPlan.Field(name='placement', kw_only=True, fn=None), ReprPlan.Field(name='kernel_id', kw_only=True"
    ", fn=None), ReprPlan.Field(name='ramdisk_id', kw_only=True, fn=None), ReprPlan.Field(name='platform', kw_only=True"
    ", fn=None), ReprPlan.Field(name='monitoring', kw_only=True, fn=None), ReprPlan.Field(name='subnet_id', kw_only=Tru"
    "e, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_address', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='public_ip_address', kw_only=True, fn=None)), id=False, terse=False, defaul"
    "t_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fInstance(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__21__annotation,
    __dataclass__init__fields__21__default,
    __dataclass__init__fields__22__annotation,
    __dataclass__init__fields__22__default,
    __dataclass__init__fields__23__annotation,
    __dataclass__init__fields__23__default,
    __dataclass__init__fields__24__annotation,
    __dataclass__init__fields__24__default,
    __dataclass__init__fields__25__annotation,
    __dataclass__init__fields__25__default,
    __dataclass__init__fields__26__annotation,
    __dataclass__init__fields__26__default,
    __dataclass__init__fields__27__annotation,
    __dataclass__init__fields__27__default,
    __dataclass__init__fields__28__annotation,
    __dataclass__init__fields__28__default,
    __dataclass__init__fields__29__annotation,
    __dataclass__init__fields__29__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__30__annotation,
    __dataclass__init__fields__30__default,
    __dataclass__init__fields__31__annotation,
    __dataclass__init__fields__31__default,
    __dataclass__init__fields__32__annotation,
    __dataclass__init__fields__32__default,
    __dataclass__init__fields__33__annotation,
    __dataclass__init__fields__33__default,
    __dataclass__init__fields__34__annotation,
    __dataclass__init__fields__34__default,
    __dataclass__init__fields__35__annotation,
    __dataclass__init__fields__35__default,
    __dataclass__init__fields__36__annotation,
    __dataclass__init__fields__36__default,
    __dataclass__init__fields__37__annotation,
    __dataclass__init__fields__37__default,
    __dataclass__init__fields__38__annotation,
    __dataclass__init__fields__38__default,
    __dataclass__init__fields__39__annotation,
    __dataclass__init__fields__39__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__40__annotation,
    __dataclass__init__fields__40__default,
    __dataclass__init__fields__41__annotation,
    __dataclass__init__fields__41__default,
    __dataclass__init__fields__42__annotation,
    __dataclass__init__fields__42__default,
    __dataclass__init__fields__43__annotation,
    __dataclass__init__fields__43__default,
    __dataclass__init__fields__44__annotation,
    __dataclass__init__fields__44__default,
    __dataclass__init__fields__45__annotation,
    __dataclass__init__fields__45__default,
    __dataclass__init__fields__46__annotation,
    __dataclass__init__fields__46__default,
    __dataclass__init__fields__47__annotation,
    __dataclass__init__fields__47__default,
    __dataclass__init__fields__48__annotation,
    __dataclass__init__fields__48__default,
    __dataclass__init__fields__49__annotation,
    __dataclass__init__fields__49__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__50__annotation,
    __dataclass__init__fields__50__default,
    __dataclass__init__fields__51__annotation,
    __dataclass__init__fields__51__default,
    __dataclass__init__fields__52__annotation,
    __dataclass__init__fields__52__default,
    __dataclass__init__fields__53__annotation,
    __dataclass__init__fields__53__default,
    __dataclass__init__fields__54__annotation,
    __dataclass__init__fields__54__default,
    __dataclass__init__fields__55__annotation,
    __dataclass__init__fields__55__default,
    __dataclass__init__fields__56__annotation,
    __dataclass__init__fields__56__default,
    __dataclass__init__fields__57__annotation,
    __dataclass__init__fields__57__default,
    __dataclass__init__fields__58__annotation,
    __dataclass__init__fields__58__default,
    __dataclass__init__fields__59__annotation,
    __dataclass__init__fields__59__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__60__annotation,
    __dataclass__init__fields__60__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            architecture=self.architecture,
            block_device_mappings=self.block_device_mappings,
            client_token=self.client_token,
            ebs_optimized=self.ebs_optimized,
            ena_support=self.ena_support,
            hypervisor=self.hypervisor,
            iam_instance_profile=self.iam_instance_profile,
            instance_lifecycle=self.instance_lifecycle,
            elastic_gpu_associations=self.elastic_gpu_associations,
            elastic_inference_accelerator_associations=self.elastic_inference_accelerator_associations,
            network_interfaces=self.network_interfaces,
            outpost_arn=self.outpost_arn,
            root_device_name=self.root_device_name,
            root_device_type=self.root_device_type,
            security_groups=self.security_groups,
            source_dest_check=self.source_dest_check,
            spot_instance_request_id=self.spot_instance_request_id,
            sriov_net_support=self.sriov_net_support,
            state_reason=self.state_reason,
            tags=self.tags,
            virtualization_type=self.virtualization_type,
            cpu_options=self.cpu_options,
            capacity_block_id=self.capacity_block_id,
            capacity_reservation_id=self.capacity_reservation_id,
            capacity_reservation_specification=self.capacity_reservation_specification,
            hibernation_options=self.hibernation_options,
            licenses=self.licenses,
            metadata_options=self.metadata_options,
            enclave_options=self.enclave_options,
            boot_mode=self.boot_mode,
            platform_details=self.platform_details,
            usage_operation=self.usage_operation,
            usage_operation_update_time=self.usage_operation_update_time,
            private_dns_name_options=self.private_dns_name_options,
            ipv6_address=self.ipv6_address,
            tpm_support=self.tpm_support,
            maintenance_options=self.maintenance_options,
            current_instance_boot_mode=self.current_instance_boot_mode,
            network_performance_options=self.network_performance_options,
            operator=self.operator,
            instance_id=self.instance_id,
            image_id=self.image_id,
            state=self.state,
            private_dns_name=self.private_dns_name,
            public_dns_name=self.public_dns_name,
            state_transition_reason=self.state_transition_reason,
            key_name=self.key_name,
            ami_launch_index=self.ami_launch_index,
            product_codes=self.product_codes,
            instance_type=self.instance_type,
            launch_time=self.launch_time,
            placement=self.placement,
            kernel_id=self.kernel_id,
            ramdisk_id=self.ramdisk_id,
            platform=self.platform,
            monitoring=self.monitoring,
            subnet_id=self.subnet_id,
            vpc_id=self.vpc_id,
            private_ip_address=self.private_ip_address,
            public_ip_address=self.public_ip_address,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.architecture == other.architecture and
            self.block_device_mappings == other.block_device_mappings and
            self.client_token == other.client_token and
            self.ebs_optimized == other.ebs_optimized and
            self.ena_support == other.ena_support and
            self.hypervisor == other.hypervisor and
            self.iam_instance_profile == other.iam_instance_profile and
            self.instance_lifecycle == other.instance_lifecycle and
            self.elastic_gpu_associations == other.elastic_gpu_associations and
            self.elastic_inference_accelerator_associations == other.elastic_inference_accelerator_associations and
            self.network_interfaces == other.network_interfaces and
            self.outpost_arn == other.outpost_arn and
            self.root_device_name == other.root_device_name and
            self.root_device_type == other.root_device_type and
            self.security_groups == other.security_groups and
            self.source_dest_check == other.source_dest_check and
            self.spot_instance_request_id == other.spot_instance_request_id and
            self.sriov_net_support == other.sriov_net_support and
            self.state_reason == other.state_reason and
            self.tags == other.tags and
            self.virtualization_type == other.virtualization_type and
            self.cpu_options == other.cpu_options and
            self.capacity_block_id == other.capacity_block_id and
            self.capacity_reservation_id == other.capacity_reservation_id and
            self.capacity_reservation_specification == other.capacity_reservation_specification and
            self.hibernation_options == other.hibernation_options and
            self.licenses == other.licenses and
            self.metadata_options == other.metadata_options and
            self.enclave_options == other.enclave_options and
            self.boot_mode == other.boot_mode and
            self.platform_details == other.platform_details and
            self.usage_operation == other.usage_operation and
            self.usage_operation_update_time == other.usage_operation_update_time and
            self.private_dns_name_options == other.private_dns_name_options and
            self.ipv6_address == other.ipv6_address and
            self.tpm_support == other.tpm_support and
            self.maintenance_options == other.maintenance_options and
            self.current_instance_boot_mode == other.current_instance_boot_mode and
            self.network_performance_options == other.network_performance_options and
            self.operator == other.operator and
            self.instance_id == other.instance_id and
            self.image_id == other.image_id and
            self.state == other.state and
            self.private_dns_name == other.private_dns_name and
            self.public_dns_name == other.public_dns_name and
            self.state_transition_reason == other.state_transition_reason and
            self.key_name == other.key_name and
            self.ami_launch_index == other.ami_launch_index and
            self.product_codes == other.product_codes and
            self.instance_type == other.instance_type and
            self.launch_time == other.launch_time and
            self.placement == other.placement and
            self.kernel_id == other.kernel_id and
            self.ramdisk_id == other.ramdisk_id and
            self.platform == other.platform and
            self.monitoring == other.monitoring and
            self.subnet_id == other.subnet_id and
            self.vpc_id == other.vpc_id and
            self.private_ip_address == other.private_ip_address and
            self.public_ip_address == other.public_ip_address
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'architecture',
        'block_device_mappings',
        'client_token',
        'ebs_optimized',
        'ena_support',
        'hypervisor',
        'iam_instance_profile',
        'instance_lifecycle',
        'elastic_gpu_associations',
        'elastic_inference_accelerator_associations',
        'network_interfaces',
        'outpost_arn',
        'root_device_name',
        'root_device_type',
        'security_groups',
        'source_dest_check',
        'spot_instance_request_id',
        'sriov_net_support',
        'state_reason',
        'tags',
        'virtualization_type',
        'cpu_options',
        'capacity_block_id',
        'capacity_reservation_id',
        'capacity_reservation_specification',
        'hibernation_options',
        'licenses',
        'metadata_options',
        'enclave_options',
        'boot_mode',
        'platform_details',
        'usage_operation',
        'usage_operation_update_time',
        'private_dns_name_options',
        'ipv6_address',
        'tpm_support',
        'maintenance_options',
        'current_instance_boot_mode',
        'network_performance_options',
        'operator',
        'instance_id',
        'image_id',
        'state',
        'private_dns_name',
        'public_dns_name',
        'state_transition_reason',
        'key_name',
        'ami_launch_index',
        'product_codes',
        'instance_type',
        'launch_time',
        'placement',
        'kernel_id',
        'ramdisk_id',
        'platform',
        'monitoring',
        'subnet_id',
        'vpc_id',
        'private_ip_address',
        'public_ip_address',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'architecture',
        'block_device_mappings',
        'client_token',
        'ebs_optimized',
        'ena_support',
        'hypervisor',
        'iam_instance_profile',
        'instance_lifecycle',
        'elastic_gpu_associations',
        'elastic_inference_accelerator_associations',
        'network_interfaces',
        'outpost_arn',
        'root_device_name',
        'root_device_type',
        'security_groups',
        'source_dest_check',
        'spot_instance_request_id',
        'sriov_net_support',
        'state_reason',
        'tags',
        'virtualization_type',
        'cpu_options',
        'capacity_block_id',
        'capacity_reservation_id',
        'capacity_reservation_specification',
        'hibernation_options',
        'licenses',
        'metadata_options',
        'enclave_options',
        'boot_mode',
        'platform_details',
        'usage_operation',
        'usage_operation_update_time',
        'private_dns_name_options',
        'ipv6_address',
        'tpm_support',
        'maintenance_options',
        'current_instance_boot_mode',
        'network_performance_options',
        'operator',
        'instance_id',
        'image_id',
        'state',
        'private_dns_name',
        'public_dns_name',
        'state_transition_reason',
        'key_name',
        'ami_launch_index',
        'product_codes',
        'instance_type',
        'launch_time',
        'placement',
        'kernel_id',
        'ramdisk_id',
        'platform',
        'monitoring',
        'subnet_id',
        'vpc_id',
        'private_ip_address',
        'public_ip_address',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.architecture,
            self.block_device_mappings,
            self.client_token,
            self.ebs_optimized,
            self.ena_support,
            self.hypervisor,
            self.iam_instance_profile,
            self.instance_lifecycle,
            self.elastic_gpu_associations,
            self.elastic_inference_accelerator_associations,
            self.network_interfaces,
            self.outpost_arn,
            self.root_device_name,
            self.root_device_type,
            self.security_groups,
            self.source_dest_check,
            self.spot_instance_request_id,
            self.sriov_net_support,
            self.state_reason,
            self.tags,
            self.virtualization_type,
            self.cpu_options,
            self.capacity_block_id,
            self.capacity_reservation_id,
            self.capacity_reservation_specification,
            self.hibernation_options,
            self.licenses,
            self.metadata_options,
            self.enclave_options,
            self.boot_mode,
            self.platform_details,
            self.usage_operation,
            self.usage_operation_update_time,
            self.private_dns_name_options,
            self.ipv6_address,
            self.tpm_support,
            self.maintenance_options,
            self.current_instance_boot_mode,
            self.network_performance_options,
            self.operator,
            self.instance_id,
            self.image_id,
            self.state,
            self.private_dns_name,
            self.public_dns_name,
            self.state_transition_reason,
            self.key_name,
            self.ami_launch_index,
            self.product_codes,
            self.instance_type,
            self.launch_time,
            self.placement,
            self.kernel_id,
            self.ramdisk_id,
            self.platform,
            self.monitoring,
            self.subnet_id,
            self.vpc_id,
            self.private_ip_address,
            self.public_ip_address,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        architecture: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        block_device_mappings: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        client_token: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ebs_optimized: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ena_support: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        hypervisor: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        iam_instance_profile: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        instance_lifecycle: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        elastic_gpu_associations: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        elastic_inference_accelerator_associations: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        network_interfaces: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        outpost_arn: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        root_device_name: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        root_device_type: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        security_groups: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        source_dest_check: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        spot_instance_request_id: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        sriov_net_support: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        state_reason: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        tags: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        virtualization_type: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
        cpu_options: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
        capacity_block_id: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
        capacity_reservation_id: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
        capacity_reservation_specification: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
        hibernation_options: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
        licenses: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
        metadata_options: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
        enclave_options: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
        boot_mode: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
        platform_details: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
        usage_operation: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
        usage_operation_update_time: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
        private_dns_name_options: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
        ipv6_address: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
        tpm_support: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
        maintenance_options: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
        current_instance_boot_mode: __dataclass__init__fields__38__annotation = __dataclass__init__fields__38__default,
        network_performance_options: __dataclass__init__fields__39__annotation = __dataclass__init__fields__39__default,
        operator: __dataclass__init__fields__40__annotation = __dataclass__init__fields__40__default,
        instance_id: __dataclass__init__fields__41__annotation = __dataclass__init__fields__41__default,
        image_id: __dataclass__init__fields__42__annotation = __dataclass__init__fields__42__default,
        state: __dataclass__init__fields__43__annotation = __dataclass__init__fields__43__default,
        private_dns_name: __dataclass__init__fields__44__annotation = __dataclass__init__fields__44__default,
        public_dns_name: __dataclass__init__fields__45__annotation = __dataclass__init__fields__45__default,
        state_transition_reason: __dataclass__init__fields__46__annotation = __dataclass__init__fields__46__default,
        key_name: __dataclass__init__fields__47__annotation = __dataclass__init__fields__47__default,
        ami_launch_index: __dataclass__init__fields__48__annotation = __dataclass__init__fields__48__default,
        product_codes: __dataclass__init__fields__49__annotation = __dataclass__init__fields__49__default,
        instance_type: __dataclass__init__fields__50__annotation = __dataclass__init__fields__50__default,
        launch_time: __dataclass__init__fields__51__annotation = __dataclass__init__fields__51__default,
        placement: __dataclass__init__fields__52__annotation = __dataclass__init__fields__52__default,
        kernel_id: __dataclass__init__fields__53__annotation = __dataclass__init__fields__53__default,
        ramdisk_id: __dataclass__init__fields__54__annotation = __dataclass__init__fields__54__default,
        platform: __dataclass__init__fields__55__annotation = __dataclass__init__fields__55__default,
        monitoring: __dataclass__init__fields__56__annotation = __dataclass__init__fields__56__default,
        subnet_id: __dataclass__init__fields__57__annotation = __dataclass__init__fields__57__default,
        vpc_id: __dataclass__init__fields__58__annotation = __dataclass__init__fields__58__default,
        private_ip_address: __dataclass__init__fields__59__annotation = __dataclass__init__fields__59__default,
        public_ip_address: __dataclass__init__fields__60__annotation = __dataclass__init__fields__60__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'architecture', architecture)
        __dataclass__object_setattr(self, 'block_device_mappings', block_device_mappings)
        __dataclass__object_setattr(self, 'client_token', client_token)
        __dataclass__object_setattr(self, 'ebs_optimized', ebs_optimized)
        __dataclass__object_setattr(self, 'ena_support', ena_support)
        __dataclass__object_setattr(self, 'hypervisor', hypervisor)
        __dataclass__object_setattr(self, 'iam_instance_profile', iam_instance_profile)
        __dataclass__object_setattr(self, 'instance_lifecycle', instance_lifecycle)
        __dataclass__object_setattr(self, 'elastic_gpu_associations', elastic_gpu_associations)
        __dataclass__object_setattr(self, 'elastic_inference_accelerator_associations', elastic_inference_accelerator_associations)
        __dataclass__object_setattr(self, 'network_interfaces', network_interfaces)
        __dataclass__object_setattr(self, 'outpost_arn', outpost_arn)
        __dataclass__object_setattr(self, 'root_device_name', root_device_name)
        __dataclass__object_setattr(self, 'root_device_type', root_device_type)
        __dataclass__object_setattr(self, 'security_groups', security_groups)
        __dataclass__object_setattr(self, 'source_dest_check', source_dest_check)
        __dataclass__object_setattr(self, 'spot_instance_request_id', spot_instance_request_id)
        __dataclass__object_setattr(self, 'sriov_net_support', sriov_net_support)
        __dataclass__object_setattr(self, 'state_reason', state_reason)
        __dataclass__object_setattr(self, 'tags', tags)
        __dataclass__object_setattr(self, 'virtualization_type', virtualization_type)
        __dataclass__object_setattr(self, 'cpu_options', cpu_options)
        __dataclass__object_setattr(self, 'capacity_block_id', capacity_block_id)
        __dataclass__object_setattr(self, 'capacity_reservation_id', capacity_reservation_id)
        __dataclass__object_setattr(self, 'capacity_reservation_specification', capacity_reservation_specification)
        __dataclass__object_setattr(self, 'hibernation_options', hibernation_options)
        __dataclass__object_setattr(self, 'licenses', licenses)
        __dataclass__object_setattr(self, 'metadata_options', metadata_options)
        __dataclass__object_setattr(self, 'enclave_options', enclave_options)
        __dataclass__object_setattr(self, 'boot_mode', boot_mode)
        __dataclass__object_setattr(self, 'platform_details', platform_details)
        __dataclass__object_setattr(self, 'usage_operation', usage_operation)
        __dataclass__object_setattr(self, 'usage_operation_update_time', usage_operation_update_time)
        __dataclass__object_setattr(self, 'private_dns_name_options', private_dns_name_options)
        __dataclass__object_setattr(self, 'ipv6_address', ipv6_address)
        __dataclass__object_setattr(self, 'tpm_support', tpm_support)
        __dataclass__object_setattr(self, 'maintenance_options', maintenance_options)
        __dataclass__object_setattr(self, 'current_instance_boot_mode', current_instance_boot_mode)
        __dataclass__object_setattr(self, 'network_performance_options', network_performance_options)
        __dataclass__object_setattr(self, 'operator', operator)
        __dataclass__object_setattr(self, 'instance_id', instance_id)
        __dataclass__object_setattr(self, 'image_id', image_id)
        __dataclass__object_setattr(self, 'state', state)
        __dataclass__object_setattr(self, 'private_dns_name', private_dns_name)
        __dataclass__object_setattr(self, 'public_dns_name', public_dns_name)
        __dataclass__object_setattr(self, 'state_transition_reason', state_transition_reason)
        __dataclass__object_setattr(self, 'key_name', key_name)
        __dataclass__object_setattr(self, 'ami_launch_index', ami_launch_index)
        __dataclass__object_setattr(self, 'product_codes', product_codes)
        __dataclass__object_setattr(self, 'instance_type', instance_type)
        __dataclass__object_setattr(self, 'launch_time', launch_time)
        __dataclass__object_setattr(self, 'placement', placement)
        __dataclass__object_setattr(self, 'kernel_id', kernel_id)
        __dataclass__object_setattr(self, 'ramdisk_id', ramdisk_id)
        __dataclass__object_setattr(self, 'platform', platform)
        __dataclass__object_setattr(self, 'monitoring', monitoring)
        __dataclass__object_setattr(self, 'subnet_id', subnet_id)
        __dataclass__object_setattr(self, 'vpc_id', vpc_id)
        __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)
        __dataclass__object_setattr(self, 'public_ip_address', public_ip_address)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"architecture={self.architecture!r}")
        parts.append(f"block_device_mappings={self.block_device_mappings!r}")
        parts.append(f"client_token={self.client_token!r}")
        parts.append(f"ebs_optimized={self.ebs_optimized!r}")
        parts.append(f"ena_support={self.ena_support!r}")
        parts.append(f"hypervisor={self.hypervisor!r}")
        parts.append(f"iam_instance_profile={self.iam_instance_profile!r}")
        parts.append(f"instance_lifecycle={self.instance_lifecycle!r}")
        parts.append(f"elastic_gpu_associations={self.elastic_gpu_associations!r}")
        parts.append(f"elastic_inference_accelerator_associations={self.elastic_inference_accelerator_associations!r}")
        parts.append(f"network_interfaces={self.network_interfaces!r}")
        parts.append(f"outpost_arn={self.outpost_arn!r}")
        parts.append(f"root_device_name={self.root_device_name!r}")
        parts.append(f"root_device_type={self.root_device_type!r}")
        parts.append(f"security_groups={self.security_groups!r}")
        parts.append(f"source_dest_check={self.source_dest_check!r}")
        parts.append(f"spot_instance_request_id={self.spot_instance_request_id!r}")
        parts.append(f"sriov_net_support={self.sriov_net_support!r}")
        parts.append(f"state_reason={self.state_reason!r}")
        parts.append(f"tags={self.tags!r}")
        parts.append(f"virtualization_type={self.virtualization_type!r}")
        parts.append(f"cpu_options={self.cpu_options!r}")
        parts.append(f"capacity_block_id={self.capacity_block_id!r}")
        parts.append(f"capacity_reservation_id={self.capacity_reservation_id!r}")
        parts.append(f"capacity_reservation_specification={self.capacity_reservation_specification!r}")
        parts.append(f"hibernation_options={self.hibernation_options!r}")
        parts.append(f"licenses={self.licenses!r}")
        parts.append(f"metadata_options={self.metadata_options!r}")
        parts.append(f"enclave_options={self.enclave_options!r}")
        parts.append(f"boot_mode={self.boot_mode!r}")
        parts.append(f"platform_details={self.platform_details!r}")
        parts.append(f"usage_operation={self.usage_operation!r}")
        parts.append(f"usage_operation_update_time={self.usage_operation_update_time!r}")
        parts.append(f"private_dns_name_options={self.private_dns_name_options!r}")
        parts.append(f"ipv6_address={self.ipv6_address!r}")
        parts.append(f"tpm_support={self.tpm_support!r}")
        parts.append(f"maintenance_options={self.maintenance_options!r}")
        parts.append(f"current_instance_boot_mode={self.current_instance_boot_mode!r}")
        parts.append(f"network_performance_options={self.network_performance_options!r}")
        parts.append(f"operator={self.operator!r}")
        parts.append(f"instance_id={self.instance_id!r}")
        parts.append(f"image_id={self.image_id!r}")
        parts.append(f"state={self.state!r}")
        parts.append(f"private_dns_name={self.private_dns_name!r}")
        parts.append(f"public_dns_name={self.public_dns_name!r}")
        parts.append(f"state_transition_reason={self.state_transition_reason!r}")
        parts.append(f"key_name={self.key_name!r}")
        parts.append(f"ami_launch_index={self.ami_launch_index!r}")
        parts.append(f"product_codes={self.product_codes!r}")
        parts.append(f"instance_type={self.instance_type!r}")
        parts.append(f"launch_time={self.launch_time!r}")
        parts.append(f"placement={self.placement!r}")
        parts.append(f"kernel_id={self.kernel_id!r}")
        parts.append(f"ramdisk_id={self.ramdisk_id!r}")
        parts.append(f"platform={self.platform!r}")
        parts.append(f"monitoring={self.monitoring!r}")
        parts.append(f"subnet_id={self.subnet_id!r}")
        parts.append(f"vpc_id={self.vpc_id!r}")
        parts.append(f"private_ip_address={self.private_ip_address!r}")
        parts.append(f"public_ip_address={self.public_ip_address!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('instance_types', 'next_token')), EqPlan(fields=('instance_types', 'next_token')), Fro"
    "zenPlan(fields=('__shape__', 'instance_types', 'next_token'), allow_dynamic_dunder_attrs=False), HashPlan(action='"
    "add', fields=('instance_types', 'next_token'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', ann"
    "otation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_types', a"
    "nnotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
    "n.Field(name='next_token', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None)), self_param='self', std_params=(), kw_only_params=('instance_types', 'next_token'), frozen=Tr"
    "ue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='insta"
    "nce_types', kw_only=True, fn=None), ReprPlan.Field(name='next_token', kw_only=True, fn=None)), id=False, terse=Fal"
    "se, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeInstanceTypesResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            instance_types=self.instance_types,
            next_token=self.next_token,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.instance_types == other.instance_types and
            self.next_token == other.next_token
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'instance_types',
        'next_token',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'instance_types',
        'next_token',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.instance_types,
            self.next_token,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        instance_types: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        next_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'instance_types', instance_types)
        __dataclass__object_setattr(self, 'next_token', next_token)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"instance_types={self.instance_types!r}")
        parts.append(f"next_token={self.next_token!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('next_token', 'security_groups')), EqPlan(fields=('next_token', 'security_groups')), F"
    "rozenPlan(fields=('__shape__', 'next_token', 'security_groups'), allow_dynamic_dunder_attrs=False), HashPlan(actio"
    "n='add', fields=('next_token', 'security_groups'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__',"
    " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False,"
    " field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', a"
    "nnotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
    "n.Field(name='security_groups', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields"
    ".2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('next_token', 'security_groups'), fro"
    "zen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name="
    "'next_token', kw_only=True, fn=None), ReprPlan.Field(name='security_groups', kw_only=True, fn=None)), id=False, te"
    "rse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeSecurityGroupsResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            next_token=self.next_token,
            security_groups=self.security_groups,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.next_token == other.next_token and
            self.security_groups == other.security_groups
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'next_token',
        'security_groups',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'next_token',
        'security_groups',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.next_token,
            self.security_groups,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        security_groups: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'next_token', next_token)
        __dataclass__object_setattr(self, 'security_groups', security_groups)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"next_token={self.next_token!r}")
        parts.append(f"security_groups={self.security_groups!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('reservation_id', 'owner_id', 'requester_id', 'groups', 'instances')), EqPlan(fields=("
    "'reservation_id', 'owner_id', 'requester_id', 'groups', 'instances')), FrozenPlan(fields=('__shape__', 'reservatio"
    "n_id', 'owner_id', 'requester_id', 'groups', 'instances'), allow_dynamic_dunder_attrs=False), HashPlan(action='add"
    "', fields=('reservation_id', 'owner_id', 'requester_id', 'groups', 'instances'), cache=False), InitPlan(fields=(In"
    "itPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitP"
    "lan.Field(name='reservation_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.field"
    "s.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='owner_id', annotation=OpRef(name='init.fields.2.annotation'), defa"
    "ult=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
    "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='requester_id', annotation=OpRef(name='in"
    "it.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='groups', a"
    "nnotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
    "n.Field(name='instances', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
    ", check_type=None)), self_param='self', std_params=(), kw_only_params=('reservation_id', 'owner_id', 'requester_id"
    "', 'groups', 'instances'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPla"
    "n(fields=(ReprPlan.Field(name='reservation_id', kw_only=True, fn=None), ReprPlan.Field(name='owner_id', kw_only=Tr"
    "ue, fn=None), ReprPlan.Field(name='requester_id', kw_only=True, fn=None), ReprPlan.Field(name='groups', kw_only=Tr"
    "ue, fn=None), ReprPlan.Field(name='instances', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fReservation(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            reservation_id=self.reservation_id,
            owner_id=self.owner_id,
            requester_id=self.requester_id,
            groups=self.groups,
            instances=self.instances,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.reservation_id == other.reservation_id and
            self.owner_id == other.owner_id and
            self.requester_id == other.requester_id and
            self.groups == other.groups and
            self.instances == other.instances
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'reservation_id',
        'owner_id',
        'requester_id',
        'groups',
        'instances',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'reservation_id',
        'owner_id',
        'requester_id',
        'groups',
        'instances',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.reservation_id,
            self.owner_id,
            self.requester_id,
            self.groups,
            self.instances,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        reservation_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        owner_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        requester_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        groups: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        instances: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'reservation_id', reservation_id)
        __dataclass__object_setattr(self, 'owner_id', owner_id)
        __dataclass__object_setattr(self, 'requester_id', requester_id)
        __dataclass__object_setattr(self, 'groups', groups)
        __dataclass__object_setattr(self, 'instances', instances)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"reservation_id={self.reservation_id!r}")
        parts.append(f"owner_id={self.owner_id!r}")
        parts.append(f"requester_id={self.requester_id!r}")
        parts.append(f"groups={self.groups!r}")
        parts.append(f"instances={self.instances!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('next_token', 'reservations')), EqPlan(fields=('next_token', 'reservations')), FrozenP"
    "lan(fields=('__shape__', 'next_token', 'reservations'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', "
    "fields=('next_token', 'reservations'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation="
    "OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type="
    "FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=Op"
    "Ref(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True"
    ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='reservations', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None)), self_param='self', std_params=(), kw_only_params=('next_token', 'reservations'), frozen=True, slots=Fa"
    "lse, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='next_token', kw_o"
    "nly=True, fn=None), ReprPlan.Field(name='reservations', kw_only=True, fn=None)), id=False, terse=False, default_fn"
    "=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fec2_2fDescribeInstancesResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            next_token=self.next_token,
            reservations=self.reservations,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.next_token == other.next_token and
            self.reservations == other.reservations
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'next_token',
        'reservations',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'next_token',
        'reservations',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.next_token,
            self.reservations,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        reservations: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'next_token', next_token)
        __dataclass__object_setattr(self, 'reservations', reservations)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"next_token={self.next_token!r}")
        parts.append(f"reservations={self.reservations!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('target_arn',)), EqPlan(fields=('target_arn',)), FrozenPlan(fields=('__shape__', 'targ"
    "et_arn'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('target_arn',), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default"
    "_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='target_arn', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='ini"
    "t.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('target_arn',), frozen=True, "
    "slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='target_ar"
    "n', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fDeadLetterConfig(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            target_arn=self.target_arn,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.target_arn == other.target_arn
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'target_arn',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'target_arn',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.target_arn,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        target_arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'target_arn', target_arn)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"target_arn={self.target_arn!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('retention_period_in_days', 'execution_timeout')), EqPlan(fields=('retention_period_in"
    "_days', 'execution_timeout')), FrozenPlan(fields=('__shape__', 'retention_period_in_days', 'execution_timeout'), a"
    "llow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('retention_period_in_days', 'execution_timeout'),"
    " cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation')"
    ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, vali"
    "date=None, check_type=None), InitPlan.Field(name='retention_period_in_days', annotation=OpRef(name='init.fields.1."
    "annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='execution_timeout', an"
    "notation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_pa"
    "ram='self', std_params=(), kw_only_params=('retention_period_in_days', 'execution_timeout'), frozen=True, slots=Fa"
    "lse, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='retention_period_"
    "in_days', kw_only=True, fn=None), ReprPlan.Field(name='execution_timeout', kw_only=True, fn=None)), id=False, ters"
    "e=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fDurableConfig(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            retention_period_in_days=self.retention_period_in_days,
            execution_timeout=self.execution_timeout,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.retention_period_in_days == other.retention_period_in_days and
            self.execution_timeout == other.execution_timeout
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'retention_period_in_days',
        'execution_timeout',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'retention_period_in_days',
        'execution_timeout',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.retention_period_in_days,
            self.execution_timeout,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        retention_period_in_days: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        execution_timeout: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'retention_period_in_days', retention_period_in_days)
        __dataclass__object_setattr(self, 'execution_timeout', execution_timeout)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"retention_period_in_days={self.retention_period_in_days!r}")
        parts.append(f"execution_timeout={self.execution_timeout!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('error_code', 'message')), EqPlan(fields=('error_code', 'message')), FrozenPlan(fields"
    "=('__shape__', 'error_code', 'message'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('error_"
    "code', 'message'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fie"
    "lds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='error_code', annotation=OpRef(name='init.field"
    "s.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='message', annotati"
    "on=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='s"
    "elf', std_params=(), kw_only_params=('error_code', 'message'), frozen=True, slots=False, post_init_params=None, in"
    "it_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='error_code', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='message', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fEnvironmentError_00(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            error_code=self.error_code,
            message=self.message,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.error_code == other.error_code and
            self.message == other.message
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'error_code',
        'message',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'error_code',
        'message',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.error_code,
            self.message,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        error_code: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'error_code', error_code)
        __dataclass__object_setattr(self, 'message', message)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"error_code={self.error_code!r}")
        parts.append(f"message={self.message!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('size',)), EqPlan(fields=('size',)), FrozenPlan(fields=('__shape__', 'size'), allow_dy"
    "namic_dunder_attrs=False), HashPlan(action='add', fields=('size',), cache=False), InitPlan(fields=(InitPlan.Field("
    "name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True"
    ", override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
    "e='size', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, overri"
    "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_par"
    "ams=(), kw_only_params=('size',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), "
    "ReprPlan(fields=(ReprPlan.Field(name='size', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fEphemeralStorage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            size=self.size,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.size == other.size
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'size',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'size',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.size,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        size: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'size', size)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"size={self.size!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('arn', 'local_mount_path')), EqPlan(fields=('arn', 'local_mount_path')), FrozenPlan(fi"
    "elds=('__shape__', 'arn', 'local_mount_path'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('"
    "arn', 'local_mount_path'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='"
    "init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CL"
    "ASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='arn', annotation=OpRef(name='init.fiel"
    "ds.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='local_mount_path', annotation=OpRef(name='init.f"
    "ields.2.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
    ", coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('arn', 'local_m"
    "ount_path'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Repr"
    "Plan.Field(name='arn', kw_only=True, fn=None), ReprPlan.Field(name='local_mount_path', kw_only=True, fn=None)), id"
    "=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fFileSystemConfig(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            arn=self.arn,
            local_mount_path=self.local_mount_path,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.arn == other.arn and
            self.local_mount_path == other.local_mount_path
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'arn',
        'local_mount_path',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'arn',
        'local_mount_path',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.arn,
            self.local_mount_path,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        arn: __dataclass__init__fields__1__annotation,
        local_mount_path: __dataclass__init__fields__2__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'arn', arn)
        __dataclass__object_setattr(self, 'local_mount_path', local_mount_path)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"arn={self.arn!r}")
        parts.append(f"local_mount_path={self.local_mount_path!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('error_code', 'message')), EqPlan(fields=('error_code', 'message')), FrozenPlan(fields"
    "=('__shape__', 'error_code', 'message'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('error_"
    "code', 'message'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fie"
    "lds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='error_code', annotation=OpRef(name='init.field"
    "s.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='message', annotati"
    "on=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='s"
    "elf', std_params=(), kw_only_params=('error_code', 'message'), frozen=True, slots=False, post_init_params=None, in"
    "it_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='error_code', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='message', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fImageConfigError(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            error_code=self.error_code,
            message=self.message,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.error_code == other.error_code and
            self.message == other.message
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'error_code',
        'message',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'error_code',
        'message',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.error_code,
            self.message,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        error_code: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'error_code', error_code)
        __dataclass__object_setattr(self, 'message', message)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"error_code={self.error_code!r}")
        parts.append(f"message={self.message!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('type', 'message')), EqPlan(fields=('type', 'message')), FrozenPlan(fields=('__shape__"
    "', 'type', 'message'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('type', 'message'), cache"
    "=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defa"
    "ult=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.1.annotation'), default=OpRe"
    "f(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='message', annotation=OpRef(name='init.fields.2.a"
    "nnotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_p"
    "arams=('type', 'message'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPla"
    "n(fields=(ReprPlan.Field(name='type', kw_only=True, fn=None), ReprPlan.Field(name='message', kw_only=True, fn=None"
    ")), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fInvalidParameterValueException(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            type=self.type,
            message=self.message,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.type == other.type and
            self.message == other.message
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'type',
        'message',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'type',
        'message',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.type,
            self.message,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'type', type)
        __dataclass__object_setattr(self, 'message', message)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"type={self.type!r}")
        parts.append(f"message={self.message!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('capacity_provider_arn', 'per_execution_environment_max_concurrency', 'execution_envir"
    "onment_memory_gi_b_per_v_cpu')), EqPlan(fields=('capacity_provider_arn', 'per_execution_environment_max_concurrenc"
    "y', 'execution_environment_memory_gi_b_per_v_cpu')), FrozenPlan(fields=('__shape__', 'capacity_provider_arn', 'per"
    "_execution_environment_max_concurrency', 'execution_environment_memory_gi_b_per_v_cpu'), allow_dynamic_dunder_attr"
    "s=False), HashPlan(action='add', fields=('capacity_provider_arn', 'per_execution_environment_max_concurrency', 'ex"
    "ecution_environment_memory_gi_b_per_v_cpu'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annot"
    "ation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field"
    "_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='capacity_provider_ar"
    "n', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='per_executio"
    "n_environment_max_concurrency', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields"
    ".2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None), InitPlan.Field(name='execution_environment_memory_gi_b_per_v_cpu', annotation=OpRef(name"
    "='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, overri"
    "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_par"
    "ams=(), kw_only_params=('capacity_provider_arn', 'per_execution_environment_max_concurrency', 'execution_environme"
    "nt_memory_gi_b_per_v_cpu'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPl"
    "an(fields=(ReprPlan.Field(name='capacity_provider_arn', kw_only=True, fn=None), ReprPlan.Field(name='per_execution"
    "_environment_max_concurrency', kw_only=True, fn=None), ReprPlan.Field(name='execution_environment_memory_gi_b_per_"
    "v_cpu', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fLambdaManagedInstancesCapacityProviderConfig(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            capacity_provider_arn=self.capacity_provider_arn,
            per_execution_environment_max_concurrency=self.per_execution_environment_max_concurrency,
            execution_environment_memory_gi_b_per_v_cpu=self.execution_environment_memory_gi_b_per_v_cpu,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.capacity_provider_arn == other.capacity_provider_arn and
            self.per_execution_environment_max_concurrency == other.per_execution_environment_max_concurrency and
            self.execution_environment_memory_gi_b_per_v_cpu == other.execution_environment_memory_gi_b_per_v_cpu
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'capacity_provider_arn',
        'per_execution_environment_max_concurrency',
        'execution_environment_memory_gi_b_per_v_cpu',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'capacity_provider_arn',
        'per_execution_environment_max_concurrency',
        'execution_environment_memory_gi_b_per_v_cpu',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.capacity_provider_arn,
            self.per_execution_environment_max_concurrency,
            self.execution_environment_memory_gi_b_per_v_cpu,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        capacity_provider_arn: __dataclass__init__fields__1__annotation,
        per_execution_environment_max_concurrency: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        execution_environment_memory_gi_b_per_v_cpu: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'capacity_provider_arn', capacity_provider_arn)
        __dataclass__object_setattr(self, 'per_execution_environment_max_concurrency', per_execution_environment_max_concurrency)
        __dataclass__object_setattr(self, 'execution_environment_memory_gi_b_per_v_cpu', execution_environment_memory_gi_b_per_v_cpu)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"capacity_provider_arn={self.capacity_provider_arn!r}")
        parts.append(f"per_execution_environment_max_concurrency={self.per_execution_environment_max_concurrency!r}")
        parts.append(f"execution_environment_memory_gi_b_per_v_cpu={self.execution_environment_memory_gi_b_per_v_cpu!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('arn', 'code_size', 'signing_profile_version_arn', 'signing_job_arn')), EqPlan(fields="
    "('arn', 'code_size', 'signing_profile_version_arn', 'signing_job_arn')), FrozenPlan(fields=('__shape__', 'arn', 'c"
    "ode_size', 'signing_profile_version_arn', 'signing_job_arn'), allow_dynamic_dunder_attrs=False), HashPlan(action='"
    "add', fields=('arn', 'code_size', 'signing_profile_version_arn', 'signing_job_arn'), cache=False), InitPlan(fields"
    "=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factor"
    "y=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), I"
    "nitPlan.Field(name='arn', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
    ", check_type=None), InitPlan.Field(name='code_size', annotation=OpRef(name='init.fields.2.annotation'), default=Op"
    "Ref(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='signing_profile_version_arn', annotation=OpRef"
    "(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='s"
    "igning_job_arn', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None)), self_param='self', std_params=(), kw_only_params=('arn', 'code_size', 'signing_profile_version_arn', '"
    "signing_job_arn'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields"
    "=(ReprPlan.Field(name='arn', kw_only=True, fn=None), ReprPlan.Field(name='code_size', kw_only=True, fn=None), Repr"
    "Plan.Field(name='signing_profile_version_arn', kw_only=True, fn=None), ReprPlan.Field(name='signing_job_arn', kw_o"
    "nly=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fLayer(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            arn=self.arn,
            code_size=self.code_size,
            signing_profile_version_arn=self.signing_profile_version_arn,
            signing_job_arn=self.signing_job_arn,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.arn == other.arn and
            self.code_size == other.code_size and
            self.signing_profile_version_arn == other.signing_profile_version_arn and
            self.signing_job_arn == other.signing_job_arn
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'arn',
        'code_size',
        'signing_profile_version_arn',
        'signing_job_arn',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'arn',
        'code_size',
        'signing_profile_version_arn',
        'signing_job_arn',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.arn,
            self.code_size,
            self.signing_profile_version_arn,
            self.signing_job_arn,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        code_size: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        signing_profile_version_arn: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        signing_job_arn: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'arn', arn)
        __dataclass__object_setattr(self, 'code_size', code_size)
        __dataclass__object_setattr(self, 'signing_profile_version_arn', signing_profile_version_arn)
        __dataclass__object_setattr(self, 'signing_job_arn', signing_job_arn)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"arn={self.arn!r}")
        parts.append(f"code_size={self.code_size!r}")
        parts.append(f"signing_profile_version_arn={self.signing_profile_version_arn!r}")
        parts.append(f"signing_job_arn={self.signing_job_arn!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('master_region', 'function_version', 'marker', 'max_items')), EqPlan(fields=('master_r"
    "egion', 'function_version', 'marker', 'max_items')), FrozenPlan(fields=('__shape__', 'master_region', 'function_ve"
    "rsion', 'marker', 'max_items'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('master_region',"
    " 'function_version', 'marker', 'max_items'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annot"
    "ation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field"
    "_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='master_region', anno"
    "tation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
    "ield(name='function_version', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2"
    ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None), InitPlan.Field(name='marker', annotation=OpRef(name='init.fields.3.annotation'), default=O"
    "pRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
    ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_items', annotation=OpRef(name='init.field"
    "s.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_o"
    "nly_params=('master_region', 'function_version', 'marker', 'max_items'), frozen=True, slots=False, post_init_param"
    "s=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='master_region', kw_only=True, fn=None"
    "), ReprPlan.Field(name='function_version', kw_only=True, fn=None), ReprPlan.Field(name='marker', kw_only=True, fn="
    "None), ReprPlan.Field(name='max_items', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fListFunctionsRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            master_region=self.master_region,
            function_version=self.function_version,
            marker=self.marker,
            max_items=self.max_items,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.master_region == other.master_region and
            self.function_version == other.function_version and
            self.marker == other.marker and
            self.max_items == other.max_items
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'master_region',
        'function_version',
        'marker',
        'max_items',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'master_region',
        'function_version',
        'marker',
        'max_items',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.master_region,
            self.function_version,
            self.marker,
            self.max_items,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        master_region: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        function_version: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        marker: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        max_items: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'master_region', master_region)
        __dataclass__object_setattr(self, 'function_version', function_version)
        __dataclass__object_setattr(self, 'marker', marker)
        __dataclass__object_setattr(self, 'max_items', max_items)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"master_region={self.master_region!r}")
        parts.append(f"function_version={self.function_version!r}")
        parts.append(f"marker={self.marker!r}")
        parts.append(f"max_items={self.max_items!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('log_format', 'application_log_level', 'system_log_level', 'log_group')), EqPlan(field"
    "s=('log_format', 'application_log_level', 'system_log_level', 'log_group')), FrozenPlan(fields=('__shape__', 'log_"
    "format', 'application_log_level', 'system_log_level', 'log_group'), allow_dynamic_dunder_attrs=False), HashPlan(ac"
    "tion='add', fields=('log_format', 'application_log_level', 'system_log_level', 'log_group'), cache=False), InitPla"
    "n(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='log_format', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='in"
    "it.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
    ", validate=None, check_type=None), InitPlan.Field(name='application_log_level', annotation=OpRef(name='init.fields"
    ".2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='system_log_level', "
    "annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='log_group', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None)), self_param='self', std_params=(), kw_only_params=('log_format', 'application_log_level', 'sy"
    "stem_log_level', 'log_group'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Rep"
    "rPlan(fields=(ReprPlan.Field(name='log_format', kw_only=True, fn=None), ReprPlan.Field(name='application_log_level"
    "', kw_only=True, fn=None), ReprPlan.Field(name='system_log_level', kw_only=True, fn=None), ReprPlan.Field(name='lo"
    "g_group', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fLoggingConfig(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            log_format=self.log_format,
            application_log_level=self.application_log_level,
            system_log_level=self.system_log_level,
            log_group=self.log_group,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.log_format == other.log_format and
            self.application_log_level == other.application_log_level and
            self.system_log_level == other.system_log_level and
            self.log_group == other.log_group
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'log_format',
        'application_log_level',
        'system_log_level',
        'log_group',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'log_format',
        'application_log_level',
        'system_log_level',
        'log_group',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.log_format,
            self.application_log_level,
            self.system_log_level,
            self.log_group,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        log_format: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        application_log_level: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        system_log_level: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        log_group: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'log_format', log_format)
        __dataclass__object_setattr(self, 'application_log_level', application_log_level)
        __dataclass__object_setattr(self, 'system_log_level', system_log_level)
        __dataclass__object_setattr(self, 'log_group', log_group)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"log_format={self.log_format!r}")
        parts.append(f"application_log_level={self.application_log_level!r}")
        parts.append(f"system_log_level={self.system_log_level!r}")
        parts.append(f"log_group={self.log_group!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('error_code', 'message')), EqPlan(fields=('error_code', 'message')), FrozenPlan(fields"
    "=('__shape__', 'error_code', 'message'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('error_"
    "code', 'message'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fie"
    "lds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='error_code', annotation=OpRef(name='init.field"
    "s.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='message', annotati"
    "on=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='s"
    "elf', std_params=(), kw_only_params=('error_code', 'message'), frozen=True, slots=False, post_init_params=None, in"
    "it_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='error_code', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='message', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fRuntimeVersionError(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            error_code=self.error_code,
            message=self.message,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.error_code == other.error_code and
            self.message == other.message
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'error_code',
        'message',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'error_code',
        'message',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.error_code,
            self.message,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        error_code: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'error_code', error_code)
        __dataclass__object_setattr(self, 'message', message)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"error_code={self.error_code!r}")
        parts.append(f"message={self.message!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('type', 'message')), EqPlan(fields=('type', 'message')), FrozenPlan(fields=('__shape__"
    "', 'type', 'message'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('type', 'message'), cache"
    "=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defa"
    "ult=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.1.annotation'), default=OpRe"
    "f(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='message', annotation=OpRef(name='init.fields.2.a"
    "nnotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_p"
    "arams=('type', 'message'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPla"
    "n(fields=(ReprPlan.Field(name='type', kw_only=True, fn=None), ReprPlan.Field(name='message', kw_only=True, fn=None"
    ")), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fServiceException(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            type=self.type,
            message=self.message,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.type == other.type and
            self.message == other.message
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'type',
        'message',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'type',
        'message',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.type,
            self.message,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'type', type)
        __dataclass__object_setattr(self, 'message', message)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"type={self.type!r}")
        parts.append(f"message={self.message!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('apply_on', 'optimization_status')), EqPlan(fields=('apply_on', 'optimization_status')"
    "), FrozenPlan(fields=('__shape__', 'apply_on', 'optimization_status'), allow_dynamic_dunder_attrs=False), HashPlan"
    "(action='add', fields=('apply_on', 'optimization_status'), cache=False), InitPlan(fields=(InitPlan.Field(name='__s"
    "hape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='apply_"
    "on', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_facto"
    "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
    "nitPlan.Field(name='optimization_status', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='i"
    "nit.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
    "e, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('apply_on', 'optimization_s"
    "tatus'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan"
    ".Field(name='apply_on', kw_only=True, fn=None), ReprPlan.Field(name='optimization_status', kw_only=True, fn=None))"
    ", id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fSnapStartResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            apply_on=self.apply_on,
            optimization_status=self.optimization_status,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.apply_on == other.apply_on and
            self.optimization_status == other.optimization_status
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'apply_on',
        'optimization_status',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'apply_on',
        'optimization_status',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.apply_on,
            self.optimization_status,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        apply_on: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        optimization_status: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'apply_on', apply_on)
        __dataclass__object_setattr(self, 'optimization_status', optimization_status)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"apply_on={self.apply_on!r}")
        parts.append(f"optimization_status={self.optimization_status!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('tenant_isolation_mode',)), EqPlan(fields=('tenant_isolation_mode',)), FrozenPlan(fiel"
    "ds=('__shape__', 'tenant_isolation_mode'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('tena"
    "nt_isolation_mode',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init."
    "fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_V"
    "AR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tenant_isolation_mode', annotation=OpRef(na"
    "me='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('tena"
    "nt_isolation_mode',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fie"
    "lds=(ReprPlan.Field(name='tenant_isolation_mode', kw_only=True, fn=None),), id=False, terse=False, default_fn=None"
    ")))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fTenancyConfig(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            tenant_isolation_mode=self.tenant_isolation_mode,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.tenant_isolation_mode == other.tenant_isolation_mode
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'tenant_isolation_mode',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'tenant_isolation_mode',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.tenant_isolation_mode,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        tenant_isolation_mode: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'tenant_isolation_mode', tenant_isolation_mode)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"tenant_isolation_mode={self.tenant_isolation_mode!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('retry_after_seconds', 'type', 'message', 'reason')), EqPlan(fields=('retry_after_seco"
    "nds', 'type', 'message', 'reason')), FrozenPlan(fields=('__shape__', 'retry_after_seconds', 'type', 'message', 're"
    "ason'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('retry_after_seconds', 'type', 'message'"
    ", 'reason'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0."
    "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='retry_after_seconds', annotation=OpRef(name='init.fi"
    "elds.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='type', annotati"
    "on=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='message', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None), InitPlan.Field(name='reason', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='in"
    "it.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
    ", validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('retry_after_seconds', 'type"
    "', 'message', 'reason'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan("
    "fields=(ReprPlan.Field(name='retry_after_seconds', kw_only=True, fn=None), ReprPlan.Field(name='type', kw_only=Tru"
    "e, fn=None), ReprPlan.Field(name='message', kw_only=True, fn=None), ReprPlan.Field(name='reason', kw_only=True, fn"
    "=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fTooManyRequestsException(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            retry_after_seconds=self.retry_after_seconds,
            type=self.type,
            message=self.message,
            reason=self.reason,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.retry_after_seconds == other.retry_after_seconds and
            self.type == other.type and
            self.message == other.message and
            self.reason == other.reason
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'retry_after_seconds',
        'type',
        'message',
        'reason',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'retry_after_seconds',
        'type',
        'message',
        'reason',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.retry_after_seconds,
            self.type,
            self.message,
            self.reason,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        retry_after_seconds: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        type: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        message: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        reason: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'retry_after_seconds', retry_after_seconds)
        __dataclass__object_setattr(self, 'type', type)
        __dataclass__object_setattr(self, 'message', message)
        __dataclass__object_setattr(self, 'reason', reason)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"retry_after_seconds={self.retry_after_seconds!r}")
        parts.append(f"type={self.type!r}")
        parts.append(f"message={self.message!r}")
        parts.append(f"reason={self.reason!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('mode',)), EqPlan(fields=('mode',)), FrozenPlan(fields=('__shape__', 'mode'), allow_dy"
    "namic_dunder_attrs=False), HashPlan(action='add', fields=('mode',), cache=False), InitPlan(fields=(InitPlan.Field("
    "name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True"
    ", override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
    "e='mode', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e)), self_param='self', std_params=(), kw_only_params=('mode',), frozen=True, slots=False, post_init_params=None, "
    "init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='mode', kw_only=True, fn=None),), id=False, te"
    "rse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fTracingConfigResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            mode=self.mode,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.mode == other.mode
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'mode',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'mode',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.mode,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        mode: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'mode', mode)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"mode={self.mode!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('lambda_managed_instances_capacity_provider_config',)), EqPlan(fields=('lambda_managed"
    "_instances_capacity_provider_config',)), FrozenPlan(fields=('__shape__', 'lambda_managed_instances_capacity_provid"
    "er_config'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('lambda_managed_instances_capacity_"
    "provider_config',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fi"
    "elds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR"
    ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='lambda_managed_instances_capacity_provider_co"
    "nfig', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override="
    "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params"
    "=(), kw_only_params=('lambda_managed_instances_capacity_provider_config',), frozen=True, slots=False, post_init_pa"
    "rams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='lambda_managed_instances_capacity_"
    "provider_config', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fCapacityProviderConfig(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            lambda_managed_instances_capacity_provider_config=self.lambda_managed_instances_capacity_provider_config,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.lambda_managed_instances_capacity_provider_config == other.lambda_managed_instances_capacity_provider_config
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'lambda_managed_instances_capacity_provider_config',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'lambda_managed_instances_capacity_provider_config',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.lambda_managed_instances_capacity_provider_config,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        lambda_managed_instances_capacity_provider_config: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'lambda_managed_instances_capacity_provider_config', lambda_managed_instances_capacity_provider_config)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"lambda_managed_instances_capacity_provider_config={self.lambda_managed_instances_capacity_provider_config!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('variables', 'error')), EqPlan(fields=('variables', 'error')), FrozenPlan(fields=('__s"
    "hape__', 'variables', 'error'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('variables', 'er"
    "ror'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annota"
    "tion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None"
    ", validate=None, check_type=None), InitPlan.Field(name='variables', annotation=OpRef(name='init.fields.1.annotatio"
    "n'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='error', annotation=OpRef(name='"
    "init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_param"
    "s=(), kw_only_params=('variables', 'error'), frozen=True, slots=False, post_init_params=None, init_fns=(), validat"
    "e_fns=()), ReprPlan(fields=(ReprPlan.Field(name='variables', kw_only=True, fn=None), ReprPlan.Field(name='error', "
    "kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fEnvironmentResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            variables=self.variables,
            error=self.error,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.variables == other.variables and
            self.error == other.error
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'variables',
        'error',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'variables',
        'error',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.variables,
            self.error,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        variables: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        error: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'variables', variables)
        __dataclass__object_setattr(self, 'error', error)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"variables={self.variables!r}")
        parts.append(f"error={self.error!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('entry_point', 'command', 'working_directory')), EqPlan(fields=('entry_point', 'comman"
    "d', 'working_directory')), FrozenPlan(fields=('__shape__', 'entry_point', 'command', 'working_directory'), allow_d"
    "ynamic_dunder_attrs=False), HashPlan(action='add', fields=('entry_point', 'command', 'working_directory'), cache=F"
    "alse), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defaul"
    "t=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=Non"
    "e, check_type=None), InitPlan.Field(name='entry_point', annotation=OpRef(name='init.fields.1.annotation'), default"
    "=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='command', annotation=OpRef(name='init.field"
    "s.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='working_directory'"
    ", annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), sel"
    "f_param='self', std_params=(), kw_only_params=('entry_point', 'command', 'working_directory'), frozen=True, slots="
    "False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='entry_point', k"
    "w_only=True, fn=None), ReprPlan.Field(name='command', kw_only=True, fn=None), ReprPlan.Field(name='working_directo"
    "ry', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fImageConfig(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            entry_point=self.entry_point,
            command=self.command,
            working_directory=self.working_directory,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.entry_point == other.entry_point and
            self.command == other.command and
            self.working_directory == other.working_directory
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'entry_point',
        'command',
        'working_directory',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'entry_point',
        'command',
        'working_directory',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.entry_point,
            self.command,
            self.working_directory,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        entry_point: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        command: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        working_directory: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'entry_point', entry_point)
        __dataclass__object_setattr(self, 'command', command)
        __dataclass__object_setattr(self, 'working_directory', working_directory)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"entry_point={self.entry_point!r}")
        parts.append(f"command={self.command!r}")
        parts.append(f"working_directory={self.working_directory!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('runtime_version_arn', 'error')), EqPlan(fields=('runtime_version_arn', 'error')), Fro"
    "zenPlan(fields=('__shape__', 'runtime_version_arn', 'error'), allow_dynamic_dunder_attrs=False), HashPlan(action='"
    "add', fields=('runtime_version_arn', 'error'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', ann"
    "otation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='runtime_version_ar"
    "n', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factor"
    "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
    "itPlan.Field(name='error', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None)), self_param='self', std_params=(), kw_only_params=('runtime_version_arn', 'error'), frozen=Tr"
    "ue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='runti"
    "me_version_arn', kw_only=True, fn=None), ReprPlan.Field(name='error', kw_only=True, fn=None)), id=False, terse=Fal"
    "se, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fRuntimeVersionConfig(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            runtime_version_arn=self.runtime_version_arn,
            error=self.error,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.runtime_version_arn == other.runtime_version_arn and
            self.error == other.error
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'runtime_version_arn',
        'error',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'runtime_version_arn',
        'error',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.runtime_version_arn,
            self.error,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        runtime_version_arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        error: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'runtime_version_arn', runtime_version_arn)
        __dataclass__object_setattr(self, 'error', error)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"runtime_version_arn={self.runtime_version_arn!r}")
        parts.append(f"error={self.error!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('subnet_ids', 'security_group_ids', 'vpc_id', 'ipv6_allowed_for_dual_stack')), EqPlan("
    "fields=('subnet_ids', 'security_group_ids', 'vpc_id', 'ipv6_allowed_for_dual_stack')), FrozenPlan(fields=('__shape"
    "__', 'subnet_ids', 'security_group_ids', 'vpc_id', 'ipv6_allowed_for_dual_stack'), allow_dynamic_dunder_attrs=Fals"
    "e), HashPlan(action='add', fields=('subnet_ids', 'security_group_ids', 'vpc_id', 'ipv6_allowed_for_dual_stack'), c"
    "ache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), "
    "default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='subnet_ids', annotation=OpRef(name='init.fields.1.annotation'), de"
    "fault=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
    "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='security_group_ids', annotation=OpRef("
    "name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, ov"
    "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vp"
    "c_id', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='ipv6_allowed_for_dual_stack', annotation=OpRef(name='init.fields.4.annotation'), default=OpR"
    "ef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('subnet_ids', 'se"
    "curity_group_ids', 'vpc_id', 'ipv6_allowed_for_dual_stack'), frozen=True, slots=False, post_init_params=None, init"
    "_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='subnet_ids', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='security_group_ids', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPl"
    "an.Field(name='ipv6_allowed_for_dual_stack', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fVpcConfigResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            subnet_ids=self.subnet_ids,
            security_group_ids=self.security_group_ids,
            vpc_id=self.vpc_id,
            ipv6_allowed_for_dual_stack=self.ipv6_allowed_for_dual_stack,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.subnet_ids == other.subnet_ids and
            self.security_group_ids == other.security_group_ids and
            self.vpc_id == other.vpc_id and
            self.ipv6_allowed_for_dual_stack == other.ipv6_allowed_for_dual_stack
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'subnet_ids',
        'security_group_ids',
        'vpc_id',
        'ipv6_allowed_for_dual_stack',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'subnet_ids',
        'security_group_ids',
        'vpc_id',
        'ipv6_allowed_for_dual_stack',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.subnet_ids,
            self.security_group_ids,
            self.vpc_id,
            self.ipv6_allowed_for_dual_stack,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        subnet_ids: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        security_group_ids: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        vpc_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ipv6_allowed_for_dual_stack: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'subnet_ids', subnet_ids)
        __dataclass__object_setattr(self, 'security_group_ids', security_group_ids)
        __dataclass__object_setattr(self, 'vpc_id', vpc_id)
        __dataclass__object_setattr(self, 'ipv6_allowed_for_dual_stack', ipv6_allowed_for_dual_stack)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"subnet_ids={self.subnet_ids!r}")
        parts.append(f"security_group_ids={self.security_group_ids!r}")
        parts.append(f"vpc_id={self.vpc_id!r}")
        parts.append(f"ipv6_allowed_for_dual_stack={self.ipv6_allowed_for_dual_stack!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('image_config', 'error')), EqPlan(fields=('image_config', 'error')), FrozenPlan(fields"
    "=('__shape__', 'image_config', 'error'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('image_"
    "config', 'error'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fie"
    "lds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='image_config', annotation=OpRef(name='init.fie"
    "lds.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='error', annotati"
    "on=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='s"
    "elf', std_params=(), kw_only_params=('image_config', 'error'), frozen=True, slots=False, post_init_params=None, in"
    "it_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='image_config', kw_only=True, fn=None), ReprPlan"
    ".Field(name='error', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fImageConfigResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            image_config=self.image_config,
            error=self.error,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.image_config == other.image_config and
            self.error == other.error
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'image_config',
        'error',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'image_config',
        'error',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.image_config,
            self.error,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        image_config: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        error: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'image_config', image_config)
        __dataclass__object_setattr(self, 'error', error)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"image_config={self.image_config!r}")
        parts.append(f"error={self.error!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('function_name', 'function_arn', 'runtime', 'role', 'handler', 'code_size', 'descripti"
    "on', 'timeout', 'memory_size', 'last_modified', 'code_sha256', 'version', 'vpc_config', 'dead_letter_config', 'env"
    "ironment', 'kms_key_arn', 'tracing_config', 'master_arn', 'revision_id', 'layers', 'state', 'state_reason', 'state"
    "_reason_code', 'last_update_status', 'last_update_status_reason', 'last_update_status_reason_code', 'file_system_c"
    "onfigs', 'package_type', 'image_config_response', 'signing_profile_version_arn', 'signing_job_arn', 'architectures"
    "', 'ephemeral_storage', 'snap_start', 'runtime_version_config', 'logging_config', 'capacity_provider_config', 'con"
    "fig_sha256', 'durable_config', 'tenancy_config')), EqPlan(fields=('function_name', 'function_arn', 'runtime', 'rol"
    "e', 'handler', 'code_size', 'description', 'timeout', 'memory_size', 'last_modified', 'code_sha256', 'version', 'v"
    "pc_config', 'dead_letter_config', 'environment', 'kms_key_arn', 'tracing_config', 'master_arn', 'revision_id', 'la"
    "yers', 'state', 'state_reason', 'state_reason_code', 'last_update_status', 'last_update_status_reason', 'last_upda"
    "te_status_reason_code', 'file_system_configs', 'package_type', 'image_config_response', 'signing_profile_version_a"
    "rn', 'signing_job_arn', 'architectures', 'ephemeral_storage', 'snap_start', 'runtime_version_config', 'logging_con"
    "fig', 'capacity_provider_config', 'config_sha256', 'durable_config', 'tenancy_config')), FrozenPlan(fields=('__sha"
    "pe__', 'function_name', 'function_arn', 'runtime', 'role', 'handler', 'code_size', 'description', 'timeout', 'memo"
    "ry_size', 'last_modified', 'code_sha256', 'version', 'vpc_config', 'dead_letter_config', 'environment', 'kms_key_a"
    "rn', 'tracing_config', 'master_arn', 'revision_id', 'layers', 'state', 'state_reason', 'state_reason_code', 'last_"
    "update_status', 'last_update_status_reason', 'last_update_status_reason_code', 'file_system_configs', 'package_typ"
    "e', 'image_config_response', 'signing_profile_version_arn', 'signing_job_arn', 'architectures', 'ephemeral_storage"
    "', 'snap_start', 'runtime_version_config', 'logging_config', 'capacity_provider_config', 'config_sha256', 'durable"
    "_config', 'tenancy_config'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('function_name', 'f"
    "unction_arn', 'runtime', 'role', 'handler', 'code_size', 'description', 'timeout', 'memory_size', 'last_modified',"
    " 'code_sha256', 'version', 'vpc_config', 'dead_letter_config', 'environment', 'kms_key_arn', 'tracing_config', 'ma"
    "ster_arn', 'revision_id', 'layers', 'state', 'state_reason', 'state_reason_code', 'last_update_status', 'last_upda"
    "te_status_reason', 'last_update_status_reason_code', 'file_system_configs', 'package_type', 'image_config_response"
    "', 'signing_profile_version_arn', 'signing_job_arn', 'architectures', 'ephemeral_storage', 'snap_start', 'runtime_"
    "version_config', 'logging_config', 'capacity_provider_config', 'config_sha256', 'durable_config', 'tenancy_config'"
    "), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation"
    "'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='function_name', annotation=OpRef(name='init.fields.1.annotatio"
    "n'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='function_arn', annotation=OpRef"
    "(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='r"
    "untime', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='role', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields."
    "4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='handler', annotation=OpRef(name='init.fields.5.annotation'), default"
    "=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='code_size', annotation=OpRef(name='init.fie"
    "lds.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='description', an"
    "notation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
    ".Field(name='timeout', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.defaul"
    "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='memory_size', annotation=OpRef(name='init.fields.9.annotation'), default=OpR"
    "ef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None), InitPlan.Field(name='last_modified', annotation=OpRef(name='init.fie"
    "lds.10.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='code_sha256', "
    "annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='version', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='vpc_config', annotation=OpRef(name='init.fields.13.annotation'), defau"
    "lt=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
    "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dead_letter_config', annotation=OpRef(na"
    "me='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, ov"
    "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='en"
    "vironment', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='kms_key_arn', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef(name="
    "'init.fields.16.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='tracing_config', annotation=OpRef(name='init.fields.17"
    ".annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='master_arn', annotat"
    "ion=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.18.default'), default_factory=None, i"
    "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
    "eld(name='revision_id', annotation=OpRef(name='init.fields.19.annotation'), default=OpRef(name='init.fields.19.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
    ", check_type=None), InitPlan.Field(name='layers', annotation=OpRef(name='init.fields.20.annotation'), default=OpRe"
    "f(name='init.fields.20.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None), InitPlan.Field(name='state', annotation=OpRef(name='init.fields.21.a"
    "nnotation'), default=OpRef(name='init.fields.21.default'), default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state_reason', annotat"
    "ion=OpRef(name='init.fields.22.annotation'), default=OpRef(name='init.fields.22.default'), default_factory=None, i"
    "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
    "eld(name='state_reason_code', annotation=OpRef(name='init.fields.23.annotation'), default=OpRef(name='init.fields."
    "23.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None), InitPlan.Field(name='last_update_status', annotation=OpRef(name='init.fields.24.annotati"
    "on'), default=OpRef(name='init.fields.24.default'), default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='last_update_status_reason', a"
    "nnotation=OpRef(name='init.fields.25.annotation'), default=OpRef(name='init.fields.25.default'), default_factory=N"
    "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
    "lan.Field(name='last_update_status_reason_code', annotation=OpRef(name='init.fields.26.annotation'), default=OpRef"
    "(name='init.fields.26.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='file_system_configs', annotation=OpRef(name='ini"
    "t.fields.27.annotation'), default=OpRef(name='init.fields.27.default'), default_factory=None, init=True, override="
    "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='package_t"
    "ype', annotation=OpRef(name='init.fields.28.annotation'), default=OpRef(name='init.fields.28.default'), default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='image_config_response', annotation=OpRef(name='init.fields.29.annotation'), default=OpRef(n"
    "ame='init.fields.29.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
    "rce=None, validate=None, check_type=None), InitPlan.Field(name='signing_profile_version_arn', annotation=OpRef(nam"
    "e='init.fields.30.annotation'), default=OpRef(name='init.fields.30.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='sig"
    "ning_job_arn', annotation=OpRef(name='init.fields.31.annotation'), default=OpRef(name='init.fields.31.default'), d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None), InitPlan.Field(name='architectures', annotation=OpRef(name='init.fields.32.annotation'), default=OpRef("
    "name='init.fields.32.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None), InitPlan.Field(name='ephemeral_storage', annotation=OpRef(name='init.f"
    "ields.33.annotation'), default=OpRef(name='init.fields.33.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='snap_start',"
    " annotation=OpRef(name='init.fields.34.annotation'), default=OpRef(name='init.fields.34.default'), default_factory"
    "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
    "tPlan.Field(name='runtime_version_config', annotation=OpRef(name='init.fields.35.annotation'), default=OpRef(name="
    "'init.fields.35.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='logging_config', annotation=OpRef(name='init.fields.36"
    ".annotation'), default=OpRef(name='init.fields.36.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='capacity_provider_co"
    "nfig', annotation=OpRef(name='init.fields.37.annotation'), default=OpRef(name='init.fields.37.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='config_sha256', annotation=OpRef(name='init.fields.38.annotation'), default=OpRef(name='in"
    "it.fields.38.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
    "e, validate=None, check_type=None), InitPlan.Field(name='durable_config', annotation=OpRef(name='init.fields.39.an"
    "notation'), default=OpRef(name='init.fields.39.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tenancy_config', annota"
    "tion=OpRef(name='init.fields.40.annotation'), default=OpRef(name='init.fields.40.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_para"
    "m='self', std_params=(), kw_only_params=('function_name', 'function_arn', 'runtime', 'role', 'handler', 'code_size"
    "', 'description', 'timeout', 'memory_size', 'last_modified', 'code_sha256', 'version', 'vpc_config', 'dead_letter_"
    "config', 'environment', 'kms_key_arn', 'tracing_config', 'master_arn', 'revision_id', 'layers', 'state', 'state_re"
    "ason', 'state_reason_code', 'last_update_status', 'last_update_status_reason', 'last_update_status_reason_code', '"
    "file_system_configs', 'package_type', 'image_config_response', 'signing_profile_version_arn', 'signing_job_arn', '"
    "architectures', 'ephemeral_storage', 'snap_start', 'runtime_version_config', 'logging_config', 'capacity_provider_"
    "config', 'config_sha256', 'durable_config', 'tenancy_config'), frozen=True, slots=False, post_init_params=None, in"
    "it_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='function_name', kw_only=True, fn=None), ReprPla"
    "n.Field(name='function_arn', kw_only=True, fn=None), ReprPlan.Field(name='runtime', kw_only=True, fn=None), ReprPl"
    "an.Field(name='role', kw_only=True, fn=None), ReprPlan.Field(name='handler', kw_only=True, fn=None), ReprPlan.Fiel"
    "d(name='code_size', kw_only=True, fn=None), ReprPlan.Field(name='description', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='timeout', kw_only=True, fn=None), ReprPlan.Field(name='memory_size', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='last_modified', kw_only=True, fn=None), ReprPlan.Field(name='code_sha256', kw_only=True, fn=None), ReprP"
    "lan.Field(name='version', kw_only=True, fn=None), ReprPlan.Field(name='vpc_config', kw_only=True, fn=None), ReprPl"
    "an.Field(name='dead_letter_config', kw_only=True, fn=None), ReprPlan.Field(name='environment', kw_only=True, fn=No"
    "ne), ReprPlan.Field(name='kms_key_arn', kw_only=True, fn=None), ReprPlan.Field(name='tracing_config', kw_only=True"
    ", fn=None), ReprPlan.Field(name='master_arn', kw_only=True, fn=None), ReprPlan.Field(name='revision_id', kw_only=T"
    "rue, fn=None), ReprPlan.Field(name='layers', kw_only=True, fn=None), ReprPlan.Field(name='state', kw_only=True, fn"
    "=None), ReprPlan.Field(name='state_reason', kw_only=True, fn=None), ReprPlan.Field(name='state_reason_code', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='last_update_status', kw_only=True, fn=None), ReprPlan.Field(name='last_upd"
    "ate_status_reason', kw_only=True, fn=None), ReprPlan.Field(name='last_update_status_reason_code', kw_only=True, fn"
    "=None), ReprPlan.Field(name='file_system_configs', kw_only=True, fn=None), ReprPlan.Field(name='package_type', kw_"
    "only=True, fn=None), ReprPlan.Field(name='image_config_response', kw_only=True, fn=None), ReprPlan.Field(name='sig"
    "ning_profile_version_arn', kw_only=True, fn=None), ReprPlan.Field(name='signing_job_arn', kw_only=True, fn=None), "
    "ReprPlan.Field(name='architectures', kw_only=True, fn=None), ReprPlan.Field(name='ephemeral_storage', kw_only=True"
    ", fn=None), ReprPlan.Field(name='snap_start', kw_only=True, fn=None), ReprPlan.Field(name='runtime_version_config'"
    ", kw_only=True, fn=None), ReprPlan.Field(name='logging_config', kw_only=True, fn=None), ReprPlan.Field(name='capac"
    "ity_provider_config', kw_only=True, fn=None), ReprPlan.Field(name='config_sha256', kw_only=True, fn=None), ReprPla"
    "n.Field(name='durable_config', kw_only=True, fn=None), ReprPlan.Field(name='tenancy_config', kw_only=True, fn=None"
    ")), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fFunctionConfiguration(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__21__annotation,
    __dataclass__init__fields__21__default,
    __dataclass__init__fields__22__annotation,
    __dataclass__init__fields__22__default,
    __dataclass__init__fields__23__annotation,
    __dataclass__init__fields__23__default,
    __dataclass__init__fields__24__annotation,
    __dataclass__init__fields__24__default,
    __dataclass__init__fields__25__annotation,
    __dataclass__init__fields__25__default,
    __dataclass__init__fields__26__annotation,
    __dataclass__init__fields__26__default,
    __dataclass__init__fields__27__annotation,
    __dataclass__init__fields__27__default,
    __dataclass__init__fields__28__annotation,
    __dataclass__init__fields__28__default,
    __dataclass__init__fields__29__annotation,
    __dataclass__init__fields__29__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__30__annotation,
    __dataclass__init__fields__30__default,
    __dataclass__init__fields__31__annotation,
    __dataclass__init__fields__31__default,
    __dataclass__init__fields__32__annotation,
    __dataclass__init__fields__32__default,
    __dataclass__init__fields__33__annotation,
    __dataclass__init__fields__33__default,
    __dataclass__init__fields__34__annotation,
    __dataclass__init__fields__34__default,
    __dataclass__init__fields__35__annotation,
    __dataclass__init__fields__35__default,
    __dataclass__init__fields__36__annotation,
    __dataclass__init__fields__36__default,
    __dataclass__init__fields__37__annotation,
    __dataclass__init__fields__37__default,
    __dataclass__init__fields__38__annotation,
    __dataclass__init__fields__38__default,
    __dataclass__init__fields__39__annotation,
    __dataclass__init__fields__39__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__40__annotation,
    __dataclass__init__fields__40__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            function_name=self.function_name,
            function_arn=self.function_arn,
            runtime=self.runtime,
            role=self.role,
            handler=self.handler,
            code_size=self.code_size,
            description=self.description,
            timeout=self.timeout,
            memory_size=self.memory_size,
            last_modified=self.last_modified,
            code_sha256=self.code_sha256,
            version=self.version,
            vpc_config=self.vpc_config,
            dead_letter_config=self.dead_letter_config,
            environment=self.environment,
            kms_key_arn=self.kms_key_arn,
            tracing_config=self.tracing_config,
            master_arn=self.master_arn,
            revision_id=self.revision_id,
            layers=self.layers,
            state=self.state,
            state_reason=self.state_reason,
            state_reason_code=self.state_reason_code,
            last_update_status=self.last_update_status,
            last_update_status_reason=self.last_update_status_reason,
            last_update_status_reason_code=self.last_update_status_reason_code,
            file_system_configs=self.file_system_configs,
            package_type=self.package_type,
            image_config_response=self.image_config_response,
            signing_profile_version_arn=self.signing_profile_version_arn,
            signing_job_arn=self.signing_job_arn,
            architectures=self.architectures,
            ephemeral_storage=self.ephemeral_storage,
            snap_start=self.snap_start,
            runtime_version_config=self.runtime_version_config,
            logging_config=self.logging_config,
            capacity_provider_config=self.capacity_provider_config,
            config_sha256=self.config_sha256,
            durable_config=self.durable_config,
            tenancy_config=self.tenancy_config,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.function_name == other.function_name and
            self.function_arn == other.function_arn and
            self.runtime == other.runtime and
            self.role == other.role and
            self.handler == other.handler and
            self.code_size == other.code_size and
            self.description == other.description and
            self.timeout == other.timeout and
            self.memory_size == other.memory_size and
            self.last_modified == other.last_modified and
            self.code_sha256 == other.code_sha256 and
            self.version == other.version and
            self.vpc_config == other.vpc_config and
            self.dead_letter_config == other.dead_letter_config and
            self.environment == other.environment and
            self.kms_key_arn == other.kms_key_arn and
            self.tracing_config == other.tracing_config and
            self.master_arn == other.master_arn and
            self.revision_id == other.revision_id and
            self.layers == other.layers and
            self.state == other.state and
            self.state_reason == other.state_reason and
            self.state_reason_code == other.state_reason_code and
            self.last_update_status == other.last_update_status and
            self.last_update_status_reason == other.last_update_status_reason and
            self.last_update_status_reason_code == other.last_update_status_reason_code and
            self.file_system_configs == other.file_system_configs and
            self.package_type == other.package_type and
            self.image_config_response == other.image_config_response and
            self.signing_profile_version_arn == other.signing_profile_version_arn and
            self.signing_job_arn == other.signing_job_arn and
            self.architectures == other.architectures and
            self.ephemeral_storage == other.ephemeral_storage and
            self.snap_start == other.snap_start and
            self.runtime_version_config == other.runtime_version_config and
            self.logging_config == other.logging_config and
            self.capacity_provider_config == other.capacity_provider_config and
            self.config_sha256 == other.config_sha256 and
            self.durable_config == other.durable_config and
            self.tenancy_config == other.tenancy_config
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'function_name',
        'function_arn',
        'runtime',
        'role',
        'handler',
        'code_size',
        'description',
        'timeout',
        'memory_size',
        'last_modified',
        'code_sha256',
        'version',
        'vpc_config',
        'dead_letter_config',
        'environment',
        'kms_key_arn',
        'tracing_config',
        'master_arn',
        'revision_id',
        'layers',
        'state',
        'state_reason',
        'state_reason_code',
        'last_update_status',
        'last_update_status_reason',
        'last_update_status_reason_code',
        'file_system_configs',
        'package_type',
        'image_config_response',
        'signing_profile_version_arn',
        'signing_job_arn',
        'architectures',
        'ephemeral_storage',
        'snap_start',
        'runtime_version_config',
        'logging_config',
        'capacity_provider_config',
        'config_sha256',
        'durable_config',
        'tenancy_config',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'function_name',
        'function_arn',
        'runtime',
        'role',
        'handler',
        'code_size',
        'description',
        'timeout',
        'memory_size',
        'last_modified',
        'code_sha256',
        'version',
        'vpc_config',
        'dead_letter_config',
        'environment',
        'kms_key_arn',
        'tracing_config',
        'master_arn',
        'revision_id',
        'layers',
        'state',
        'state_reason',
        'state_reason_code',
        'last_update_status',
        'last_update_status_reason',
        'last_update_status_reason_code',
        'file_system_configs',
        'package_type',
        'image_config_response',
        'signing_profile_version_arn',
        'signing_job_arn',
        'architectures',
        'ephemeral_storage',
        'snap_start',
        'runtime_version_config',
        'logging_config',
        'capacity_provider_config',
        'config_sha256',
        'durable_config',
        'tenancy_config',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.function_name,
            self.function_arn,
            self.runtime,
            self.role,
            self.handler,
            self.code_size,
            self.description,
            self.timeout,
            self.memory_size,
            self.last_modified,
            self.code_sha256,
            self.version,
            self.vpc_config,
            self.dead_letter_config,
            self.environment,
            self.kms_key_arn,
            self.tracing_config,
            self.master_arn,
            self.revision_id,
            self.layers,
            self.state,
            self.state_reason,
            self.state_reason_code,
            self.last_update_status,
            self.last_update_status_reason,
            self.last_update_status_reason_code,
            self.file_system_configs,
            self.package_type,
            self.image_config_response,
            self.signing_profile_version_arn,
            self.signing_job_arn,
            self.architectures,
            self.ephemeral_storage,
            self.snap_start,
            self.runtime_version_config,
            self.logging_config,
            self.capacity_provider_config,
            self.config_sha256,
            self.durable_config,
            self.tenancy_config,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        function_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        function_arn: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        runtime: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        role: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        handler: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        code_size: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        description: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        timeout: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        memory_size: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        last_modified: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        code_sha256: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        version: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        vpc_config: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        dead_letter_config: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        environment: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        kms_key_arn: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        tracing_config: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        master_arn: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        revision_id: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        layers: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        state: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
        state_reason: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
        state_reason_code: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
        last_update_status: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
        last_update_status_reason: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
        last_update_status_reason_code: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
        file_system_configs: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
        package_type: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
        image_config_response: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
        signing_profile_version_arn: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
        signing_job_arn: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
        architectures: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
        ephemeral_storage: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
        snap_start: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
        runtime_version_config: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
        logging_config: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
        capacity_provider_config: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
        config_sha256: __dataclass__init__fields__38__annotation = __dataclass__init__fields__38__default,
        durable_config: __dataclass__init__fields__39__annotation = __dataclass__init__fields__39__default,
        tenancy_config: __dataclass__init__fields__40__annotation = __dataclass__init__fields__40__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'function_name', function_name)
        __dataclass__object_setattr(self, 'function_arn', function_arn)
        __dataclass__object_setattr(self, 'runtime', runtime)
        __dataclass__object_setattr(self, 'role', role)
        __dataclass__object_setattr(self, 'handler', handler)
        __dataclass__object_setattr(self, 'code_size', code_size)
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'timeout', timeout)
        __dataclass__object_setattr(self, 'memory_size', memory_size)
        __dataclass__object_setattr(self, 'last_modified', last_modified)
        __dataclass__object_setattr(self, 'code_sha256', code_sha256)
        __dataclass__object_setattr(self, 'version', version)
        __dataclass__object_setattr(self, 'vpc_config', vpc_config)
        __dataclass__object_setattr(self, 'dead_letter_config', dead_letter_config)
        __dataclass__object_setattr(self, 'environment', environment)
        __dataclass__object_setattr(self, 'kms_key_arn', kms_key_arn)
        __dataclass__object_setattr(self, 'tracing_config', tracing_config)
        __dataclass__object_setattr(self, 'master_arn', master_arn)
        __dataclass__object_setattr(self, 'revision_id', revision_id)
        __dataclass__object_setattr(self, 'layers', layers)
        __dataclass__object_setattr(self, 'state', state)
        __dataclass__object_setattr(self, 'state_reason', state_reason)
        __dataclass__object_setattr(self, 'state_reason_code', state_reason_code)
        __dataclass__object_setattr(self, 'last_update_status', last_update_status)
        __dataclass__object_setattr(self, 'last_update_status_reason', last_update_status_reason)
        __dataclass__object_setattr(self, 'last_update_status_reason_code', last_update_status_reason_code)
        __dataclass__object_setattr(self, 'file_system_configs', file_system_configs)
        __dataclass__object_setattr(self, 'package_type', package_type)
        __dataclass__object_setattr(self, 'image_config_response', image_config_response)
        __dataclass__object_setattr(self, 'signing_profile_version_arn', signing_profile_version_arn)
        __dataclass__object_setattr(self, 'signing_job_arn', signing_job_arn)
        __dataclass__object_setattr(self, 'architectures', architectures)
        __dataclass__object_setattr(self, 'ephemeral_storage', ephemeral_storage)
        __dataclass__object_setattr(self, 'snap_start', snap_start)
        __dataclass__object_setattr(self, 'runtime_version_config', runtime_version_config)
        __dataclass__object_setattr(self, 'logging_config', logging_config)
        __dataclass__object_setattr(self, 'capacity_provider_config', capacity_provider_config)
        __dataclass__object_setattr(self, 'config_sha256', config_sha256)
        __dataclass__object_setattr(self, 'durable_config', durable_config)
        __dataclass__object_setattr(self, 'tenancy_config', tenancy_config)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"function_name={self.function_name!r}")
        parts.append(f"function_arn={self.function_arn!r}")
        parts.append(f"runtime={self.runtime!r}")
        parts.append(f"role={self.role!r}")
        parts.append(f"handler={self.handler!r}")
        parts.append(f"code_size={self.code_size!r}")
        parts.append(f"description={self.description!r}")
        parts.append(f"timeout={self.timeout!r}")
        parts.append(f"memory_size={self.memory_size!r}")
        parts.append(f"last_modified={self.last_modified!r}")
        parts.append(f"code_sha256={self.code_sha256!r}")
        parts.append(f"version={self.version!r}")
        parts.append(f"vpc_config={self.vpc_config!r}")
        parts.append(f"dead_letter_config={self.dead_letter_config!r}")
        parts.append(f"environment={self.environment!r}")
        parts.append(f"kms_key_arn={self.kms_key_arn!r}")
        parts.append(f"tracing_config={self.tracing_config!r}")
        parts.append(f"master_arn={self.master_arn!r}")
        parts.append(f"revision_id={self.revision_id!r}")
        parts.append(f"layers={self.layers!r}")
        parts.append(f"state={self.state!r}")
        parts.append(f"state_reason={self.state_reason!r}")
        parts.append(f"state_reason_code={self.state_reason_code!r}")
        parts.append(f"last_update_status={self.last_update_status!r}")
        parts.append(f"last_update_status_reason={self.last_update_status_reason!r}")
        parts.append(f"last_update_status_reason_code={self.last_update_status_reason_code!r}")
        parts.append(f"file_system_configs={self.file_system_configs!r}")
        parts.append(f"package_type={self.package_type!r}")
        parts.append(f"image_config_response={self.image_config_response!r}")
        parts.append(f"signing_profile_version_arn={self.signing_profile_version_arn!r}")
        parts.append(f"signing_job_arn={self.signing_job_arn!r}")
        parts.append(f"architectures={self.architectures!r}")
        parts.append(f"ephemeral_storage={self.ephemeral_storage!r}")
        parts.append(f"snap_start={self.snap_start!r}")
        parts.append(f"runtime_version_config={self.runtime_version_config!r}")
        parts.append(f"logging_config={self.logging_config!r}")
        parts.append(f"capacity_provider_config={self.capacity_provider_config!r}")
        parts.append(f"config_sha256={self.config_sha256!r}")
        parts.append(f"durable_config={self.durable_config!r}")
        parts.append(f"tenancy_config={self.tenancy_config!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('next_marker', 'functions')), EqPlan(fields=('next_marker', 'functions')), FrozenPlan("
    "fields=('__shape__', 'next_marker', 'functions'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields"
    "=('next_marker', 'functions'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(na"
    "me='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_marker', annotation=OpRef(nam"
    "e='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='funct"
    "ions', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None))"
    ", self_param='self', std_params=(), kw_only_params=('next_marker', 'functions'), frozen=True, slots=False, post_in"
    "it_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='next_marker', kw_only=True, f"
    "n=None), ReprPlan.Field(name='functions', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2flambda_00_2fListFunctionsResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            next_marker=self.next_marker,
            functions=self.functions,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.next_marker == other.next_marker and
            self.functions == other.functions
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'next_marker',
        'functions',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'next_marker',
        'functions',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.next_marker,
            self.functions,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        next_marker: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        functions: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'next_marker', next_marker)
        __dataclass__object_setattr(self, 'functions', functions)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"next_marker={self.next_marker!r}")
        parts.append(f"functions={self.functions!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fAuthorizationNotFoundFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fBackupPolicyNotFoundFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fCertificateNotFoundFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDBClusterNotFoundFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDBInstanceAlreadyExistsFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDBInstanceAutomatedBackupQuotaExceededFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDBInstanceNotFoundFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDBParameterGroupNotFoundFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDBSecurityGroupNotFoundFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDBSnapshotAlreadyExistsFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDBSubnetGroupDoesNotCoverEnoughAZs(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDBSubnetGroupNotFoundFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDomainNotFoundFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fInstanceQuotaExceededFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fInsufficientDBInstanceCapacityFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fInvalidDBClusterStateFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fInvalidDBInstanceStateFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fInvalidSubnet(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fInvalidVPCNetworkStateFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fKMSKeyNotAccessibleFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fNetworkTypeNotSupported(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fOptionGroupNotFoundFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fProvisionedIopsNotAvailableInAZFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fSnapshotQuotaExceededFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fStorageQuotaExceededFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fStorageTypeNotSupportedFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fTenantDatabaseQuotaExceededFault(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fVpcEncryptionControlViolationException(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('volume_name', 'allocated_storage', 'io_p_s', 'max_allocated_storage', 'storage_throug"
    "hput', 'storage_type')), EqPlan(fields=('volume_name', 'allocated_storage', 'io_p_s', 'max_allocated_storage', 'st"
    "orage_throughput', 'storage_type')), FrozenPlan(fields=('__shape__', 'volume_name', 'allocated_storage', 'io_p_s',"
    " 'max_allocated_storage', 'storage_throughput', 'storage_type'), allow_dynamic_dunder_attrs=False), HashPlan(actio"
    "n='add', fields=('volume_name', 'allocated_storage', 'io_p_s', 'max_allocated_storage', 'storage_throughput', 'sto"
    "rage_type'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0."
    "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='volume_name', annotation=OpRef(name='init.fields.1.a"
    "nnotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='allocated_storage', annotation=OpRef(name='init.fields"
    ".2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='io_p_s', annotation"
    "=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=T"
    "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
    "ame='max_allocated_storage', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='storage_throughput', annotation=OpRef(name='init.fields.5.annotation')"
    ", default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
    "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='storage_type', annotation=OpRef(na"
    "me='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_p"
    "arams=(), kw_only_params=('volume_name', 'allocated_storage', 'io_p_s', 'max_allocated_storage', 'storage_throughp"
    "ut', 'storage_type'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fie"
    "lds=(ReprPlan.Field(name='volume_name', kw_only=True, fn=None), ReprPlan.Field(name='allocated_storage', kw_only=T"
    "rue, fn=None), ReprPlan.Field(name='io_p_s', kw_only=True, fn=None), ReprPlan.Field(name='max_allocated_storage', "
    "kw_only=True, fn=None), ReprPlan.Field(name='storage_throughput', kw_only=True, fn=None), ReprPlan.Field(name='sto"
    "rage_type', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fAdditionalStorageVolume(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            volume_name=self.volume_name,
            allocated_storage=self.allocated_storage,
            io_p_s=self.io_p_s,
            max_allocated_storage=self.max_allocated_storage,
            storage_throughput=self.storage_throughput,
            storage_type=self.storage_type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.volume_name == other.volume_name and
            self.allocated_storage == other.allocated_storage and
            self.io_p_s == other.io_p_s and
            self.max_allocated_storage == other.max_allocated_storage and
            self.storage_throughput == other.storage_throughput and
            self.storage_type == other.storage_type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'volume_name',
        'allocated_storage',
        'io_p_s',
        'max_allocated_storage',
        'storage_throughput',
        'storage_type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'volume_name',
        'allocated_storage',
        'io_p_s',
        'max_allocated_storage',
        'storage_throughput',
        'storage_type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.volume_name,
            self.allocated_storage,
            self.io_p_s,
            self.max_allocated_storage,
            self.storage_throughput,
            self.storage_type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        volume_name: __dataclass__init__fields__1__annotation,
        allocated_storage: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        io_p_s: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        max_allocated_storage: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        storage_throughput: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        storage_type: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'volume_name', volume_name)
        __dataclass__object_setattr(self, 'allocated_storage', allocated_storage)
        __dataclass__object_setattr(self, 'io_p_s', io_p_s)
        __dataclass__object_setattr(self, 'max_allocated_storage', max_allocated_storage)
        __dataclass__object_setattr(self, 'storage_throughput', storage_throughput)
        __dataclass__object_setattr(self, 'storage_type', storage_type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"volume_name={self.volume_name!r}")
        parts.append(f"allocated_storage={self.allocated_storage!r}")
        parts.append(f"io_p_s={self.io_p_s!r}")
        parts.append(f"max_allocated_storage={self.max_allocated_storage!r}")
        parts.append(f"storage_throughput={self.storage_throughput!r}")
        parts.append(f"storage_type={self.storage_type!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('volume_name', 'storage_volume_status', 'allocated_storage', 'io_p_s', 'max_allocated_"
    "storage', 'storage_throughput', 'storage_type')), EqPlan(fields=('volume_name', 'storage_volume_status', 'allocate"
    "d_storage', 'io_p_s', 'max_allocated_storage', 'storage_throughput', 'storage_type')), FrozenPlan(fields=('__shape"
    "__', 'volume_name', 'storage_volume_status', 'allocated_storage', 'io_p_s', 'max_allocated_storage', 'storage_thro"
    "ughput', 'storage_type'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('volume_name', 'storag"
    "e_volume_status', 'allocated_storage', 'io_p_s', 'max_allocated_storage', 'storage_throughput', 'storage_type'), c"
    "ache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), "
    "default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='volume_name', annotation=OpRef(name='init.fields.1.annotation'), d"
    "efault=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType."
    "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='storage_volume_status', annotation=Op"
    "Ref(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True"
    ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='allocated_storage', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default"
    "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None), InitPlan.Field(name='io_p_s', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(nam"
    "e='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='max_allocated_storage', annotation=OpRef(name='init.f"
    "ields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='storage_throug"
    "hput', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='storage_type', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.f"
    "ields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('volume_name', 'storage_volume_s"
    "tatus', 'allocated_storage', 'io_p_s', 'max_allocated_storage', 'storage_throughput', 'storage_type'), frozen=True"
    ", slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='volume_"
    "name', kw_only=True, fn=None), ReprPlan.Field(name='storage_volume_status', kw_only=True, fn=None), ReprPlan.Field"
    "(name='allocated_storage', kw_only=True, fn=None), ReprPlan.Field(name='io_p_s', kw_only=True, fn=None), ReprPlan."
    "Field(name='max_allocated_storage', kw_only=True, fn=None), ReprPlan.Field(name='storage_throughput', kw_only=True"
    ", fn=None), ReprPlan.Field(name='storage_type', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fAdditionalStorageVolumeOutput(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            volume_name=self.volume_name,
            storage_volume_status=self.storage_volume_status,
            allocated_storage=self.allocated_storage,
            io_p_s=self.io_p_s,
            max_allocated_storage=self.max_allocated_storage,
            storage_throughput=self.storage_throughput,
            storage_type=self.storage_type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.volume_name == other.volume_name and
            self.storage_volume_status == other.storage_volume_status and
            self.allocated_storage == other.allocated_storage and
            self.io_p_s == other.io_p_s and
            self.max_allocated_storage == other.max_allocated_storage and
            self.storage_throughput == other.storage_throughput and
            self.storage_type == other.storage_type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'volume_name',
        'storage_volume_status',
        'allocated_storage',
        'io_p_s',
        'max_allocated_storage',
        'storage_throughput',
        'storage_type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'volume_name',
        'storage_volume_status',
        'allocated_storage',
        'io_p_s',
        'max_allocated_storage',
        'storage_throughput',
        'storage_type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.volume_name,
            self.storage_volume_status,
            self.allocated_storage,
            self.io_p_s,
            self.max_allocated_storage,
            self.storage_throughput,
            self.storage_type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        volume_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        storage_volume_status: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        allocated_storage: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        io_p_s: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        max_allocated_storage: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        storage_throughput: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        storage_type: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'volume_name', volume_name)
        __dataclass__object_setattr(self, 'storage_volume_status', storage_volume_status)
        __dataclass__object_setattr(self, 'allocated_storage', allocated_storage)
        __dataclass__object_setattr(self, 'io_p_s', io_p_s)
        __dataclass__object_setattr(self, 'max_allocated_storage', max_allocated_storage)
        __dataclass__object_setattr(self, 'storage_throughput', storage_throughput)
        __dataclass__object_setattr(self, 'storage_type', storage_type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"volume_name={self.volume_name!r}")
        parts.append(f"storage_volume_status={self.storage_volume_status!r}")
        parts.append(f"allocated_storage={self.allocated_storage!r}")
        parts.append(f"io_p_s={self.io_p_s!r}")
        parts.append(f"max_allocated_storage={self.max_allocated_storage!r}")
        parts.append(f"storage_throughput={self.storage_throughput!r}")
        parts.append(f"storage_type={self.storage_type!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name',)), EqPlan(fields=('name',)), FrozenPlan(fields=('__shape__', 'name'), allow_dy"
    "namic_dunder_attrs=False), HashPlan(action='add', fields=('name',), cache=False), InitPlan(fields=(InitPlan.Field("
    "name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True"
    ", override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
    "e='name', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e)), self_param='self', std_params=(), kw_only_params=('name',), frozen=True, slots=False, post_init_params=None, "
    "init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_only=True, fn=None),), id=False, te"
    "rse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fAvailabilityZone(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ca_identifier', 'valid_till')), EqPlan(fields=('ca_identifier', 'valid_till')), Froze"
    "nPlan(fields=('__shape__', 'ca_identifier', 'valid_till'), allow_dynamic_dunder_attrs=False), HashPlan(action='add"
    "', fields=('ca_identifier', 'valid_till'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotat"
    "ion=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ca_identifier', annota"
    "tion=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='valid_till', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default"
    "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None)), self_param='self', std_params=(), kw_only_params=('ca_identifier', 'valid_till'), frozen=True, sl"
    "ots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ca_identifi"
    "er', kw_only=True, fn=None), ReprPlan.Field(name='valid_till', kw_only=True, fn=None)), id=False, terse=False, def"
    "ault_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fCertificateDetails(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ca_identifier=self.ca_identifier,
            valid_till=self.valid_till,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ca_identifier == other.ca_identifier and
            self.valid_till == other.valid_till
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'ca_identifier',
        'valid_till',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'ca_identifier',
        'valid_till',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ca_identifier,
            self.valid_till,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ca_identifier: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        valid_till: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ca_identifier', ca_identifier)
        __dataclass__object_setattr(self, 'valid_till', valid_till)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ca_identifier={self.ca_identifier!r}")
        parts.append(f"valid_till={self.valid_till!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('db_instance_automated_backups_arn',)), EqPlan(fields=('db_instance_automated_backups_"
    "arn',)), FrozenPlan(fields=('__shape__', 'db_instance_automated_backups_arn'), allow_dynamic_dunder_attrs=False), "
    "HashPlan(action='add', fields=('db_instance_automated_backups_arn',), cache=False), InitPlan(fields=(InitPlan.Fiel"
    "d(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
    "ame='db_instance_automated_backups_arn', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='in"
    "it.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
    ", validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('db_instance_automated_backu"
    "ps_arn',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPl"
    "an.Field(name='db_instance_automated_backups_arn', kw_only=True, fn=None),), id=False, terse=False, default_fn=Non"
    "e)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDBInstanceAutomatedBackupsReplication(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            db_instance_automated_backups_arn=self.db_instance_automated_backups_arn,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.db_instance_automated_backups_arn == other.db_instance_automated_backups_arn
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'db_instance_automated_backups_arn',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'db_instance_automated_backups_arn',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.db_instance_automated_backups_arn,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        db_instance_automated_backups_arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'db_instance_automated_backups_arn', db_instance_automated_backups_arn)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"db_instance_automated_backups_arn={self.db_instance_automated_backups_arn!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('role_arn', 'feature_name', 'status')), EqPlan(fields=('role_arn', 'feature_name', 'st"
    "atus')), FrozenPlan(fields=('__shape__', 'role_arn', 'feature_name', 'status'), allow_dynamic_dunder_attrs=False),"
    " HashPlan(action='add', fields=('role_arn', 'feature_name', 'status'), cache=False), InitPlan(fields=(InitPlan.Fie"
    "ld(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=T"
    "rue, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='role_arn', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None), InitPlan.Field(name='feature_name', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(na"
    "me='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='status', annotation=OpRef(name='init.fields.3.annota"
    "tion'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=F"
    "ieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params"
    "=('role_arn', 'feature_name', 'status'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fn"
    "s=()), ReprPlan(fields=(ReprPlan.Field(name='role_arn', kw_only=True, fn=None), ReprPlan.Field(name='feature_name'"
    ", kw_only=True, fn=None), ReprPlan.Field(name='status', kw_only=True, fn=None)), id=False, terse=False, default_fn"
    "=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDBInstanceRole(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            role_arn=self.role_arn,
            feature_name=self.feature_name,
            status=self.status,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.role_arn == other.role_arn and
            self.feature_name == other.feature_name and
            self.status == other.status
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'role_arn',
        'feature_name',
        'status',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'role_arn',
        'feature_name',
        'status',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.role_arn,
            self.feature_name,
            self.status,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        role_arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        feature_name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        status: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'role_arn', role_arn)
        __dataclass__object_setattr(self, 'feature_name', feature_name)
        __dataclass__object_setattr(self, 'status', status)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"role_arn={self.role_arn!r}")
        parts.append(f"feature_name={self.feature_name!r}")
        parts.append(f"status={self.status!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('status_type', 'normal', 'status', 'message')), EqPlan(fields=('status_type', 'normal'"
    ", 'status', 'message')), FrozenPlan(fields=('__shape__', 'status_type', 'normal', 'status', 'message'), allow_dyna"
    "mic_dunder_attrs=False), HashPlan(action='add', fields=('status_type', 'normal', 'status', 'message'), cache=False"
    "), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=No"
    "ne, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='status_type', annotation=OpRef(name='init.fields.1.annotation'), default=OpR"
    "ef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None), InitPlan.Field(name='normal', annotation=OpRef(name='init.fields.2.a"
    "nnotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='status', annotation=OpR"
    "ef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True,"
    " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
    "'message', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default"
    "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
    "ne)), self_param='self', std_params=(), kw_only_params=('status_type', 'normal', 'status', 'message'), frozen=True"
    ", slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='status_"
    "type', kw_only=True, fn=None), ReprPlan.Field(name='normal', kw_only=True, fn=None), ReprPlan.Field(name='status',"
    " kw_only=True, fn=None), ReprPlan.Field(name='message', kw_only=True, fn=None)), id=False, terse=False, default_fn"
    "=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDBInstanceStatusInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            status_type=self.status_type,
            normal=self.normal,
            status=self.status,
            message=self.message,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.status_type == other.status_type and
            self.normal == other.normal and
            self.status == other.status and
            self.message == other.message
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'status_type',
        'normal',
        'status',
        'message',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'status_type',
        'normal',
        'status',
        'message',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.status_type,
            self.normal,
            self.status,
            self.message,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        status_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        normal: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        status: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        message: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'status_type', status_type)
        __dataclass__object_setattr(self, 'normal', normal)
        __dataclass__object_setattr(self, 'status', status)
        __dataclass__object_setattr(self, 'message', message)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"status_type={self.status_type!r}")
        parts.append(f"normal={self.normal!r}")
        parts.append(f"status={self.status!r}")
        parts.append(f"message={self.message!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('db_parameter_group_name', 'parameter_apply_status')), EqPlan(fields=('db_parameter_gr"
    "oup_name', 'parameter_apply_status')), FrozenPlan(fields=('__shape__', 'db_parameter_group_name', 'parameter_apply"
    "_status'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('db_parameter_group_name', 'parameter"
    "_apply_status'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.field"
    "s.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='db_parameter_group_name', annotation=OpRef(name="
    "'init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='paramet"
    "er_apply_status', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None)), self_param='self', std_params=(), kw_only_params=('db_parameter_group_name', 'parameter_apply_status'"
    "), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field"
    "(name='db_parameter_group_name', kw_only=True, fn=None), ReprPlan.Field(name='parameter_apply_status', kw_only=Tru"
    "e, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDBParameterGroupStatus(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            db_parameter_group_name=self.db_parameter_group_name,
            parameter_apply_status=self.parameter_apply_status,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.db_parameter_group_name == other.db_parameter_group_name and
            self.parameter_apply_status == other.parameter_apply_status
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'db_parameter_group_name',
        'parameter_apply_status',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'db_parameter_group_name',
        'parameter_apply_status',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.db_parameter_group_name,
            self.parameter_apply_status,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        db_parameter_group_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        parameter_apply_status: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'db_parameter_group_name', db_parameter_group_name)
        __dataclass__object_setattr(self, 'parameter_apply_status', parameter_apply_status)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"db_parameter_group_name={self.db_parameter_group_name!r}")
        parts.append(f"parameter_apply_status={self.parameter_apply_status!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('db_security_group_name', 'status')), EqPlan(fields=('db_security_group_name', 'status"
    "')), FrozenPlan(fields=('__shape__', 'db_security_group_name', 'status'), allow_dynamic_dunder_attrs=False), HashP"
    "lan(action='add', fields=('db_security_group_name', 'status'), cache=False), InitPlan(fields=(InitPlan.Field(name="
    "'__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db"
    "_security_group_name', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defaul"
    "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='status', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(na"
    "me='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
    "e=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('db_security_group_nam"
    "e', 'status'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Re"
    "prPlan.Field(name='db_security_group_name', kw_only=True, fn=None), ReprPlan.Field(name='status', kw_only=True, fn"
    "=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDBSecurityGroupMembership(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            db_security_group_name=self.db_security_group_name,
            status=self.status,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.db_security_group_name == other.db_security_group_name and
            self.status == other.status
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'db_security_group_name',
        'status',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'db_security_group_name',
        'status',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.db_security_group_name,
            self.status,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        db_security_group_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        status: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'db_security_group_name', db_security_group_name)
        __dataclass__object_setattr(self, 'status', status)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"db_security_group_name={self.db_security_group_name!r}")
        parts.append(f"status={self.status!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('db_instance_identifier', 'skip_final_snapshot', 'final_db_snapshot_identifier', 'dele"
    "te_automated_backups')), EqPlan(fields=('db_instance_identifier', 'skip_final_snapshot', 'final_db_snapshot_identi"
    "fier', 'delete_automated_backups')), FrozenPlan(fields=('__shape__', 'db_instance_identifier', 'skip_final_snapsho"
    "t', 'final_db_snapshot_identifier', 'delete_automated_backups'), allow_dynamic_dunder_attrs=False), HashPlan(actio"
    "n='add', fields=('db_instance_identifier', 'skip_final_snapshot', 'final_db_snapshot_identifier', 'delete_automate"
    "d_backups'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0."
    "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='db_instance_identifier', annotation=OpRef(name='init"
    ".fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='skip_final_snapshot', annotation=OpRef(name"
    "='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, overri"
    "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='final_"
    "db_snapshot_identifier', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='delete_automated_backups', annotation=OpRef(name='init.fields.4.annotation"
    "'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('d"
    "b_instance_identifier', 'skip_final_snapshot', 'final_db_snapshot_identifier', 'delete_automated_backups'), frozen"
    "=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db"
    "_instance_identifier', kw_only=True, fn=None), ReprPlan.Field(name='skip_final_snapshot', kw_only=True, fn=None), "
    "ReprPlan.Field(name='final_db_snapshot_identifier', kw_only=True, fn=None), ReprPlan.Field(name='delete_automated_"
    "backups', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDeleteDBInstanceMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            db_instance_identifier=self.db_instance_identifier,
            skip_final_snapshot=self.skip_final_snapshot,
            final_db_snapshot_identifier=self.final_db_snapshot_identifier,
            delete_automated_backups=self.delete_automated_backups,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.db_instance_identifier == other.db_instance_identifier and
            self.skip_final_snapshot == other.skip_final_snapshot and
            self.final_db_snapshot_identifier == other.final_db_snapshot_identifier and
            self.delete_automated_backups == other.delete_automated_backups
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'db_instance_identifier',
        'skip_final_snapshot',
        'final_db_snapshot_identifier',
        'delete_automated_backups',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'db_instance_identifier',
        'skip_final_snapshot',
        'final_db_snapshot_identifier',
        'delete_automated_backups',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.db_instance_identifier,
            self.skip_final_snapshot,
            self.final_db_snapshot_identifier,
            self.delete_automated_backups,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        db_instance_identifier: __dataclass__init__fields__1__annotation,
        skip_final_snapshot: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        final_db_snapshot_identifier: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        delete_automated_backups: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'db_instance_identifier', db_instance_identifier)
        __dataclass__object_setattr(self, 'skip_final_snapshot', skip_final_snapshot)
        __dataclass__object_setattr(self, 'final_db_snapshot_identifier', final_db_snapshot_identifier)
        __dataclass__object_setattr(self, 'delete_automated_backups', delete_automated_backups)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"db_instance_identifier={self.db_instance_identifier!r}")
        parts.append(f"skip_final_snapshot={self.skip_final_snapshot!r}")
        parts.append(f"final_db_snapshot_identifier={self.final_db_snapshot_identifier!r}")
        parts.append(f"delete_automated_backups={self.delete_automated_backups!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('address', 'port', 'hosted_zone_id')), EqPlan(fields=('address', 'port', 'hosted_zone_"
    "id')), FrozenPlan(fields=('__shape__', 'address', 'port', 'hosted_zone_id'), allow_dynamic_dunder_attrs=False), Ha"
    "shPlan(action='add', fields=('address', 'port', 'hosted_zone_id'), cache=False), InitPlan(fields=(InitPlan.Field(n"
    "ame='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True,"
    " override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='address', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='port', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fiel"
    "ds.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='hosted_zone_id', annotation=OpRef(name='init.fields.3.annotation'"
    "), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('ad"
    "dress', 'port', 'hosted_zone_id'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
    " ReprPlan(fields=(ReprPlan.Field(name='address', kw_only=True, fn=None), ReprPlan.Field(name='port', kw_only=True,"
    " fn=None), ReprPlan.Field(name='hosted_zone_id', kw_only=True, fn=None)), id=False, terse=False, default_fn=None))"
    ")"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fEndpoint(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            address=self.address,
            port=self.port,
            hosted_zone_id=self.hosted_zone_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.address == other.address and
            self.port == other.port and
            self.hosted_zone_id == other.hosted_zone_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'address',
        'port',
        'hosted_zone_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'address',
        'port',
        'hosted_zone_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.address,
            self.port,
            self.hosted_zone_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        address: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        port: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        hosted_zone_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'address', address)
        __dataclass__object_setattr(self, 'port', port)
        __dataclass__object_setattr(self, 'hosted_zone_id', hosted_zone_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"address={self.address!r}")
        parts.append(f"port={self.port!r}")
        parts.append(f"hosted_zone_id={self.hosted_zone_id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('secret_arn', 'secret_status', 'kms_key_id')), EqPlan(fields=('secret_arn', 'secret_st"
    "atus', 'kms_key_id')), FrozenPlan(fields=('__shape__', 'secret_arn', 'secret_status', 'kms_key_id'), allow_dynamic"
    "_dunder_attrs=False), HashPlan(action='add', fields=('secret_arn', 'secret_status', 'kms_key_id'), cache=False), I"
    "nitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, "
    "default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check"
    "_type=None), InitPlan.Field(name='secret_arn', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(na"
    "me='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='secret_status', annotation=OpRef(name='init.fields.2"
    ".annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field"
    "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='kms_key_id', annotati"
    "on=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='s"
    "elf', std_params=(), kw_only_params=('secret_arn', 'secret_status', 'kms_key_id'), frozen=True, slots=False, post_"
    "init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='secret_arn', kw_only=True, "
    "fn=None), ReprPlan.Field(name='secret_status', kw_only=True, fn=None), ReprPlan.Field(name='kms_key_id', kw_only=T"
    "rue, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fMasterUserSecret(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            secret_arn=self.secret_arn,
            secret_status=self.secret_status,
            kms_key_id=self.kms_key_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.secret_arn == other.secret_arn and
            self.secret_status == other.secret_status and
            self.kms_key_id == other.kms_key_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'secret_arn',
        'secret_status',
        'kms_key_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'secret_arn',
        'secret_status',
        'kms_key_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.secret_arn,
            self.secret_status,
            self.kms_key_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        secret_arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        secret_status: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        kms_key_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'secret_arn', secret_arn)
        __dataclass__object_setattr(self, 'secret_status', secret_status)
        __dataclass__object_setattr(self, 'kms_key_id', kms_key_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"secret_arn={self.secret_arn!r}")
        parts.append(f"secret_status={self.secret_status!r}")
        parts.append(f"kms_key_id={self.kms_key_id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('option_group_name', 'status')), EqPlan(fields=('option_group_name', 'status')), Froze"
    "nPlan(fields=('__shape__', 'option_group_name', 'status'), allow_dynamic_dunder_attrs=False), HashPlan(action='add"
    "', fields=('option_group_name', 'status'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotat"
    "ion=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='option_group_name', an"
    "notation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
    ".Field(name='status', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default"
    "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None)), self_param='self', std_params=(), kw_only_params=('option_group_name', 'status'), frozen=True, sl"
    "ots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='option_grou"
    "p_name', kw_only=True, fn=None), ReprPlan.Field(name='status', kw_only=True, fn=None)), id=False, terse=False, def"
    "ault_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fOptionGroupMembership(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            option_group_name=self.option_group_name,
            status=self.status,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.option_group_name == other.option_group_name and
            self.status == other.status
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'option_group_name',
        'status',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'option_group_name',
        'status',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.option_group_name,
            self.status,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        option_group_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        status: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'option_group_name', option_group_name)
        __dataclass__object_setattr(self, 'status', status)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"option_group_name={self.option_group_name!r}")
        parts.append(f"status={self.status!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('arn',)), EqPlan(fields=('arn',)), FrozenPlan(fields=('__shape__', 'arn'), allow_dynam"
    "ic_dunder_attrs=False), HashPlan(action='add', fields=('arn',), cache=False), InitPlan(fields=(InitPlan.Field(name"
    "='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, ov"
    "erride=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='a"
    "rn', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_facto"
    "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), "
    "self_param='self', std_params=(), kw_only_params=('arn',), frozen=True, slots=False, post_init_params=None, init_f"
    "ns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='arn', kw_only=True, fn=None),), id=False, terse=Fal"
    "se, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fOutpost(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            arn=self.arn,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.arn == other.arn
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'arn',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'arn',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.arn,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'arn', arn)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"arn={self.arn!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'value')), EqPlan(fields=('name', 'value')), FrozenPlan(fields=('__shape__', '"
    "name', 'value'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'value'), cache=False),"
    " InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None"
    ", default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, che"
    "ck_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='"
    "init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
    "ne, validate=None, check_type=None), InitPlan.Field(name='value', annotation=OpRef(name='init.fields.2.annotation'"
    "), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('na"
    "me', 'value'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Re"
    "prPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='value', kw_only=True, fn=None)), id=False, "
    "terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fProcessorFeature(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            value=self.value,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.value == other.value
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'name',
        'value',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'name',
        'value',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.value,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        value: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'value', value)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"value={self.value!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('db_instance_identifier', 'force_failover')), EqPlan(fields=('db_instance_identifier',"
    " 'force_failover')), FrozenPlan(fields=('__shape__', 'db_instance_identifier', 'force_failover'), allow_dynamic_du"
    "nder_attrs=False), HashPlan(action='add', fields=('db_instance_identifier', 'force_failover'), cache=False), InitP"
    "lan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='db_instance_identifier', annotation=OpRef(name='init.fields.1.annotation'), default="
    "None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
    "check_type=None), InitPlan.Field(name='force_failover', annotation=OpRef(name='init.fields.2.annotation'), default"
    "=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('db_instance_"
    "identifier', 'force_failover'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Re"
    "prPlan(fields=(ReprPlan.Field(name='db_instance_identifier', kw_only=True, fn=None), ReprPlan.Field(name='force_fa"
    "ilover', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fRebootDBInstanceMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            db_instance_identifier=self.db_instance_identifier,
            force_failover=self.force_failover,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.db_instance_identifier == other.db_instance_identifier and
            self.force_failover == other.force_failover
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'db_instance_identifier',
        'force_failover',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'db_instance_identifier',
        'force_failover',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.db_instance_identifier,
            self.force_failover,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        db_instance_identifier: __dataclass__init__fields__1__annotation,
        force_failover: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'db_instance_identifier', db_instance_identifier)
        __dataclass__object_setattr(self, 'force_failover', force_failover)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"db_instance_identifier={self.db_instance_identifier!r}")
        parts.append(f"force_failover={self.force_failover!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('db_instance_identifier',)), EqPlan(fields=('db_instance_identifier',)), FrozenPlan(fi"
    "elds=('__shape__', 'db_instance_identifier'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('d"
    "b_instance_identifier',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='i"
    "nit.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLA"
    "SS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_instance_identifier', annotation=OpR"
    "ef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=("
    "'db_instance_identifier',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPl"
    "an(fields=(ReprPlan.Field(name='db_instance_identifier', kw_only=True, fn=None),), id=False, terse=False, default_"
    "fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fStartDBInstanceMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            db_instance_identifier=self.db_instance_identifier,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.db_instance_identifier == other.db_instance_identifier
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'db_instance_identifier',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'db_instance_identifier',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.db_instance_identifier,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        db_instance_identifier: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'db_instance_identifier', db_instance_identifier)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"db_instance_identifier={self.db_instance_identifier!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('db_instance_identifier', 'db_snapshot_identifier')), EqPlan(fields=('db_instance_iden"
    "tifier', 'db_snapshot_identifier')), FrozenPlan(fields=('__shape__', 'db_instance_identifier', 'db_snapshot_identi"
    "fier'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('db_instance_identifier', 'db_snapshot_i"
    "dentifier'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0."
    "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='db_instance_identifier', annotation=OpRef(name='init"
    ".fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_snapshot_identifier', annotation=OpRef(n"
    "ame='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_"
    "params=(), kw_only_params=('db_instance_identifier', 'db_snapshot_identifier'), frozen=True, slots=False, post_ini"
    "t_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db_instance_identifier', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='db_snapshot_identifier', kw_only=True, fn=None)), id=False, terse=False, d"
    "efault_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fStopDBInstanceMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            db_instance_identifier=self.db_instance_identifier,
            db_snapshot_identifier=self.db_snapshot_identifier,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.db_instance_identifier == other.db_instance_identifier and
            self.db_snapshot_identifier == other.db_snapshot_identifier
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'db_instance_identifier',
        'db_snapshot_identifier',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'db_instance_identifier',
        'db_snapshot_identifier',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.db_instance_identifier,
            self.db_snapshot_identifier,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        db_instance_identifier: __dataclass__init__fields__1__annotation,
        db_snapshot_identifier: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'db_instance_identifier', db_instance_identifier)
        __dataclass__object_setattr(self, 'db_snapshot_identifier', db_snapshot_identifier)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"db_instance_identifier={self.db_instance_identifier!r}")
        parts.append(f"db_snapshot_identifier={self.db_snapshot_identifier!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('vpc_security_group_id', 'status')), EqPlan(fields=('vpc_security_group_id', 'status')"
    "), FrozenPlan(fields=('__shape__', 'vpc_security_group_id', 'status'), allow_dynamic_dunder_attrs=False), HashPlan"
    "(action='add', fields=('vpc_security_group_id', 'status'), cache=False), InitPlan(fields=(InitPlan.Field(name='__s"
    "hape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_se"
    "curity_group_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None), InitPlan.Field(name='status', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='i"
    "nit.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
    "e, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('vpc_security_group_id', 's"
    "tatus'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan"
    ".Field(name='vpc_security_group_id', kw_only=True, fn=None), ReprPlan.Field(name='status', kw_only=True, fn=None))"
    ", id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fVpcSecurityGroupMembership(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            vpc_security_group_id=self.vpc_security_group_id,
            status=self.status,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.vpc_security_group_id == other.vpc_security_group_id and
            self.status == other.status
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'vpc_security_group_id',
        'status',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'vpc_security_group_id',
        'status',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.vpc_security_group_id,
            self.status,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        vpc_security_group_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        status: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'vpc_security_group_id', vpc_security_group_id)
        __dataclass__object_setattr(self, 'status', status)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"vpc_security_group_id={self.vpc_security_group_id!r}")
        parts.append(f"status={self.status!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('domain', 'status', 'fqdn', 'iam_role_name', 'ou', 'auth_secret_arn', 'dns_ips')), EqP"
    "lan(fields=('domain', 'status', 'fqdn', 'iam_role_name', 'ou', 'auth_secret_arn', 'dns_ips')), FrozenPlan(fields=("
    "'__shape__', 'domain', 'status', 'fqdn', 'iam_role_name', 'ou', 'auth_secret_arn', 'dns_ips'), allow_dynamic_dunde"
    "r_attrs=False), HashPlan(action='add', fields=('domain', 'status', 'fqdn', 'iam_role_name', 'ou', 'auth_secret_arn"
    "', 'dns_ips'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields."
    "0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coe"
    "rce=None, validate=None, check_type=None), InitPlan.Field(name='domain', annotation=OpRef(name='init.fields.1.anno"
    "tation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type"
    "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='status', annotation=OpRef("
    "name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, ov"
    "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='fq"
    "dn', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_facto"
    "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
    "nitPlan.Field(name='iam_role_name', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fi"
    "elds.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='ou', annotation=OpRef(name='init.fields.5.annotation'), default"
    "=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='auth_secret_arn', annotation=OpRef(name='in"
    "it.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dns_ips', "
    "annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_"
    "param='self', std_params=(), kw_only_params=('domain', 'status', 'fqdn', 'iam_role_name', 'ou', 'auth_secret_arn',"
    " 'dns_ips'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Repr"
    "Plan.Field(name='domain', kw_only=True, fn=None), ReprPlan.Field(name='status', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='fqdn', kw_only=True, fn=None), ReprPlan.Field(name='iam_role_name', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='ou', kw_only=True, fn=None), ReprPlan.Field(name='auth_secret_arn', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='dns_ips', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDomainMembership(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            domain=self.domain,
            status=self.status,
            fqdn=self.fqdn,
            iam_role_name=self.iam_role_name,
            ou=self.ou,
            auth_secret_arn=self.auth_secret_arn,
            dns_ips=self.dns_ips,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.domain == other.domain and
            self.status == other.status and
            self.fqdn == other.fqdn and
            self.iam_role_name == other.iam_role_name and
            self.ou == other.ou and
            self.auth_secret_arn == other.auth_secret_arn and
            self.dns_ips == other.dns_ips
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'domain',
        'status',
        'fqdn',
        'iam_role_name',
        'ou',
        'auth_secret_arn',
        'dns_ips',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'domain',
        'status',
        'fqdn',
        'iam_role_name',
        'ou',
        'auth_secret_arn',
        'dns_ips',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.domain,
            self.status,
            self.fqdn,
            self.iam_role_name,
            self.ou,
            self.auth_secret_arn,
            self.dns_ips,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        domain: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        status: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        fqdn: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        iam_role_name: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ou: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        auth_secret_arn: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        dns_ips: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'domain', domain)
        __dataclass__object_setattr(self, 'status', status)
        __dataclass__object_setattr(self, 'fqdn', fqdn)
        __dataclass__object_setattr(self, 'iam_role_name', iam_role_name)
        __dataclass__object_setattr(self, 'ou', ou)
        __dataclass__object_setattr(self, 'auth_secret_arn', auth_secret_arn)
        __dataclass__object_setattr(self, 'dns_ips', dns_ips)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"domain={self.domain!r}")
        parts.append(f"status={self.status!r}")
        parts.append(f"fqdn={self.fqdn!r}")
        parts.append(f"iam_role_name={self.iam_role_name!r}")
        parts.append(f"ou={self.ou!r}")
        parts.append(f"auth_secret_arn={self.auth_secret_arn!r}")
        parts.append(f"dns_ips={self.dns_ips!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'values')), EqPlan(fields=('name', 'values')), FrozenPlan(fields=('__shape__',"
    " 'name', 'values'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'values'), cache=Fal"
    "se), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default="
    "None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation'), default=None, de"
    "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='values', annotation=OpRef(name='init.fields.2.annotation'), default=None, default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    ")), self_param='self', std_params=(), kw_only_params=('name', 'values'), frozen=True, slots=False, post_init_param"
    "s=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPl"
    "an.Field(name='values', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fFilter(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            values=self.values,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.values == other.values
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'name',
        'values',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'name',
        'values',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.values,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        name: __dataclass__init__fields__1__annotation,
        values: __dataclass__init__fields__2__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'values', values)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"values={self.values!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('log_types_to_enable', 'log_types_to_disable')), EqPlan(fields=('log_types_to_enable',"
    " 'log_types_to_disable')), FrozenPlan(fields=('__shape__', 'log_types_to_enable', 'log_types_to_disable'), allow_d"
    "ynamic_dunder_attrs=False), HashPlan(action='add', fields=('log_types_to_enable', 'log_types_to_disable'), cache=F"
    "alse), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defaul"
    "t=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=Non"
    "e, check_type=None), InitPlan.Field(name='log_types_to_enable', annotation=OpRef(name='init.fields.1.annotation'),"
    " default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='log_types_to_disable', annotation=O"
    "pRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=Tru"
    "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self'"
    ", std_params=(), kw_only_params=('log_types_to_enable', 'log_types_to_disable'), frozen=True, slots=False, post_in"
    "it_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='log_types_to_enable', kw_only"
    "=True, fn=None), ReprPlan.Field(name='log_types_to_disable', kw_only=True, fn=None)), id=False, terse=False, defau"
    "lt_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fPendingCloudwatchLogsExports(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            log_types_to_enable=self.log_types_to_enable,
            log_types_to_disable=self.log_types_to_disable,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.log_types_to_enable == other.log_types_to_enable and
            self.log_types_to_disable == other.log_types_to_disable
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'log_types_to_enable',
        'log_types_to_disable',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'log_types_to_enable',
        'log_types_to_disable',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.log_types_to_enable,
            self.log_types_to_disable,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        log_types_to_enable: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        log_types_to_disable: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'log_types_to_enable', log_types_to_enable)
        __dataclass__object_setattr(self, 'log_types_to_disable', log_types_to_disable)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"log_types_to_enable={self.log_types_to_enable!r}")
        parts.append(f"log_types_to_disable={self.log_types_to_disable!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('subnet_identifier', 'subnet_availability_zone', 'subnet_outpost', 'subnet_status')), "
    "EqPlan(fields=('subnet_identifier', 'subnet_availability_zone', 'subnet_outpost', 'subnet_status')), FrozenPlan(fi"
    "elds=('__shape__', 'subnet_identifier', 'subnet_availability_zone', 'subnet_outpost', 'subnet_status'), allow_dyna"
    "mic_dunder_attrs=False), HashPlan(action='add', fields=('subnet_identifier', 'subnet_availability_zone', 'subnet_o"
    "utpost', 'subnet_status'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='"
    "init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CL"
    "ASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnet_identifier', annotation=OpRef(n"
    "ame='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='sub"
    "net_availability_zone', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defau"
    "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
    "check_type=None), InitPlan.Field(name='subnet_outpost', annotation=OpRef(name='init.fields.3.annotation'), default"
    "=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnet_status', annotation=OpRef(name='init"
    ".fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=()"
    ", kw_only_params=('subnet_identifier', 'subnet_availability_zone', 'subnet_outpost', 'subnet_status'), frozen=True"
    ", slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='subnet_"
    "identifier', kw_only=True, fn=None), ReprPlan.Field(name='subnet_availability_zone', kw_only=True, fn=None), ReprP"
    "lan.Field(name='subnet_outpost', kw_only=True, fn=None), ReprPlan.Field(name='subnet_status', kw_only=True, fn=Non"
    "e)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fSubnet(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            subnet_identifier=self.subnet_identifier,
            subnet_availability_zone=self.subnet_availability_zone,
            subnet_outpost=self.subnet_outpost,
            subnet_status=self.subnet_status,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.subnet_identifier == other.subnet_identifier and
            self.subnet_availability_zone == other.subnet_availability_zone and
            self.subnet_outpost == other.subnet_outpost and
            self.subnet_status == other.subnet_status
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'subnet_identifier',
        'subnet_availability_zone',
        'subnet_outpost',
        'subnet_status',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'subnet_identifier',
        'subnet_availability_zone',
        'subnet_outpost',
        'subnet_status',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.subnet_identifier,
            self.subnet_availability_zone,
            self.subnet_outpost,
            self.subnet_status,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        subnet_identifier: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        subnet_availability_zone: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        subnet_outpost: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        subnet_status: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'subnet_identifier', subnet_identifier)
        __dataclass__object_setattr(self, 'subnet_availability_zone', subnet_availability_zone)
        __dataclass__object_setattr(self, 'subnet_outpost', subnet_outpost)
        __dataclass__object_setattr(self, 'subnet_status', subnet_status)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"subnet_identifier={self.subnet_identifier!r}")
        parts.append(f"subnet_availability_zone={self.subnet_availability_zone!r}")
        parts.append(f"subnet_outpost={self.subnet_outpost!r}")
        parts.append(f"subnet_status={self.subnet_status!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('db_name', 'db_instance_identifier', 'allocated_storage', 'db_instance_class', 'engine"
    "', 'master_username', 'master_user_password', 'db_security_groups', 'vpc_security_group_ids', 'availability_zone',"
    " 'db_subnet_group_name', 'preferred_maintenance_window', 'db_parameter_group_name', 'backup_retention_period', 'pr"
    "eferred_backup_window', 'port', 'multi_az', 'engine_version', 'auto_minor_version_upgrade', 'license_model', 'iops"
    "', 'storage_throughput', 'option_group_name', 'character_set_name', 'nchar_character_set_name', 'publicly_accessib"
    "le', 'tags', 'db_cluster_identifier', 'storage_type', 'tde_credential_arn', 'tde_credential_password', 'storage_en"
    "crypted', 'kms_key_id', 'domain', 'domain_fqdn', 'domain_ou', 'domain_auth_secret_arn', 'domain_dns_ips', 'copy_ta"
    "gs_to_snapshot', 'monitoring_interval', 'monitoring_role_arn', 'domain_iam_role_name', 'promotion_tier', 'timezone"
    "', 'enable_iam_database_authentication', 'database_insights_mode', 'enable_performance_insights', 'performance_ins"
    "ights_kms_key_id', 'performance_insights_retention_period', 'enable_cloudwatch_logs_exports', 'processor_features'"
    ", 'deletion_protection', 'max_allocated_storage', 'enable_customer_owned_ip', 'network_type', 'backup_target', 'cu"
    "stom_iam_instance_profile', 'db_system_id', 'ca_certificate_identifier', 'manage_master_user_password', 'master_us"
    "er_secret_kms_key_id', 'multi_tenant', 'dedicated_log_volume', 'engine_lifecycle_support', 'master_user_authentica"
    "tion_type', 'additional_storage_volumes')), EqPlan(fields=('db_name', 'db_instance_identifier', 'allocated_storage"
    "', 'db_instance_class', 'engine', 'master_username', 'master_user_password', 'db_security_groups', 'vpc_security_g"
    "roup_ids', 'availability_zone', 'db_subnet_group_name', 'preferred_maintenance_window', 'db_parameter_group_name',"
    " 'backup_retention_period', 'preferred_backup_window', 'port', 'multi_az', 'engine_version', 'auto_minor_version_u"
    "pgrade', 'license_model', 'iops', 'storage_throughput', 'option_group_name', 'character_set_name', 'nchar_characte"
    "r_set_name', 'publicly_accessible', 'tags', 'db_cluster_identifier', 'storage_type', 'tde_credential_arn', 'tde_cr"
    "edential_password', 'storage_encrypted', 'kms_key_id', 'domain', 'domain_fqdn', 'domain_ou', 'domain_auth_secret_a"
    "rn', 'domain_dns_ips', 'copy_tags_to_snapshot', 'monitoring_interval', 'monitoring_role_arn', 'domain_iam_role_nam"
    "e', 'promotion_tier', 'timezone', 'enable_iam_database_authentication', 'database_insights_mode', 'enable_performa"
    "nce_insights', 'performance_insights_kms_key_id', 'performance_insights_retention_period', 'enable_cloudwatch_logs"
    "_exports', 'processor_features', 'deletion_protection', 'max_allocated_storage', 'enable_customer_owned_ip', 'netw"
    "ork_type', 'backup_target', 'custom_iam_instance_profile', 'db_system_id', 'ca_certificate_identifier', 'manage_ma"
    "ster_user_password', 'master_user_secret_kms_key_id', 'multi_tenant', 'dedicated_log_volume', 'engine_lifecycle_su"
    "pport', 'master_user_authentication_type', 'additional_storage_volumes')), FrozenPlan(fields=('__shape__', 'db_nam"
    "e', 'db_instance_identifier', 'allocated_storage', 'db_instance_class', 'engine', 'master_username', 'master_user_"
    "password', 'db_security_groups', 'vpc_security_group_ids', 'availability_zone', 'db_subnet_group_name', 'preferred"
    "_maintenance_window', 'db_parameter_group_name', 'backup_retention_period', 'preferred_backup_window', 'port', 'mu"
    "lti_az', 'engine_version', 'auto_minor_version_upgrade', 'license_model', 'iops', 'storage_throughput', 'option_gr"
    "oup_name', 'character_set_name', 'nchar_character_set_name', 'publicly_accessible', 'tags', 'db_cluster_identifier"
    "', 'storage_type', 'tde_credential_arn', 'tde_credential_password', 'storage_encrypted', 'kms_key_id', 'domain', '"
    "domain_fqdn', 'domain_ou', 'domain_auth_secret_arn', 'domain_dns_ips', 'copy_tags_to_snapshot', 'monitoring_interv"
    "al', 'monitoring_role_arn', 'domain_iam_role_name', 'promotion_tier', 'timezone', 'enable_iam_database_authenticat"
    "ion', 'database_insights_mode', 'enable_performance_insights', 'performance_insights_kms_key_id', 'performance_ins"
    "ights_retention_period', 'enable_cloudwatch_logs_exports', 'processor_features', 'deletion_protection', 'max_alloc"
    "ated_storage', 'enable_customer_owned_ip', 'network_type', 'backup_target', 'custom_iam_instance_profile', 'db_sys"
    "tem_id', 'ca_certificate_identifier', 'manage_master_user_password', 'master_user_secret_kms_key_id', 'multi_tenan"
    "t', 'dedicated_log_volume', 'engine_lifecycle_support', 'master_user_authentication_type', 'additional_storage_vol"
    "umes'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('db_name', 'db_instance_identifier', 'al"
    "located_storage', 'db_instance_class', 'engine', 'master_username', 'master_user_password', 'db_security_groups', "
    "'vpc_security_group_ids', 'availability_zone', 'db_subnet_group_name', 'preferred_maintenance_window', 'db_paramet"
    "er_group_name', 'backup_retention_period', 'preferred_backup_window', 'port', 'multi_az', 'engine_version', 'auto_"
    "minor_version_upgrade', 'license_model', 'iops', 'storage_throughput', 'option_group_name', 'character_set_name', "
    "'nchar_character_set_name', 'publicly_accessible', 'tags', 'db_cluster_identifier', 'storage_type', 'tde_credentia"
    "l_arn', 'tde_credential_password', 'storage_encrypted', 'kms_key_id', 'domain', 'domain_fqdn', 'domain_ou', 'domai"
    "n_auth_secret_arn', 'domain_dns_ips', 'copy_tags_to_snapshot', 'monitoring_interval', 'monitoring_role_arn', 'doma"
    "in_iam_role_name', 'promotion_tier', 'timezone', 'enable_iam_database_authentication', 'database_insights_mode', '"
    "enable_performance_insights', 'performance_insights_kms_key_id', 'performance_insights_retention_period', 'enable_"
    "cloudwatch_logs_exports', 'processor_features', 'deletion_protection', 'max_allocated_storage', 'enable_customer_o"
    "wned_ip', 'network_type', 'backup_target', 'custom_iam_instance_profile', 'db_system_id', 'ca_certificate_identifi"
    "er', 'manage_master_user_password', 'master_user_secret_kms_key_id', 'multi_tenant', 'dedicated_log_volume', 'engi"
    "ne_lifecycle_support', 'master_user_authentication_type', 'additional_storage_volumes'), cache=False), InitPlan(fi"
    "elds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='db_name', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fiel"
    "ds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='db_instance_identifier', annotation=OpRef(name='init.fields.2.ann"
    "otation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
    "ne, validate=None, check_type=None), InitPlan.Field(name='allocated_storage', annotation=OpRef(name='init.fields.3"
    ".annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field"
    "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_instance_class', a"
    "nnotation=OpRef(name='init.fields.4.annotation'), default=None, default_factory=None, init=True, override=False, f"
    "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='engine', annotati"
    "on=OpRef(name='init.fields.5.annotation'), default=None, default_factory=None, init=True, override=False, field_ty"
    "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='master_username', annota"
    "tion=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='master_user_password', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields"
    ".7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None), InitPlan.Field(name='db_security_groups', annotation=OpRef(name='init.fields.8.annotatio"
    "n'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_security_group_ids', annota"
    "tion=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='availability_zone', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.1"
    "0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='db_subnet_group_name', annotation=OpRef(name='init.fields.11.annotat"
    "ion'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=F"
    "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='preferred_maintenance_window"
    "', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_facto"
    "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
    "nitPlan.Field(name='db_parameter_group_name', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(na"
    "me='init.fields.13.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='backup_retention_period', annotation=OpRef(name='in"
    "it.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='preferre"
    "d_backup_window', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default')"
    ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='port', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef(name='"
    "init.fields.16.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
    "one, validate=None, check_type=None), InitPlan.Field(name='multi_az', annotation=OpRef(name='init.fields.17.annota"
    "tion'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=True, override=False, field_type="
    "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='engine_version', annotation"
    "=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.18.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='auto_minor_version_upgrade', annotation=OpRef(name='init.fields.19.annotation'), default=OpRef(name='init.f"
    "ields.19.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None), InitPlan.Field(name='license_model', annotation=OpRef(name='init.fields.20.annotat"
    "ion'), default=OpRef(name='init.fields.20.default'), default_factory=None, init=True, override=False, field_type=F"
    "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='iops', annotation=OpRef(name"
    "='init.fields.21.annotation'), default=OpRef(name='init.fields.21.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='stor"
    "age_throughput', annotation=OpRef(name='init.fields.22.annotation'), default=OpRef(name='init.fields.22.default'),"
    " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
    "_type=None), InitPlan.Field(name='option_group_name', annotation=OpRef(name='init.fields.23.annotation'), default="
    "OpRef(name='init.fields.23.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='character_set_name', annotation=OpRef(name="
    "'init.fields.24.annotation'), default=OpRef(name='init.fields.24.default'), default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='nchar"
    "_character_set_name', annotation=OpRef(name='init.fields.25.annotation'), default=OpRef(name='init.fields.25.defau"
    "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
    "check_type=None), InitPlan.Field(name='publicly_accessible', annotation=OpRef(name='init.fields.26.annotation'), d"
    "efault=OpRef(name='init.fields.26.default'), default_factory=None, init=True, override=False, field_type=FieldType"
    ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='init.f"
    "ields.27.annotation'), default=OpRef(name='init.fields.27.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_cluster_i"
    "dentifier', annotation=OpRef(name='init.fields.28.annotation'), default=OpRef(name='init.fields.28.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='storage_type', annotation=OpRef(name='init.fields.29.annotation'), default=OpRef(name"
    "='init.fields.29.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='tde_credential_arn', annotation=OpRef(name='init.fiel"
    "ds.30.annotation'), default=OpRef(name='init.fields.30.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tde_credential_"
    "password', annotation=OpRef(name='init.fields.31.annotation'), default=OpRef(name='init.fields.31.default'), defau"
    "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='storage_encrypted', annotation=OpRef(name='init.fields.32.annotation'), default=OpRef("
    "name='init.fields.32.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None), InitPlan.Field(name='kms_key_id', annotation=OpRef(name='init.fields.3"
    "3.annotation'), default=OpRef(name='init.fields.33.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='domain', annotation"
    "=OpRef(name='init.fields.34.annotation'), default=OpRef(name='init.fields.34.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='domain_fqdn', annotation=OpRef(name='init.fields.35.annotation'), default=OpRef(name='init.fields.35.defaul"
    "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='domain_ou', annotation=OpRef(name='init.fields.36.annotation'), default=OpRe"
    "f(name='init.fields.36.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None), InitPlan.Field(name='domain_auth_secret_arn', annotation=OpRef(name="
    "'init.fields.37.annotation'), default=OpRef(name='init.fields.37.default'), default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='domai"
    "n_dns_ips', annotation=OpRef(name='init.fields.38.annotation'), default=OpRef(name='init.fields.38.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='copy_tags_to_snapshot', annotation=OpRef(name='init.fields.39.annotation'), default=O"
    "pRef(name='init.fields.39.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
    "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='monitoring_interval', annotation=OpRef(name="
    "'init.fields.40.annotation'), default=OpRef(name='init.fields.40.default'), default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='monit"
    "oring_role_arn', annotation=OpRef(name='init.fields.41.annotation'), default=OpRef(name='init.fields.41.default'),"
    " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
    "_type=None), InitPlan.Field(name='domain_iam_role_name', annotation=OpRef(name='init.fields.42.annotation'), defau"
    "lt=OpRef(name='init.fields.42.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
    "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='promotion_tier', annotation=OpRef(name='"
    "init.fields.43.annotation'), default=OpRef(name='init.fields.43.default'), default_factory=None, init=True, overri"
    "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='timezo"
    "ne', annotation=OpRef(name='init.fields.44.annotation'), default=OpRef(name='init.fields.44.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='enable_iam_database_authentication', annotation=OpRef(name='init.fields.45.annotation'), def"
    "ault=OpRef(name='init.fields.45.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
    "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='database_insights_mode', annotation=Op"
    "Ref(name='init.fields.46.annotation'), default=OpRef(name='init.fields.46.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='enable_performance_insights', annotation=OpRef(name='init.fields.47.annotation'), default=OpRef(name='init.fie"
    "lds.47.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='performance_insights_kms_key_id', annotation=OpRef(name='init.f"
    "ields.48.annotation'), default=OpRef(name='init.fields.48.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='performance_"
    "insights_retention_period', annotation=OpRef(name='init.fields.49.annotation'), default=OpRef(name='init.fields.49"
    ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None), InitPlan.Field(name='enable_cloudwatch_logs_exports', annotation=OpRef(name='init.fields.5"
    "0.annotation'), default=OpRef(name='init.fields.50.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='processor_features'"
    ", annotation=OpRef(name='init.fields.51.annotation'), default=OpRef(name='init.fields.51.default'), default_factor"
    "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
    "itPlan.Field(name='deletion_protection', annotation=OpRef(name='init.fields.52.annotation'), default=OpRef(name='i"
    "nit.fields.52.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
    "ne, validate=None, check_type=None), InitPlan.Field(name='max_allocated_storage', annotation=OpRef(name='init.fiel"
    "ds.53.annotation'), default=OpRef(name='init.fields.53.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='enable_customer"
    "_owned_ip', annotation=OpRef(name='init.fields.54.annotation'), default=OpRef(name='init.fields.54.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='network_type', annotation=OpRef(name='init.fields.55.annotation'), default=OpRef(name"
    "='init.fields.55.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='backup_target', annotation=OpRef(name='init.fields.56"
    ".annotation'), default=OpRef(name='init.fields.56.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='custom_iam_instance_"
    "profile', annotation=OpRef(name='init.fields.57.annotation'), default=OpRef(name='init.fields.57.default'), defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='db_system_id', annotation=OpRef(name='init.fields.58.annotation'), default=OpRef(name='"
    "init.fields.58.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
    "one, validate=None, check_type=None), InitPlan.Field(name='ca_certificate_identifier', annotation=OpRef(name='init"
    ".fields.59.annotation'), default=OpRef(name='init.fields.59.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='manage_mas"
    "ter_user_password', annotation=OpRef(name='init.fields.60.annotation'), default=OpRef(name='init.fields.60.default"
    "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None), InitPlan.Field(name='master_user_secret_kms_key_id', annotation=OpRef(name='init.fields.61.annotat"
    "ion'), default=OpRef(name='init.fields.61.default'), default_factory=None, init=True, override=False, field_type=F"
    "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='multi_tenant', annotation=Op"
    "Ref(name='init.fields.62.annotation'), default=OpRef(name='init.fields.62.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='dedicated_log_volume', annotation=OpRef(name='init.fields.63.annotation'), default=OpRef(name='init.fields.63."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='engine_lifecycle_support', annotation=OpRef(name='init.fields.64.annot"
    "ation'), default=OpRef(name='init.fields.64.default'), default_factory=None, init=True, override=False, field_type"
    "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='master_user_authentication"
    "_type', annotation=OpRef(name='init.fields.65.annotation'), default=OpRef(name='init.fields.65.default'), default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e), InitPlan.Field(name='additional_storage_volumes', annotation=OpRef(name='init.fields.66.annotation'), default="
    "OpRef(name='init.fields.66.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('db_name', 'd"
    "b_instance_identifier', 'allocated_storage', 'db_instance_class', 'engine', 'master_username', 'master_user_passwo"
    "rd', 'db_security_groups', 'vpc_security_group_ids', 'availability_zone', 'db_subnet_group_name', 'preferred_maint"
    "enance_window', 'db_parameter_group_name', 'backup_retention_period', 'preferred_backup_window', 'port', 'multi_az"
    "', 'engine_version', 'auto_minor_version_upgrade', 'license_model', 'iops', 'storage_throughput', 'option_group_na"
    "me', 'character_set_name', 'nchar_character_set_name', 'publicly_accessible', 'tags', 'db_cluster_identifier', 'st"
    "orage_type', 'tde_credential_arn', 'tde_credential_password', 'storage_encrypted', 'kms_key_id', 'domain', 'domain"
    "_fqdn', 'domain_ou', 'domain_auth_secret_arn', 'domain_dns_ips', 'copy_tags_to_snapshot', 'monitoring_interval', '"
    "monitoring_role_arn', 'domain_iam_role_name', 'promotion_tier', 'timezone', 'enable_iam_database_authentication', "
    "'database_insights_mode', 'enable_performance_insights', 'performance_insights_kms_key_id', 'performance_insights_"
    "retention_period', 'enable_cloudwatch_logs_exports', 'processor_features', 'deletion_protection', 'max_allocated_s"
    "torage', 'enable_customer_owned_ip', 'network_type', 'backup_target', 'custom_iam_instance_profile', 'db_system_id"
    "', 'ca_certificate_identifier', 'manage_master_user_password', 'master_user_secret_kms_key_id', 'multi_tenant', 'd"
    "edicated_log_volume', 'engine_lifecycle_support', 'master_user_authentication_type', 'additional_storage_volumes')"
    ", frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field("
    "name='db_name', kw_only=True, fn=None), ReprPlan.Field(name='db_instance_identifier', kw_only=True, fn=None), Repr"
    "Plan.Field(name='allocated_storage', kw_only=True, fn=None), ReprPlan.Field(name='db_instance_class', kw_only=True"
    ", fn=None), ReprPlan.Field(name='engine', kw_only=True, fn=None), ReprPlan.Field(name='master_username', kw_only=T"
    "rue, fn=None), ReprPlan.Field(name='master_user_password', kw_only=True, fn=None), ReprPlan.Field(name='db_securit"
    "y_groups', kw_only=True, fn=None), ReprPlan.Field(name='vpc_security_group_ids', kw_only=True, fn=None), ReprPlan."
    "Field(name='availability_zone', kw_only=True, fn=None), ReprPlan.Field(name='db_subnet_group_name', kw_only=True, "
    "fn=None), ReprPlan.Field(name='preferred_maintenance_window', kw_only=True, fn=None), ReprPlan.Field(name='db_para"
    "meter_group_name', kw_only=True, fn=None), ReprPlan.Field(name='backup_retention_period', kw_only=True, fn=None), "
    "ReprPlan.Field(name='preferred_backup_window', kw_only=True, fn=None), ReprPlan.Field(name='port', kw_only=True, f"
    "n=None), ReprPlan.Field(name='multi_az', kw_only=True, fn=None), ReprPlan.Field(name='engine_version', kw_only=Tru"
    "e, fn=None), ReprPlan.Field(name='auto_minor_version_upgrade', kw_only=True, fn=None), ReprPlan.Field(name='licens"
    "e_model', kw_only=True, fn=None), ReprPlan.Field(name='iops', kw_only=True, fn=None), ReprPlan.Field(name='storage"
    "_throughput', kw_only=True, fn=None), ReprPlan.Field(name='option_group_name', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='character_set_name', kw_only=True, fn=None), ReprPlan.Field(name='nchar_character_set_name', kw_only=Tru"
    "e, fn=None), ReprPlan.Field(name='publicly_accessible', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_onl"
    "y=True, fn=None), ReprPlan.Field(name='db_cluster_identifier', kw_only=True, fn=None), ReprPlan.Field(name='storag"
    "e_type', kw_only=True, fn=None), ReprPlan.Field(name='tde_credential_arn', kw_only=True, fn=None), ReprPlan.Field("
    "name='tde_credential_password', kw_only=True, fn=None), ReprPlan.Field(name='storage_encrypted', kw_only=True, fn="
    "None), ReprPlan.Field(name='kms_key_id', kw_only=True, fn=None), ReprPlan.Field(name='domain', kw_only=True, fn=No"
    "ne), ReprPlan.Field(name='domain_fqdn', kw_only=True, fn=None), ReprPlan.Field(name='domain_ou', kw_only=True, fn="
    "None), ReprPlan.Field(name='domain_auth_secret_arn', kw_only=True, fn=None), ReprPlan.Field(name='domain_dns_ips',"
    " kw_only=True, fn=None), ReprPlan.Field(name='copy_tags_to_snapshot', kw_only=True, fn=None), ReprPlan.Field(name="
    "'monitoring_interval', kw_only=True, fn=None), ReprPlan.Field(name='monitoring_role_arn', kw_only=True, fn=None), "
    "ReprPlan.Field(name='domain_iam_role_name', kw_only=True, fn=None), ReprPlan.Field(name='promotion_tier', kw_only="
    "True, fn=None), ReprPlan.Field(name='timezone', kw_only=True, fn=None), ReprPlan.Field(name='enable_iam_database_a"
    "uthentication', kw_only=True, fn=None), ReprPlan.Field(name='database_insights_mode', kw_only=True, fn=None), Repr"
    "Plan.Field(name='enable_performance_insights', kw_only=True, fn=None), ReprPlan.Field(name='performance_insights_k"
    "ms_key_id', kw_only=True, fn=None), ReprPlan.Field(name='performance_insights_retention_period', kw_only=True, fn="
    "None), ReprPlan.Field(name='enable_cloudwatch_logs_exports', kw_only=True, fn=None), ReprPlan.Field(name='processo"
    "r_features', kw_only=True, fn=None), ReprPlan.Field(name='deletion_protection', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='max_allocated_storage', kw_only=True, fn=None), ReprPlan.Field(name='enable_customer_owned_ip', kw_only"
    "=True, fn=None), ReprPlan.Field(name='network_type', kw_only=True, fn=None), ReprPlan.Field(name='backup_target', "
    "kw_only=True, fn=None), ReprPlan.Field(name='custom_iam_instance_profile', kw_only=True, fn=None), ReprPlan.Field("
    "name='db_system_id', kw_only=True, fn=None), ReprPlan.Field(name='ca_certificate_identifier', kw_only=True, fn=Non"
    "e), ReprPlan.Field(name='manage_master_user_password', kw_only=True, fn=None), ReprPlan.Field(name='master_user_se"
    "cret_kms_key_id', kw_only=True, fn=None), ReprPlan.Field(name='multi_tenant', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='dedicated_log_volume', kw_only=True, fn=None), ReprPlan.Field(name='engine_lifecycle_support', kw_only=Tr"
    "ue, fn=None), ReprPlan.Field(name='master_user_authentication_type', kw_only=True, fn=None), ReprPlan.Field(name='"
    "additional_storage_volumes', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fCreateDBInstanceMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__21__annotation,
    __dataclass__init__fields__21__default,
    __dataclass__init__fields__22__annotation,
    __dataclass__init__fields__22__default,
    __dataclass__init__fields__23__annotation,
    __dataclass__init__fields__23__default,
    __dataclass__init__fields__24__annotation,
    __dataclass__init__fields__24__default,
    __dataclass__init__fields__25__annotation,
    __dataclass__init__fields__25__default,
    __dataclass__init__fields__26__annotation,
    __dataclass__init__fields__26__default,
    __dataclass__init__fields__27__annotation,
    __dataclass__init__fields__27__default,
    __dataclass__init__fields__28__annotation,
    __dataclass__init__fields__28__default,
    __dataclass__init__fields__29__annotation,
    __dataclass__init__fields__29__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__30__annotation,
    __dataclass__init__fields__30__default,
    __dataclass__init__fields__31__annotation,
    __dataclass__init__fields__31__default,
    __dataclass__init__fields__32__annotation,
    __dataclass__init__fields__32__default,
    __dataclass__init__fields__33__annotation,
    __dataclass__init__fields__33__default,
    __dataclass__init__fields__34__annotation,
    __dataclass__init__fields__34__default,
    __dataclass__init__fields__35__annotation,
    __dataclass__init__fields__35__default,
    __dataclass__init__fields__36__annotation,
    __dataclass__init__fields__36__default,
    __dataclass__init__fields__37__annotation,
    __dataclass__init__fields__37__default,
    __dataclass__init__fields__38__annotation,
    __dataclass__init__fields__38__default,
    __dataclass__init__fields__39__annotation,
    __dataclass__init__fields__39__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__40__annotation,
    __dataclass__init__fields__40__default,
    __dataclass__init__fields__41__annotation,
    __dataclass__init__fields__41__default,
    __dataclass__init__fields__42__annotation,
    __dataclass__init__fields__42__default,
    __dataclass__init__fields__43__annotation,
    __dataclass__init__fields__43__default,
    __dataclass__init__fields__44__annotation,
    __dataclass__init__fields__44__default,
    __dataclass__init__fields__45__annotation,
    __dataclass__init__fields__45__default,
    __dataclass__init__fields__46__annotation,
    __dataclass__init__fields__46__default,
    __dataclass__init__fields__47__annotation,
    __dataclass__init__fields__47__default,
    __dataclass__init__fields__48__annotation,
    __dataclass__init__fields__48__default,
    __dataclass__init__fields__49__annotation,
    __dataclass__init__fields__49__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__50__annotation,
    __dataclass__init__fields__50__default,
    __dataclass__init__fields__51__annotation,
    __dataclass__init__fields__51__default,
    __dataclass__init__fields__52__annotation,
    __dataclass__init__fields__52__default,
    __dataclass__init__fields__53__annotation,
    __dataclass__init__fields__53__default,
    __dataclass__init__fields__54__annotation,
    __dataclass__init__fields__54__default,
    __dataclass__init__fields__55__annotation,
    __dataclass__init__fields__55__default,
    __dataclass__init__fields__56__annotation,
    __dataclass__init__fields__56__default,
    __dataclass__init__fields__57__annotation,
    __dataclass__init__fields__57__default,
    __dataclass__init__fields__58__annotation,
    __dataclass__init__fields__58__default,
    __dataclass__init__fields__59__annotation,
    __dataclass__init__fields__59__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__60__annotation,
    __dataclass__init__fields__60__default,
    __dataclass__init__fields__61__annotation,
    __dataclass__init__fields__61__default,
    __dataclass__init__fields__62__annotation,
    __dataclass__init__fields__62__default,
    __dataclass__init__fields__63__annotation,
    __dataclass__init__fields__63__default,
    __dataclass__init__fields__64__annotation,
    __dataclass__init__fields__64__default,
    __dataclass__init__fields__65__annotation,
    __dataclass__init__fields__65__default,
    __dataclass__init__fields__66__annotation,
    __dataclass__init__fields__66__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            db_name=self.db_name,
            db_instance_identifier=self.db_instance_identifier,
            allocated_storage=self.allocated_storage,
            db_instance_class=self.db_instance_class,
            engine=self.engine,
            master_username=self.master_username,
            master_user_password=self.master_user_password,
            db_security_groups=self.db_security_groups,
            vpc_security_group_ids=self.vpc_security_group_ids,
            availability_zone=self.availability_zone,
            db_subnet_group_name=self.db_subnet_group_name,
            preferred_maintenance_window=self.preferred_maintenance_window,
            db_parameter_group_name=self.db_parameter_group_name,
            backup_retention_period=self.backup_retention_period,
            preferred_backup_window=self.preferred_backup_window,
            port=self.port,
            multi_az=self.multi_az,
            engine_version=self.engine_version,
            auto_minor_version_upgrade=self.auto_minor_version_upgrade,
            license_model=self.license_model,
            iops=self.iops,
            storage_throughput=self.storage_throughput,
            option_group_name=self.option_group_name,
            character_set_name=self.character_set_name,
            nchar_character_set_name=self.nchar_character_set_name,
            publicly_accessible=self.publicly_accessible,
            tags=self.tags,
            db_cluster_identifier=self.db_cluster_identifier,
            storage_type=self.storage_type,
            tde_credential_arn=self.tde_credential_arn,
            tde_credential_password=self.tde_credential_password,
            storage_encrypted=self.storage_encrypted,
            kms_key_id=self.kms_key_id,
            domain=self.domain,
            domain_fqdn=self.domain_fqdn,
            domain_ou=self.domain_ou,
            domain_auth_secret_arn=self.domain_auth_secret_arn,
            domain_dns_ips=self.domain_dns_ips,
            copy_tags_to_snapshot=self.copy_tags_to_snapshot,
            monitoring_interval=self.monitoring_interval,
            monitoring_role_arn=self.monitoring_role_arn,
            domain_iam_role_name=self.domain_iam_role_name,
            promotion_tier=self.promotion_tier,
            timezone=self.timezone,
            enable_iam_database_authentication=self.enable_iam_database_authentication,
            database_insights_mode=self.database_insights_mode,
            enable_performance_insights=self.enable_performance_insights,
            performance_insights_kms_key_id=self.performance_insights_kms_key_id,
            performance_insights_retention_period=self.performance_insights_retention_period,
            enable_cloudwatch_logs_exports=self.enable_cloudwatch_logs_exports,
            processor_features=self.processor_features,
            deletion_protection=self.deletion_protection,
            max_allocated_storage=self.max_allocated_storage,
            enable_customer_owned_ip=self.enable_customer_owned_ip,
            network_type=self.network_type,
            backup_target=self.backup_target,
            custom_iam_instance_profile=self.custom_iam_instance_profile,
            db_system_id=self.db_system_id,
            ca_certificate_identifier=self.ca_certificate_identifier,
            manage_master_user_password=self.manage_master_user_password,
            master_user_secret_kms_key_id=self.master_user_secret_kms_key_id,
            multi_tenant=self.multi_tenant,
            dedicated_log_volume=self.dedicated_log_volume,
            engine_lifecycle_support=self.engine_lifecycle_support,
            master_user_authentication_type=self.master_user_authentication_type,
            additional_storage_volumes=self.additional_storage_volumes,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.db_name == other.db_name and
            self.db_instance_identifier == other.db_instance_identifier and
            self.allocated_storage == other.allocated_storage and
            self.db_instance_class == other.db_instance_class and
            self.engine == other.engine and
            self.master_username == other.master_username and
            self.master_user_password == other.master_user_password and
            self.db_security_groups == other.db_security_groups and
            self.vpc_security_group_ids == other.vpc_security_group_ids and
            self.availability_zone == other.availability_zone and
            self.db_subnet_group_name == other.db_subnet_group_name and
            self.preferred_maintenance_window == other.preferred_maintenance_window and
            self.db_parameter_group_name == other.db_parameter_group_name and
            self.backup_retention_period == other.backup_retention_period and
            self.preferred_backup_window == other.preferred_backup_window and
            self.port == other.port and
            self.multi_az == other.multi_az and
            self.engine_version == other.engine_version and
            self.auto_minor_version_upgrade == other.auto_minor_version_upgrade and
            self.license_model == other.license_model and
            self.iops == other.iops and
            self.storage_throughput == other.storage_throughput and
            self.option_group_name == other.option_group_name and
            self.character_set_name == other.character_set_name and
            self.nchar_character_set_name == other.nchar_character_set_name and
            self.publicly_accessible == other.publicly_accessible and
            self.tags == other.tags and
            self.db_cluster_identifier == other.db_cluster_identifier and
            self.storage_type == other.storage_type and
            self.tde_credential_arn == other.tde_credential_arn and
            self.tde_credential_password == other.tde_credential_password and
            self.storage_encrypted == other.storage_encrypted and
            self.kms_key_id == other.kms_key_id and
            self.domain == other.domain and
            self.domain_fqdn == other.domain_fqdn and
            self.domain_ou == other.domain_ou and
            self.domain_auth_secret_arn == other.domain_auth_secret_arn and
            self.domain_dns_ips == other.domain_dns_ips and
            self.copy_tags_to_snapshot == other.copy_tags_to_snapshot and
            self.monitoring_interval == other.monitoring_interval and
            self.monitoring_role_arn == other.monitoring_role_arn and
            self.domain_iam_role_name == other.domain_iam_role_name and
            self.promotion_tier == other.promotion_tier and
            self.timezone == other.timezone and
            self.enable_iam_database_authentication == other.enable_iam_database_authentication and
            self.database_insights_mode == other.database_insights_mode and
            self.enable_performance_insights == other.enable_performance_insights and
            self.performance_insights_kms_key_id == other.performance_insights_kms_key_id and
            self.performance_insights_retention_period == other.performance_insights_retention_period and
            self.enable_cloudwatch_logs_exports == other.enable_cloudwatch_logs_exports and
            self.processor_features == other.processor_features and
            self.deletion_protection == other.deletion_protection and
            self.max_allocated_storage == other.max_allocated_storage and
            self.enable_customer_owned_ip == other.enable_customer_owned_ip and
            self.network_type == other.network_type and
            self.backup_target == other.backup_target and
            self.custom_iam_instance_profile == other.custom_iam_instance_profile and
            self.db_system_id == other.db_system_id and
            self.ca_certificate_identifier == other.ca_certificate_identifier and
            self.manage_master_user_password == other.manage_master_user_password and
            self.master_user_secret_kms_key_id == other.master_user_secret_kms_key_id and
            self.multi_tenant == other.multi_tenant and
            self.dedicated_log_volume == other.dedicated_log_volume and
            self.engine_lifecycle_support == other.engine_lifecycle_support and
            self.master_user_authentication_type == other.master_user_authentication_type and
            self.additional_storage_volumes == other.additional_storage_volumes
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'db_name',
        'db_instance_identifier',
        'allocated_storage',
        'db_instance_class',
        'engine',
        'master_username',
        'master_user_password',
        'db_security_groups',
        'vpc_security_group_ids',
        'availability_zone',
        'db_subnet_group_name',
        'preferred_maintenance_window',
        'db_parameter_group_name',
        'backup_retention_period',
        'preferred_backup_window',
        'port',
        'multi_az',
        'engine_version',
        'auto_minor_version_upgrade',
        'license_model',
        'iops',
        'storage_throughput',
        'option_group_name',
        'character_set_name',
        'nchar_character_set_name',
        'publicly_accessible',
        'tags',
        'db_cluster_identifier',
        'storage_type',
        'tde_credential_arn',
        'tde_credential_password',
        'storage_encrypted',
        'kms_key_id',
        'domain',
        'domain_fqdn',
        'domain_ou',
        'domain_auth_secret_arn',
        'domain_dns_ips',
        'copy_tags_to_snapshot',
        'monitoring_interval',
        'monitoring_role_arn',
        'domain_iam_role_name',
        'promotion_tier',
        'timezone',
        'enable_iam_database_authentication',
        'database_insights_mode',
        'enable_performance_insights',
        'performance_insights_kms_key_id',
        'performance_insights_retention_period',
        'enable_cloudwatch_logs_exports',
        'processor_features',
        'deletion_protection',
        'max_allocated_storage',
        'enable_customer_owned_ip',
        'network_type',
        'backup_target',
        'custom_iam_instance_profile',
        'db_system_id',
        'ca_certificate_identifier',
        'manage_master_user_password',
        'master_user_secret_kms_key_id',
        'multi_tenant',
        'dedicated_log_volume',
        'engine_lifecycle_support',
        'master_user_authentication_type',
        'additional_storage_volumes',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'db_name',
        'db_instance_identifier',
        'allocated_storage',
        'db_instance_class',
        'engine',
        'master_username',
        'master_user_password',
        'db_security_groups',
        'vpc_security_group_ids',
        'availability_zone',
        'db_subnet_group_name',
        'preferred_maintenance_window',
        'db_parameter_group_name',
        'backup_retention_period',
        'preferred_backup_window',
        'port',
        'multi_az',
        'engine_version',
        'auto_minor_version_upgrade',
        'license_model',
        'iops',
        'storage_throughput',
        'option_group_name',
        'character_set_name',
        'nchar_character_set_name',
        'publicly_accessible',
        'tags',
        'db_cluster_identifier',
        'storage_type',
        'tde_credential_arn',
        'tde_credential_password',
        'storage_encrypted',
        'kms_key_id',
        'domain',
        'domain_fqdn',
        'domain_ou',
        'domain_auth_secret_arn',
        'domain_dns_ips',
        'copy_tags_to_snapshot',
        'monitoring_interval',
        'monitoring_role_arn',
        'domain_iam_role_name',
        'promotion_tier',
        'timezone',
        'enable_iam_database_authentication',
        'database_insights_mode',
        'enable_performance_insights',
        'performance_insights_kms_key_id',
        'performance_insights_retention_period',
        'enable_cloudwatch_logs_exports',
        'processor_features',
        'deletion_protection',
        'max_allocated_storage',
        'enable_customer_owned_ip',
        'network_type',
        'backup_target',
        'custom_iam_instance_profile',
        'db_system_id',
        'ca_certificate_identifier',
        'manage_master_user_password',
        'master_user_secret_kms_key_id',
        'multi_tenant',
        'dedicated_log_volume',
        'engine_lifecycle_support',
        'master_user_authentication_type',
        'additional_storage_volumes',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.db_name,
            self.db_instance_identifier,
            self.allocated_storage,
            self.db_instance_class,
            self.engine,
            self.master_username,
            self.master_user_password,
            self.db_security_groups,
            self.vpc_security_group_ids,
            self.availability_zone,
            self.db_subnet_group_name,
            self.preferred_maintenance_window,
            self.db_parameter_group_name,
            self.backup_retention_period,
            self.preferred_backup_window,
            self.port,
            self.multi_az,
            self.engine_version,
            self.auto_minor_version_upgrade,
            self.license_model,
            self.iops,
            self.storage_throughput,
            self.option_group_name,
            self.character_set_name,
            self.nchar_character_set_name,
            self.publicly_accessible,
            self.tags,
            self.db_cluster_identifier,
            self.storage_type,
            self.tde_credential_arn,
            self.tde_credential_password,
            self.storage_encrypted,
            self.kms_key_id,
            self.domain,
            self.domain_fqdn,
            self.domain_ou,
            self.domain_auth_secret_arn,
            self.domain_dns_ips,
            self.copy_tags_to_snapshot,
            self.monitoring_interval,
            self.monitoring_role_arn,
            self.domain_iam_role_name,
            self.promotion_tier,
            self.timezone,
            self.enable_iam_database_authentication,
            self.database_insights_mode,
            self.enable_performance_insights,
            self.performance_insights_kms_key_id,
            self.performance_insights_retention_period,
            self.enable_cloudwatch_logs_exports,
            self.processor_features,
            self.deletion_protection,
            self.max_allocated_storage,
            self.enable_customer_owned_ip,
            self.network_type,
            self.backup_target,
            self.custom_iam_instance_profile,
            self.db_system_id,
            self.ca_certificate_identifier,
            self.manage_master_user_password,
            self.master_user_secret_kms_key_id,
            self.multi_tenant,
            self.dedicated_log_volume,
            self.engine_lifecycle_support,
            self.master_user_authentication_type,
            self.additional_storage_volumes,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        db_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        db_instance_identifier: __dataclass__init__fields__2__annotation,
        allocated_storage: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        db_instance_class: __dataclass__init__fields__4__annotation,
        engine: __dataclass__init__fields__5__annotation,
        master_username: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        master_user_password: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        db_security_groups: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        vpc_security_group_ids: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        availability_zone: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        db_subnet_group_name: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        preferred_maintenance_window: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        db_parameter_group_name: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        backup_retention_period: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        preferred_backup_window: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        port: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        multi_az: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        engine_version: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        auto_minor_version_upgrade: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        license_model: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        iops: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
        storage_throughput: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
        option_group_name: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
        character_set_name: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
        nchar_character_set_name: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
        publicly_accessible: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
        tags: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
        db_cluster_identifier: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
        storage_type: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
        tde_credential_arn: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
        tde_credential_password: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
        storage_encrypted: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
        kms_key_id: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
        domain: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
        domain_fqdn: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
        domain_ou: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
        domain_auth_secret_arn: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
        domain_dns_ips: __dataclass__init__fields__38__annotation = __dataclass__init__fields__38__default,
        copy_tags_to_snapshot: __dataclass__init__fields__39__annotation = __dataclass__init__fields__39__default,
        monitoring_interval: __dataclass__init__fields__40__annotation = __dataclass__init__fields__40__default,
        monitoring_role_arn: __dataclass__init__fields__41__annotation = __dataclass__init__fields__41__default,
        domain_iam_role_name: __dataclass__init__fields__42__annotation = __dataclass__init__fields__42__default,
        promotion_tier: __dataclass__init__fields__43__annotation = __dataclass__init__fields__43__default,
        timezone: __dataclass__init__fields__44__annotation = __dataclass__init__fields__44__default,
        enable_iam_database_authentication: __dataclass__init__fields__45__annotation = __dataclass__init__fields__45__default,
        database_insights_mode: __dataclass__init__fields__46__annotation = __dataclass__init__fields__46__default,
        enable_performance_insights: __dataclass__init__fields__47__annotation = __dataclass__init__fields__47__default,
        performance_insights_kms_key_id: __dataclass__init__fields__48__annotation = __dataclass__init__fields__48__default,
        performance_insights_retention_period: __dataclass__init__fields__49__annotation = __dataclass__init__fields__49__default,
        enable_cloudwatch_logs_exports: __dataclass__init__fields__50__annotation = __dataclass__init__fields__50__default,
        processor_features: __dataclass__init__fields__51__annotation = __dataclass__init__fields__51__default,
        deletion_protection: __dataclass__init__fields__52__annotation = __dataclass__init__fields__52__default,
        max_allocated_storage: __dataclass__init__fields__53__annotation = __dataclass__init__fields__53__default,
        enable_customer_owned_ip: __dataclass__init__fields__54__annotation = __dataclass__init__fields__54__default,
        network_type: __dataclass__init__fields__55__annotation = __dataclass__init__fields__55__default,
        backup_target: __dataclass__init__fields__56__annotation = __dataclass__init__fields__56__default,
        custom_iam_instance_profile: __dataclass__init__fields__57__annotation = __dataclass__init__fields__57__default,
        db_system_id: __dataclass__init__fields__58__annotation = __dataclass__init__fields__58__default,
        ca_certificate_identifier: __dataclass__init__fields__59__annotation = __dataclass__init__fields__59__default,
        manage_master_user_password: __dataclass__init__fields__60__annotation = __dataclass__init__fields__60__default,
        master_user_secret_kms_key_id: __dataclass__init__fields__61__annotation = __dataclass__init__fields__61__default,
        multi_tenant: __dataclass__init__fields__62__annotation = __dataclass__init__fields__62__default,
        dedicated_log_volume: __dataclass__init__fields__63__annotation = __dataclass__init__fields__63__default,
        engine_lifecycle_support: __dataclass__init__fields__64__annotation = __dataclass__init__fields__64__default,
        master_user_authentication_type: __dataclass__init__fields__65__annotation = __dataclass__init__fields__65__default,
        additional_storage_volumes: __dataclass__init__fields__66__annotation = __dataclass__init__fields__66__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'db_name', db_name)
        __dataclass__object_setattr(self, 'db_instance_identifier', db_instance_identifier)
        __dataclass__object_setattr(self, 'allocated_storage', allocated_storage)
        __dataclass__object_setattr(self, 'db_instance_class', db_instance_class)
        __dataclass__object_setattr(self, 'engine', engine)
        __dataclass__object_setattr(self, 'master_username', master_username)
        __dataclass__object_setattr(self, 'master_user_password', master_user_password)
        __dataclass__object_setattr(self, 'db_security_groups', db_security_groups)
        __dataclass__object_setattr(self, 'vpc_security_group_ids', vpc_security_group_ids)
        __dataclass__object_setattr(self, 'availability_zone', availability_zone)
        __dataclass__object_setattr(self, 'db_subnet_group_name', db_subnet_group_name)
        __dataclass__object_setattr(self, 'preferred_maintenance_window', preferred_maintenance_window)
        __dataclass__object_setattr(self, 'db_parameter_group_name', db_parameter_group_name)
        __dataclass__object_setattr(self, 'backup_retention_period', backup_retention_period)
        __dataclass__object_setattr(self, 'preferred_backup_window', preferred_backup_window)
        __dataclass__object_setattr(self, 'port', port)
        __dataclass__object_setattr(self, 'multi_az', multi_az)
        __dataclass__object_setattr(self, 'engine_version', engine_version)
        __dataclass__object_setattr(self, 'auto_minor_version_upgrade', auto_minor_version_upgrade)
        __dataclass__object_setattr(self, 'license_model', license_model)
        __dataclass__object_setattr(self, 'iops', iops)
        __dataclass__object_setattr(self, 'storage_throughput', storage_throughput)
        __dataclass__object_setattr(self, 'option_group_name', option_group_name)
        __dataclass__object_setattr(self, 'character_set_name', character_set_name)
        __dataclass__object_setattr(self, 'nchar_character_set_name', nchar_character_set_name)
        __dataclass__object_setattr(self, 'publicly_accessible', publicly_accessible)
        __dataclass__object_setattr(self, 'tags', tags)
        __dataclass__object_setattr(self, 'db_cluster_identifier', db_cluster_identifier)
        __dataclass__object_setattr(self, 'storage_type', storage_type)
        __dataclass__object_setattr(self, 'tde_credential_arn', tde_credential_arn)
        __dataclass__object_setattr(self, 'tde_credential_password', tde_credential_password)
        __dataclass__object_setattr(self, 'storage_encrypted', storage_encrypted)
        __dataclass__object_setattr(self, 'kms_key_id', kms_key_id)
        __dataclass__object_setattr(self, 'domain', domain)
        __dataclass__object_setattr(self, 'domain_fqdn', domain_fqdn)
        __dataclass__object_setattr(self, 'domain_ou', domain_ou)
        __dataclass__object_setattr(self, 'domain_auth_secret_arn', domain_auth_secret_arn)
        __dataclass__object_setattr(self, 'domain_dns_ips', domain_dns_ips)
        __dataclass__object_setattr(self, 'copy_tags_to_snapshot', copy_tags_to_snapshot)
        __dataclass__object_setattr(self, 'monitoring_interval', monitoring_interval)
        __dataclass__object_setattr(self, 'monitoring_role_arn', monitoring_role_arn)
        __dataclass__object_setattr(self, 'domain_iam_role_name', domain_iam_role_name)
        __dataclass__object_setattr(self, 'promotion_tier', promotion_tier)
        __dataclass__object_setattr(self, 'timezone', timezone)
        __dataclass__object_setattr(self, 'enable_iam_database_authentication', enable_iam_database_authentication)
        __dataclass__object_setattr(self, 'database_insights_mode', database_insights_mode)
        __dataclass__object_setattr(self, 'enable_performance_insights', enable_performance_insights)
        __dataclass__object_setattr(self, 'performance_insights_kms_key_id', performance_insights_kms_key_id)
        __dataclass__object_setattr(self, 'performance_insights_retention_period', performance_insights_retention_period)
        __dataclass__object_setattr(self, 'enable_cloudwatch_logs_exports', enable_cloudwatch_logs_exports)
        __dataclass__object_setattr(self, 'processor_features', processor_features)
        __dataclass__object_setattr(self, 'deletion_protection', deletion_protection)
        __dataclass__object_setattr(self, 'max_allocated_storage', max_allocated_storage)
        __dataclass__object_setattr(self, 'enable_customer_owned_ip', enable_customer_owned_ip)
        __dataclass__object_setattr(self, 'network_type', network_type)
        __dataclass__object_setattr(self, 'backup_target', backup_target)
        __dataclass__object_setattr(self, 'custom_iam_instance_profile', custom_iam_instance_profile)
        __dataclass__object_setattr(self, 'db_system_id', db_system_id)
        __dataclass__object_setattr(self, 'ca_certificate_identifier', ca_certificate_identifier)
        __dataclass__object_setattr(self, 'manage_master_user_password', manage_master_user_password)
        __dataclass__object_setattr(self, 'master_user_secret_kms_key_id', master_user_secret_kms_key_id)
        __dataclass__object_setattr(self, 'multi_tenant', multi_tenant)
        __dataclass__object_setattr(self, 'dedicated_log_volume', dedicated_log_volume)
        __dataclass__object_setattr(self, 'engine_lifecycle_support', engine_lifecycle_support)
        __dataclass__object_setattr(self, 'master_user_authentication_type', master_user_authentication_type)
        __dataclass__object_setattr(self, 'additional_storage_volumes', additional_storage_volumes)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"db_name={self.db_name!r}")
        parts.append(f"db_instance_identifier={self.db_instance_identifier!r}")
        parts.append(f"allocated_storage={self.allocated_storage!r}")
        parts.append(f"db_instance_class={self.db_instance_class!r}")
        parts.append(f"engine={self.engine!r}")
        parts.append(f"master_username={self.master_username!r}")
        parts.append(f"master_user_password={self.master_user_password!r}")
        parts.append(f"db_security_groups={self.db_security_groups!r}")
        parts.append(f"vpc_security_group_ids={self.vpc_security_group_ids!r}")
        parts.append(f"availability_zone={self.availability_zone!r}")
        parts.append(f"db_subnet_group_name={self.db_subnet_group_name!r}")
        parts.append(f"preferred_maintenance_window={self.preferred_maintenance_window!r}")
        parts.append(f"db_parameter_group_name={self.db_parameter_group_name!r}")
        parts.append(f"backup_retention_period={self.backup_retention_period!r}")
        parts.append(f"preferred_backup_window={self.preferred_backup_window!r}")
        parts.append(f"port={self.port!r}")
        parts.append(f"multi_az={self.multi_az!r}")
        parts.append(f"engine_version={self.engine_version!r}")
        parts.append(f"auto_minor_version_upgrade={self.auto_minor_version_upgrade!r}")
        parts.append(f"license_model={self.license_model!r}")
        parts.append(f"iops={self.iops!r}")
        parts.append(f"storage_throughput={self.storage_throughput!r}")
        parts.append(f"option_group_name={self.option_group_name!r}")
        parts.append(f"character_set_name={self.character_set_name!r}")
        parts.append(f"nchar_character_set_name={self.nchar_character_set_name!r}")
        parts.append(f"publicly_accessible={self.publicly_accessible!r}")
        parts.append(f"tags={self.tags!r}")
        parts.append(f"db_cluster_identifier={self.db_cluster_identifier!r}")
        parts.append(f"storage_type={self.storage_type!r}")
        parts.append(f"tde_credential_arn={self.tde_credential_arn!r}")
        parts.append(f"tde_credential_password={self.tde_credential_password!r}")
        parts.append(f"storage_encrypted={self.storage_encrypted!r}")
        parts.append(f"kms_key_id={self.kms_key_id!r}")
        parts.append(f"domain={self.domain!r}")
        parts.append(f"domain_fqdn={self.domain_fqdn!r}")
        parts.append(f"domain_ou={self.domain_ou!r}")
        parts.append(f"domain_auth_secret_arn={self.domain_auth_secret_arn!r}")
        parts.append(f"domain_dns_ips={self.domain_dns_ips!r}")
        parts.append(f"copy_tags_to_snapshot={self.copy_tags_to_snapshot!r}")
        parts.append(f"monitoring_interval={self.monitoring_interval!r}")
        parts.append(f"monitoring_role_arn={self.monitoring_role_arn!r}")
        parts.append(f"domain_iam_role_name={self.domain_iam_role_name!r}")
        parts.append(f"promotion_tier={self.promotion_tier!r}")
        parts.append(f"timezone={self.timezone!r}")
        parts.append(f"enable_iam_database_authentication={self.enable_iam_database_authentication!r}")
        parts.append(f"database_insights_mode={self.database_insights_mode!r}")
        parts.append(f"enable_performance_insights={self.enable_performance_insights!r}")
        parts.append(f"performance_insights_kms_key_id={self.performance_insights_kms_key_id!r}")
        parts.append(f"performance_insights_retention_period={self.performance_insights_retention_period!r}")
        parts.append(f"enable_cloudwatch_logs_exports={self.enable_cloudwatch_logs_exports!r}")
        parts.append(f"processor_features={self.processor_features!r}")
        parts.append(f"deletion_protection={self.deletion_protection!r}")
        parts.append(f"max_allocated_storage={self.max_allocated_storage!r}")
        parts.append(f"enable_customer_owned_ip={self.enable_customer_owned_ip!r}")
        parts.append(f"network_type={self.network_type!r}")
        parts.append(f"backup_target={self.backup_target!r}")
        parts.append(f"custom_iam_instance_profile={self.custom_iam_instance_profile!r}")
        parts.append(f"db_system_id={self.db_system_id!r}")
        parts.append(f"ca_certificate_identifier={self.ca_certificate_identifier!r}")
        parts.append(f"manage_master_user_password={self.manage_master_user_password!r}")
        parts.append(f"master_user_secret_kms_key_id={self.master_user_secret_kms_key_id!r}")
        parts.append(f"multi_tenant={self.multi_tenant!r}")
        parts.append(f"dedicated_log_volume={self.dedicated_log_volume!r}")
        parts.append(f"engine_lifecycle_support={self.engine_lifecycle_support!r}")
        parts.append(f"master_user_authentication_type={self.master_user_authentication_type!r}")
        parts.append(f"additional_storage_volumes={self.additional_storage_volumes!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('db_instance_class', 'allocated_storage', 'master_user_password', 'port', 'backup_rete"
    "ntion_period', 'multi_az', 'engine_version', 'license_model', 'iops', 'storage_throughput', 'db_instance_identifie"
    "r', 'storage_type', 'ca_certificate_identifier', 'db_subnet_group_name', 'pending_cloudwatch_logs_exports', 'proce"
    "ssor_features', 'automation_mode', 'resume_full_automation_mode_time', 'multi_tenant', 'iam_database_authenticatio"
    "n_enabled', 'dedicated_log_volume', 'engine', 'additional_storage_volumes')), EqPlan(fields=('db_instance_class', "
    "'allocated_storage', 'master_user_password', 'port', 'backup_retention_period', 'multi_az', 'engine_version', 'lic"
    "ense_model', 'iops', 'storage_throughput', 'db_instance_identifier', 'storage_type', 'ca_certificate_identifier', "
    "'db_subnet_group_name', 'pending_cloudwatch_logs_exports', 'processor_features', 'automation_mode', 'resume_full_a"
    "utomation_mode_time', 'multi_tenant', 'iam_database_authentication_enabled', 'dedicated_log_volume', 'engine', 'ad"
    "ditional_storage_volumes')), FrozenPlan(fields=('__shape__', 'db_instance_class', 'allocated_storage', 'master_use"
    "r_password', 'port', 'backup_retention_period', 'multi_az', 'engine_version', 'license_model', 'iops', 'storage_th"
    "roughput', 'db_instance_identifier', 'storage_type', 'ca_certificate_identifier', 'db_subnet_group_name', 'pending"
    "_cloudwatch_logs_exports', 'processor_features', 'automation_mode', 'resume_full_automation_mode_time', 'multi_ten"
    "ant', 'iam_database_authentication_enabled', 'dedicated_log_volume', 'engine', 'additional_storage_volumes'), allo"
    "w_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('db_instance_class', 'allocated_storage', 'master_us"
    "er_password', 'port', 'backup_retention_period', 'multi_az', 'engine_version', 'license_model', 'iops', 'storage_t"
    "hroughput', 'db_instance_identifier', 'storage_type', 'ca_certificate_identifier', 'db_subnet_group_name', 'pendin"
    "g_cloudwatch_logs_exports', 'processor_features', 'automation_mode', 'resume_full_automation_mode_time', 'multi_te"
    "nant', 'iam_database_authentication_enabled', 'dedicated_log_volume', 'engine', 'additional_storage_volumes'), cac"
    "he=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), de"
    "fault=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='db_instance_class', annotation=OpRef(name='init.fields.1.annotation'"
    "), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='allocated_storage', annotation=Op"
    "Ref(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True"
    ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='master_user_password', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='port', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(na"
    "me='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='backup_retention_period', annotation=OpRef(name='ini"
    "t.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=Fa"
    "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='multi_az', "
    "annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='engine_version', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields"
    ".7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None), InitPlan.Field(name='license_model', annotation=OpRef(name='init.fields.8.annotation'), "
    "default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType"
    ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='iops', annotation=OpRef(name='init.f"
    "ields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='storage_throug"
    "hput', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='db_instance_identifier', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef"
    "(name='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='storage_type', annotation=OpRef(name='init.field"
    "s.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ca_certificate_i"
    "dentifier', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='db_subnet_group_name', annotation=OpRef(name='init.fields.14.annotation'), default=Op"
    "Ref(name='init.fields.14.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
    ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='pending_cloudwatch_logs_exports', annotation="
    "OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='processor_features', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef(name='init.fields.16."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='automation_mode', annotation=OpRef(name='init.fields.17.annotation'), "
    "default=OpRef(name='init.fields.17.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='resume_full_automation_mode_time', "
    "annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.18.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='multi_tenant', annotation=OpRef(name='init.fields.19.annotation'), default=OpRef(name='init.field"
    "s.19.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='iam_database_authentication_enabled', annotation=OpRef(name='init"
    ".fields.20.annotation'), default=OpRef(name='init.fields.20.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dedicated_"
    "log_volume', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='init.fields.21.default'), def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='engine', annotation=OpRef(name='init.fields.22.annotation'), default=OpRef(name='ini"
    "t.fields.22.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
    ", validate=None, check_type=None), InitPlan.Field(name='additional_storage_volumes', annotation=OpRef(name='init.f"
    "ields.23.annotation'), default=OpRef(name='init.fields.23.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=()"
    ", kw_only_params=('db_instance_class', 'allocated_storage', 'master_user_password', 'port', 'backup_retention_peri"
    "od', 'multi_az', 'engine_version', 'license_model', 'iops', 'storage_throughput', 'db_instance_identifier', 'stora"
    "ge_type', 'ca_certificate_identifier', 'db_subnet_group_name', 'pending_cloudwatch_logs_exports', 'processor_featu"
    "res', 'automation_mode', 'resume_full_automation_mode_time', 'multi_tenant', 'iam_database_authentication_enabled'"
    ", 'dedicated_log_volume', 'engine', 'additional_storage_volumes'), frozen=True, slots=False, post_init_params=None"
    ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db_instance_class', kw_only=True, fn=None),"
    " ReprPlan.Field(name='allocated_storage', kw_only=True, fn=None), ReprPlan.Field(name='master_user_password', kw_o"
    "nly=True, fn=None), ReprPlan.Field(name='port', kw_only=True, fn=None), ReprPlan.Field(name='backup_retention_peri"
    "od', kw_only=True, fn=None), ReprPlan.Field(name='multi_az', kw_only=True, fn=None), ReprPlan.Field(name='engine_v"
    "ersion', kw_only=True, fn=None), ReprPlan.Field(name='license_model', kw_only=True, fn=None), ReprPlan.Field(name="
    "'iops', kw_only=True, fn=None), ReprPlan.Field(name='storage_throughput', kw_only=True, fn=None), ReprPlan.Field(n"
    "ame='db_instance_identifier', kw_only=True, fn=None), ReprPlan.Field(name='storage_type', kw_only=True, fn=None), "
    "ReprPlan.Field(name='ca_certificate_identifier', kw_only=True, fn=None), ReprPlan.Field(name='db_subnet_group_name"
    "', kw_only=True, fn=None), ReprPlan.Field(name='pending_cloudwatch_logs_exports', kw_only=True, fn=None), ReprPlan"
    ".Field(name='processor_features', kw_only=True, fn=None), ReprPlan.Field(name='automation_mode', kw_only=True, fn="
    "None), ReprPlan.Field(name='resume_full_automation_mode_time', kw_only=True, fn=None), ReprPlan.Field(name='multi_"
    "tenant', kw_only=True, fn=None), ReprPlan.Field(name='iam_database_authentication_enabled', kw_only=True, fn=None)"
    ", ReprPlan.Field(name='dedicated_log_volume', kw_only=True, fn=None), ReprPlan.Field(name='engine', kw_only=True, "
    "fn=None), ReprPlan.Field(name='additional_storage_volumes', kw_only=True, fn=None)), id=False, terse=False, defaul"
    "t_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fPendingModifiedValues(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__21__annotation,
    __dataclass__init__fields__21__default,
    __dataclass__init__fields__22__annotation,
    __dataclass__init__fields__22__default,
    __dataclass__init__fields__23__annotation,
    __dataclass__init__fields__23__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            db_instance_class=self.db_instance_class,
            allocated_storage=self.allocated_storage,
            master_user_password=self.master_user_password,
            port=self.port,
            backup_retention_period=self.backup_retention_period,
            multi_az=self.multi_az,
            engine_version=self.engine_version,
            license_model=self.license_model,
            iops=self.iops,
            storage_throughput=self.storage_throughput,
            db_instance_identifier=self.db_instance_identifier,
            storage_type=self.storage_type,
            ca_certificate_identifier=self.ca_certificate_identifier,
            db_subnet_group_name=self.db_subnet_group_name,
            pending_cloudwatch_logs_exports=self.pending_cloudwatch_logs_exports,
            processor_features=self.processor_features,
            automation_mode=self.automation_mode,
            resume_full_automation_mode_time=self.resume_full_automation_mode_time,
            multi_tenant=self.multi_tenant,
            iam_database_authentication_enabled=self.iam_database_authentication_enabled,
            dedicated_log_volume=self.dedicated_log_volume,
            engine=self.engine,
            additional_storage_volumes=self.additional_storage_volumes,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.db_instance_class == other.db_instance_class and
            self.allocated_storage == other.allocated_storage and
            self.master_user_password == other.master_user_password and
            self.port == other.port and
            self.backup_retention_period == other.backup_retention_period and
            self.multi_az == other.multi_az and
            self.engine_version == other.engine_version and
            self.license_model == other.license_model and
            self.iops == other.iops and
            self.storage_throughput == other.storage_throughput and
            self.db_instance_identifier == other.db_instance_identifier and
            self.storage_type == other.storage_type and
            self.ca_certificate_identifier == other.ca_certificate_identifier and
            self.db_subnet_group_name == other.db_subnet_group_name and
            self.pending_cloudwatch_logs_exports == other.pending_cloudwatch_logs_exports and
            self.processor_features == other.processor_features and
            self.automation_mode == other.automation_mode and
            self.resume_full_automation_mode_time == other.resume_full_automation_mode_time and
            self.multi_tenant == other.multi_tenant and
            self.iam_database_authentication_enabled == other.iam_database_authentication_enabled and
            self.dedicated_log_volume == other.dedicated_log_volume and
            self.engine == other.engine and
            self.additional_storage_volumes == other.additional_storage_volumes
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'db_instance_class',
        'allocated_storage',
        'master_user_password',
        'port',
        'backup_retention_period',
        'multi_az',
        'engine_version',
        'license_model',
        'iops',
        'storage_throughput',
        'db_instance_identifier',
        'storage_type',
        'ca_certificate_identifier',
        'db_subnet_group_name',
        'pending_cloudwatch_logs_exports',
        'processor_features',
        'automation_mode',
        'resume_full_automation_mode_time',
        'multi_tenant',
        'iam_database_authentication_enabled',
        'dedicated_log_volume',
        'engine',
        'additional_storage_volumes',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'db_instance_class',
        'allocated_storage',
        'master_user_password',
        'port',
        'backup_retention_period',
        'multi_az',
        'engine_version',
        'license_model',
        'iops',
        'storage_throughput',
        'db_instance_identifier',
        'storage_type',
        'ca_certificate_identifier',
        'db_subnet_group_name',
        'pending_cloudwatch_logs_exports',
        'processor_features',
        'automation_mode',
        'resume_full_automation_mode_time',
        'multi_tenant',
        'iam_database_authentication_enabled',
        'dedicated_log_volume',
        'engine',
        'additional_storage_volumes',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.db_instance_class,
            self.allocated_storage,
            self.master_user_password,
            self.port,
            self.backup_retention_period,
            self.multi_az,
            self.engine_version,
            self.license_model,
            self.iops,
            self.storage_throughput,
            self.db_instance_identifier,
            self.storage_type,
            self.ca_certificate_identifier,
            self.db_subnet_group_name,
            self.pending_cloudwatch_logs_exports,
            self.processor_features,
            self.automation_mode,
            self.resume_full_automation_mode_time,
            self.multi_tenant,
            self.iam_database_authentication_enabled,
            self.dedicated_log_volume,
            self.engine,
            self.additional_storage_volumes,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        db_instance_class: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        allocated_storage: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        master_user_password: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        port: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        backup_retention_period: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        multi_az: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        engine_version: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        license_model: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        iops: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        storage_throughput: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        db_instance_identifier: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        storage_type: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        ca_certificate_identifier: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        db_subnet_group_name: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        pending_cloudwatch_logs_exports: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        processor_features: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        automation_mode: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        resume_full_automation_mode_time: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        multi_tenant: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        iam_database_authentication_enabled: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        dedicated_log_volume: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
        engine: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
        additional_storage_volumes: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'db_instance_class', db_instance_class)
        __dataclass__object_setattr(self, 'allocated_storage', allocated_storage)
        __dataclass__object_setattr(self, 'master_user_password', master_user_password)
        __dataclass__object_setattr(self, 'port', port)
        __dataclass__object_setattr(self, 'backup_retention_period', backup_retention_period)
        __dataclass__object_setattr(self, 'multi_az', multi_az)
        __dataclass__object_setattr(self, 'engine_version', engine_version)
        __dataclass__object_setattr(self, 'license_model', license_model)
        __dataclass__object_setattr(self, 'iops', iops)
        __dataclass__object_setattr(self, 'storage_throughput', storage_throughput)
        __dataclass__object_setattr(self, 'db_instance_identifier', db_instance_identifier)
        __dataclass__object_setattr(self, 'storage_type', storage_type)
        __dataclass__object_setattr(self, 'ca_certificate_identifier', ca_certificate_identifier)
        __dataclass__object_setattr(self, 'db_subnet_group_name', db_subnet_group_name)
        __dataclass__object_setattr(self, 'pending_cloudwatch_logs_exports', pending_cloudwatch_logs_exports)
        __dataclass__object_setattr(self, 'processor_features', processor_features)
        __dataclass__object_setattr(self, 'automation_mode', automation_mode)
        __dataclass__object_setattr(self, 'resume_full_automation_mode_time', resume_full_automation_mode_time)
        __dataclass__object_setattr(self, 'multi_tenant', multi_tenant)
        __dataclass__object_setattr(self, 'iam_database_authentication_enabled', iam_database_authentication_enabled)
        __dataclass__object_setattr(self, 'dedicated_log_volume', dedicated_log_volume)
        __dataclass__object_setattr(self, 'engine', engine)
        __dataclass__object_setattr(self, 'additional_storage_volumes', additional_storage_volumes)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"db_instance_class={self.db_instance_class!r}")
        parts.append(f"allocated_storage={self.allocated_storage!r}")
        parts.append(f"master_user_password={self.master_user_password!r}")
        parts.append(f"port={self.port!r}")
        parts.append(f"backup_retention_period={self.backup_retention_period!r}")
        parts.append(f"multi_az={self.multi_az!r}")
        parts.append(f"engine_version={self.engine_version!r}")
        parts.append(f"license_model={self.license_model!r}")
        parts.append(f"iops={self.iops!r}")
        parts.append(f"storage_throughput={self.storage_throughput!r}")
        parts.append(f"db_instance_identifier={self.db_instance_identifier!r}")
        parts.append(f"storage_type={self.storage_type!r}")
        parts.append(f"ca_certificate_identifier={self.ca_certificate_identifier!r}")
        parts.append(f"db_subnet_group_name={self.db_subnet_group_name!r}")
        parts.append(f"pending_cloudwatch_logs_exports={self.pending_cloudwatch_logs_exports!r}")
        parts.append(f"processor_features={self.processor_features!r}")
        parts.append(f"automation_mode={self.automation_mode!r}")
        parts.append(f"resume_full_automation_mode_time={self.resume_full_automation_mode_time!r}")
        parts.append(f"multi_tenant={self.multi_tenant!r}")
        parts.append(f"iam_database_authentication_enabled={self.iam_database_authentication_enabled!r}")
        parts.append(f"dedicated_log_volume={self.dedicated_log_volume!r}")
        parts.append(f"engine={self.engine!r}")
        parts.append(f"additional_storage_volumes={self.additional_storage_volumes!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('db_subnet_group_name', 'db_subnet_group_description', 'vpc_id', 'subnet_group_status'"
    ", 'subnets', 'db_subnet_group_arn', 'supported_network_types')), EqPlan(fields=('db_subnet_group_name', 'db_subnet"
    "_group_description', 'vpc_id', 'subnet_group_status', 'subnets', 'db_subnet_group_arn', 'supported_network_types')"
    "), FrozenPlan(fields=('__shape__', 'db_subnet_group_name', 'db_subnet_group_description', 'vpc_id', 'subnet_group_"
    "status', 'subnets', 'db_subnet_group_arn', 'supported_network_types'), allow_dynamic_dunder_attrs=False), HashPlan"
    "(action='add', fields=('db_subnet_group_name', 'db_subnet_group_description', 'vpc_id', 'subnet_group_status', 'su"
    "bnets', 'db_subnet_group_arn', 'supported_network_types'), cache=False), InitPlan(fields=(InitPlan.Field(name='__s"
    "hape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_sub"
    "net_group_name', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None), InitPlan.Field(name='db_subnet_group_description', annotation=OpRef(name='init.fields.2.annotation'), d"
    "efault=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType."
    "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init."
    "fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=Fals"
    "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnet_group_"
    "status', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='subnets', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fiel"
    "ds.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='db_subnet_group_arn', annotation=OpRef(name='init.fields.6.annota"
    "tion'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=F"
    "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='supported_network_types', an"
    "notation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_pa"
    "ram='self', std_params=(), kw_only_params=('db_subnet_group_name', 'db_subnet_group_description', 'vpc_id', 'subne"
    "t_group_status', 'subnets', 'db_subnet_group_arn', 'supported_network_types'), frozen=True, slots=False, post_init"
    "_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db_subnet_group_name', kw_only="
    "True, fn=None), ReprPlan.Field(name='db_subnet_group_description', kw_only=True, fn=None), ReprPlan.Field(name='vp"
    "c_id', kw_only=True, fn=None), ReprPlan.Field(name='subnet_group_status', kw_only=True, fn=None), ReprPlan.Field(n"
    "ame='subnets', kw_only=True, fn=None), ReprPlan.Field(name='db_subnet_group_arn', kw_only=True, fn=None), ReprPlan"
    ".Field(name='supported_network_types', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDBSubnetGroup(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            db_subnet_group_name=self.db_subnet_group_name,
            db_subnet_group_description=self.db_subnet_group_description,
            vpc_id=self.vpc_id,
            subnet_group_status=self.subnet_group_status,
            subnets=self.subnets,
            db_subnet_group_arn=self.db_subnet_group_arn,
            supported_network_types=self.supported_network_types,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.db_subnet_group_name == other.db_subnet_group_name and
            self.db_subnet_group_description == other.db_subnet_group_description and
            self.vpc_id == other.vpc_id and
            self.subnet_group_status == other.subnet_group_status and
            self.subnets == other.subnets and
            self.db_subnet_group_arn == other.db_subnet_group_arn and
            self.supported_network_types == other.supported_network_types
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'db_subnet_group_name',
        'db_subnet_group_description',
        'vpc_id',
        'subnet_group_status',
        'subnets',
        'db_subnet_group_arn',
        'supported_network_types',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'db_subnet_group_name',
        'db_subnet_group_description',
        'vpc_id',
        'subnet_group_status',
        'subnets',
        'db_subnet_group_arn',
        'supported_network_types',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.db_subnet_group_name,
            self.db_subnet_group_description,
            self.vpc_id,
            self.subnet_group_status,
            self.subnets,
            self.db_subnet_group_arn,
            self.supported_network_types,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        db_subnet_group_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        db_subnet_group_description: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        vpc_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        subnet_group_status: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        subnets: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        db_subnet_group_arn: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        supported_network_types: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'db_subnet_group_name', db_subnet_group_name)
        __dataclass__object_setattr(self, 'db_subnet_group_description', db_subnet_group_description)
        __dataclass__object_setattr(self, 'vpc_id', vpc_id)
        __dataclass__object_setattr(self, 'subnet_group_status', subnet_group_status)
        __dataclass__object_setattr(self, 'subnets', subnets)
        __dataclass__object_setattr(self, 'db_subnet_group_arn', db_subnet_group_arn)
        __dataclass__object_setattr(self, 'supported_network_types', supported_network_types)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"db_subnet_group_name={self.db_subnet_group_name!r}")
        parts.append(f"db_subnet_group_description={self.db_subnet_group_description!r}")
        parts.append(f"vpc_id={self.vpc_id!r}")
        parts.append(f"subnet_group_status={self.subnet_group_status!r}")
        parts.append(f"subnets={self.subnets!r}")
        parts.append(f"db_subnet_group_arn={self.db_subnet_group_arn!r}")
        parts.append(f"supported_network_types={self.supported_network_types!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('db_instance_identifier', 'filters', 'max_records', 'marker')), EqPlan(fields=('db_ins"
    "tance_identifier', 'filters', 'max_records', 'marker')), FrozenPlan(fields=('__shape__', 'db_instance_identifier',"
    " 'filters', 'max_records', 'marker'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('db_instan"
    "ce_identifier', 'filters', 'max_records', 'marker'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__"
    "', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=Fals"
    "e, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_instance_"
    "identifier', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), defau"
    "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='filters', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init."
    "fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None), InitPlan.Field(name='max_records', annotation=OpRef(name='init.fields.3.annotation"
    "'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='marker', annotation=OpRef(name='"
    "init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_param"
    "s=(), kw_only_params=('db_instance_identifier', 'filters', 'max_records', 'marker'), frozen=True, slots=False, pos"
    "t_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db_instance_identifier', "
    "kw_only=True, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn=None), ReprPlan.Field(name='max_records', "
    "kw_only=True, fn=None), ReprPlan.Field(name='marker', kw_only=True, fn=None)), id=False, terse=False, default_fn=N"
    "one)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDescribeDBInstancesMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            db_instance_identifier=self.db_instance_identifier,
            filters=self.filters,
            max_records=self.max_records,
            marker=self.marker,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.db_instance_identifier == other.db_instance_identifier and
            self.filters == other.filters and
            self.max_records == other.max_records and
            self.marker == other.marker
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'db_instance_identifier',
        'filters',
        'max_records',
        'marker',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'db_instance_identifier',
        'filters',
        'max_records',
        'marker',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.db_instance_identifier,
            self.filters,
            self.max_records,
            self.marker,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        db_instance_identifier: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        filters: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        max_records: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        marker: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'db_instance_identifier', db_instance_identifier)
        __dataclass__object_setattr(self, 'filters', filters)
        __dataclass__object_setattr(self, 'max_records', max_records)
        __dataclass__object_setattr(self, 'marker', marker)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"db_instance_identifier={self.db_instance_identifier!r}")
        parts.append(f"filters={self.filters!r}")
        parts.append(f"max_records={self.max_records!r}")
        parts.append(f"marker={self.marker!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('db_instance_identifier', 'db_instance_class', 'engine', 'db_instance_status', 'master"
    "_username', 'db_name', 'endpoint', 'allocated_storage', 'instance_create_time', 'preferred_backup_window', 'backup"
    "_retention_period', 'db_security_groups', 'vpc_security_groups', 'db_parameter_groups', 'availability_zone', 'db_s"
    "ubnet_group', 'preferred_maintenance_window', 'upgrade_rollout_order', 'pending_modified_values', 'latest_restorab"
    "le_time', 'multi_az', 'engine_version', 'auto_minor_version_upgrade', 'read_replica_source_db_instance_identifier'"
    ", 'read_replica_db_instance_identifiers', 'read_replica_db_cluster_identifiers', 'replica_mode', 'license_model', "
    "'iops', 'storage_throughput', 'option_group_memberships', 'character_set_name', 'nchar_character_set_name', 'secon"
    "dary_availability_zone', 'publicly_accessible', 'status_infos', 'storage_type', 'tde_credential_arn', 'db_instance"
    "_port', 'db_cluster_identifier', 'storage_encrypted', 'kms_key_id', 'dbi_resource_id', 'ca_certificate_identifier'"
    ", 'domain_memberships', 'copy_tags_to_snapshot', 'monitoring_interval', 'enhanced_monitoring_resource_arn', 'monit"
    "oring_role_arn', 'promotion_tier', 'db_instance_arn', 'timezone', 'iam_database_authentication_enabled', 'database"
    "_insights_mode', 'performance_insights_enabled', 'performance_insights_kms_key_id', 'performance_insights_retentio"
    "n_period', 'enabled_cloudwatch_logs_exports', 'processor_features', 'deletion_protection', 'associated_roles', 'li"
    "stener_endpoint', 'max_allocated_storage', 'tag_list', 'automation_mode', 'resume_full_automation_mode_time', 'cus"
    "tomer_owned_ip_enabled', 'network_type', 'activity_stream_status', 'activity_stream_kms_key_id', 'activity_stream_"
    "kinesis_stream_name', 'activity_stream_mode', 'activity_stream_engine_native_audit_fields_included', 'aws_backup_r"
    "ecovery_point_arn', 'db_instance_automated_backups_replications', 'backup_target', 'automatic_restart_time', 'cust"
    "om_iam_instance_profile', 'activity_stream_policy_status', 'certificate_details', 'db_system_id', 'master_user_sec"
    "ret', 'read_replica_source_db_cluster_identifier', 'percent_progress', 'multi_tenant', 'dedicated_log_volume', 'is"
    "_storage_config_upgrade_available', 'engine_lifecycle_support', 'additional_storage_volumes', 'storage_volume_stat"
    "us')), EqPlan(fields=('db_instance_identifier', 'db_instance_class', 'engine', 'db_instance_status', 'master_usern"
    "ame', 'db_name', 'endpoint', 'allocated_storage', 'instance_create_time', 'preferred_backup_window', 'backup_reten"
    "tion_period', 'db_security_groups', 'vpc_security_groups', 'db_parameter_groups', 'availability_zone', 'db_subnet_"
    "group', 'preferred_maintenance_window', 'upgrade_rollout_order', 'pending_modified_values', 'latest_restorable_tim"
    "e', 'multi_az', 'engine_version', 'auto_minor_version_upgrade', 'read_replica_source_db_instance_identifier', 'rea"
    "d_replica_db_instance_identifiers', 'read_replica_db_cluster_identifiers', 'replica_mode', 'license_model', 'iops'"
    ", 'storage_throughput', 'option_group_memberships', 'character_set_name', 'nchar_character_set_name', 'secondary_a"
    "vailability_zone', 'publicly_accessible', 'status_infos', 'storage_type', 'tde_credential_arn', 'db_instance_port'"
    ", 'db_cluster_identifier', 'storage_encrypted', 'kms_key_id', 'dbi_resource_id', 'ca_certificate_identifier', 'dom"
    "ain_memberships', 'copy_tags_to_snapshot', 'monitoring_interval', 'enhanced_monitoring_resource_arn', 'monitoring_"
    "role_arn', 'promotion_tier', 'db_instance_arn', 'timezone', 'iam_database_authentication_enabled', 'database_insig"
    "hts_mode', 'performance_insights_enabled', 'performance_insights_kms_key_id', 'performance_insights_retention_peri"
    "od', 'enabled_cloudwatch_logs_exports', 'processor_features', 'deletion_protection', 'associated_roles', 'listener"
    "_endpoint', 'max_allocated_storage', 'tag_list', 'automation_mode', 'resume_full_automation_mode_time', 'customer_"
    "owned_ip_enabled', 'network_type', 'activity_stream_status', 'activity_stream_kms_key_id', 'activity_stream_kinesi"
    "s_stream_name', 'activity_stream_mode', 'activity_stream_engine_native_audit_fields_included', 'aws_backup_recover"
    "y_point_arn', 'db_instance_automated_backups_replications', 'backup_target', 'automatic_restart_time', 'custom_iam"
    "_instance_profile', 'activity_stream_policy_status', 'certificate_details', 'db_system_id', 'master_user_secret', "
    "'read_replica_source_db_cluster_identifier', 'percent_progress', 'multi_tenant', 'dedicated_log_volume', 'is_stora"
    "ge_config_upgrade_available', 'engine_lifecycle_support', 'additional_storage_volumes', 'storage_volume_status')),"
    " FrozenPlan(fields=('__shape__', 'db_instance_identifier', 'db_instance_class', 'engine', 'db_instance_status', 'm"
    "aster_username', 'db_name', 'endpoint', 'allocated_storage', 'instance_create_time', 'preferred_backup_window', 'b"
    "ackup_retention_period', 'db_security_groups', 'vpc_security_groups', 'db_parameter_groups', 'availability_zone', "
    "'db_subnet_group', 'preferred_maintenance_window', 'upgrade_rollout_order', 'pending_modified_values', 'latest_res"
    "torable_time', 'multi_az', 'engine_version', 'auto_minor_version_upgrade', 'read_replica_source_db_instance_identi"
    "fier', 'read_replica_db_instance_identifiers', 'read_replica_db_cluster_identifiers', 'replica_mode', 'license_mod"
    "el', 'iops', 'storage_throughput', 'option_group_memberships', 'character_set_name', 'nchar_character_set_name', '"
    "secondary_availability_zone', 'publicly_accessible', 'status_infos', 'storage_type', 'tde_credential_arn', 'db_ins"
    "tance_port', 'db_cluster_identifier', 'storage_encrypted', 'kms_key_id', 'dbi_resource_id', 'ca_certificate_identi"
    "fier', 'domain_memberships', 'copy_tags_to_snapshot', 'monitoring_interval', 'enhanced_monitoring_resource_arn', '"
    "monitoring_role_arn', 'promotion_tier', 'db_instance_arn', 'timezone', 'iam_database_authentication_enabled', 'dat"
    "abase_insights_mode', 'performance_insights_enabled', 'performance_insights_kms_key_id', 'performance_insights_ret"
    "ention_period', 'enabled_cloudwatch_logs_exports', 'processor_features', 'deletion_protection', 'associated_roles'"
    ", 'listener_endpoint', 'max_allocated_storage', 'tag_list', 'automation_mode', 'resume_full_automation_mode_time',"
    " 'customer_owned_ip_enabled', 'network_type', 'activity_stream_status', 'activity_stream_kms_key_id', 'activity_st"
    "ream_kinesis_stream_name', 'activity_stream_mode', 'activity_stream_engine_native_audit_fields_included', 'aws_bac"
    "kup_recovery_point_arn', 'db_instance_automated_backups_replications', 'backup_target', 'automatic_restart_time', "
    "'custom_iam_instance_profile', 'activity_stream_policy_status', 'certificate_details', 'db_system_id', 'master_use"
    "r_secret', 'read_replica_source_db_cluster_identifier', 'percent_progress', 'multi_tenant', 'dedicated_log_volume'"
    ", 'is_storage_config_upgrade_available', 'engine_lifecycle_support', 'additional_storage_volumes', 'storage_volume"
    "_status'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('db_instance_identifier', 'db_instanc"
    "e_class', 'engine', 'db_instance_status', 'master_username', 'db_name', 'endpoint', 'allocated_storage', 'instance"
    "_create_time', 'preferred_backup_window', 'backup_retention_period', 'db_security_groups', 'vpc_security_groups', "
    "'db_parameter_groups', 'availability_zone', 'db_subnet_group', 'preferred_maintenance_window', 'upgrade_rollout_or"
    "der', 'pending_modified_values', 'latest_restorable_time', 'multi_az', 'engine_version', 'auto_minor_version_upgra"
    "de', 'read_replica_source_db_instance_identifier', 'read_replica_db_instance_identifiers', 'read_replica_db_cluste"
    "r_identifiers', 'replica_mode', 'license_model', 'iops', 'storage_throughput', 'option_group_memberships', 'charac"
    "ter_set_name', 'nchar_character_set_name', 'secondary_availability_zone', 'publicly_accessible', 'status_infos', '"
    "storage_type', 'tde_credential_arn', 'db_instance_port', 'db_cluster_identifier', 'storage_encrypted', 'kms_key_id"
    "', 'dbi_resource_id', 'ca_certificate_identifier', 'domain_memberships', 'copy_tags_to_snapshot', 'monitoring_inte"
    "rval', 'enhanced_monitoring_resource_arn', 'monitoring_role_arn', 'promotion_tier', 'db_instance_arn', 'timezone',"
    " 'iam_database_authentication_enabled', 'database_insights_mode', 'performance_insights_enabled', 'performance_ins"
    "ights_kms_key_id', 'performance_insights_retention_period', 'enabled_cloudwatch_logs_exports', 'processor_features"
    "', 'deletion_protection', 'associated_roles', 'listener_endpoint', 'max_allocated_storage', 'tag_list', 'automatio"
    "n_mode', 'resume_full_automation_mode_time', 'customer_owned_ip_enabled', 'network_type', 'activity_stream_status'"
    ", 'activity_stream_kms_key_id', 'activity_stream_kinesis_stream_name', 'activity_stream_mode', 'activity_stream_en"
    "gine_native_audit_fields_included', 'aws_backup_recovery_point_arn', 'db_instance_automated_backups_replications',"
    " 'backup_target', 'automatic_restart_time', 'custom_iam_instance_profile', 'activity_stream_policy_status', 'certi"
    "ficate_details', 'db_system_id', 'master_user_secret', 'read_replica_source_db_cluster_identifier', 'percent_progr"
    "ess', 'multi_tenant', 'dedicated_log_volume', 'is_storage_config_upgrade_available', 'engine_lifecycle_support', '"
    "additional_storage_volumes', 'storage_volume_status'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape"
    "__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=Fa"
    "lse, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_instanc"
    "e_identifier', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='db_instance_class', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef"
    "(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None), InitPlan.Field(name='engine', annotation=OpRef(name='init.fields.3.ann"
    "otation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_instance_status', anno"
    "tation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
    "ield(name='master_username', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='db_name', annotation=OpRef(name='init.fields.6.annotation'), default=O"
    "pRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
    ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='endpoint', annotation=OpRef(name='init.fields"
    ".7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='allocated_storage',"
    " annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=N"
    "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
    "lan.Field(name='instance_create_time', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init"
    ".fields.9.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='preferred_backup_window', annotation=OpRef(name='init.fields"
    ".10.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, f"
    "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='backup_retention_"
    "period', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default"
    "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
    "ne), InitPlan.Field(name='db_security_groups', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(n"
    "ame='init.fields.12.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
    "rce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_security_groups', annotation=OpRef(name='init."
    "fields.13.annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=Fa"
    "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_paramete"
    "r_groups', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), defau"
    "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='availability_zone', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef("
    "name='init.fields.15.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None), InitPlan.Field(name='db_subnet_group', annotation=OpRef(name='init.fie"
    "lds.16.annotation'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='preferred_main"
    "tenance_window', annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'),"
    " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
    "_type=None), InitPlan.Field(name='upgrade_rollout_order', annotation=OpRef(name='init.fields.18.annotation'), defa"
    "ult=OpRef(name='init.fields.18.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='pending_modified_values', annotation=Op"
    "Ref(name='init.fields.19.annotation'), default=OpRef(name='init.fields.19.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='latest_restorable_time', annotation=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.fields.2"
    "0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='multi_az', annotation=OpRef(name='init.fields.21.annotation'), defau"
    "lt=OpRef(name='init.fields.21.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
    "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='engine_version', annotation=OpRef(name='"
    "init.fields.22.annotation'), default=OpRef(name='init.fields.22.default'), default_factory=None, init=True, overri"
    "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='auto_m"
    "inor_version_upgrade', annotation=OpRef(name='init.fields.23.annotation'), default=OpRef(name='init.fields.23.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='read_replica_source_db_instance_identifier', annotation=OpRef(name='init.f"
    "ields.24.annotation'), default=OpRef(name='init.fields.24.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='read_replica"
    "_db_instance_identifiers', annotation=OpRef(name='init.fields.25.annotation'), default=OpRef(name='init.fields.25."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='read_replica_db_cluster_identifiers', annotation=OpRef(name='init.fiel"
    "ds.26.annotation'), default=OpRef(name='init.fields.26.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='replica_mode', "
    "annotation=OpRef(name='init.fields.27.annotation'), default=OpRef(name='init.fields.27.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='license_model', annotation=OpRef(name='init.fields.28.annotation'), default=OpRef(name='init.fiel"
    "ds.28.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None), InitPlan.Field(name='iops', annotation=OpRef(name='init.fields.29.annotation'), defau"
    "lt=OpRef(name='init.fields.29.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
    "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='storage_throughput', annotation=OpRef(na"
    "me='init.fields.30.annotation'), default=OpRef(name='init.fields.30.default'), default_factory=None, init=True, ov"
    "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='op"
    "tion_group_memberships', annotation=OpRef(name='init.fields.31.annotation'), default=OpRef(name='init.fields.31.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None), InitPlan.Field(name='character_set_name', annotation=OpRef(name='init.fields.32.annotation'),"
    " default=OpRef(name='init.fields.32.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
    "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='nchar_character_set_name', annotat"
    "ion=OpRef(name='init.fields.33.annotation'), default=OpRef(name='init.fields.33.default'), default_factory=None, i"
    "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
    "eld(name='secondary_availability_zone', annotation=OpRef(name='init.fields.34.annotation'), default=OpRef(name='in"
    "it.fields.34.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
    "e, validate=None, check_type=None), InitPlan.Field(name='publicly_accessible', annotation=OpRef(name='init.fields."
    "35.annotation'), default=OpRef(name='init.fields.35.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='status_infos', ann"
    "otation=OpRef(name='init.fields.36.annotation'), default=OpRef(name='init.fields.36.default'), default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
    "n.Field(name='storage_type', annotation=OpRef(name='init.fields.37.annotation'), default=OpRef(name='init.fields.3"
    "7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='tde_credential_arn', annotation=OpRef(name='init.fields.38.annotatio"
    "n'), default=OpRef(name='init.fields.38.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_instance_port', annotation="
    "OpRef(name='init.fields.39.annotation'), default=OpRef(name='init.fields.39.default'), default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='db_cluster_identifier', annotation=OpRef(name='init.fields.40.annotation'), default=OpRef(name='init.fields."
    "40.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None), InitPlan.Field(name='storage_encrypted', annotation=OpRef(name='init.fields.41.annotatio"
    "n'), default=OpRef(name='init.fields.41.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='kms_key_id', annotation=OpRef("
    "name='init.fields.42.annotation'), default=OpRef(name='init.fields.42.default'), default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "dbi_resource_id', annotation=OpRef(name='init.fields.43.annotation'), default=OpRef(name='init.fields.43.default')"
    ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='ca_certificate_identifier', annotation=OpRef(name='init.fields.44.annotation'),"
    " default=OpRef(name='init.fields.44.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
    "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='domain_memberships', annotation=Op"
    "Ref(name='init.fields.45.annotation'), default=OpRef(name='init.fields.45.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='copy_tags_to_snapshot', annotation=OpRef(name='init.fields.46.annotation'), default=OpRef(name='init.fields.46"
    ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None), InitPlan.Field(name='monitoring_interval', annotation=OpRef(name='init.fields.47.annotatio"
    "n'), default=OpRef(name='init.fields.47.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='enhanced_monitoring_resource_a"
    "rn', annotation=OpRef(name='init.fields.48.annotation'), default=OpRef(name='init.fields.48.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='monitoring_role_arn', annotation=OpRef(name='init.fields.49.annotation'), default=OpRef(name"
    "='init.fields.49.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='promotion_tier', annotation=OpRef(name='init.fields.5"
    "0.annotation'), default=OpRef(name='init.fields.50.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_instance_arn', a"
    "nnotation=OpRef(name='init.fields.51.annotation'), default=OpRef(name='init.fields.51.default'), default_factory=N"
    "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
    "lan.Field(name='timezone', annotation=OpRef(name='init.fields.52.annotation'), default=OpRef(name='init.fields.52."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='iam_database_authentication_enabled', annotation=OpRef(name='init.fiel"
    "ds.53.annotation'), default=OpRef(name='init.fields.53.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='database_insigh"
    "ts_mode', annotation=OpRef(name='init.fields.54.annotation'), default=OpRef(name='init.fields.54.default'), defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='performance_insights_enabled', annotation=OpRef(name='init.fields.55.annotation'), defa"
    "ult=OpRef(name='init.fields.55.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='performance_insights_kms_key_id', annot"
    "ation=OpRef(name='init.fields.56.annotation'), default=OpRef(name='init.fields.56.default'), default_factory=None,"
    " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
    "Field(name='performance_insights_retention_period', annotation=OpRef(name='init.fields.57.annotation'), default=Op"
    "Ref(name='init.fields.57.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
    ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='enabled_cloudwatch_logs_exports', annotation="
    "OpRef(name='init.fields.58.annotation'), default=OpRef(name='init.fields.58.default'), default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='processor_features', annotation=OpRef(name='init.fields.59.annotation'), default=OpRef(name='init.fields.59."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='deletion_protection', annotation=OpRef(name='init.fields.60.annotation"
    "'), default=OpRef(name='init.fields.60.default'), default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='associated_roles', annotation=O"
    "pRef(name='init.fields.61.annotation'), default=OpRef(name='init.fields.61.default'), default_factory=None, init=T"
    "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
    "ame='listener_endpoint', annotation=OpRef(name='init.fields.62.annotation'), default=OpRef(name='init.fields.62.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None), InitPlan.Field(name='max_allocated_storage', annotation=OpRef(name='init.fields.63.annotation"
    "'), default=OpRef(name='init.fields.63.default'), default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tag_list', annotation=OpRef(nam"
    "e='init.fields.64.annotation'), default=OpRef(name='init.fields.64.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='aut"
    "omation_mode', annotation=OpRef(name='init.fields.65.annotation'), default=OpRef(name='init.fields.65.default'), d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None), InitPlan.Field(name='resume_full_automation_mode_time', annotation=OpRef(name='init.fields.66.annotatio"
    "n'), default=OpRef(name='init.fields.66.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='customer_owned_ip_enabled', an"
    "notation=OpRef(name='init.fields.67.annotation'), default=OpRef(name='init.fields.67.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='network_type', annotation=OpRef(name='init.fields.68.annotation'), default=OpRef(name='init.fields."
    "68.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None), InitPlan.Field(name='activity_stream_status', annotation=OpRef(name='init.fields.69.anno"
    "tation'), default=OpRef(name='init.fields.69.default'), default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='activity_stream_kms_key_i"
    "d', annotation=OpRef(name='init.fields.70.annotation'), default=OpRef(name='init.fields.70.default'), default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
    "InitPlan.Field(name='activity_stream_kinesis_stream_name', annotation=OpRef(name='init.fields.71.annotation'), def"
    "ault=OpRef(name='init.fields.71.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
    "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='activity_stream_mode', annotation=OpRe"
    "f(name='init.fields.72.annotation'), default=OpRef(name='init.fields.72.default'), default_factory=None, init=True"
    ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='activity_stream_engine_native_audit_fields_included', annotation=OpRef(name='init.fields.73.annotation'), defaul"
    "t=OpRef(name='init.fields.73.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
    "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='aws_backup_recovery_point_arn', annotatio"
    "n=OpRef(name='init.fields.74.annotation'), default=OpRef(name='init.fields.74.default'), default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='db_instance_automated_backups_replications', annotation=OpRef(name='init.fields.75.annotation'), default=O"
    "pRef(name='init.fields.75.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
    "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='backup_target', annotation=OpRef(name='init."
    "fields.76.annotation'), default=OpRef(name='init.fields.76.default'), default_factory=None, init=True, override=Fa"
    "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='automatic_r"
    "estart_time', annotation=OpRef(name='init.fields.77.annotation'), default=OpRef(name='init.fields.77.default'), de"
    "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='custom_iam_instance_profile', annotation=OpRef(name='init.fields.78.annotation'), d"
    "efault=OpRef(name='init.fields.78.default'), default_factory=None, init=True, override=False, field_type=FieldType"
    ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='activity_stream_policy_status', anno"
    "tation=OpRef(name='init.fields.79.annotation'), default=OpRef(name='init.fields.79.default'), default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
    ".Field(name='certificate_details', annotation=OpRef(name='init.fields.80.annotation'), default=OpRef(name='init.fi"
    "elds.80.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='db_system_id', annotation=OpRef(name='init.fields.81.annotatio"
    "n'), default=OpRef(name='init.fields.81.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='master_user_secret', annotatio"
    "n=OpRef(name='init.fields.82.annotation'), default=OpRef(name='init.fields.82.default'), default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='read_replica_source_db_cluster_identifier', annotation=OpRef(name='init.fields.83.annotation'), default=Op"
    "Ref(name='init.fields.83.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
    ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='percent_progress', annotation=OpRef(name='ini"
    "t.fields.84.annotation'), default=OpRef(name='init.fields.84.default'), default_factory=None, init=True, override="
    "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='multi_ten"
    "ant', annotation=OpRef(name='init.fields.85.annotation'), default=OpRef(name='init.fields.85.default'), default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='dedicated_log_volume', annotation=OpRef(name='init.fields.86.annotation'), default=OpRef(na"
    "me='init.fields.86.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='is_storage_config_upgrade_available', annotation=Op"
    "Ref(name='init.fields.87.annotation'), default=OpRef(name='init.fields.87.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='engine_lifecycle_support', annotation=OpRef(name='init.fields.88.annotation'), default=OpRef(name='init.fields"
    ".88.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='additional_storage_volumes', annotation=OpRef(name='init.fields.89"
    ".annotation'), default=OpRef(name='init.fields.89.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='storage_volume_statu"
    "s', annotation=OpRef(name='init.fields.90.annotation'), default=OpRef(name='init.fields.90.default'), default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)),"
    " self_param='self', std_params=(), kw_only_params=('db_instance_identifier', 'db_instance_class', 'engine', 'db_in"
    "stance_status', 'master_username', 'db_name', 'endpoint', 'allocated_storage', 'instance_create_time', 'preferred_"
    "backup_window', 'backup_retention_period', 'db_security_groups', 'vpc_security_groups', 'db_parameter_groups', 'av"
    "ailability_zone', 'db_subnet_group', 'preferred_maintenance_window', 'upgrade_rollout_order', 'pending_modified_va"
    "lues', 'latest_restorable_time', 'multi_az', 'engine_version', 'auto_minor_version_upgrade', 'read_replica_source_"
    "db_instance_identifier', 'read_replica_db_instance_identifiers', 'read_replica_db_cluster_identifiers', 'replica_m"
    "ode', 'license_model', 'iops', 'storage_throughput', 'option_group_memberships', 'character_set_name', 'nchar_char"
    "acter_set_name', 'secondary_availability_zone', 'publicly_accessible', 'status_infos', 'storage_type', 'tde_creden"
    "tial_arn', 'db_instance_port', 'db_cluster_identifier', 'storage_encrypted', 'kms_key_id', 'dbi_resource_id', 'ca_"
    "certificate_identifier', 'domain_memberships', 'copy_tags_to_snapshot', 'monitoring_interval', 'enhanced_monitorin"
    "g_resource_arn', 'monitoring_role_arn', 'promotion_tier', 'db_instance_arn', 'timezone', 'iam_database_authenticat"
    "ion_enabled', 'database_insights_mode', 'performance_insights_enabled', 'performance_insights_kms_key_id', 'perfor"
    "mance_insights_retention_period', 'enabled_cloudwatch_logs_exports', 'processor_features', 'deletion_protection', "
    "'associated_roles', 'listener_endpoint', 'max_allocated_storage', 'tag_list', 'automation_mode', 'resume_full_auto"
    "mation_mode_time', 'customer_owned_ip_enabled', 'network_type', 'activity_stream_status', 'activity_stream_kms_key"
    "_id', 'activity_stream_kinesis_stream_name', 'activity_stream_mode', 'activity_stream_engine_native_audit_fields_i"
    "ncluded', 'aws_backup_recovery_point_arn', 'db_instance_automated_backups_replications', 'backup_target', 'automat"
    "ic_restart_time', 'custom_iam_instance_profile', 'activity_stream_policy_status', 'certificate_details', 'db_syste"
    "m_id', 'master_user_secret', 'read_replica_source_db_cluster_identifier', 'percent_progress', 'multi_tenant', 'ded"
    "icated_log_volume', 'is_storage_config_upgrade_available', 'engine_lifecycle_support', 'additional_storage_volumes"
    "', 'storage_volume_status'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
    "lan(fields=(ReprPlan.Field(name='db_instance_identifier', kw_only=True, fn=None), ReprPlan.Field(name='db_instance"
    "_class', kw_only=True, fn=None), ReprPlan.Field(name='engine', kw_only=True, fn=None), ReprPlan.Field(name='db_ins"
    "tance_status', kw_only=True, fn=None), ReprPlan.Field(name='master_username', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='db_name', kw_only=True, fn=None), ReprPlan.Field(name='endpoint', kw_only=True, fn=None), ReprPlan.Field("
    "name='allocated_storage', kw_only=True, fn=None), ReprPlan.Field(name='instance_create_time', kw_only=True, fn=Non"
    "e), ReprPlan.Field(name='preferred_backup_window', kw_only=True, fn=None), ReprPlan.Field(name='backup_retention_p"
    "eriod', kw_only=True, fn=None), ReprPlan.Field(name='db_security_groups', kw_only=True, fn=None), ReprPlan.Field(n"
    "ame='vpc_security_groups', kw_only=True, fn=None), ReprPlan.Field(name='db_parameter_groups', kw_only=True, fn=Non"
    "e), ReprPlan.Field(name='availability_zone', kw_only=True, fn=None), ReprPlan.Field(name='db_subnet_group', kw_onl"
    "y=True, fn=None), ReprPlan.Field(name='preferred_maintenance_window', kw_only=True, fn=None), ReprPlan.Field(name="
    "'upgrade_rollout_order', kw_only=True, fn=None), ReprPlan.Field(name='pending_modified_values', kw_only=True, fn=N"
    "one), ReprPlan.Field(name='latest_restorable_time', kw_only=True, fn=None), ReprPlan.Field(name='multi_az', kw_onl"
    "y=True, fn=None), ReprPlan.Field(name='engine_version', kw_only=True, fn=None), ReprPlan.Field(name='auto_minor_ve"
    "rsion_upgrade', kw_only=True, fn=None), ReprPlan.Field(name='read_replica_source_db_instance_identifier', kw_only="
    "True, fn=None), ReprPlan.Field(name='read_replica_db_instance_identifiers', kw_only=True, fn=None), ReprPlan.Field"
    "(name='read_replica_db_cluster_identifiers', kw_only=True, fn=None), ReprPlan.Field(name='replica_mode', kw_only=T"
    "rue, fn=None), ReprPlan.Field(name='license_model', kw_only=True, fn=None), ReprPlan.Field(name='iops', kw_only=Tr"
    "ue, fn=None), ReprPlan.Field(name='storage_throughput', kw_only=True, fn=None), ReprPlan.Field(name='option_group_"
    "memberships', kw_only=True, fn=None), ReprPlan.Field(name='character_set_name', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='nchar_character_set_name', kw_only=True, fn=None), ReprPlan.Field(name='secondary_availability_zone', k"
    "w_only=True, fn=None), ReprPlan.Field(name='publicly_accessible', kw_only=True, fn=None), ReprPlan.Field(name='sta"
    "tus_infos', kw_only=True, fn=None), ReprPlan.Field(name='storage_type', kw_only=True, fn=None), ReprPlan.Field(nam"
    "e='tde_credential_arn', kw_only=True, fn=None), ReprPlan.Field(name='db_instance_port', kw_only=True, fn=None), Re"
    "prPlan.Field(name='db_cluster_identifier', kw_only=True, fn=None), ReprPlan.Field(name='storage_encrypted', kw_onl"
    "y=True, fn=None), ReprPlan.Field(name='kms_key_id', kw_only=True, fn=None), ReprPlan.Field(name='dbi_resource_id',"
    " kw_only=True, fn=None), ReprPlan.Field(name='ca_certificate_identifier', kw_only=True, fn=None), ReprPlan.Field(n"
    "ame='domain_memberships', kw_only=True, fn=None), ReprPlan.Field(name='copy_tags_to_snapshot', kw_only=True, fn=No"
    "ne), ReprPlan.Field(name='monitoring_interval', kw_only=True, fn=None), ReprPlan.Field(name='enhanced_monitoring_r"
    "esource_arn', kw_only=True, fn=None), ReprPlan.Field(name='monitoring_role_arn', kw_only=True, fn=None), ReprPlan."
    "Field(name='promotion_tier', kw_only=True, fn=None), ReprPlan.Field(name='db_instance_arn', kw_only=True, fn=None)"
    ", ReprPlan.Field(name='timezone', kw_only=True, fn=None), ReprPlan.Field(name='iam_database_authentication_enabled"
    "', kw_only=True, fn=None), ReprPlan.Field(name='database_insights_mode', kw_only=True, fn=None), ReprPlan.Field(na"
    "me='performance_insights_enabled', kw_only=True, fn=None), ReprPlan.Field(name='performance_insights_kms_key_id', "
    "kw_only=True, fn=None), ReprPlan.Field(name='performance_insights_retention_period', kw_only=True, fn=None), ReprP"
    "lan.Field(name='enabled_cloudwatch_logs_exports', kw_only=True, fn=None), ReprPlan.Field(name='processor_features'"
    ", kw_only=True, fn=None), ReprPlan.Field(name='deletion_protection', kw_only=True, fn=None), ReprPlan.Field(name='"
    "associated_roles', kw_only=True, fn=None), ReprPlan.Field(name='listener_endpoint', kw_only=True, fn=None), ReprPl"
    "an.Field(name='max_allocated_storage', kw_only=True, fn=None), ReprPlan.Field(name='tag_list', kw_only=True, fn=No"
    "ne), ReprPlan.Field(name='automation_mode', kw_only=True, fn=None), ReprPlan.Field(name='resume_full_automation_mo"
    "de_time', kw_only=True, fn=None), ReprPlan.Field(name='customer_owned_ip_enabled', kw_only=True, fn=None), ReprPla"
    "n.Field(name='network_type', kw_only=True, fn=None), ReprPlan.Field(name='activity_stream_status', kw_only=True, f"
    "n=None), ReprPlan.Field(name='activity_stream_kms_key_id', kw_only=True, fn=None), ReprPlan.Field(name='activity_s"
    "tream_kinesis_stream_name', kw_only=True, fn=None), ReprPlan.Field(name='activity_stream_mode', kw_only=True, fn=N"
    "one), ReprPlan.Field(name='activity_stream_engine_native_audit_fields_included', kw_only=True, fn=None), ReprPlan."
    "Field(name='aws_backup_recovery_point_arn', kw_only=True, fn=None), ReprPlan.Field(name='db_instance_automated_bac"
    "kups_replications', kw_only=True, fn=None), ReprPlan.Field(name='backup_target', kw_only=True, fn=None), ReprPlan."
    "Field(name='automatic_restart_time', kw_only=True, fn=None), ReprPlan.Field(name='custom_iam_instance_profile', kw"
    "_only=True, fn=None), ReprPlan.Field(name='activity_stream_policy_status', kw_only=True, fn=None), ReprPlan.Field("
    "name='certificate_details', kw_only=True, fn=None), ReprPlan.Field(name='db_system_id', kw_only=True, fn=None), Re"
    "prPlan.Field(name='master_user_secret', kw_only=True, fn=None), ReprPlan.Field(name='read_replica_source_db_cluste"
    "r_identifier', kw_only=True, fn=None), ReprPlan.Field(name='percent_progress', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='multi_tenant', kw_only=True, fn=None), ReprPlan.Field(name='dedicated_log_volume', kw_only=True, fn=None"
    "), ReprPlan.Field(name='is_storage_config_upgrade_available', kw_only=True, fn=None), ReprPlan.Field(name='engine_"
    "lifecycle_support', kw_only=True, fn=None), ReprPlan.Field(name='additional_storage_volumes', kw_only=True, fn=Non"
    "e), ReprPlan.Field(name='storage_volume_status', kw_only=True, fn=None)), id=False, terse=False, default_fn=None))"
    ")"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDBInstance(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__21__annotation,
    __dataclass__init__fields__21__default,
    __dataclass__init__fields__22__annotation,
    __dataclass__init__fields__22__default,
    __dataclass__init__fields__23__annotation,
    __dataclass__init__fields__23__default,
    __dataclass__init__fields__24__annotation,
    __dataclass__init__fields__24__default,
    __dataclass__init__fields__25__annotation,
    __dataclass__init__fields__25__default,
    __dataclass__init__fields__26__annotation,
    __dataclass__init__fields__26__default,
    __dataclass__init__fields__27__annotation,
    __dataclass__init__fields__27__default,
    __dataclass__init__fields__28__annotation,
    __dataclass__init__fields__28__default,
    __dataclass__init__fields__29__annotation,
    __dataclass__init__fields__29__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__30__annotation,
    __dataclass__init__fields__30__default,
    __dataclass__init__fields__31__annotation,
    __dataclass__init__fields__31__default,
    __dataclass__init__fields__32__annotation,
    __dataclass__init__fields__32__default,
    __dataclass__init__fields__33__annotation,
    __dataclass__init__fields__33__default,
    __dataclass__init__fields__34__annotation,
    __dataclass__init__fields__34__default,
    __dataclass__init__fields__35__annotation,
    __dataclass__init__fields__35__default,
    __dataclass__init__fields__36__annotation,
    __dataclass__init__fields__36__default,
    __dataclass__init__fields__37__annotation,
    __dataclass__init__fields__37__default,
    __dataclass__init__fields__38__annotation,
    __dataclass__init__fields__38__default,
    __dataclass__init__fields__39__annotation,
    __dataclass__init__fields__39__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__40__annotation,
    __dataclass__init__fields__40__default,
    __dataclass__init__fields__41__annotation,
    __dataclass__init__fields__41__default,
    __dataclass__init__fields__42__annotation,
    __dataclass__init__fields__42__default,
    __dataclass__init__fields__43__annotation,
    __dataclass__init__fields__43__default,
    __dataclass__init__fields__44__annotation,
    __dataclass__init__fields__44__default,
    __dataclass__init__fields__45__annotation,
    __dataclass__init__fields__45__default,
    __dataclass__init__fields__46__annotation,
    __dataclass__init__fields__46__default,
    __dataclass__init__fields__47__annotation,
    __dataclass__init__fields__47__default,
    __dataclass__init__fields__48__annotation,
    __dataclass__init__fields__48__default,
    __dataclass__init__fields__49__annotation,
    __dataclass__init__fields__49__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__50__annotation,
    __dataclass__init__fields__50__default,
    __dataclass__init__fields__51__annotation,
    __dataclass__init__fields__51__default,
    __dataclass__init__fields__52__annotation,
    __dataclass__init__fields__52__default,
    __dataclass__init__fields__53__annotation,
    __dataclass__init__fields__53__default,
    __dataclass__init__fields__54__annotation,
    __dataclass__init__fields__54__default,
    __dataclass__init__fields__55__annotation,
    __dataclass__init__fields__55__default,
    __dataclass__init__fields__56__annotation,
    __dataclass__init__fields__56__default,
    __dataclass__init__fields__57__annotation,
    __dataclass__init__fields__57__default,
    __dataclass__init__fields__58__annotation,
    __dataclass__init__fields__58__default,
    __dataclass__init__fields__59__annotation,
    __dataclass__init__fields__59__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__60__annotation,
    __dataclass__init__fields__60__default,
    __dataclass__init__fields__61__annotation,
    __dataclass__init__fields__61__default,
    __dataclass__init__fields__62__annotation,
    __dataclass__init__fields__62__default,
    __dataclass__init__fields__63__annotation,
    __dataclass__init__fields__63__default,
    __dataclass__init__fields__64__annotation,
    __dataclass__init__fields__64__default,
    __dataclass__init__fields__65__annotation,
    __dataclass__init__fields__65__default,
    __dataclass__init__fields__66__annotation,
    __dataclass__init__fields__66__default,
    __dataclass__init__fields__67__annotation,
    __dataclass__init__fields__67__default,
    __dataclass__init__fields__68__annotation,
    __dataclass__init__fields__68__default,
    __dataclass__init__fields__69__annotation,
    __dataclass__init__fields__69__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__70__annotation,
    __dataclass__init__fields__70__default,
    __dataclass__init__fields__71__annotation,
    __dataclass__init__fields__71__default,
    __dataclass__init__fields__72__annotation,
    __dataclass__init__fields__72__default,
    __dataclass__init__fields__73__annotation,
    __dataclass__init__fields__73__default,
    __dataclass__init__fields__74__annotation,
    __dataclass__init__fields__74__default,
    __dataclass__init__fields__75__annotation,
    __dataclass__init__fields__75__default,
    __dataclass__init__fields__76__annotation,
    __dataclass__init__fields__76__default,
    __dataclass__init__fields__77__annotation,
    __dataclass__init__fields__77__default,
    __dataclass__init__fields__78__annotation,
    __dataclass__init__fields__78__default,
    __dataclass__init__fields__79__annotation,
    __dataclass__init__fields__79__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__80__annotation,
    __dataclass__init__fields__80__default,
    __dataclass__init__fields__81__annotation,
    __dataclass__init__fields__81__default,
    __dataclass__init__fields__82__annotation,
    __dataclass__init__fields__82__default,
    __dataclass__init__fields__83__annotation,
    __dataclass__init__fields__83__default,
    __dataclass__init__fields__84__annotation,
    __dataclass__init__fields__84__default,
    __dataclass__init__fields__85__annotation,
    __dataclass__init__fields__85__default,
    __dataclass__init__fields__86__annotation,
    __dataclass__init__fields__86__default,
    __dataclass__init__fields__87__annotation,
    __dataclass__init__fields__87__default,
    __dataclass__init__fields__88__annotation,
    __dataclass__init__fields__88__default,
    __dataclass__init__fields__89__annotation,
    __dataclass__init__fields__89__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__90__annotation,
    __dataclass__init__fields__90__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            db_instance_identifier=self.db_instance_identifier,
            db_instance_class=self.db_instance_class,
            engine=self.engine,
            db_instance_status=self.db_instance_status,
            master_username=self.master_username,
            db_name=self.db_name,
            endpoint=self.endpoint,
            allocated_storage=self.allocated_storage,
            instance_create_time=self.instance_create_time,
            preferred_backup_window=self.preferred_backup_window,
            backup_retention_period=self.backup_retention_period,
            db_security_groups=self.db_security_groups,
            vpc_security_groups=self.vpc_security_groups,
            db_parameter_groups=self.db_parameter_groups,
            availability_zone=self.availability_zone,
            db_subnet_group=self.db_subnet_group,
            preferred_maintenance_window=self.preferred_maintenance_window,
            upgrade_rollout_order=self.upgrade_rollout_order,
            pending_modified_values=self.pending_modified_values,
            latest_restorable_time=self.latest_restorable_time,
            multi_az=self.multi_az,
            engine_version=self.engine_version,
            auto_minor_version_upgrade=self.auto_minor_version_upgrade,
            read_replica_source_db_instance_identifier=self.read_replica_source_db_instance_identifier,
            read_replica_db_instance_identifiers=self.read_replica_db_instance_identifiers,
            read_replica_db_cluster_identifiers=self.read_replica_db_cluster_identifiers,
            replica_mode=self.replica_mode,
            license_model=self.license_model,
            iops=self.iops,
            storage_throughput=self.storage_throughput,
            option_group_memberships=self.option_group_memberships,
            character_set_name=self.character_set_name,
            nchar_character_set_name=self.nchar_character_set_name,
            secondary_availability_zone=self.secondary_availability_zone,
            publicly_accessible=self.publicly_accessible,
            status_infos=self.status_infos,
            storage_type=self.storage_type,
            tde_credential_arn=self.tde_credential_arn,
            db_instance_port=self.db_instance_port,
            db_cluster_identifier=self.db_cluster_identifier,
            storage_encrypted=self.storage_encrypted,
            kms_key_id=self.kms_key_id,
            dbi_resource_id=self.dbi_resource_id,
            ca_certificate_identifier=self.ca_certificate_identifier,
            domain_memberships=self.domain_memberships,
            copy_tags_to_snapshot=self.copy_tags_to_snapshot,
            monitoring_interval=self.monitoring_interval,
            enhanced_monitoring_resource_arn=self.enhanced_monitoring_resource_arn,
            monitoring_role_arn=self.monitoring_role_arn,
            promotion_tier=self.promotion_tier,
            db_instance_arn=self.db_instance_arn,
            timezone=self.timezone,
            iam_database_authentication_enabled=self.iam_database_authentication_enabled,
            database_insights_mode=self.database_insights_mode,
            performance_insights_enabled=self.performance_insights_enabled,
            performance_insights_kms_key_id=self.performance_insights_kms_key_id,
            performance_insights_retention_period=self.performance_insights_retention_period,
            enabled_cloudwatch_logs_exports=self.enabled_cloudwatch_logs_exports,
            processor_features=self.processor_features,
            deletion_protection=self.deletion_protection,
            associated_roles=self.associated_roles,
            listener_endpoint=self.listener_endpoint,
            max_allocated_storage=self.max_allocated_storage,
            tag_list=self.tag_list,
            automation_mode=self.automation_mode,
            resume_full_automation_mode_time=self.resume_full_automation_mode_time,
            customer_owned_ip_enabled=self.customer_owned_ip_enabled,
            network_type=self.network_type,
            activity_stream_status=self.activity_stream_status,
            activity_stream_kms_key_id=self.activity_stream_kms_key_id,
            activity_stream_kinesis_stream_name=self.activity_stream_kinesis_stream_name,
            activity_stream_mode=self.activity_stream_mode,
            activity_stream_engine_native_audit_fields_included=self.activity_stream_engine_native_audit_fields_included,
            aws_backup_recovery_point_arn=self.aws_backup_recovery_point_arn,
            db_instance_automated_backups_replications=self.db_instance_automated_backups_replications,
            backup_target=self.backup_target,
            automatic_restart_time=self.automatic_restart_time,
            custom_iam_instance_profile=self.custom_iam_instance_profile,
            activity_stream_policy_status=self.activity_stream_policy_status,
            certificate_details=self.certificate_details,
            db_system_id=self.db_system_id,
            master_user_secret=self.master_user_secret,
            read_replica_source_db_cluster_identifier=self.read_replica_source_db_cluster_identifier,
            percent_progress=self.percent_progress,
            multi_tenant=self.multi_tenant,
            dedicated_log_volume=self.dedicated_log_volume,
            is_storage_config_upgrade_available=self.is_storage_config_upgrade_available,
            engine_lifecycle_support=self.engine_lifecycle_support,
            additional_storage_volumes=self.additional_storage_volumes,
            storage_volume_status=self.storage_volume_status,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.db_instance_identifier == other.db_instance_identifier and
            self.db_instance_class == other.db_instance_class and
            self.engine == other.engine and
            self.db_instance_status == other.db_instance_status and
            self.master_username == other.master_username and
            self.db_name == other.db_name and
            self.endpoint == other.endpoint and
            self.allocated_storage == other.allocated_storage and
            self.instance_create_time == other.instance_create_time and
            self.preferred_backup_window == other.preferred_backup_window and
            self.backup_retention_period == other.backup_retention_period and
            self.db_security_groups == other.db_security_groups and
            self.vpc_security_groups == other.vpc_security_groups and
            self.db_parameter_groups == other.db_parameter_groups and
            self.availability_zone == other.availability_zone and
            self.db_subnet_group == other.db_subnet_group and
            self.preferred_maintenance_window == other.preferred_maintenance_window and
            self.upgrade_rollout_order == other.upgrade_rollout_order and
            self.pending_modified_values == other.pending_modified_values and
            self.latest_restorable_time == other.latest_restorable_time and
            self.multi_az == other.multi_az and
            self.engine_version == other.engine_version and
            self.auto_minor_version_upgrade == other.auto_minor_version_upgrade and
            self.read_replica_source_db_instance_identifier == other.read_replica_source_db_instance_identifier and
            self.read_replica_db_instance_identifiers == other.read_replica_db_instance_identifiers and
            self.read_replica_db_cluster_identifiers == other.read_replica_db_cluster_identifiers and
            self.replica_mode == other.replica_mode and
            self.license_model == other.license_model and
            self.iops == other.iops and
            self.storage_throughput == other.storage_throughput and
            self.option_group_memberships == other.option_group_memberships and
            self.character_set_name == other.character_set_name and
            self.nchar_character_set_name == other.nchar_character_set_name and
            self.secondary_availability_zone == other.secondary_availability_zone and
            self.publicly_accessible == other.publicly_accessible and
            self.status_infos == other.status_infos and
            self.storage_type == other.storage_type and
            self.tde_credential_arn == other.tde_credential_arn and
            self.db_instance_port == other.db_instance_port and
            self.db_cluster_identifier == other.db_cluster_identifier and
            self.storage_encrypted == other.storage_encrypted and
            self.kms_key_id == other.kms_key_id and
            self.dbi_resource_id == other.dbi_resource_id and
            self.ca_certificate_identifier == other.ca_certificate_identifier and
            self.domain_memberships == other.domain_memberships and
            self.copy_tags_to_snapshot == other.copy_tags_to_snapshot and
            self.monitoring_interval == other.monitoring_interval and
            self.enhanced_monitoring_resource_arn == other.enhanced_monitoring_resource_arn and
            self.monitoring_role_arn == other.monitoring_role_arn and
            self.promotion_tier == other.promotion_tier and
            self.db_instance_arn == other.db_instance_arn and
            self.timezone == other.timezone and
            self.iam_database_authentication_enabled == other.iam_database_authentication_enabled and
            self.database_insights_mode == other.database_insights_mode and
            self.performance_insights_enabled == other.performance_insights_enabled and
            self.performance_insights_kms_key_id == other.performance_insights_kms_key_id and
            self.performance_insights_retention_period == other.performance_insights_retention_period and
            self.enabled_cloudwatch_logs_exports == other.enabled_cloudwatch_logs_exports and
            self.processor_features == other.processor_features and
            self.deletion_protection == other.deletion_protection and
            self.associated_roles == other.associated_roles and
            self.listener_endpoint == other.listener_endpoint and
            self.max_allocated_storage == other.max_allocated_storage and
            self.tag_list == other.tag_list and
            self.automation_mode == other.automation_mode and
            self.resume_full_automation_mode_time == other.resume_full_automation_mode_time and
            self.customer_owned_ip_enabled == other.customer_owned_ip_enabled and
            self.network_type == other.network_type and
            self.activity_stream_status == other.activity_stream_status and
            self.activity_stream_kms_key_id == other.activity_stream_kms_key_id and
            self.activity_stream_kinesis_stream_name == other.activity_stream_kinesis_stream_name and
            self.activity_stream_mode == other.activity_stream_mode and
            self.activity_stream_engine_native_audit_fields_included == other.activity_stream_engine_native_audit_fields_included and
            self.aws_backup_recovery_point_arn == other.aws_backup_recovery_point_arn and
            self.db_instance_automated_backups_replications == other.db_instance_automated_backups_replications and
            self.backup_target == other.backup_target and
            self.automatic_restart_time == other.automatic_restart_time and
            self.custom_iam_instance_profile == other.custom_iam_instance_profile and
            self.activity_stream_policy_status == other.activity_stream_policy_status and
            self.certificate_details == other.certificate_details and
            self.db_system_id == other.db_system_id and
            self.master_user_secret == other.master_user_secret and
            self.read_replica_source_db_cluster_identifier == other.read_replica_source_db_cluster_identifier and
            self.percent_progress == other.percent_progress and
            self.multi_tenant == other.multi_tenant and
            self.dedicated_log_volume == other.dedicated_log_volume and
            self.is_storage_config_upgrade_available == other.is_storage_config_upgrade_available and
            self.engine_lifecycle_support == other.engine_lifecycle_support and
            self.additional_storage_volumes == other.additional_storage_volumes and
            self.storage_volume_status == other.storage_volume_status
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'db_instance_identifier',
        'db_instance_class',
        'engine',
        'db_instance_status',
        'master_username',
        'db_name',
        'endpoint',
        'allocated_storage',
        'instance_create_time',
        'preferred_backup_window',
        'backup_retention_period',
        'db_security_groups',
        'vpc_security_groups',
        'db_parameter_groups',
        'availability_zone',
        'db_subnet_group',
        'preferred_maintenance_window',
        'upgrade_rollout_order',
        'pending_modified_values',
        'latest_restorable_time',
        'multi_az',
        'engine_version',
        'auto_minor_version_upgrade',
        'read_replica_source_db_instance_identifier',
        'read_replica_db_instance_identifiers',
        'read_replica_db_cluster_identifiers',
        'replica_mode',
        'license_model',
        'iops',
        'storage_throughput',
        'option_group_memberships',
        'character_set_name',
        'nchar_character_set_name',
        'secondary_availability_zone',
        'publicly_accessible',
        'status_infos',
        'storage_type',
        'tde_credential_arn',
        'db_instance_port',
        'db_cluster_identifier',
        'storage_encrypted',
        'kms_key_id',
        'dbi_resource_id',
        'ca_certificate_identifier',
        'domain_memberships',
        'copy_tags_to_snapshot',
        'monitoring_interval',
        'enhanced_monitoring_resource_arn',
        'monitoring_role_arn',
        'promotion_tier',
        'db_instance_arn',
        'timezone',
        'iam_database_authentication_enabled',
        'database_insights_mode',
        'performance_insights_enabled',
        'performance_insights_kms_key_id',
        'performance_insights_retention_period',
        'enabled_cloudwatch_logs_exports',
        'processor_features',
        'deletion_protection',
        'associated_roles',
        'listener_endpoint',
        'max_allocated_storage',
        'tag_list',
        'automation_mode',
        'resume_full_automation_mode_time',
        'customer_owned_ip_enabled',
        'network_type',
        'activity_stream_status',
        'activity_stream_kms_key_id',
        'activity_stream_kinesis_stream_name',
        'activity_stream_mode',
        'activity_stream_engine_native_audit_fields_included',
        'aws_backup_recovery_point_arn',
        'db_instance_automated_backups_replications',
        'backup_target',
        'automatic_restart_time',
        'custom_iam_instance_profile',
        'activity_stream_policy_status',
        'certificate_details',
        'db_system_id',
        'master_user_secret',
        'read_replica_source_db_cluster_identifier',
        'percent_progress',
        'multi_tenant',
        'dedicated_log_volume',
        'is_storage_config_upgrade_available',
        'engine_lifecycle_support',
        'additional_storage_volumes',
        'storage_volume_status',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'db_instance_identifier',
        'db_instance_class',
        'engine',
        'db_instance_status',
        'master_username',
        'db_name',
        'endpoint',
        'allocated_storage',
        'instance_create_time',
        'preferred_backup_window',
        'backup_retention_period',
        'db_security_groups',
        'vpc_security_groups',
        'db_parameter_groups',
        'availability_zone',
        'db_subnet_group',
        'preferred_maintenance_window',
        'upgrade_rollout_order',
        'pending_modified_values',
        'latest_restorable_time',
        'multi_az',
        'engine_version',
        'auto_minor_version_upgrade',
        'read_replica_source_db_instance_identifier',
        'read_replica_db_instance_identifiers',
        'read_replica_db_cluster_identifiers',
        'replica_mode',
        'license_model',
        'iops',
        'storage_throughput',
        'option_group_memberships',
        'character_set_name',
        'nchar_character_set_name',
        'secondary_availability_zone',
        'publicly_accessible',
        'status_infos',
        'storage_type',
        'tde_credential_arn',
        'db_instance_port',
        'db_cluster_identifier',
        'storage_encrypted',
        'kms_key_id',
        'dbi_resource_id',
        'ca_certificate_identifier',
        'domain_memberships',
        'copy_tags_to_snapshot',
        'monitoring_interval',
        'enhanced_monitoring_resource_arn',
        'monitoring_role_arn',
        'promotion_tier',
        'db_instance_arn',
        'timezone',
        'iam_database_authentication_enabled',
        'database_insights_mode',
        'performance_insights_enabled',
        'performance_insights_kms_key_id',
        'performance_insights_retention_period',
        'enabled_cloudwatch_logs_exports',
        'processor_features',
        'deletion_protection',
        'associated_roles',
        'listener_endpoint',
        'max_allocated_storage',
        'tag_list',
        'automation_mode',
        'resume_full_automation_mode_time',
        'customer_owned_ip_enabled',
        'network_type',
        'activity_stream_status',
        'activity_stream_kms_key_id',
        'activity_stream_kinesis_stream_name',
        'activity_stream_mode',
        'activity_stream_engine_native_audit_fields_included',
        'aws_backup_recovery_point_arn',
        'db_instance_automated_backups_replications',
        'backup_target',
        'automatic_restart_time',
        'custom_iam_instance_profile',
        'activity_stream_policy_status',
        'certificate_details',
        'db_system_id',
        'master_user_secret',
        'read_replica_source_db_cluster_identifier',
        'percent_progress',
        'multi_tenant',
        'dedicated_log_volume',
        'is_storage_config_upgrade_available',
        'engine_lifecycle_support',
        'additional_storage_volumes',
        'storage_volume_status',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.db_instance_identifier,
            self.db_instance_class,
            self.engine,
            self.db_instance_status,
            self.master_username,
            self.db_name,
            self.endpoint,
            self.allocated_storage,
            self.instance_create_time,
            self.preferred_backup_window,
            self.backup_retention_period,
            self.db_security_groups,
            self.vpc_security_groups,
            self.db_parameter_groups,
            self.availability_zone,
            self.db_subnet_group,
            self.preferred_maintenance_window,
            self.upgrade_rollout_order,
            self.pending_modified_values,
            self.latest_restorable_time,
            self.multi_az,
            self.engine_version,
            self.auto_minor_version_upgrade,
            self.read_replica_source_db_instance_identifier,
            self.read_replica_db_instance_identifiers,
            self.read_replica_db_cluster_identifiers,
            self.replica_mode,
            self.license_model,
            self.iops,
            self.storage_throughput,
            self.option_group_memberships,
            self.character_set_name,
            self.nchar_character_set_name,
            self.secondary_availability_zone,
            self.publicly_accessible,
            self.status_infos,
            self.storage_type,
            self.tde_credential_arn,
            self.db_instance_port,
            self.db_cluster_identifier,
            self.storage_encrypted,
            self.kms_key_id,
            self.dbi_resource_id,
            self.ca_certificate_identifier,
            self.domain_memberships,
            self.copy_tags_to_snapshot,
            self.monitoring_interval,
            self.enhanced_monitoring_resource_arn,
            self.monitoring_role_arn,
            self.promotion_tier,
            self.db_instance_arn,
            self.timezone,
            self.iam_database_authentication_enabled,
            self.database_insights_mode,
            self.performance_insights_enabled,
            self.performance_insights_kms_key_id,
            self.performance_insights_retention_period,
            self.enabled_cloudwatch_logs_exports,
            self.processor_features,
            self.deletion_protection,
            self.associated_roles,
            self.listener_endpoint,
            self.max_allocated_storage,
            self.tag_list,
            self.automation_mode,
            self.resume_full_automation_mode_time,
            self.customer_owned_ip_enabled,
            self.network_type,
            self.activity_stream_status,
            self.activity_stream_kms_key_id,
            self.activity_stream_kinesis_stream_name,
            self.activity_stream_mode,
            self.activity_stream_engine_native_audit_fields_included,
            self.aws_backup_recovery_point_arn,
            self.db_instance_automated_backups_replications,
            self.backup_target,
            self.automatic_restart_time,
            self.custom_iam_instance_profile,
            self.activity_stream_policy_status,
            self.certificate_details,
            self.db_system_id,
            self.master_user_secret,
            self.read_replica_source_db_cluster_identifier,
            self.percent_progress,
            self.multi_tenant,
            self.dedicated_log_volume,
            self.is_storage_config_upgrade_available,
            self.engine_lifecycle_support,
            self.additional_storage_volumes,
            self.storage_volume_status,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        db_instance_identifier: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        db_instance_class: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        engine: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        db_instance_status: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        master_username: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        db_name: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        endpoint: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        allocated_storage: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        instance_create_time: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        preferred_backup_window: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        backup_retention_period: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        db_security_groups: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        vpc_security_groups: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        db_parameter_groups: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        availability_zone: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        db_subnet_group: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        preferred_maintenance_window: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        upgrade_rollout_order: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        pending_modified_values: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        latest_restorable_time: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        multi_az: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
        engine_version: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
        auto_minor_version_upgrade: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
        read_replica_source_db_instance_identifier: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
        read_replica_db_instance_identifiers: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
        read_replica_db_cluster_identifiers: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
        replica_mode: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
        license_model: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
        iops: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
        storage_throughput: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
        option_group_memberships: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
        character_set_name: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
        nchar_character_set_name: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
        secondary_availability_zone: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
        publicly_accessible: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
        status_infos: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
        storage_type: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
        tde_credential_arn: __dataclass__init__fields__38__annotation = __dataclass__init__fields__38__default,
        db_instance_port: __dataclass__init__fields__39__annotation = __dataclass__init__fields__39__default,
        db_cluster_identifier: __dataclass__init__fields__40__annotation = __dataclass__init__fields__40__default,
        storage_encrypted: __dataclass__init__fields__41__annotation = __dataclass__init__fields__41__default,
        kms_key_id: __dataclass__init__fields__42__annotation = __dataclass__init__fields__42__default,
        dbi_resource_id: __dataclass__init__fields__43__annotation = __dataclass__init__fields__43__default,
        ca_certificate_identifier: __dataclass__init__fields__44__annotation = __dataclass__init__fields__44__default,
        domain_memberships: __dataclass__init__fields__45__annotation = __dataclass__init__fields__45__default,
        copy_tags_to_snapshot: __dataclass__init__fields__46__annotation = __dataclass__init__fields__46__default,
        monitoring_interval: __dataclass__init__fields__47__annotation = __dataclass__init__fields__47__default,
        enhanced_monitoring_resource_arn: __dataclass__init__fields__48__annotation = __dataclass__init__fields__48__default,
        monitoring_role_arn: __dataclass__init__fields__49__annotation = __dataclass__init__fields__49__default,
        promotion_tier: __dataclass__init__fields__50__annotation = __dataclass__init__fields__50__default,
        db_instance_arn: __dataclass__init__fields__51__annotation = __dataclass__init__fields__51__default,
        timezone: __dataclass__init__fields__52__annotation = __dataclass__init__fields__52__default,
        iam_database_authentication_enabled: __dataclass__init__fields__53__annotation = __dataclass__init__fields__53__default,
        database_insights_mode: __dataclass__init__fields__54__annotation = __dataclass__init__fields__54__default,
        performance_insights_enabled: __dataclass__init__fields__55__annotation = __dataclass__init__fields__55__default,
        performance_insights_kms_key_id: __dataclass__init__fields__56__annotation = __dataclass__init__fields__56__default,
        performance_insights_retention_period: __dataclass__init__fields__57__annotation = __dataclass__init__fields__57__default,
        enabled_cloudwatch_logs_exports: __dataclass__init__fields__58__annotation = __dataclass__init__fields__58__default,
        processor_features: __dataclass__init__fields__59__annotation = __dataclass__init__fields__59__default,
        deletion_protection: __dataclass__init__fields__60__annotation = __dataclass__init__fields__60__default,
        associated_roles: __dataclass__init__fields__61__annotation = __dataclass__init__fields__61__default,
        listener_endpoint: __dataclass__init__fields__62__annotation = __dataclass__init__fields__62__default,
        max_allocated_storage: __dataclass__init__fields__63__annotation = __dataclass__init__fields__63__default,
        tag_list: __dataclass__init__fields__64__annotation = __dataclass__init__fields__64__default,
        automation_mode: __dataclass__init__fields__65__annotation = __dataclass__init__fields__65__default,
        resume_full_automation_mode_time: __dataclass__init__fields__66__annotation = __dataclass__init__fields__66__default,
        customer_owned_ip_enabled: __dataclass__init__fields__67__annotation = __dataclass__init__fields__67__default,
        network_type: __dataclass__init__fields__68__annotation = __dataclass__init__fields__68__default,
        activity_stream_status: __dataclass__init__fields__69__annotation = __dataclass__init__fields__69__default,
        activity_stream_kms_key_id: __dataclass__init__fields__70__annotation = __dataclass__init__fields__70__default,
        activity_stream_kinesis_stream_name: __dataclass__init__fields__71__annotation = __dataclass__init__fields__71__default,
        activity_stream_mode: __dataclass__init__fields__72__annotation = __dataclass__init__fields__72__default,
        activity_stream_engine_native_audit_fields_included: __dataclass__init__fields__73__annotation = __dataclass__init__fields__73__default,
        aws_backup_recovery_point_arn: __dataclass__init__fields__74__annotation = __dataclass__init__fields__74__default,
        db_instance_automated_backups_replications: __dataclass__init__fields__75__annotation = __dataclass__init__fields__75__default,
        backup_target: __dataclass__init__fields__76__annotation = __dataclass__init__fields__76__default,
        automatic_restart_time: __dataclass__init__fields__77__annotation = __dataclass__init__fields__77__default,
        custom_iam_instance_profile: __dataclass__init__fields__78__annotation = __dataclass__init__fields__78__default,
        activity_stream_policy_status: __dataclass__init__fields__79__annotation = __dataclass__init__fields__79__default,
        certificate_details: __dataclass__init__fields__80__annotation = __dataclass__init__fields__80__default,
        db_system_id: __dataclass__init__fields__81__annotation = __dataclass__init__fields__81__default,
        master_user_secret: __dataclass__init__fields__82__annotation = __dataclass__init__fields__82__default,
        read_replica_source_db_cluster_identifier: __dataclass__init__fields__83__annotation = __dataclass__init__fields__83__default,
        percent_progress: __dataclass__init__fields__84__annotation = __dataclass__init__fields__84__default,
        multi_tenant: __dataclass__init__fields__85__annotation = __dataclass__init__fields__85__default,
        dedicated_log_volume: __dataclass__init__fields__86__annotation = __dataclass__init__fields__86__default,
        is_storage_config_upgrade_available: __dataclass__init__fields__87__annotation = __dataclass__init__fields__87__default,
        engine_lifecycle_support: __dataclass__init__fields__88__annotation = __dataclass__init__fields__88__default,
        additional_storage_volumes: __dataclass__init__fields__89__annotation = __dataclass__init__fields__89__default,
        storage_volume_status: __dataclass__init__fields__90__annotation = __dataclass__init__fields__90__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'db_instance_identifier', db_instance_identifier)
        __dataclass__object_setattr(self, 'db_instance_class', db_instance_class)
        __dataclass__object_setattr(self, 'engine', engine)
        __dataclass__object_setattr(self, 'db_instance_status', db_instance_status)
        __dataclass__object_setattr(self, 'master_username', master_username)
        __dataclass__object_setattr(self, 'db_name', db_name)
        __dataclass__object_setattr(self, 'endpoint', endpoint)
        __dataclass__object_setattr(self, 'allocated_storage', allocated_storage)
        __dataclass__object_setattr(self, 'instance_create_time', instance_create_time)
        __dataclass__object_setattr(self, 'preferred_backup_window', preferred_backup_window)
        __dataclass__object_setattr(self, 'backup_retention_period', backup_retention_period)
        __dataclass__object_setattr(self, 'db_security_groups', db_security_groups)
        __dataclass__object_setattr(self, 'vpc_security_groups', vpc_security_groups)
        __dataclass__object_setattr(self, 'db_parameter_groups', db_parameter_groups)
        __dataclass__object_setattr(self, 'availability_zone', availability_zone)
        __dataclass__object_setattr(self, 'db_subnet_group', db_subnet_group)
        __dataclass__object_setattr(self, 'preferred_maintenance_window', preferred_maintenance_window)
        __dataclass__object_setattr(self, 'upgrade_rollout_order', upgrade_rollout_order)
        __dataclass__object_setattr(self, 'pending_modified_values', pending_modified_values)
        __dataclass__object_setattr(self, 'latest_restorable_time', latest_restorable_time)
        __dataclass__object_setattr(self, 'multi_az', multi_az)
        __dataclass__object_setattr(self, 'engine_version', engine_version)
        __dataclass__object_setattr(self, 'auto_minor_version_upgrade', auto_minor_version_upgrade)
        __dataclass__object_setattr(self, 'read_replica_source_db_instance_identifier', read_replica_source_db_instance_identifier)
        __dataclass__object_setattr(self, 'read_replica_db_instance_identifiers', read_replica_db_instance_identifiers)
        __dataclass__object_setattr(self, 'read_replica_db_cluster_identifiers', read_replica_db_cluster_identifiers)
        __dataclass__object_setattr(self, 'replica_mode', replica_mode)
        __dataclass__object_setattr(self, 'license_model', license_model)
        __dataclass__object_setattr(self, 'iops', iops)
        __dataclass__object_setattr(self, 'storage_throughput', storage_throughput)
        __dataclass__object_setattr(self, 'option_group_memberships', option_group_memberships)
        __dataclass__object_setattr(self, 'character_set_name', character_set_name)
        __dataclass__object_setattr(self, 'nchar_character_set_name', nchar_character_set_name)
        __dataclass__object_setattr(self, 'secondary_availability_zone', secondary_availability_zone)
        __dataclass__object_setattr(self, 'publicly_accessible', publicly_accessible)
        __dataclass__object_setattr(self, 'status_infos', status_infos)
        __dataclass__object_setattr(self, 'storage_type', storage_type)
        __dataclass__object_setattr(self, 'tde_credential_arn', tde_credential_arn)
        __dataclass__object_setattr(self, 'db_instance_port', db_instance_port)
        __dataclass__object_setattr(self, 'db_cluster_identifier', db_cluster_identifier)
        __dataclass__object_setattr(self, 'storage_encrypted', storage_encrypted)
        __dataclass__object_setattr(self, 'kms_key_id', kms_key_id)
        __dataclass__object_setattr(self, 'dbi_resource_id', dbi_resource_id)
        __dataclass__object_setattr(self, 'ca_certificate_identifier', ca_certificate_identifier)
        __dataclass__object_setattr(self, 'domain_memberships', domain_memberships)
        __dataclass__object_setattr(self, 'copy_tags_to_snapshot', copy_tags_to_snapshot)
        __dataclass__object_setattr(self, 'monitoring_interval', monitoring_interval)
        __dataclass__object_setattr(self, 'enhanced_monitoring_resource_arn', enhanced_monitoring_resource_arn)
        __dataclass__object_setattr(self, 'monitoring_role_arn', monitoring_role_arn)
        __dataclass__object_setattr(self, 'promotion_tier', promotion_tier)
        __dataclass__object_setattr(self, 'db_instance_arn', db_instance_arn)
        __dataclass__object_setattr(self, 'timezone', timezone)
        __dataclass__object_setattr(self, 'iam_database_authentication_enabled', iam_database_authentication_enabled)
        __dataclass__object_setattr(self, 'database_insights_mode', database_insights_mode)
        __dataclass__object_setattr(self, 'performance_insights_enabled', performance_insights_enabled)
        __dataclass__object_setattr(self, 'performance_insights_kms_key_id', performance_insights_kms_key_id)
        __dataclass__object_setattr(self, 'performance_insights_retention_period', performance_insights_retention_period)
        __dataclass__object_setattr(self, 'enabled_cloudwatch_logs_exports', enabled_cloudwatch_logs_exports)
        __dataclass__object_setattr(self, 'processor_features', processor_features)
        __dataclass__object_setattr(self, 'deletion_protection', deletion_protection)
        __dataclass__object_setattr(self, 'associated_roles', associated_roles)
        __dataclass__object_setattr(self, 'listener_endpoint', listener_endpoint)
        __dataclass__object_setattr(self, 'max_allocated_storage', max_allocated_storage)
        __dataclass__object_setattr(self, 'tag_list', tag_list)
        __dataclass__object_setattr(self, 'automation_mode', automation_mode)
        __dataclass__object_setattr(self, 'resume_full_automation_mode_time', resume_full_automation_mode_time)
        __dataclass__object_setattr(self, 'customer_owned_ip_enabled', customer_owned_ip_enabled)
        __dataclass__object_setattr(self, 'network_type', network_type)
        __dataclass__object_setattr(self, 'activity_stream_status', activity_stream_status)
        __dataclass__object_setattr(self, 'activity_stream_kms_key_id', activity_stream_kms_key_id)
        __dataclass__object_setattr(self, 'activity_stream_kinesis_stream_name', activity_stream_kinesis_stream_name)
        __dataclass__object_setattr(self, 'activity_stream_mode', activity_stream_mode)
        __dataclass__object_setattr(self, 'activity_stream_engine_native_audit_fields_included', activity_stream_engine_native_audit_fields_included)
        __dataclass__object_setattr(self, 'aws_backup_recovery_point_arn', aws_backup_recovery_point_arn)
        __dataclass__object_setattr(self, 'db_instance_automated_backups_replications', db_instance_automated_backups_replications)
        __dataclass__object_setattr(self, 'backup_target', backup_target)
        __dataclass__object_setattr(self, 'automatic_restart_time', automatic_restart_time)
        __dataclass__object_setattr(self, 'custom_iam_instance_profile', custom_iam_instance_profile)
        __dataclass__object_setattr(self, 'activity_stream_policy_status', activity_stream_policy_status)
        __dataclass__object_setattr(self, 'certificate_details', certificate_details)
        __dataclass__object_setattr(self, 'db_system_id', db_system_id)
        __dataclass__object_setattr(self, 'master_user_secret', master_user_secret)
        __dataclass__object_setattr(self, 'read_replica_source_db_cluster_identifier', read_replica_source_db_cluster_identifier)
        __dataclass__object_setattr(self, 'percent_progress', percent_progress)
        __dataclass__object_setattr(self, 'multi_tenant', multi_tenant)
        __dataclass__object_setattr(self, 'dedicated_log_volume', dedicated_log_volume)
        __dataclass__object_setattr(self, 'is_storage_config_upgrade_available', is_storage_config_upgrade_available)
        __dataclass__object_setattr(self, 'engine_lifecycle_support', engine_lifecycle_support)
        __dataclass__object_setattr(self, 'additional_storage_volumes', additional_storage_volumes)
        __dataclass__object_setattr(self, 'storage_volume_status', storage_volume_status)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"db_instance_identifier={self.db_instance_identifier!r}")
        parts.append(f"db_instance_class={self.db_instance_class!r}")
        parts.append(f"engine={self.engine!r}")
        parts.append(f"db_instance_status={self.db_instance_status!r}")
        parts.append(f"master_username={self.master_username!r}")
        parts.append(f"db_name={self.db_name!r}")
        parts.append(f"endpoint={self.endpoint!r}")
        parts.append(f"allocated_storage={self.allocated_storage!r}")
        parts.append(f"instance_create_time={self.instance_create_time!r}")
        parts.append(f"preferred_backup_window={self.preferred_backup_window!r}")
        parts.append(f"backup_retention_period={self.backup_retention_period!r}")
        parts.append(f"db_security_groups={self.db_security_groups!r}")
        parts.append(f"vpc_security_groups={self.vpc_security_groups!r}")
        parts.append(f"db_parameter_groups={self.db_parameter_groups!r}")
        parts.append(f"availability_zone={self.availability_zone!r}")
        parts.append(f"db_subnet_group={self.db_subnet_group!r}")
        parts.append(f"preferred_maintenance_window={self.preferred_maintenance_window!r}")
        parts.append(f"upgrade_rollout_order={self.upgrade_rollout_order!r}")
        parts.append(f"pending_modified_values={self.pending_modified_values!r}")
        parts.append(f"latest_restorable_time={self.latest_restorable_time!r}")
        parts.append(f"multi_az={self.multi_az!r}")
        parts.append(f"engine_version={self.engine_version!r}")
        parts.append(f"auto_minor_version_upgrade={self.auto_minor_version_upgrade!r}")
        parts.append(f"read_replica_source_db_instance_identifier={self.read_replica_source_db_instance_identifier!r}")
        parts.append(f"read_replica_db_instance_identifiers={self.read_replica_db_instance_identifiers!r}")
        parts.append(f"read_replica_db_cluster_identifiers={self.read_replica_db_cluster_identifiers!r}")
        parts.append(f"replica_mode={self.replica_mode!r}")
        parts.append(f"license_model={self.license_model!r}")
        parts.append(f"iops={self.iops!r}")
        parts.append(f"storage_throughput={self.storage_throughput!r}")
        parts.append(f"option_group_memberships={self.option_group_memberships!r}")
        parts.append(f"character_set_name={self.character_set_name!r}")
        parts.append(f"nchar_character_set_name={self.nchar_character_set_name!r}")
        parts.append(f"secondary_availability_zone={self.secondary_availability_zone!r}")
        parts.append(f"publicly_accessible={self.publicly_accessible!r}")
        parts.append(f"status_infos={self.status_infos!r}")
        parts.append(f"storage_type={self.storage_type!r}")
        parts.append(f"tde_credential_arn={self.tde_credential_arn!r}")
        parts.append(f"db_instance_port={self.db_instance_port!r}")
        parts.append(f"db_cluster_identifier={self.db_cluster_identifier!r}")
        parts.append(f"storage_encrypted={self.storage_encrypted!r}")
        parts.append(f"kms_key_id={self.kms_key_id!r}")
        parts.append(f"dbi_resource_id={self.dbi_resource_id!r}")
        parts.append(f"ca_certificate_identifier={self.ca_certificate_identifier!r}")
        parts.append(f"domain_memberships={self.domain_memberships!r}")
        parts.append(f"copy_tags_to_snapshot={self.copy_tags_to_snapshot!r}")
        parts.append(f"monitoring_interval={self.monitoring_interval!r}")
        parts.append(f"enhanced_monitoring_resource_arn={self.enhanced_monitoring_resource_arn!r}")
        parts.append(f"monitoring_role_arn={self.monitoring_role_arn!r}")
        parts.append(f"promotion_tier={self.promotion_tier!r}")
        parts.append(f"db_instance_arn={self.db_instance_arn!r}")
        parts.append(f"timezone={self.timezone!r}")
        parts.append(f"iam_database_authentication_enabled={self.iam_database_authentication_enabled!r}")
        parts.append(f"database_insights_mode={self.database_insights_mode!r}")
        parts.append(f"performance_insights_enabled={self.performance_insights_enabled!r}")
        parts.append(f"performance_insights_kms_key_id={self.performance_insights_kms_key_id!r}")
        parts.append(f"performance_insights_retention_period={self.performance_insights_retention_period!r}")
        parts.append(f"enabled_cloudwatch_logs_exports={self.enabled_cloudwatch_logs_exports!r}")
        parts.append(f"processor_features={self.processor_features!r}")
        parts.append(f"deletion_protection={self.deletion_protection!r}")
        parts.append(f"associated_roles={self.associated_roles!r}")
        parts.append(f"listener_endpoint={self.listener_endpoint!r}")
        parts.append(f"max_allocated_storage={self.max_allocated_storage!r}")
        parts.append(f"tag_list={self.tag_list!r}")
        parts.append(f"automation_mode={self.automation_mode!r}")
        parts.append(f"resume_full_automation_mode_time={self.resume_full_automation_mode_time!r}")
        parts.append(f"customer_owned_ip_enabled={self.customer_owned_ip_enabled!r}")
        parts.append(f"network_type={self.network_type!r}")
        parts.append(f"activity_stream_status={self.activity_stream_status!r}")
        parts.append(f"activity_stream_kms_key_id={self.activity_stream_kms_key_id!r}")
        parts.append(f"activity_stream_kinesis_stream_name={self.activity_stream_kinesis_stream_name!r}")
        parts.append(f"activity_stream_mode={self.activity_stream_mode!r}")
        parts.append(f"activity_stream_engine_native_audit_fields_included={self.activity_stream_engine_native_audit_fields_included!r}")
        parts.append(f"aws_backup_recovery_point_arn={self.aws_backup_recovery_point_arn!r}")
        parts.append(f"db_instance_automated_backups_replications={self.db_instance_automated_backups_replications!r}")
        parts.append(f"backup_target={self.backup_target!r}")
        parts.append(f"automatic_restart_time={self.automatic_restart_time!r}")
        parts.append(f"custom_iam_instance_profile={self.custom_iam_instance_profile!r}")
        parts.append(f"activity_stream_policy_status={self.activity_stream_policy_status!r}")
        parts.append(f"certificate_details={self.certificate_details!r}")
        parts.append(f"db_system_id={self.db_system_id!r}")
        parts.append(f"master_user_secret={self.master_user_secret!r}")
        parts.append(f"read_replica_source_db_cluster_identifier={self.read_replica_source_db_cluster_identifier!r}")
        parts.append(f"percent_progress={self.percent_progress!r}")
        parts.append(f"multi_tenant={self.multi_tenant!r}")
        parts.append(f"dedicated_log_volume={self.dedicated_log_volume!r}")
        parts.append(f"is_storage_config_upgrade_available={self.is_storage_config_upgrade_available!r}")
        parts.append(f"engine_lifecycle_support={self.engine_lifecycle_support!r}")
        parts.append(f"additional_storage_volumes={self.additional_storage_volumes!r}")
        parts.append(f"storage_volume_status={self.storage_volume_status!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('db_instance',)), EqPlan(fields=('db_instance',)), FrozenPlan(fields=('__shape__', 'db"
    "_instance'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('db_instance',), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='db_instance', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name"
    "='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('db_instance',), frozen="
    "True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db_"
    "instance', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fCreateDBInstanceResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            db_instance=self.db_instance,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.db_instance == other.db_instance
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'db_instance',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'db_instance',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.db_instance,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        db_instance: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'db_instance', db_instance)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"db_instance={self.db_instance!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('db_instance',)), EqPlan(fields=('db_instance',)), FrozenPlan(fields=('__shape__', 'db"
    "_instance'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('db_instance',), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='db_instance', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name"
    "='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('db_instance',), frozen="
    "True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db_"
    "instance', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDeleteDBInstanceResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            db_instance=self.db_instance,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.db_instance == other.db_instance
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'db_instance',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'db_instance',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.db_instance,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        db_instance: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'db_instance', db_instance)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"db_instance={self.db_instance!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('db_instance',)), EqPlan(fields=('db_instance',)), FrozenPlan(fields=('__shape__', 'db"
    "_instance'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('db_instance',), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='db_instance', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name"
    "='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('db_instance',), frozen="
    "True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db_"
    "instance', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fRebootDBInstanceResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            db_instance=self.db_instance,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.db_instance == other.db_instance
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'db_instance',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'db_instance',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.db_instance,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        db_instance: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'db_instance', db_instance)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"db_instance={self.db_instance!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('db_instance',)), EqPlan(fields=('db_instance',)), FrozenPlan(fields=('__shape__', 'db"
    "_instance'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('db_instance',), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='db_instance', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name"
    "='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('db_instance',), frozen="
    "True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db_"
    "instance', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fStartDBInstanceResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            db_instance=self.db_instance,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.db_instance == other.db_instance
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'db_instance',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'db_instance',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.db_instance,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        db_instance: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'db_instance', db_instance)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"db_instance={self.db_instance!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('db_instance',)), EqPlan(fields=('db_instance',)), FrozenPlan(fields=('__shape__', 'db"
    "_instance'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('db_instance',), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='db_instance', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name"
    "='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('db_instance',), frozen="
    "True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='db_"
    "instance', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fStopDBInstanceResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            db_instance=self.db_instance,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.db_instance == other.db_instance
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'db_instance',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'db_instance',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.db_instance,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        db_instance: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'db_instance', db_instance)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"db_instance={self.db_instance!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('marker', 'db_instances')), EqPlan(fields=('marker', 'db_instances')), FrozenPlan(fiel"
    "ds=('__shape__', 'marker', 'db_instances'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('mar"
    "ker', 'db_instances'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init"
    ".fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_"
    "VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='marker', annotation=OpRef(name='init.field"
    "s.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='db_instances', ann"
    "otation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None,"
    " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_par"
    "am='self', std_params=(), kw_only_params=('marker', 'db_instances'), frozen=True, slots=False, post_init_params=No"
    "ne, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='marker', kw_only=True, fn=None), ReprPlan"
    ".Field(name='db_instances', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2frds_2fDBInstanceMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            marker=self.marker,
            db_instances=self.db_instances,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.marker == other.marker and
            self.db_instances == other.db_instances
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'marker',
        'db_instances',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'marker',
        'db_instances',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.marker,
            self.db_instances,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        marker: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        db_instances: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'marker', marker)
        __dataclass__object_setattr(self, 'db_instances', db_instances)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"marker={self.marker!r}")
        parts.append(f"db_instances={self.db_instances!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fEncryptionTypeMismatch(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fInvalidRequest(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fInvalidWriteOffset(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fNoSuchBucket(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fNoSuchKey(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=('__shape__',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=(), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fTooManyParts(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'creation_date', 'bucket_region', 'bucket_arn')), EqPlan(fields=('name', 'crea"
    "tion_date', 'bucket_region', 'bucket_arn')), FrozenPlan(fields=('__shape__', 'name', 'creation_date', 'bucket_regi"
    "on', 'bucket_arn'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'creation_date', 'bu"
    "cket_region', 'bucket_arn'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name"
    "='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType."
    "CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.f"
    "ields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='creation_date'"
    ", annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='bucket_region', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.field"
    "s.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='bucket_arn', annotation=OpRef(name='init.fields.4.annotation'), de"
    "fault=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
    "NSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('name', "
    "'creation_date', 'bucket_region', 'bucket_arn'), frozen=True, slots=False, post_init_params=None, init_fns=(), val"
    "idate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='creation_"
    "date', kw_only=True, fn=None), ReprPlan.Field(name='bucket_region', kw_only=True, fn=None), ReprPlan.Field(name='b"
    "ucket_arn', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fBucket(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            creation_date=self.creation_date,
            bucket_region=self.bucket_region,
            bucket_arn=self.bucket_arn,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.creation_date == other.creation_date and
            self.bucket_region == other.bucket_region and
            self.bucket_arn == other.bucket_arn
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'name',
        'creation_date',
        'bucket_region',
        'bucket_arn',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'name',
        'creation_date',
        'bucket_region',
        'bucket_arn',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.creation_date,
            self.bucket_region,
            self.bucket_arn,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        creation_date: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        bucket_region: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        bucket_arn: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'creation_date', creation_date)
        __dataclass__object_setattr(self, 'bucket_region', bucket_region)
        __dataclass__object_setattr(self, 'bucket_arn', bucket_arn)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"creation_date={self.creation_date!r}")
        parts.append(f"bucket_region={self.bucket_region!r}")
        parts.append(f"bucket_arn={self.bucket_arn!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('prefix',)), EqPlan(fields=('prefix',)), FrozenPlan(fields=('__shape__', 'prefix'), al"
    "low_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('prefix',), cache=False), InitPlan(fields=(InitPla"
    "n.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, i"
    "nit=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.F"
    "ield(name='prefix', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default')"
    ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
    "k_type=None)), self_param='self', std_params=(), kw_only_params=('prefix',), frozen=True, slots=False, post_init_p"
    "arams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='prefix', kw_only=True, fn=None),)"
    ", id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fCommonPrefix(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            prefix=self.prefix,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.prefix == other.prefix
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'prefix',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'prefix',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.prefix,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        prefix: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'prefix', prefix)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"prefix={self.prefix!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('delete_marker', 'version_id', 'request_charged')), EqPlan(fields=('delete_marker', 'v"
    "ersion_id', 'request_charged')), FrozenPlan(fields=('__shape__', 'delete_marker', 'version_id', 'request_charged')"
    ", allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('delete_marker', 'version_id', 'request_charge"
    "d'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotati"
    "on'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='delete_marker', annotation=OpRef(name='init.fields.1.annotat"
    "ion'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='version_id', annotation=OpRef"
    "(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='r"
    "equest_charged', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None)), self_param='self', std_params=(), kw_only_params=('delete_marker', 'version_id', 'request_charged'), f"
    "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
    "e='delete_marker', kw_only=True, fn=None), ReprPlan.Field(name='version_id', kw_only=True, fn=None), ReprPlan.Fiel"
    "d(name='request_charged', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fDeleteObjectOutput(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            delete_marker=self.delete_marker,
            version_id=self.version_id,
            request_charged=self.request_charged,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.delete_marker == other.delete_marker and
            self.version_id == other.version_id and
            self.request_charged == other.request_charged
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'delete_marker',
        'version_id',
        'request_charged',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'delete_marker',
        'version_id',
        'request_charged',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.delete_marker,
            self.version_id,
            self.request_charged,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        delete_marker: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        version_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        request_charged: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'delete_marker', delete_marker)
        __dataclass__object_setattr(self, 'version_id', version_id)
        __dataclass__object_setattr(self, 'request_charged', request_charged)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"delete_marker={self.delete_marker!r}")
        parts.append(f"version_id={self.version_id!r}")
        parts.append(f"request_charged={self.request_charged!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('bucket', 'key', 'mfa', 'version_id', 'request_payer', 'bypass_governance_retention', "
    "'expected_bucket_owner', 'if_match', 'if_match_last_modified_time', 'if_match_size')), EqPlan(fields=('bucket', 'k"
    "ey', 'mfa', 'version_id', 'request_payer', 'bypass_governance_retention', 'expected_bucket_owner', 'if_match', 'if"
    "_match_last_modified_time', 'if_match_size')), FrozenPlan(fields=('__shape__', 'bucket', 'key', 'mfa', 'version_id"
    "', 'request_payer', 'bypass_governance_retention', 'expected_bucket_owner', 'if_match', 'if_match_last_modified_ti"
    "me', 'if_match_size'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('bucket', 'key', 'mfa', '"
    "version_id', 'request_payer', 'bypass_governance_retention', 'expected_bucket_owner', 'if_match', 'if_match_last_m"
    "odified_time', 'if_match_size'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef("
    "name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='bucket', annotation=OpRef(name='"
    "init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='key', annotation=OpRef(name='init.field"
    "s.2.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None), InitPlan.Field(name='mfa', annotation=OpRef(name='init.fields.3.annota"
    "tion'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=F"
    "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='version_id', annotation=OpRe"
    "f(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "request_payer', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), de"
    "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='bypass_governance_retention', annotation=OpRef(name='init.fields.6.annotation'), de"
    "fault=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
    "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='expected_bucket_owner', annotation=OpR"
    "ef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True,"
    " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
    "'if_match', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='if_match_last_modified_time', annotation=OpRef(name='init.fields.9.annotation'), defaul"
    "t=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
    "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='if_match_size', annotation=OpRef(name='ini"
    "t.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override="
    "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params"
    "=(), kw_only_params=('bucket', 'key', 'mfa', 'version_id', 'request_payer', 'bypass_governance_retention', 'expect"
    "ed_bucket_owner', 'if_match', 'if_match_last_modified_time', 'if_match_size'), frozen=True, slots=False, post_init"
    "_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='bucket', kw_only=True, fn=None)"
    ", ReprPlan.Field(name='key', kw_only=True, fn=None), ReprPlan.Field(name='mfa', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='version_id', kw_only=True, fn=None), ReprPlan.Field(name='request_payer', kw_only=True, fn=None), ReprP"
    "lan.Field(name='bypass_governance_retention', kw_only=True, fn=None), ReprPlan.Field(name='expected_bucket_owner',"
    " kw_only=True, fn=None), ReprPlan.Field(name='if_match', kw_only=True, fn=None), ReprPlan.Field(name='if_match_las"
    "t_modified_time', kw_only=True, fn=None), ReprPlan.Field(name='if_match_size', kw_only=True, fn=None)), id=False, "
    "terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fDeleteObjectRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            bucket=self.bucket,
            key=self.key,
            mfa=self.mfa,
            version_id=self.version_id,
            request_payer=self.request_payer,
            bypass_governance_retention=self.bypass_governance_retention,
            expected_bucket_owner=self.expected_bucket_owner,
            if_match=self.if_match,
            if_match_last_modified_time=self.if_match_last_modified_time,
            if_match_size=self.if_match_size,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.bucket == other.bucket and
            self.key == other.key and
            self.mfa == other.mfa and
            self.version_id == other.version_id and
            self.request_payer == other.request_payer and
            self.bypass_governance_retention == other.bypass_governance_retention and
            self.expected_bucket_owner == other.expected_bucket_owner and
            self.if_match == other.if_match and
            self.if_match_last_modified_time == other.if_match_last_modified_time and
            self.if_match_size == other.if_match_size
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'bucket',
        'key',
        'mfa',
        'version_id',
        'request_payer',
        'bypass_governance_retention',
        'expected_bucket_owner',
        'if_match',
        'if_match_last_modified_time',
        'if_match_size',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'bucket',
        'key',
        'mfa',
        'version_id',
        'request_payer',
        'bypass_governance_retention',
        'expected_bucket_owner',
        'if_match',
        'if_match_last_modified_time',
        'if_match_size',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.bucket,
            self.key,
            self.mfa,
            self.version_id,
            self.request_payer,
            self.bypass_governance_retention,
            self.expected_bucket_owner,
            self.if_match,
            self.if_match_last_modified_time,
            self.if_match_size,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        bucket: __dataclass__init__fields__1__annotation,
        key: __dataclass__init__fields__2__annotation,
        mfa: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        version_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        request_payer: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        bypass_governance_retention: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        expected_bucket_owner: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        if_match: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        if_match_last_modified_time: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        if_match_size: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'bucket', bucket)
        __dataclass__object_setattr(self, 'key', key)
        __dataclass__object_setattr(self, 'mfa', mfa)
        __dataclass__object_setattr(self, 'version_id', version_id)
        __dataclass__object_setattr(self, 'request_payer', request_payer)
        __dataclass__object_setattr(self, 'bypass_governance_retention', bypass_governance_retention)
        __dataclass__object_setattr(self, 'expected_bucket_owner', expected_bucket_owner)
        __dataclass__object_setattr(self, 'if_match', if_match)
        __dataclass__object_setattr(self, 'if_match_last_modified_time', if_match_last_modified_time)
        __dataclass__object_setattr(self, 'if_match_size', if_match_size)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"bucket={self.bucket!r}")
        parts.append(f"key={self.key!r}")
        parts.append(f"mfa={self.mfa!r}")
        parts.append(f"version_id={self.version_id!r}")
        parts.append(f"request_payer={self.request_payer!r}")
        parts.append(f"bypass_governance_retention={self.bypass_governance_retention!r}")
        parts.append(f"expected_bucket_owner={self.expected_bucket_owner!r}")
        parts.append(f"if_match={self.if_match!r}")
        parts.append(f"if_match_last_modified_time={self.if_match_last_modified_time!r}")
        parts.append(f"if_match_size={self.if_match_size!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('bucket', 'if_match', 'if_modified_since', 'if_none_match', 'if_unmodified_since', 'ke"
    "y', 'range', 'response_cache_control', 'response_content_disposition', 'response_content_encoding', 'response_cont"
    "ent_language', 'response_content_type', 'response_expires', 'version_id', 'sse_customer_algorithm', 'sse_customer_"
    "key', 'sse_customer_key_md5', 'request_payer', 'part_number', 'expected_bucket_owner', 'checksum_mode')), EqPlan(f"
    "ields=('bucket', 'if_match', 'if_modified_since', 'if_none_match', 'if_unmodified_since', 'key', 'range', 'respons"
    "e_cache_control', 'response_content_disposition', 'response_content_encoding', 'response_content_language', 'respo"
    "nse_content_type', 'response_expires', 'version_id', 'sse_customer_algorithm', 'sse_customer_key', 'sse_customer_k"
    "ey_md5', 'request_payer', 'part_number', 'expected_bucket_owner', 'checksum_mode')), FrozenPlan(fields=('__shape__"
    "', 'bucket', 'if_match', 'if_modified_since', 'if_none_match', 'if_unmodified_since', 'key', 'range', 'response_ca"
    "che_control', 'response_content_disposition', 'response_content_encoding', 'response_content_language', 'response_"
    "content_type', 'response_expires', 'version_id', 'sse_customer_algorithm', 'sse_customer_key', 'sse_customer_key_m"
    "d5', 'request_payer', 'part_number', 'expected_bucket_owner', 'checksum_mode'), allow_dynamic_dunder_attrs=False),"
    " HashPlan(action='add', fields=('bucket', 'if_match', 'if_modified_since', 'if_none_match', 'if_unmodified_since',"
    " 'key', 'range', 'response_cache_control', 'response_content_disposition', 'response_content_encoding', 'response_"
    "content_language', 'response_content_type', 'response_expires', 'version_id', 'sse_customer_algorithm', 'sse_custo"
    "mer_key', 'sse_customer_key_md5', 'request_payer', 'part_number', 'expected_bucket_owner', 'checksum_mode'), cache"
    "=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defa"
    "ult=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='bucket', annotation=OpRef(name='init.fields.1.annotation'), default=No"
    "ne, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None), InitPlan.Field(name='if_match', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(n"
    "ame='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='if_modified_since', annotation=OpRef(name='init.fie"
    "lds.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='if_none_match', "
    "annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='if_unmodified_since', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.f"
    "ields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='key', annotation=OpRef(name='init.fields.6.annotation'), defau"
    "lt=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None), InitPlan.Field(name='range', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef"
    "(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None), InitPlan.Field(name='response_cache_control', annotation=OpRef(name='i"
    "nit.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override="
    "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='response_"
    "content_disposition', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default"
    "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None), InitPlan.Field(name='response_content_encoding', annotation=OpRef(name='init.fields.10.annotation'"
    "), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='response_content_language', anno"
    "tation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
    ".Field(name='response_content_type', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init."
    "fields.12.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='response_expires', annotation=OpRef(name='init.fields.13.ann"
    "otation'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=False, field_ty"
    "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='version_id', annotation="
    "OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='sse_customer_algorithm', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields"
    ".15.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='sse_customer_key', annotation=OpRef(name='init.fields.16.annotatio"
    "n'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='sse_customer_key_md5', annotat"
    "ion=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, i"
    "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
    "eld(name='request_payer', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.18.d"
    "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
    "ne, check_type=None), InitPlan.Field(name='part_number', annotation=OpRef(name='init.fields.19.annotation'), defau"
    "lt=OpRef(name='init.fields.19.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
    "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='expected_bucket_owner', annotation=OpRef"
    "(name='init.fields.20.annotation'), default=OpRef(name='init.fields.20.default'), default_factory=None, init=True,"
    " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
    "'checksum_mode', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='init.fields.21.default'),"
    " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
    "_type=None)), self_param='self', std_params=(), kw_only_params=('bucket', 'if_match', 'if_modified_since', 'if_non"
    "e_match', 'if_unmodified_since', 'key', 'range', 'response_cache_control', 'response_content_disposition', 'respon"
    "se_content_encoding', 'response_content_language', 'response_content_type', 'response_expires', 'version_id', 'sse"
    "_customer_algorithm', 'sse_customer_key', 'sse_customer_key_md5', 'request_payer', 'part_number', 'expected_bucket"
    "_owner', 'checksum_mode'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPla"
    "n(fields=(ReprPlan.Field(name='bucket', kw_only=True, fn=None), ReprPlan.Field(name='if_match', kw_only=True, fn=N"
    "one), ReprPlan.Field(name='if_modified_since', kw_only=True, fn=None), ReprPlan.Field(name='if_none_match', kw_onl"
    "y=True, fn=None), ReprPlan.Field(name='if_unmodified_since', kw_only=True, fn=None), ReprPlan.Field(name='key', kw"
    "_only=True, fn=None), ReprPlan.Field(name='range', kw_only=True, fn=None), ReprPlan.Field(name='response_cache_con"
    "trol', kw_only=True, fn=None), ReprPlan.Field(name='response_content_disposition', kw_only=True, fn=None), ReprPla"
    "n.Field(name='response_content_encoding', kw_only=True, fn=None), ReprPlan.Field(name='response_content_language',"
    " kw_only=True, fn=None), ReprPlan.Field(name='response_content_type', kw_only=True, fn=None), ReprPlan.Field(name="
    "'response_expires', kw_only=True, fn=None), ReprPlan.Field(name='version_id', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='sse_customer_algorithm', kw_only=True, fn=None), ReprPlan.Field(name='sse_customer_key', kw_only=True, fn"
    "=None), ReprPlan.Field(name='sse_customer_key_md5', kw_only=True, fn=None), ReprPlan.Field(name='request_payer', k"
    "w_only=True, fn=None), ReprPlan.Field(name='part_number', kw_only=True, fn=None), ReprPlan.Field(name='expected_bu"
    "cket_owner', kw_only=True, fn=None), ReprPlan.Field(name='checksum_mode', kw_only=True, fn=None)), id=False, terse"
    "=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fGetObjectRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__21__annotation,
    __dataclass__init__fields__21__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            bucket=self.bucket,
            if_match=self.if_match,
            if_modified_since=self.if_modified_since,
            if_none_match=self.if_none_match,
            if_unmodified_since=self.if_unmodified_since,
            key=self.key,
            range=self.range,
            response_cache_control=self.response_cache_control,
            response_content_disposition=self.response_content_disposition,
            response_content_encoding=self.response_content_encoding,
            response_content_language=self.response_content_language,
            response_content_type=self.response_content_type,
            response_expires=self.response_expires,
            version_id=self.version_id,
            sse_customer_algorithm=self.sse_customer_algorithm,
            sse_customer_key=self.sse_customer_key,
            sse_customer_key_md5=self.sse_customer_key_md5,
            request_payer=self.request_payer,
            part_number=self.part_number,
            expected_bucket_owner=self.expected_bucket_owner,
            checksum_mode=self.checksum_mode,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.bucket == other.bucket and
            self.if_match == other.if_match and
            self.if_modified_since == other.if_modified_since and
            self.if_none_match == other.if_none_match and
            self.if_unmodified_since == other.if_unmodified_since and
            self.key == other.key and
            self.range == other.range and
            self.response_cache_control == other.response_cache_control and
            self.response_content_disposition == other.response_content_disposition and
            self.response_content_encoding == other.response_content_encoding and
            self.response_content_language == other.response_content_language and
            self.response_content_type == other.response_content_type and
            self.response_expires == other.response_expires and
            self.version_id == other.version_id and
            self.sse_customer_algorithm == other.sse_customer_algorithm and
            self.sse_customer_key == other.sse_customer_key and
            self.sse_customer_key_md5 == other.sse_customer_key_md5 and
            self.request_payer == other.request_payer and
            self.part_number == other.part_number and
            self.expected_bucket_owner == other.expected_bucket_owner and
            self.checksum_mode == other.checksum_mode
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'bucket',
        'if_match',
        'if_modified_since',
        'if_none_match',
        'if_unmodified_since',
        'key',
        'range',
        'response_cache_control',
        'response_content_disposition',
        'response_content_encoding',
        'response_content_language',
        'response_content_type',
        'response_expires',
        'version_id',
        'sse_customer_algorithm',
        'sse_customer_key',
        'sse_customer_key_md5',
        'request_payer',
        'part_number',
        'expected_bucket_owner',
        'checksum_mode',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'bucket',
        'if_match',
        'if_modified_since',
        'if_none_match',
        'if_unmodified_since',
        'key',
        'range',
        'response_cache_control',
        'response_content_disposition',
        'response_content_encoding',
        'response_content_language',
        'response_content_type',
        'response_expires',
        'version_id',
        'sse_customer_algorithm',
        'sse_customer_key',
        'sse_customer_key_md5',
        'request_payer',
        'part_number',
        'expected_bucket_owner',
        'checksum_mode',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.bucket,
            self.if_match,
            self.if_modified_since,
            self.if_none_match,
            self.if_unmodified_since,
            self.key,
            self.range,
            self.response_cache_control,
            self.response_content_disposition,
            self.response_content_encoding,
            self.response_content_language,
            self.response_content_type,
            self.response_expires,
            self.version_id,
            self.sse_customer_algorithm,
            self.sse_customer_key,
            self.sse_customer_key_md5,
            self.request_payer,
            self.part_number,
            self.expected_bucket_owner,
            self.checksum_mode,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        bucket: __dataclass__init__fields__1__annotation,
        if_match: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        if_modified_since: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        if_none_match: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        if_unmodified_since: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        key: __dataclass__init__fields__6__annotation,
        range: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        response_cache_control: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        response_content_disposition: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        response_content_encoding: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        response_content_language: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        response_content_type: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        response_expires: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        version_id: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        sse_customer_algorithm: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        sse_customer_key: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        sse_customer_key_md5: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        request_payer: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        part_number: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        expected_bucket_owner: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        checksum_mode: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'bucket', bucket)
        __dataclass__object_setattr(self, 'if_match', if_match)
        __dataclass__object_setattr(self, 'if_modified_since', if_modified_since)
        __dataclass__object_setattr(self, 'if_none_match', if_none_match)
        __dataclass__object_setattr(self, 'if_unmodified_since', if_unmodified_since)
        __dataclass__object_setattr(self, 'key', key)
        __dataclass__object_setattr(self, 'range', range)
        __dataclass__object_setattr(self, 'response_cache_control', response_cache_control)
        __dataclass__object_setattr(self, 'response_content_disposition', response_content_disposition)
        __dataclass__object_setattr(self, 'response_content_encoding', response_content_encoding)
        __dataclass__object_setattr(self, 'response_content_language', response_content_language)
        __dataclass__object_setattr(self, 'response_content_type', response_content_type)
        __dataclass__object_setattr(self, 'response_expires', response_expires)
        __dataclass__object_setattr(self, 'version_id', version_id)
        __dataclass__object_setattr(self, 'sse_customer_algorithm', sse_customer_algorithm)
        __dataclass__object_setattr(self, 'sse_customer_key', sse_customer_key)
        __dataclass__object_setattr(self, 'sse_customer_key_md5', sse_customer_key_md5)
        __dataclass__object_setattr(self, 'request_payer', request_payer)
        __dataclass__object_setattr(self, 'part_number', part_number)
        __dataclass__object_setattr(self, 'expected_bucket_owner', expected_bucket_owner)
        __dataclass__object_setattr(self, 'checksum_mode', checksum_mode)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"bucket={self.bucket!r}")
        parts.append(f"if_match={self.if_match!r}")
        parts.append(f"if_modified_since={self.if_modified_since!r}")
        parts.append(f"if_none_match={self.if_none_match!r}")
        parts.append(f"if_unmodified_since={self.if_unmodified_since!r}")
        parts.append(f"key={self.key!r}")
        parts.append(f"range={self.range!r}")
        parts.append(f"response_cache_control={self.response_cache_control!r}")
        parts.append(f"response_content_disposition={self.response_content_disposition!r}")
        parts.append(f"response_content_encoding={self.response_content_encoding!r}")
        parts.append(f"response_content_language={self.response_content_language!r}")
        parts.append(f"response_content_type={self.response_content_type!r}")
        parts.append(f"response_expires={self.response_expires!r}")
        parts.append(f"version_id={self.version_id!r}")
        parts.append(f"sse_customer_algorithm={self.sse_customer_algorithm!r}")
        parts.append(f"sse_customer_key={self.sse_customer_key!r}")
        parts.append(f"sse_customer_key_md5={self.sse_customer_key_md5!r}")
        parts.append(f"request_payer={self.request_payer!r}")
        parts.append(f"part_number={self.part_number!r}")
        parts.append(f"expected_bucket_owner={self.expected_bucket_owner!r}")
        parts.append(f"checksum_mode={self.checksum_mode!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('storage_class', 'access_tier')), EqPlan(fields=('storage_class', 'access_tier')), Fro"
    "zenPlan(fields=('__shape__', 'storage_class', 'access_tier'), allow_dynamic_dunder_attrs=False), HashPlan(action='"
    "add', fields=('storage_class', 'access_tier'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', ann"
    "otation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='storage_class', an"
    "notation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
    ".Field(name='access_tier', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None)), self_param='self', std_params=(), kw_only_params=('storage_class', 'access_tier'), frozen=Tr"
    "ue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='stora"
    "ge_class', kw_only=True, fn=None), ReprPlan.Field(name='access_tier', kw_only=True, fn=None)), id=False, terse=Fal"
    "se, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fInvalidObjectState(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            storage_class=self.storage_class,
            access_tier=self.access_tier,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.storage_class == other.storage_class and
            self.access_tier == other.access_tier
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'storage_class',
        'access_tier',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'storage_class',
        'access_tier',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.storage_class,
            self.access_tier,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        storage_class: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        access_tier: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'storage_class', storage_class)
        __dataclass__object_setattr(self, 'access_tier', access_tier)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"storage_class={self.storage_class!r}")
        parts.append(f"access_tier={self.access_tier!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('max_buckets', 'continuation_token', 'prefix', 'bucket_region')), EqPlan(fields=('max_"
    "buckets', 'continuation_token', 'prefix', 'bucket_region')), FrozenPlan(fields=('__shape__', 'max_buckets', 'conti"
    "nuation_token', 'prefix', 'bucket_region'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('max"
    "_buckets', 'continuation_token', 'prefix', 'bucket_region'), cache=False), InitPlan(fields=(InitPlan.Field(name='_"
    "_shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_"
    "buckets', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e), InitPlan.Field(name='continuation_token', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(nam"
    "e='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='prefix', annotation=OpRef(name='init.fields.3.annotat"
    "ion'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='bucket_region', annotation=Op"
    "Ref(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True"
    ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self',"
    " std_params=(), kw_only_params=('max_buckets', 'continuation_token', 'prefix', 'bucket_region'), frozen=True, slot"
    "s=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='max_buckets',"
    " kw_only=True, fn=None), ReprPlan.Field(name='continuation_token', kw_only=True, fn=None), ReprPlan.Field(name='pr"
    "efix', kw_only=True, fn=None), ReprPlan.Field(name='bucket_region', kw_only=True, fn=None)), id=False, terse=False"
    ", default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fListBucketsRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            max_buckets=self.max_buckets,
            continuation_token=self.continuation_token,
            prefix=self.prefix,
            bucket_region=self.bucket_region,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.max_buckets == other.max_buckets and
            self.continuation_token == other.continuation_token and
            self.prefix == other.prefix and
            self.bucket_region == other.bucket_region
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'max_buckets',
        'continuation_token',
        'prefix',
        'bucket_region',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'max_buckets',
        'continuation_token',
        'prefix',
        'bucket_region',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.max_buckets,
            self.continuation_token,
            self.prefix,
            self.bucket_region,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        max_buckets: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        continuation_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        prefix: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        bucket_region: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'max_buckets', max_buckets)
        __dataclass__object_setattr(self, 'continuation_token', continuation_token)
        __dataclass__object_setattr(self, 'prefix', prefix)
        __dataclass__object_setattr(self, 'bucket_region', bucket_region)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"max_buckets={self.max_buckets!r}")
        parts.append(f"continuation_token={self.continuation_token!r}")
        parts.append(f"prefix={self.prefix!r}")
        parts.append(f"bucket_region={self.bucket_region!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('display_name', 'i_d')), EqPlan(fields=('display_name', 'i_d')), FrozenPlan(fields=('_"
    "_shape__', 'display_name', 'i_d'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('display_name"
    "', 'i_d'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.an"
    "notation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='display_name', annotation=OpRef(name='init.fields.1.an"
    "notation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_ty"
    "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='i_d', annotation=OpRef(n"
    "ame='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_"
    "params=(), kw_only_params=('display_name', 'i_d'), frozen=True, slots=False, post_init_params=None, init_fns=(), v"
    "alidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='display_name', kw_only=True, fn=None), ReprPlan.Field(name="
    "'i_d', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fOwner(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            display_name=self.display_name,
            i_d=self.i_d,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.display_name == other.display_name and
            self.i_d == other.i_d
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'display_name',
        'i_d',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'display_name',
        'i_d',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.display_name,
            self.i_d,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        display_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        i_d: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'display_name', display_name)
        __dataclass__object_setattr(self, 'i_d', i_d)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"display_name={self.display_name!r}")
        parts.append(f"i_d={self.i_d!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('expiration', 'etag', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc64_nvme', 'che"
    "cksum_sha1', 'checksum_sha256', 'checksum_type', 'server_side_encryption', 'version_id', 'sse_customer_algorithm',"
    " 'sse_customer_key_md5', 'sse_kms_key_id', 'sse_kms_encryption_context', 'bucket_key_enabled', 'size', 'request_ch"
    "arged')), EqPlan(fields=('expiration', 'etag', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc64_nvme', 'checks"
    "um_sha1', 'checksum_sha256', 'checksum_type', 'server_side_encryption', 'version_id', 'sse_customer_algorithm', 's"
    "se_customer_key_md5', 'sse_kms_key_id', 'sse_kms_encryption_context', 'bucket_key_enabled', 'size', 'request_charg"
    "ed')), FrozenPlan(fields=('__shape__', 'expiration', 'etag', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc64_"
    "nvme', 'checksum_sha1', 'checksum_sha256', 'checksum_type', 'server_side_encryption', 'version_id', 'sse_customer_"
    "algorithm', 'sse_customer_key_md5', 'sse_kms_key_id', 'sse_kms_encryption_context', 'bucket_key_enabled', 'size', "
    "'request_charged'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('expiration', 'etag', 'check"
    "sum_crc32', 'checksum_crc32c', 'checksum_crc64_nvme', 'checksum_sha1', 'checksum_sha256', 'checksum_type', 'server"
    "_side_encryption', 'version_id', 'sse_customer_algorithm', 'sse_customer_key_md5', 'sse_kms_key_id', 'sse_kms_encr"
    "yption_context', 'bucket_key_enabled', 'size', 'request_charged'), cache=False), InitPlan(fields=(InitPlan.Field(n"
    "ame='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True,"
    " override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='expiration', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='etag', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.f"
    "ields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='checksum_crc32', annotation=OpRef(name='init.fields.3.annotati"
    "on'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='checksum_crc32c', annotation=O"
    "pRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=Tru"
    "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
    "e='checksum_crc64_nvme', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='checksum_sha1', annotation=OpRef(name='init.fields.6.annotation'), default"
    "=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='checksum_sha256', annotation=OpRef(name='in"
    "it.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='checksum_t"
    "ype', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
    "InitPlan.Field(name='server_side_encryption', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(nam"
    "e='init.fields.9.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='version_id', annotation=OpRef(name='init.fields.10.an"
    "notation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='sse_customer_algorithm'"
    ", annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factor"
    "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
    "itPlan.Field(name='sse_customer_key_md5', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='"
    "init.fields.12.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
    "one, validate=None, check_type=None), InitPlan.Field(name='sse_kms_key_id', annotation=OpRef(name='init.fields.13."
    "annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=False, field"
    "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='sse_kms_encryption_co"
    "ntext', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e), InitPlan.Field(name='bucket_key_enabled', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(na"
    "me='init.fields.15.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='size', annotation=OpRef(name='init.fields.16.annota"
    "tion'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=True, override=False, field_type="
    "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='request_charged', annotatio"
    "n=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='"
    "self', std_params=(), kw_only_params=('expiration', 'etag', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc64_n"
    "vme', 'checksum_sha1', 'checksum_sha256', 'checksum_type', 'server_side_encryption', 'version_id', 'sse_customer_a"
    "lgorithm', 'sse_customer_key_md5', 'sse_kms_key_id', 'sse_kms_encryption_context', 'bucket_key_enabled', 'size', '"
    "request_charged'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields"
    "=(ReprPlan.Field(name='expiration', kw_only=True, fn=None), ReprPlan.Field(name='etag', kw_only=True, fn=None), Re"
    "prPlan.Field(name='checksum_crc32', kw_only=True, fn=None), ReprPlan.Field(name='checksum_crc32c', kw_only=True, f"
    "n=None), ReprPlan.Field(name='checksum_crc64_nvme', kw_only=True, fn=None), ReprPlan.Field(name='checksum_sha1', k"
    "w_only=True, fn=None), ReprPlan.Field(name='checksum_sha256', kw_only=True, fn=None), ReprPlan.Field(name='checksu"
    "m_type', kw_only=True, fn=None), ReprPlan.Field(name='server_side_encryption', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='version_id', kw_only=True, fn=None), ReprPlan.Field(name='sse_customer_algorithm', kw_only=True, fn=None"
    "), ReprPlan.Field(name='sse_customer_key_md5', kw_only=True, fn=None), ReprPlan.Field(name='sse_kms_key_id', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='sse_kms_encryption_context', kw_only=True, fn=None), ReprPlan.Field(name='"
    "bucket_key_enabled', kw_only=True, fn=None), ReprPlan.Field(name='size', kw_only=True, fn=None), ReprPlan.Field(na"
    "me='request_charged', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fPutObjectOutput(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            expiration=self.expiration,
            etag=self.etag,
            checksum_crc32=self.checksum_crc32,
            checksum_crc32c=self.checksum_crc32c,
            checksum_crc64_nvme=self.checksum_crc64_nvme,
            checksum_sha1=self.checksum_sha1,
            checksum_sha256=self.checksum_sha256,
            checksum_type=self.checksum_type,
            server_side_encryption=self.server_side_encryption,
            version_id=self.version_id,
            sse_customer_algorithm=self.sse_customer_algorithm,
            sse_customer_key_md5=self.sse_customer_key_md5,
            sse_kms_key_id=self.sse_kms_key_id,
            sse_kms_encryption_context=self.sse_kms_encryption_context,
            bucket_key_enabled=self.bucket_key_enabled,
            size=self.size,
            request_charged=self.request_charged,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.expiration == other.expiration and
            self.etag == other.etag and
            self.checksum_crc32 == other.checksum_crc32 and
            self.checksum_crc32c == other.checksum_crc32c and
            self.checksum_crc64_nvme == other.checksum_crc64_nvme and
            self.checksum_sha1 == other.checksum_sha1 and
            self.checksum_sha256 == other.checksum_sha256 and
            self.checksum_type == other.checksum_type and
            self.server_side_encryption == other.server_side_encryption and
            self.version_id == other.version_id and
            self.sse_customer_algorithm == other.sse_customer_algorithm and
            self.sse_customer_key_md5 == other.sse_customer_key_md5 and
            self.sse_kms_key_id == other.sse_kms_key_id and
            self.sse_kms_encryption_context == other.sse_kms_encryption_context and
            self.bucket_key_enabled == other.bucket_key_enabled and
            self.size == other.size and
            self.request_charged == other.request_charged
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'expiration',
        'etag',
        'checksum_crc32',
        'checksum_crc32c',
        'checksum_crc64_nvme',
        'checksum_sha1',
        'checksum_sha256',
        'checksum_type',
        'server_side_encryption',
        'version_id',
        'sse_customer_algorithm',
        'sse_customer_key_md5',
        'sse_kms_key_id',
        'sse_kms_encryption_context',
        'bucket_key_enabled',
        'size',
        'request_charged',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'expiration',
        'etag',
        'checksum_crc32',
        'checksum_crc32c',
        'checksum_crc64_nvme',
        'checksum_sha1',
        'checksum_sha256',
        'checksum_type',
        'server_side_encryption',
        'version_id',
        'sse_customer_algorithm',
        'sse_customer_key_md5',
        'sse_kms_key_id',
        'sse_kms_encryption_context',
        'bucket_key_enabled',
        'size',
        'request_charged',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.expiration,
            self.etag,
            self.checksum_crc32,
            self.checksum_crc32c,
            self.checksum_crc64_nvme,
            self.checksum_sha1,
            self.checksum_sha256,
            self.checksum_type,
            self.server_side_encryption,
            self.version_id,
            self.sse_customer_algorithm,
            self.sse_customer_key_md5,
            self.sse_kms_key_id,
            self.sse_kms_encryption_context,
            self.bucket_key_enabled,
            self.size,
            self.request_charged,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        expiration: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        etag: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        checksum_crc32: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        checksum_crc32c: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        checksum_crc64_nvme: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        checksum_sha1: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        checksum_sha256: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        checksum_type: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        server_side_encryption: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        version_id: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        sse_customer_algorithm: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        sse_customer_key_md5: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        sse_kms_key_id: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        sse_kms_encryption_context: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        bucket_key_enabled: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        size: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        request_charged: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'expiration', expiration)
        __dataclass__object_setattr(self, 'etag', etag)
        __dataclass__object_setattr(self, 'checksum_crc32', checksum_crc32)
        __dataclass__object_setattr(self, 'checksum_crc32c', checksum_crc32c)
        __dataclass__object_setattr(self, 'checksum_crc64_nvme', checksum_crc64_nvme)
        __dataclass__object_setattr(self, 'checksum_sha1', checksum_sha1)
        __dataclass__object_setattr(self, 'checksum_sha256', checksum_sha256)
        __dataclass__object_setattr(self, 'checksum_type', checksum_type)
        __dataclass__object_setattr(self, 'server_side_encryption', server_side_encryption)
        __dataclass__object_setattr(self, 'version_id', version_id)
        __dataclass__object_setattr(self, 'sse_customer_algorithm', sse_customer_algorithm)
        __dataclass__object_setattr(self, 'sse_customer_key_md5', sse_customer_key_md5)
        __dataclass__object_setattr(self, 'sse_kms_key_id', sse_kms_key_id)
        __dataclass__object_setattr(self, 'sse_kms_encryption_context', sse_kms_encryption_context)
        __dataclass__object_setattr(self, 'bucket_key_enabled', bucket_key_enabled)
        __dataclass__object_setattr(self, 'size', size)
        __dataclass__object_setattr(self, 'request_charged', request_charged)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"expiration={self.expiration!r}")
        parts.append(f"etag={self.etag!r}")
        parts.append(f"checksum_crc32={self.checksum_crc32!r}")
        parts.append(f"checksum_crc32c={self.checksum_crc32c!r}")
        parts.append(f"checksum_crc64_nvme={self.checksum_crc64_nvme!r}")
        parts.append(f"checksum_sha1={self.checksum_sha1!r}")
        parts.append(f"checksum_sha256={self.checksum_sha256!r}")
        parts.append(f"checksum_type={self.checksum_type!r}")
        parts.append(f"server_side_encryption={self.server_side_encryption!r}")
        parts.append(f"version_id={self.version_id!r}")
        parts.append(f"sse_customer_algorithm={self.sse_customer_algorithm!r}")
        parts.append(f"sse_customer_key_md5={self.sse_customer_key_md5!r}")
        parts.append(f"sse_kms_key_id={self.sse_kms_key_id!r}")
        parts.append(f"sse_kms_encryption_context={self.sse_kms_encryption_context!r}")
        parts.append(f"bucket_key_enabled={self.bucket_key_enabled!r}")
        parts.append(f"size={self.size!r}")
        parts.append(f"request_charged={self.request_charged!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('is_restore_in_progress', 'restore_expiry_date')), EqPlan(fields=('is_restore_in_progr"
    "ess', 'restore_expiry_date')), FrozenPlan(fields=('__shape__', 'is_restore_in_progress', 'restore_expiry_date'), a"
    "llow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('is_restore_in_progress', 'restore_expiry_date'),"
    " cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation')"
    ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, vali"
    "date=None, check_type=None), InitPlan.Field(name='is_restore_in_progress', annotation=OpRef(name='init.fields.1.an"
    "notation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_ty"
    "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='restore_expiry_date', an"
    "notation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_pa"
    "ram='self', std_params=(), kw_only_params=('is_restore_in_progress', 'restore_expiry_date'), frozen=True, slots=Fa"
    "lse, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='is_restore_in_pro"
    "gress', kw_only=True, fn=None), ReprPlan.Field(name='restore_expiry_date', kw_only=True, fn=None)), id=False, ters"
    "e=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fRestoreStatus(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            is_restore_in_progress=self.is_restore_in_progress,
            restore_expiry_date=self.restore_expiry_date,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.is_restore_in_progress == other.is_restore_in_progress and
            self.restore_expiry_date == other.restore_expiry_date
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'is_restore_in_progress',
        'restore_expiry_date',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'is_restore_in_progress',
        'restore_expiry_date',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.is_restore_in_progress,
            self.restore_expiry_date,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        is_restore_in_progress: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        restore_expiry_date: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'is_restore_in_progress', is_restore_in_progress)
        __dataclass__object_setattr(self, 'restore_expiry_date', restore_expiry_date)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"is_restore_in_progress={self.is_restore_in_progress!r}")
        parts.append(f"restore_expiry_date={self.restore_expiry_date!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('body', 'delete_marker', 'accept_ranges', 'expiration', 'restore', 'last_modified', 'c"
    "ontent_length', 'etag', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc64_nvme', 'checksum_sha1', 'checksum_sha"
    "256', 'checksum_type', 'missing_meta', 'version_id', 'cache_control', 'content_disposition', 'content_encoding', '"
    "content_language', 'content_range', 'content_type', 'expires', 'website_redirect_location', 'server_side_encryptio"
    "n', 'metadata', 'sse_customer_algorithm', 'sse_customer_key_md5', 'sse_kms_key_id', 'bucket_key_enabled', 'storage"
    "_class', 'request_charged', 'replication_status', 'parts_count', 'tag_count', 'object_lock_mode', 'object_lock_ret"
    "ain_until_date', 'object_lock_legal_hold_status')), EqPlan(fields=('body', 'delete_marker', 'accept_ranges', 'expi"
    "ration', 'restore', 'last_modified', 'content_length', 'etag', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc6"
    "4_nvme', 'checksum_sha1', 'checksum_sha256', 'checksum_type', 'missing_meta', 'version_id', 'cache_control', 'cont"
    "ent_disposition', 'content_encoding', 'content_language', 'content_range', 'content_type', 'expires', 'website_red"
    "irect_location', 'server_side_encryption', 'metadata', 'sse_customer_algorithm', 'sse_customer_key_md5', 'sse_kms_"
    "key_id', 'bucket_key_enabled', 'storage_class', 'request_charged', 'replication_status', 'parts_count', 'tag_count"
    "', 'object_lock_mode', 'object_lock_retain_until_date', 'object_lock_legal_hold_status')), FrozenPlan(fields=('__s"
    "hape__', 'body', 'delete_marker', 'accept_ranges', 'expiration', 'restore', 'last_modified', 'content_length', 'et"
    "ag', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc64_nvme', 'checksum_sha1', 'checksum_sha256', 'checksum_typ"
    "e', 'missing_meta', 'version_id', 'cache_control', 'content_disposition', 'content_encoding', 'content_language', "
    "'content_range', 'content_type', 'expires', 'website_redirect_location', 'server_side_encryption', 'metadata', 'ss"
    "e_customer_algorithm', 'sse_customer_key_md5', 'sse_kms_key_id', 'bucket_key_enabled', 'storage_class', 'request_c"
    "harged', 'replication_status', 'parts_count', 'tag_count', 'object_lock_mode', 'object_lock_retain_until_date', 'o"
    "bject_lock_legal_hold_status'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('body', 'delete_"
    "marker', 'accept_ranges', 'expiration', 'restore', 'last_modified', 'content_length', 'etag', 'checksum_crc32', 'c"
    "hecksum_crc32c', 'checksum_crc64_nvme', 'checksum_sha1', 'checksum_sha256', 'checksum_type', 'missing_meta', 'vers"
    "ion_id', 'cache_control', 'content_disposition', 'content_encoding', 'content_language', 'content_range', 'content"
    "_type', 'expires', 'website_redirect_location', 'server_side_encryption', 'metadata', 'sse_customer_algorithm', 's"
    "se_customer_key_md5', 'sse_kms_key_id', 'bucket_key_enabled', 'storage_class', 'request_charged', 'replication_sta"
    "tus', 'parts_count', 'tag_count', 'object_lock_mode', 'object_lock_retain_until_date', 'object_lock_legal_hold_sta"
    "tus'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annota"
    "tion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None"
    ", validate=None, check_type=None), InitPlan.Field(name='body', annotation=OpRef(name='init.fields.1.annotation'), "
    "default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType"
    ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='delete_marker', annotation=OpRef(nam"
    "e='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='accep"
    "t_ranges', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default"
    "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
    "ne), InitPlan.Field(name='expiration', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init"
    ".fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='restore', annotation=OpRef(name='init.fields.5.annotation'),"
    " default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='last_modified', annotation=OpRef(na"
    "me='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cont"
    "ent_length', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), defau"
    "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='etag', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fie"
    "lds.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None), InitPlan.Field(name='checksum_crc32', annotation=OpRef(name='init.fields.9.annotation"
    "'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='checksum_crc32c', annotation=OpR"
    "ef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=Tru"
    "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
    "e='checksum_crc64_nvme', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None), InitPlan.Field(name='checksum_sha1', annotation=OpRef(name='init.fields.12.annotation'), defa"
    "ult=OpRef(name='init.fields.12.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='checksum_sha256', annotation=OpRef(name"
    "='init.fields.13.annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='chec"
    "ksum_type', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='missing_meta', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name"
    "='init.fields.15.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='version_id', annotation=OpRef(name='init.fields.16.an"
    "notation'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cache_control', annotat"
    "ion=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, i"
    "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
    "eld(name='content_disposition', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.field"
    "s.18.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='content_encoding', annotation=OpRef(name='init.fields.19.annotati"
    "on'), default=OpRef(name='init.fields.19.default'), default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='content_language', annotation"
    "=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.fields.20.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='content_range', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='init.fields.21.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='content_type', annotation=OpRef(name='init.fields.22.annotation'), default"
    "=OpRef(name='init.fields.22.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
    "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='expires', annotation=OpRef(name='init.fiel"
    "ds.23.annotation'), default=OpRef(name='init.fields.23.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='website_redirec"
    "t_location', annotation=OpRef(name='init.fields.24.annotation'), default=OpRef(name='init.fields.24.default'), def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='server_side_encryption', annotation=OpRef(name='init.fields.25.annotation'), default"
    "=OpRef(name='init.fields.25.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
    "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='metadata', annotation=OpRef(name='init.fie"
    "lds.26.annotation'), default=OpRef(name='init.fields.26.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='sse_customer_a"
    "lgorithm', annotation=OpRef(name='init.fields.27.annotation'), default=OpRef(name='init.fields.27.default'), defau"
    "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='sse_customer_key_md5', annotation=OpRef(name='init.fields.28.annotation'), default=OpR"
    "ef(name='init.fields.28.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='sse_kms_key_id', annotation=OpRef(name='init.f"
    "ields.29.annotation'), default=OpRef(name='init.fields.29.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='bucket_key_e"
    "nabled', annotation=OpRef(name='init.fields.30.annotation'), default=OpRef(name='init.fields.30.default'), default"
    "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
    "ne), InitPlan.Field(name='storage_class', annotation=OpRef(name='init.fields.31.annotation'), default=OpRef(name='"
    "init.fields.31.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
    "one, validate=None, check_type=None), InitPlan.Field(name='request_charged', annotation=OpRef(name='init.fields.32"
    ".annotation'), default=OpRef(name='init.fields.32.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='replication_status',"
    " annotation=OpRef(name='init.fields.33.annotation'), default=OpRef(name='init.fields.33.default'), default_factory"
    "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
    "tPlan.Field(name='parts_count', annotation=OpRef(name='init.fields.34.annotation'), default=OpRef(name='init.field"
    "s.34.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='tag_count', annotation=OpRef(name='init.fields.35.annotation'), d"
    "efault=OpRef(name='init.fields.35.default'), default_factory=None, init=True, override=False, field_type=FieldType"
    ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='object_lock_mode', annotation=OpRef("
    "name='init.fields.36.annotation'), default=OpRef(name='init.fields.36.default'), default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "object_lock_retain_until_date', annotation=OpRef(name='init.fields.37.annotation'), default=OpRef(name='init.field"
    "s.37.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='object_lock_legal_hold_status', annotation=OpRef(name='init.field"
    "s.38.annotation'), default=OpRef(name='init.fields.38.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw"
    "_only_params=('body', 'delete_marker', 'accept_ranges', 'expiration', 'restore', 'last_modified', 'content_length'"
    ", 'etag', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc64_nvme', 'checksum_sha1', 'checksum_sha256', 'checksu"
    "m_type', 'missing_meta', 'version_id', 'cache_control', 'content_disposition', 'content_encoding', 'content_langua"
    "ge', 'content_range', 'content_type', 'expires', 'website_redirect_location', 'server_side_encryption', 'metadata'"
    ", 'sse_customer_algorithm', 'sse_customer_key_md5', 'sse_kms_key_id', 'bucket_key_enabled', 'storage_class', 'requ"
    "est_charged', 'replication_status', 'parts_count', 'tag_count', 'object_lock_mode', 'object_lock_retain_until_date"
    "', 'object_lock_legal_hold_status'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()"
    "), ReprPlan(fields=(ReprPlan.Field(name='body', kw_only=True, fn=None), ReprPlan.Field(name='delete_marker', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='accept_ranges', kw_only=True, fn=None), ReprPlan.Field(name='expiration', "
    "kw_only=True, fn=None), ReprPlan.Field(name='restore', kw_only=True, fn=None), ReprPlan.Field(name='last_modified'"
    ", kw_only=True, fn=None), ReprPlan.Field(name='content_length', kw_only=True, fn=None), ReprPlan.Field(name='etag'"
    ", kw_only=True, fn=None), ReprPlan.Field(name='checksum_crc32', kw_only=True, fn=None), ReprPlan.Field(name='check"
    "sum_crc32c', kw_only=True, fn=None), ReprPlan.Field(name='checksum_crc64_nvme', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='checksum_sha1', kw_only=True, fn=None), ReprPlan.Field(name='checksum_sha256', kw_only=True, fn=None), "
    "ReprPlan.Field(name='checksum_type', kw_only=True, fn=None), ReprPlan.Field(name='missing_meta', kw_only=True, fn="
    "None), ReprPlan.Field(name='version_id', kw_only=True, fn=None), ReprPlan.Field(name='cache_control', kw_only=True"
    ", fn=None), ReprPlan.Field(name='content_disposition', kw_only=True, fn=None), ReprPlan.Field(name='content_encodi"
    "ng', kw_only=True, fn=None), ReprPlan.Field(name='content_language', kw_only=True, fn=None), ReprPlan.Field(name='"
    "content_range', kw_only=True, fn=None), ReprPlan.Field(name='content_type', kw_only=True, fn=None), ReprPlan.Field"
    "(name='expires', kw_only=True, fn=None), ReprPlan.Field(name='website_redirect_location', kw_only=True, fn=None), "
    "ReprPlan.Field(name='server_side_encryption', kw_only=True, fn=None), ReprPlan.Field(name='metadata', kw_only=True"
    ", fn=None), ReprPlan.Field(name='sse_customer_algorithm', kw_only=True, fn=None), ReprPlan.Field(name='sse_custome"
    "r_key_md5', kw_only=True, fn=None), ReprPlan.Field(name='sse_kms_key_id', kw_only=True, fn=None), ReprPlan.Field(n"
    "ame='bucket_key_enabled', kw_only=True, fn=None), ReprPlan.Field(name='storage_class', kw_only=True, fn=None), Rep"
    "rPlan.Field(name='request_charged', kw_only=True, fn=None), ReprPlan.Field(name='replication_status', kw_only=True"
    ", fn=None), ReprPlan.Field(name='parts_count', kw_only=True, fn=None), ReprPlan.Field(name='tag_count', kw_only=Tr"
    "ue, fn=None), ReprPlan.Field(name='object_lock_mode', kw_only=True, fn=None), ReprPlan.Field(name='object_lock_ret"
    "ain_until_date', kw_only=True, fn=None), ReprPlan.Field(name='object_lock_legal_hold_status', kw_only=True, fn=Non"
    "e)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fGetObjectOutput(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__21__annotation,
    __dataclass__init__fields__21__default,
    __dataclass__init__fields__22__annotation,
    __dataclass__init__fields__22__default,
    __dataclass__init__fields__23__annotation,
    __dataclass__init__fields__23__default,
    __dataclass__init__fields__24__annotation,
    __dataclass__init__fields__24__default,
    __dataclass__init__fields__25__annotation,
    __dataclass__init__fields__25__default,
    __dataclass__init__fields__26__annotation,
    __dataclass__init__fields__26__default,
    __dataclass__init__fields__27__annotation,
    __dataclass__init__fields__27__default,
    __dataclass__init__fields__28__annotation,
    __dataclass__init__fields__28__default,
    __dataclass__init__fields__29__annotation,
    __dataclass__init__fields__29__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__30__annotation,
    __dataclass__init__fields__30__default,
    __dataclass__init__fields__31__annotation,
    __dataclass__init__fields__31__default,
    __dataclass__init__fields__32__annotation,
    __dataclass__init__fields__32__default,
    __dataclass__init__fields__33__annotation,
    __dataclass__init__fields__33__default,
    __dataclass__init__fields__34__annotation,
    __dataclass__init__fields__34__default,
    __dataclass__init__fields__35__annotation,
    __dataclass__init__fields__35__default,
    __dataclass__init__fields__36__annotation,
    __dataclass__init__fields__36__default,
    __dataclass__init__fields__37__annotation,
    __dataclass__init__fields__37__default,
    __dataclass__init__fields__38__annotation,
    __dataclass__init__fields__38__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            body=self.body,
            delete_marker=self.delete_marker,
            accept_ranges=self.accept_ranges,
            expiration=self.expiration,
            restore=self.restore,
            last_modified=self.last_modified,
            content_length=self.content_length,
            etag=self.etag,
            checksum_crc32=self.checksum_crc32,
            checksum_crc32c=self.checksum_crc32c,
            checksum_crc64_nvme=self.checksum_crc64_nvme,
            checksum_sha1=self.checksum_sha1,
            checksum_sha256=self.checksum_sha256,
            checksum_type=self.checksum_type,
            missing_meta=self.missing_meta,
            version_id=self.version_id,
            cache_control=self.cache_control,
            content_disposition=self.content_disposition,
            content_encoding=self.content_encoding,
            content_language=self.content_language,
            content_range=self.content_range,
            content_type=self.content_type,
            expires=self.expires,
            website_redirect_location=self.website_redirect_location,
            server_side_encryption=self.server_side_encryption,
            metadata=self.metadata,
            sse_customer_algorithm=self.sse_customer_algorithm,
            sse_customer_key_md5=self.sse_customer_key_md5,
            sse_kms_key_id=self.sse_kms_key_id,
            bucket_key_enabled=self.bucket_key_enabled,
            storage_class=self.storage_class,
            request_charged=self.request_charged,
            replication_status=self.replication_status,
            parts_count=self.parts_count,
            tag_count=self.tag_count,
            object_lock_mode=self.object_lock_mode,
            object_lock_retain_until_date=self.object_lock_retain_until_date,
            object_lock_legal_hold_status=self.object_lock_legal_hold_status,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.body == other.body and
            self.delete_marker == other.delete_marker and
            self.accept_ranges == other.accept_ranges and
            self.expiration == other.expiration and
            self.restore == other.restore and
            self.last_modified == other.last_modified and
            self.content_length == other.content_length and
            self.etag == other.etag and
            self.checksum_crc32 == other.checksum_crc32 and
            self.checksum_crc32c == other.checksum_crc32c and
            self.checksum_crc64_nvme == other.checksum_crc64_nvme and
            self.checksum_sha1 == other.checksum_sha1 and
            self.checksum_sha256 == other.checksum_sha256 and
            self.checksum_type == other.checksum_type and
            self.missing_meta == other.missing_meta and
            self.version_id == other.version_id and
            self.cache_control == other.cache_control and
            self.content_disposition == other.content_disposition and
            self.content_encoding == other.content_encoding and
            self.content_language == other.content_language and
            self.content_range == other.content_range and
            self.content_type == other.content_type and
            self.expires == other.expires and
            self.website_redirect_location == other.website_redirect_location and
            self.server_side_encryption == other.server_side_encryption and
            self.metadata == other.metadata and
            self.sse_customer_algorithm == other.sse_customer_algorithm and
            self.sse_customer_key_md5 == other.sse_customer_key_md5 and
            self.sse_kms_key_id == other.sse_kms_key_id and
            self.bucket_key_enabled == other.bucket_key_enabled and
            self.storage_class == other.storage_class and
            self.request_charged == other.request_charged and
            self.replication_status == other.replication_status and
            self.parts_count == other.parts_count and
            self.tag_count == other.tag_count and
            self.object_lock_mode == other.object_lock_mode and
            self.object_lock_retain_until_date == other.object_lock_retain_until_date and
            self.object_lock_legal_hold_status == other.object_lock_legal_hold_status
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'body',
        'delete_marker',
        'accept_ranges',
        'expiration',
        'restore',
        'last_modified',
        'content_length',
        'etag',
        'checksum_crc32',
        'checksum_crc32c',
        'checksum_crc64_nvme',
        'checksum_sha1',
        'checksum_sha256',
        'checksum_type',
        'missing_meta',
        'version_id',
        'cache_control',
        'content_disposition',
        'content_encoding',
        'content_language',
        'content_range',
        'content_type',
        'expires',
        'website_redirect_location',
        'server_side_encryption',
        'metadata',
        'sse_customer_algorithm',
        'sse_customer_key_md5',
        'sse_kms_key_id',
        'bucket_key_enabled',
        'storage_class',
        'request_charged',
        'replication_status',
        'parts_count',
        'tag_count',
        'object_lock_mode',
        'object_lock_retain_until_date',
        'object_lock_legal_hold_status',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'body',
        'delete_marker',
        'accept_ranges',
        'expiration',
        'restore',
        'last_modified',
        'content_length',
        'etag',
        'checksum_crc32',
        'checksum_crc32c',
        'checksum_crc64_nvme',
        'checksum_sha1',
        'checksum_sha256',
        'checksum_type',
        'missing_meta',
        'version_id',
        'cache_control',
        'content_disposition',
        'content_encoding',
        'content_language',
        'content_range',
        'content_type',
        'expires',
        'website_redirect_location',
        'server_side_encryption',
        'metadata',
        'sse_customer_algorithm',
        'sse_customer_key_md5',
        'sse_kms_key_id',
        'bucket_key_enabled',
        'storage_class',
        'request_charged',
        'replication_status',
        'parts_count',
        'tag_count',
        'object_lock_mode',
        'object_lock_retain_until_date',
        'object_lock_legal_hold_status',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.body,
            self.delete_marker,
            self.accept_ranges,
            self.expiration,
            self.restore,
            self.last_modified,
            self.content_length,
            self.etag,
            self.checksum_crc32,
            self.checksum_crc32c,
            self.checksum_crc64_nvme,
            self.checksum_sha1,
            self.checksum_sha256,
            self.checksum_type,
            self.missing_meta,
            self.version_id,
            self.cache_control,
            self.content_disposition,
            self.content_encoding,
            self.content_language,
            self.content_range,
            self.content_type,
            self.expires,
            self.website_redirect_location,
            self.server_side_encryption,
            self.metadata,
            self.sse_customer_algorithm,
            self.sse_customer_key_md5,
            self.sse_kms_key_id,
            self.bucket_key_enabled,
            self.storage_class,
            self.request_charged,
            self.replication_status,
            self.parts_count,
            self.tag_count,
            self.object_lock_mode,
            self.object_lock_retain_until_date,
            self.object_lock_legal_hold_status,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        body: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        delete_marker: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        accept_ranges: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        expiration: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        restore: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        last_modified: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        content_length: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        etag: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        checksum_crc32: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        checksum_crc32c: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        checksum_crc64_nvme: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        checksum_sha1: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        checksum_sha256: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        checksum_type: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        missing_meta: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        version_id: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        cache_control: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        content_disposition: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        content_encoding: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        content_language: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        content_range: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
        content_type: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
        expires: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
        website_redirect_location: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
        server_side_encryption: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
        metadata: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
        sse_customer_algorithm: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
        sse_customer_key_md5: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
        sse_kms_key_id: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
        bucket_key_enabled: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
        storage_class: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
        request_charged: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
        replication_status: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
        parts_count: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
        tag_count: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
        object_lock_mode: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
        object_lock_retain_until_date: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
        object_lock_legal_hold_status: __dataclass__init__fields__38__annotation = __dataclass__init__fields__38__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'body', body)
        __dataclass__object_setattr(self, 'delete_marker', delete_marker)
        __dataclass__object_setattr(self, 'accept_ranges', accept_ranges)
        __dataclass__object_setattr(self, 'expiration', expiration)
        __dataclass__object_setattr(self, 'restore', restore)
        __dataclass__object_setattr(self, 'last_modified', last_modified)
        __dataclass__object_setattr(self, 'content_length', content_length)
        __dataclass__object_setattr(self, 'etag', etag)
        __dataclass__object_setattr(self, 'checksum_crc32', checksum_crc32)
        __dataclass__object_setattr(self, 'checksum_crc32c', checksum_crc32c)
        __dataclass__object_setattr(self, 'checksum_crc64_nvme', checksum_crc64_nvme)
        __dataclass__object_setattr(self, 'checksum_sha1', checksum_sha1)
        __dataclass__object_setattr(self, 'checksum_sha256', checksum_sha256)
        __dataclass__object_setattr(self, 'checksum_type', checksum_type)
        __dataclass__object_setattr(self, 'missing_meta', missing_meta)
        __dataclass__object_setattr(self, 'version_id', version_id)
        __dataclass__object_setattr(self, 'cache_control', cache_control)
        __dataclass__object_setattr(self, 'content_disposition', content_disposition)
        __dataclass__object_setattr(self, 'content_encoding', content_encoding)
        __dataclass__object_setattr(self, 'content_language', content_language)
        __dataclass__object_setattr(self, 'content_range', content_range)
        __dataclass__object_setattr(self, 'content_type', content_type)
        __dataclass__object_setattr(self, 'expires', expires)
        __dataclass__object_setattr(self, 'website_redirect_location', website_redirect_location)
        __dataclass__object_setattr(self, 'server_side_encryption', server_side_encryption)
        __dataclass__object_setattr(self, 'metadata', metadata)
        __dataclass__object_setattr(self, 'sse_customer_algorithm', sse_customer_algorithm)
        __dataclass__object_setattr(self, 'sse_customer_key_md5', sse_customer_key_md5)
        __dataclass__object_setattr(self, 'sse_kms_key_id', sse_kms_key_id)
        __dataclass__object_setattr(self, 'bucket_key_enabled', bucket_key_enabled)
        __dataclass__object_setattr(self, 'storage_class', storage_class)
        __dataclass__object_setattr(self, 'request_charged', request_charged)
        __dataclass__object_setattr(self, 'replication_status', replication_status)
        __dataclass__object_setattr(self, 'parts_count', parts_count)
        __dataclass__object_setattr(self, 'tag_count', tag_count)
        __dataclass__object_setattr(self, 'object_lock_mode', object_lock_mode)
        __dataclass__object_setattr(self, 'object_lock_retain_until_date', object_lock_retain_until_date)
        __dataclass__object_setattr(self, 'object_lock_legal_hold_status', object_lock_legal_hold_status)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"body={self.body!r}")
        parts.append(f"delete_marker={self.delete_marker!r}")
        parts.append(f"accept_ranges={self.accept_ranges!r}")
        parts.append(f"expiration={self.expiration!r}")
        parts.append(f"restore={self.restore!r}")
        parts.append(f"last_modified={self.last_modified!r}")
        parts.append(f"content_length={self.content_length!r}")
        parts.append(f"etag={self.etag!r}")
        parts.append(f"checksum_crc32={self.checksum_crc32!r}")
        parts.append(f"checksum_crc32c={self.checksum_crc32c!r}")
        parts.append(f"checksum_crc64_nvme={self.checksum_crc64_nvme!r}")
        parts.append(f"checksum_sha1={self.checksum_sha1!r}")
        parts.append(f"checksum_sha256={self.checksum_sha256!r}")
        parts.append(f"checksum_type={self.checksum_type!r}")
        parts.append(f"missing_meta={self.missing_meta!r}")
        parts.append(f"version_id={self.version_id!r}")
        parts.append(f"cache_control={self.cache_control!r}")
        parts.append(f"content_disposition={self.content_disposition!r}")
        parts.append(f"content_encoding={self.content_encoding!r}")
        parts.append(f"content_language={self.content_language!r}")
        parts.append(f"content_range={self.content_range!r}")
        parts.append(f"content_type={self.content_type!r}")
        parts.append(f"expires={self.expires!r}")
        parts.append(f"website_redirect_location={self.website_redirect_location!r}")
        parts.append(f"server_side_encryption={self.server_side_encryption!r}")
        parts.append(f"metadata={self.metadata!r}")
        parts.append(f"sse_customer_algorithm={self.sse_customer_algorithm!r}")
        parts.append(f"sse_customer_key_md5={self.sse_customer_key_md5!r}")
        parts.append(f"sse_kms_key_id={self.sse_kms_key_id!r}")
        parts.append(f"bucket_key_enabled={self.bucket_key_enabled!r}")
        parts.append(f"storage_class={self.storage_class!r}")
        parts.append(f"request_charged={self.request_charged!r}")
        parts.append(f"replication_status={self.replication_status!r}")
        parts.append(f"parts_count={self.parts_count!r}")
        parts.append(f"tag_count={self.tag_count!r}")
        parts.append(f"object_lock_mode={self.object_lock_mode!r}")
        parts.append(f"object_lock_retain_until_date={self.object_lock_retain_until_date!r}")
        parts.append(f"object_lock_legal_hold_status={self.object_lock_legal_hold_status!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('bucket', 'delimiter', 'encoding_type', 'max_keys', 'prefix', 'continuation_token', 'f"
    "etch_owner', 'start_after', 'request_payer', 'expected_bucket_owner', 'optional_object_attributes')), EqPlan(field"
    "s=('bucket', 'delimiter', 'encoding_type', 'max_keys', 'prefix', 'continuation_token', 'fetch_owner', 'start_after"
    "', 'request_payer', 'expected_bucket_owner', 'optional_object_attributes')), FrozenPlan(fields=('__shape__', 'buck"
    "et', 'delimiter', 'encoding_type', 'max_keys', 'prefix', 'continuation_token', 'fetch_owner', 'start_after', 'requ"
    "est_payer', 'expected_bucket_owner', 'optional_object_attributes'), allow_dynamic_dunder_attrs=False), HashPlan(ac"
    "tion='add', fields=('bucket', 'delimiter', 'encoding_type', 'max_keys', 'prefix', 'continuation_token', 'fetch_own"
    "er', 'start_after', 'request_payer', 'expected_bucket_owner', 'optional_object_attributes'), cache=False), InitPla"
    "n(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='bucket', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
    "InitPlan.Field(name='delimiter', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.field"
    "s.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='encoding_type', annotation=OpRef(name='init.fields.3.annotation'),"
    " default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_keys', annotation=OpRef(name='i"
    "nit.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override="
    "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='prefix', "
    "annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='continuation_token', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fi"
    "elds.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='fetch_owner', annotation=OpRef(name='init.fields.7.annotation')"
    ", default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
    "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='start_after', annotation=OpRef(nam"
    "e='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='reque"
    "st_payer', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default"
    "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
    "ne), InitPlan.Field(name='expected_bucket_owner', annotation=OpRef(name='init.fields.10.annotation'), default=OpRe"
    "f(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None), InitPlan.Field(name='optional_object_attributes', annotation=OpRef(n"
    "ame='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', st"
    "d_params=(), kw_only_params=('bucket', 'delimiter', 'encoding_type', 'max_keys', 'prefix', 'continuation_token', '"
    "fetch_owner', 'start_after', 'request_payer', 'expected_bucket_owner', 'optional_object_attributes'), frozen=True,"
    " slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='bucket',"
    " kw_only=True, fn=None), ReprPlan.Field(name='delimiter', kw_only=True, fn=None), ReprPlan.Field(name='encoding_ty"
    "pe', kw_only=True, fn=None), ReprPlan.Field(name='max_keys', kw_only=True, fn=None), ReprPlan.Field(name='prefix',"
    " kw_only=True, fn=None), ReprPlan.Field(name='continuation_token', kw_only=True, fn=None), ReprPlan.Field(name='fe"
    "tch_owner', kw_only=True, fn=None), ReprPlan.Field(name='start_after', kw_only=True, fn=None), ReprPlan.Field(name"
    "='request_payer', kw_only=True, fn=None), ReprPlan.Field(name='expected_bucket_owner', kw_only=True, fn=None), Rep"
    "rPlan.Field(name='optional_object_attributes', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fListObjectsV2Request(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            bucket=self.bucket,
            delimiter=self.delimiter,
            encoding_type=self.encoding_type,
            max_keys=self.max_keys,
            prefix=self.prefix,
            continuation_token=self.continuation_token,
            fetch_owner=self.fetch_owner,
            start_after=self.start_after,
            request_payer=self.request_payer,
            expected_bucket_owner=self.expected_bucket_owner,
            optional_object_attributes=self.optional_object_attributes,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.bucket == other.bucket and
            self.delimiter == other.delimiter and
            self.encoding_type == other.encoding_type and
            self.max_keys == other.max_keys and
            self.prefix == other.prefix and
            self.continuation_token == other.continuation_token and
            self.fetch_owner == other.fetch_owner and
            self.start_after == other.start_after and
            self.request_payer == other.request_payer and
            self.expected_bucket_owner == other.expected_bucket_owner and
            self.optional_object_attributes == other.optional_object_attributes
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'bucket',
        'delimiter',
        'encoding_type',
        'max_keys',
        'prefix',
        'continuation_token',
        'fetch_owner',
        'start_after',
        'request_payer',
        'expected_bucket_owner',
        'optional_object_attributes',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'bucket',
        'delimiter',
        'encoding_type',
        'max_keys',
        'prefix',
        'continuation_token',
        'fetch_owner',
        'start_after',
        'request_payer',
        'expected_bucket_owner',
        'optional_object_attributes',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.bucket,
            self.delimiter,
            self.encoding_type,
            self.max_keys,
            self.prefix,
            self.continuation_token,
            self.fetch_owner,
            self.start_after,
            self.request_payer,
            self.expected_bucket_owner,
            self.optional_object_attributes,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        bucket: __dataclass__init__fields__1__annotation,
        delimiter: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        encoding_type: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        max_keys: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        prefix: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        continuation_token: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        fetch_owner: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        start_after: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        request_payer: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        expected_bucket_owner: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        optional_object_attributes: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'bucket', bucket)
        __dataclass__object_setattr(self, 'delimiter', delimiter)
        __dataclass__object_setattr(self, 'encoding_type', encoding_type)
        __dataclass__object_setattr(self, 'max_keys', max_keys)
        __dataclass__object_setattr(self, 'prefix', prefix)
        __dataclass__object_setattr(self, 'continuation_token', continuation_token)
        __dataclass__object_setattr(self, 'fetch_owner', fetch_owner)
        __dataclass__object_setattr(self, 'start_after', start_after)
        __dataclass__object_setattr(self, 'request_payer', request_payer)
        __dataclass__object_setattr(self, 'expected_bucket_owner', expected_bucket_owner)
        __dataclass__object_setattr(self, 'optional_object_attributes', optional_object_attributes)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"bucket={self.bucket!r}")
        parts.append(f"delimiter={self.delimiter!r}")
        parts.append(f"encoding_type={self.encoding_type!r}")
        parts.append(f"max_keys={self.max_keys!r}")
        parts.append(f"prefix={self.prefix!r}")
        parts.append(f"continuation_token={self.continuation_token!r}")
        parts.append(f"fetch_owner={self.fetch_owner!r}")
        parts.append(f"start_after={self.start_after!r}")
        parts.append(f"request_payer={self.request_payer!r}")
        parts.append(f"expected_bucket_owner={self.expected_bucket_owner!r}")
        parts.append(f"optional_object_attributes={self.optional_object_attributes!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('key', 'last_modified', 'etag', 'checksum_algorithm', 'checksum_type', 'size', 'storag"
    "e_class', 'owner', 'restore_status')), EqPlan(fields=('key', 'last_modified', 'etag', 'checksum_algorithm', 'check"
    "sum_type', 'size', 'storage_class', 'owner', 'restore_status')), FrozenPlan(fields=('__shape__', 'key', 'last_modi"
    "fied', 'etag', 'checksum_algorithm', 'checksum_type', 'size', 'storage_class', 'owner', 'restore_status'), allow_d"
    "ynamic_dunder_attrs=False), HashPlan(action='add', fields=('key', 'last_modified', 'etag', 'checksum_algorithm', '"
    "checksum_type', 'size', 'storage_class', 'owner', 'restore_status'), cache=False), InitPlan(fields=(InitPlan.Field"
    "(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=Tru"
    "e, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='key', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e), InitPlan.Field(name='last_modified', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='in"
    "it.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
    ", validate=None, check_type=None), InitPlan.Field(name='etag', annotation=OpRef(name='init.fields.3.annotation'), "
    "default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType"
    ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='checksum_algorithm', annotation=OpRe"
    "f(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "checksum_type', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), de"
    "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='size', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init."
    "fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None), InitPlan.Field(name='storage_class', annotation=OpRef(name='init.fields.7.annotati"
    "on'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='owner', annotation=OpRef(name="
    "'init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='restore"
    "_status', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e)), self_param='self', std_params=(), kw_only_params=('key', 'last_modified', 'etag', 'checksum_algorithm', 'chec"
    "ksum_type', 'size', 'storage_class', 'owner', 'restore_status'), frozen=True, slots=False, post_init_params=None, "
    "init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='key', kw_only=True, fn=None), ReprPlan.Field("
    "name='last_modified', kw_only=True, fn=None), ReprPlan.Field(name='etag', kw_only=True, fn=None), ReprPlan.Field(n"
    "ame='checksum_algorithm', kw_only=True, fn=None), ReprPlan.Field(name='checksum_type', kw_only=True, fn=None), Rep"
    "rPlan.Field(name='size', kw_only=True, fn=None), ReprPlan.Field(name='storage_class', kw_only=True, fn=None), Repr"
    "Plan.Field(name='owner', kw_only=True, fn=None), ReprPlan.Field(name='restore_status', kw_only=True, fn=None)), id"
    "=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fObject(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            key=self.key,
            last_modified=self.last_modified,
            etag=self.etag,
            checksum_algorithm=self.checksum_algorithm,
            checksum_type=self.checksum_type,
            size=self.size,
            storage_class=self.storage_class,
            owner=self.owner,
            restore_status=self.restore_status,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.key == other.key and
            self.last_modified == other.last_modified and
            self.etag == other.etag and
            self.checksum_algorithm == other.checksum_algorithm and
            self.checksum_type == other.checksum_type and
            self.size == other.size and
            self.storage_class == other.storage_class and
            self.owner == other.owner and
            self.restore_status == other.restore_status
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'key',
        'last_modified',
        'etag',
        'checksum_algorithm',
        'checksum_type',
        'size',
        'storage_class',
        'owner',
        'restore_status',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'key',
        'last_modified',
        'etag',
        'checksum_algorithm',
        'checksum_type',
        'size',
        'storage_class',
        'owner',
        'restore_status',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.key,
            self.last_modified,
            self.etag,
            self.checksum_algorithm,
            self.checksum_type,
            self.size,
            self.storage_class,
            self.owner,
            self.restore_status,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        key: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        last_modified: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        etag: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        checksum_algorithm: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        checksum_type: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        size: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        storage_class: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        owner: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        restore_status: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'key', key)
        __dataclass__object_setattr(self, 'last_modified', last_modified)
        __dataclass__object_setattr(self, 'etag', etag)
        __dataclass__object_setattr(self, 'checksum_algorithm', checksum_algorithm)
        __dataclass__object_setattr(self, 'checksum_type', checksum_type)
        __dataclass__object_setattr(self, 'size', size)
        __dataclass__object_setattr(self, 'storage_class', storage_class)
        __dataclass__object_setattr(self, 'owner', owner)
        __dataclass__object_setattr(self, 'restore_status', restore_status)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"key={self.key!r}")
        parts.append(f"last_modified={self.last_modified!r}")
        parts.append(f"etag={self.etag!r}")
        parts.append(f"checksum_algorithm={self.checksum_algorithm!r}")
        parts.append(f"checksum_type={self.checksum_type!r}")
        parts.append(f"size={self.size!r}")
        parts.append(f"storage_class={self.storage_class!r}")
        parts.append(f"owner={self.owner!r}")
        parts.append(f"restore_status={self.restore_status!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('acl', 'body', 'bucket', 'cache_control', 'content_disposition', 'content_encoding', '"
    "content_language', 'content_length', 'content_md5', 'content_type', 'checksum_algorithm', 'checksum_crc32', 'check"
    "sum_crc32c', 'checksum_crc64_nvme', 'checksum_sha1', 'checksum_sha256', 'expires', 'if_match', 'if_none_match', 'g"
    "rant_full_control', 'grant_read', 'grant_read_acp', 'grant_write_acp', 'key', 'write_offset_bytes', 'metadata', 's"
    "erver_side_encryption', 'storage_class', 'website_redirect_location', 'sse_customer_algorithm', 'sse_customer_key'"
    ", 'sse_customer_key_md5', 'sse_kms_key_id', 'sse_kms_encryption_context', 'bucket_key_enabled', 'request_payer', '"
    "tagging', 'object_lock_mode', 'object_lock_retain_until_date', 'object_lock_legal_hold_status', 'expected_bucket_o"
    "wner')), EqPlan(fields=('acl', 'body', 'bucket', 'cache_control', 'content_disposition', 'content_encoding', 'cont"
    "ent_language', 'content_length', 'content_md5', 'content_type', 'checksum_algorithm', 'checksum_crc32', 'checksum_"
    "crc32c', 'checksum_crc64_nvme', 'checksum_sha1', 'checksum_sha256', 'expires', 'if_match', 'if_none_match', 'grant"
    "_full_control', 'grant_read', 'grant_read_acp', 'grant_write_acp', 'key', 'write_offset_bytes', 'metadata', 'serve"
    "r_side_encryption', 'storage_class', 'website_redirect_location', 'sse_customer_algorithm', 'sse_customer_key', 's"
    "se_customer_key_md5', 'sse_kms_key_id', 'sse_kms_encryption_context', 'bucket_key_enabled', 'request_payer', 'tagg"
    "ing', 'object_lock_mode', 'object_lock_retain_until_date', 'object_lock_legal_hold_status', 'expected_bucket_owner"
    "')), FrozenPlan(fields=('__shape__', 'acl', 'body', 'bucket', 'cache_control', 'content_disposition', 'content_enc"
    "oding', 'content_language', 'content_length', 'content_md5', 'content_type', 'checksum_algorithm', 'checksum_crc32"
    "', 'checksum_crc32c', 'checksum_crc64_nvme', 'checksum_sha1', 'checksum_sha256', 'expires', 'if_match', 'if_none_m"
    "atch', 'grant_full_control', 'grant_read', 'grant_read_acp', 'grant_write_acp', 'key', 'write_offset_bytes', 'meta"
    "data', 'server_side_encryption', 'storage_class', 'website_redirect_location', 'sse_customer_algorithm', 'sse_cust"
    "omer_key', 'sse_customer_key_md5', 'sse_kms_key_id', 'sse_kms_encryption_context', 'bucket_key_enabled', 'request_"
    "payer', 'tagging', 'object_lock_mode', 'object_lock_retain_until_date', 'object_lock_legal_hold_status', 'expected"
    "_bucket_owner'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('acl', 'body', 'bucket', 'cache"
    "_control', 'content_disposition', 'content_encoding', 'content_language', 'content_length', 'content_md5', 'conten"
    "t_type', 'checksum_algorithm', 'checksum_crc32', 'checksum_crc32c', 'checksum_crc64_nvme', 'checksum_sha1', 'check"
    "sum_sha256', 'expires', 'if_match', 'if_none_match', 'grant_full_control', 'grant_read', 'grant_read_acp', 'grant_"
    "write_acp', 'key', 'write_offset_bytes', 'metadata', 'server_side_encryption', 'storage_class', 'website_redirect_"
    "location', 'sse_customer_algorithm', 'sse_customer_key', 'sse_customer_key_md5', 'sse_kms_key_id', 'sse_kms_encryp"
    "tion_context', 'bucket_key_enabled', 'request_payer', 'tagging', 'object_lock_mode', 'object_lock_retain_until_dat"
    "e', 'object_lock_legal_hold_status', 'expected_bucket_owner'), cache=False), InitPlan(fields=(InitPlan.Field(name="
    "'__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ac"
    "l', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factor"
    "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
    "itPlan.Field(name='body', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
    ", check_type=None), InitPlan.Field(name='bucket', annotation=OpRef(name='init.fields.3.annotation'), default=None,"
    " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
    "_type=None), InitPlan.Field(name='cache_control', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef"
    "(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None), InitPlan.Field(name='content_disposition', annotation=OpRef(name='init"
    ".fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='content_enco"
    "ding', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='content_language', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='in"
    "it.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
    ", validate=None, check_type=None), InitPlan.Field(name='content_length', annotation=OpRef(name='init.fields.8.anno"
    "tation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type"
    "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='content_md5', annotation=O"
    "pRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=Tru"
    "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
    "e='content_type', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default')"
    ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='checksum_algorithm', annotation=OpRef(name='init.fields.11.annotation'), defaul"
    "t=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
    "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='checksum_crc32', annotation=OpRef(name='i"
    "nit.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='checksu"
    "m_crc32c', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13.default'), defau"
    "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='checksum_crc64_nvme', annotation=OpRef(name='init.fields.14.annotation'), default=OpRe"
    "f(name='init.fields.14.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None), InitPlan.Field(name='checksum_sha1', annotation=OpRef(name='init.fie"
    "lds.15.annotation'), default=OpRef(name='init.fields.15.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='checksum_sha25"
    "6', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
    "InitPlan.Field(name='expires', annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields"
    ".17.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='if_match', annotation=OpRef(name='init.fields.18.annotation'), def"
    "ault=OpRef(name='init.fields.18.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
    "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='if_none_match', annotation=OpRef(name="
    "'init.fields.19.annotation'), default=OpRef(name='init.fields.19.default'), default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='grant"
    "_full_control', annotation=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.fields.20.default'), "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None), InitPlan.Field(name='grant_read', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(na"
    "me='init.fields.21.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='grant_read_acp', annotation=OpRef(name='init.fields"
    ".22.annotation'), default=OpRef(name='init.fields.22.default'), default_factory=None, init=True, override=False, f"
    "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='grant_write_acp',"
    " annotation=OpRef(name='init.fields.23.annotation'), default=OpRef(name='init.fields.23.default'), default_factory"
    "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
    "tPlan.Field(name='key', annotation=OpRef(name='init.fields.24.annotation'), default=None, default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='write_offset_bytes', annotation=OpRef(name='init.fields.25.annotation'), default=OpRef(name='init.fields."
    "25.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None), InitPlan.Field(name='metadata', annotation=OpRef(name='init.fields.26.annotation'), defa"
    "ult=OpRef(name='init.fields.26.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='server_side_encryption', annotation=OpR"
    "ef(name='init.fields.27.annotation'), default=OpRef(name='init.fields.27.default'), default_factory=None, init=Tru"
    "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
    "e='storage_class', annotation=OpRef(name='init.fields.28.annotation'), default=OpRef(name='init.fields.28.default'"
    "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
    "ck_type=None), InitPlan.Field(name='website_redirect_location', annotation=OpRef(name='init.fields.29.annotation')"
    ", default=OpRef(name='init.fields.29.default'), default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='sse_customer_algorithm', annotati"
    "on=OpRef(name='init.fields.30.annotation'), default=OpRef(name='init.fields.30.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='sse_customer_key', annotation=OpRef(name='init.fields.31.annotation'), default=OpRef(name='init.fields.31"
    ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None), InitPlan.Field(name='sse_customer_key_md5', annotation=OpRef(name='init.fields.32.annotati"
    "on'), default=OpRef(name='init.fields.32.default'), default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='sse_kms_key_id', annotation=O"
    "pRef(name='init.fields.33.annotation'), default=OpRef(name='init.fields.33.default'), default_factory=None, init=T"
    "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
    "ame='sse_kms_encryption_context', annotation=OpRef(name='init.fields.34.annotation'), default=OpRef(name='init.fie"
    "lds.34.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='bucket_key_enabled', annotation=OpRef(name='init.fields.35.anno"
    "tation'), default=OpRef(name='init.fields.35.default'), default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='request_payer', annotatio"
    "n=OpRef(name='init.fields.36.annotation'), default=OpRef(name='init.fields.36.default'), default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='tagging', annotation=OpRef(name='init.fields.37.annotation'), default=OpRef(name='init.fields.37.default')"
    ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='object_lock_mode', annotation=OpRef(name='init.fields.38.annotation'), default="
    "OpRef(name='init.fields.38.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='object_lock_retain_until_date', annotation="
    "OpRef(name='init.fields.39.annotation'), default=OpRef(name='init.fields.39.default'), default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='object_lock_legal_hold_status', annotation=OpRef(name='init.fields.40.annotation'), default=OpRef(name='init"
    ".fields.40.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None), InitPlan.Field(name='expected_bucket_owner', annotation=OpRef(name='init.fields."
    "41.annotation'), default=OpRef(name='init.fields.41.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_o"
    "nly_params=('acl', 'body', 'bucket', 'cache_control', 'content_disposition', 'content_encoding', 'content_language"
    "', 'content_length', 'content_md5', 'content_type', 'checksum_algorithm', 'checksum_crc32', 'checksum_crc32c', 'ch"
    "ecksum_crc64_nvme', 'checksum_sha1', 'checksum_sha256', 'expires', 'if_match', 'if_none_match', 'grant_full_contro"
    "l', 'grant_read', 'grant_read_acp', 'grant_write_acp', 'key', 'write_offset_bytes', 'metadata', 'server_side_encry"
    "ption', 'storage_class', 'website_redirect_location', 'sse_customer_algorithm', 'sse_customer_key', 'sse_customer_"
    "key_md5', 'sse_kms_key_id', 'sse_kms_encryption_context', 'bucket_key_enabled', 'request_payer', 'tagging', 'objec"
    "t_lock_mode', 'object_lock_retain_until_date', 'object_lock_legal_hold_status', 'expected_bucket_owner'), frozen=T"
    "rue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='acl'"
    ", kw_only=True, fn=None), ReprPlan.Field(name='body', kw_only=True, fn=None), ReprPlan.Field(name='bucket', kw_onl"
    "y=True, fn=None), ReprPlan.Field(name='cache_control', kw_only=True, fn=None), ReprPlan.Field(name='content_dispos"
    "ition', kw_only=True, fn=None), ReprPlan.Field(name='content_encoding', kw_only=True, fn=None), ReprPlan.Field(nam"
    "e='content_language', kw_only=True, fn=None), ReprPlan.Field(name='content_length', kw_only=True, fn=None), ReprPl"
    "an.Field(name='content_md5', kw_only=True, fn=None), ReprPlan.Field(name='content_type', kw_only=True, fn=None), R"
    "eprPlan.Field(name='checksum_algorithm', kw_only=True, fn=None), ReprPlan.Field(name='checksum_crc32', kw_only=Tru"
    "e, fn=None), ReprPlan.Field(name='checksum_crc32c', kw_only=True, fn=None), ReprPlan.Field(name='checksum_crc64_nv"
    "me', kw_only=True, fn=None), ReprPlan.Field(name='checksum_sha1', kw_only=True, fn=None), ReprPlan.Field(name='che"
    "cksum_sha256', kw_only=True, fn=None), ReprPlan.Field(name='expires', kw_only=True, fn=None), ReprPlan.Field(name="
    "'if_match', kw_only=True, fn=None), ReprPlan.Field(name='if_none_match', kw_only=True, fn=None), ReprPlan.Field(na"
    "me='grant_full_control', kw_only=True, fn=None), ReprPlan.Field(name='grant_read', kw_only=True, fn=None), ReprPla"
    "n.Field(name='grant_read_acp', kw_only=True, fn=None), ReprPlan.Field(name='grant_write_acp', kw_only=True, fn=Non"
    "e), ReprPlan.Field(name='key', kw_only=True, fn=None), ReprPlan.Field(name='write_offset_bytes', kw_only=True, fn="
    "None), ReprPlan.Field(name='metadata', kw_only=True, fn=None), ReprPlan.Field(name='server_side_encryption', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='storage_class', kw_only=True, fn=None), ReprPlan.Field(name='website_redir"
    "ect_location', kw_only=True, fn=None), ReprPlan.Field(name='sse_customer_algorithm', kw_only=True, fn=None), ReprP"
    "lan.Field(name='sse_customer_key', kw_only=True, fn=None), ReprPlan.Field(name='sse_customer_key_md5', kw_only=Tru"
    "e, fn=None), ReprPlan.Field(name='sse_kms_key_id', kw_only=True, fn=None), ReprPlan.Field(name='sse_kms_encryption"
    "_context', kw_only=True, fn=None), ReprPlan.Field(name='bucket_key_enabled', kw_only=True, fn=None), ReprPlan.Fiel"
    "d(name='request_payer', kw_only=True, fn=None), ReprPlan.Field(name='tagging', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='object_lock_mode', kw_only=True, fn=None), ReprPlan.Field(name='object_lock_retain_until_date', kw_only="
    "True, fn=None), ReprPlan.Field(name='object_lock_legal_hold_status', kw_only=True, fn=None), ReprPlan.Field(name='"
    "expected_bucket_owner', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fPutObjectRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__21__annotation,
    __dataclass__init__fields__21__default,
    __dataclass__init__fields__22__annotation,
    __dataclass__init__fields__22__default,
    __dataclass__init__fields__23__annotation,
    __dataclass__init__fields__23__default,
    __dataclass__init__fields__24__annotation,
    __dataclass__init__fields__25__annotation,
    __dataclass__init__fields__25__default,
    __dataclass__init__fields__26__annotation,
    __dataclass__init__fields__26__default,
    __dataclass__init__fields__27__annotation,
    __dataclass__init__fields__27__default,
    __dataclass__init__fields__28__annotation,
    __dataclass__init__fields__28__default,
    __dataclass__init__fields__29__annotation,
    __dataclass__init__fields__29__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__30__annotation,
    __dataclass__init__fields__30__default,
    __dataclass__init__fields__31__annotation,
    __dataclass__init__fields__31__default,
    __dataclass__init__fields__32__annotation,
    __dataclass__init__fields__32__default,
    __dataclass__init__fields__33__annotation,
    __dataclass__init__fields__33__default,
    __dataclass__init__fields__34__annotation,
    __dataclass__init__fields__34__default,
    __dataclass__init__fields__35__annotation,
    __dataclass__init__fields__35__default,
    __dataclass__init__fields__36__annotation,
    __dataclass__init__fields__36__default,
    __dataclass__init__fields__37__annotation,
    __dataclass__init__fields__37__default,
    __dataclass__init__fields__38__annotation,
    __dataclass__init__fields__38__default,
    __dataclass__init__fields__39__annotation,
    __dataclass__init__fields__39__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__40__annotation,
    __dataclass__init__fields__40__default,
    __dataclass__init__fields__41__annotation,
    __dataclass__init__fields__41__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            acl=self.acl,
            body=self.body,
            bucket=self.bucket,
            cache_control=self.cache_control,
            content_disposition=self.content_disposition,
            content_encoding=self.content_encoding,
            content_language=self.content_language,
            content_length=self.content_length,
            content_md5=self.content_md5,
            content_type=self.content_type,
            checksum_algorithm=self.checksum_algorithm,
            checksum_crc32=self.checksum_crc32,
            checksum_crc32c=self.checksum_crc32c,
            checksum_crc64_nvme=self.checksum_crc64_nvme,
            checksum_sha1=self.checksum_sha1,
            checksum_sha256=self.checksum_sha256,
            expires=self.expires,
            if_match=self.if_match,
            if_none_match=self.if_none_match,
            grant_full_control=self.grant_full_control,
            grant_read=self.grant_read,
            grant_read_acp=self.grant_read_acp,
            grant_write_acp=self.grant_write_acp,
            key=self.key,
            write_offset_bytes=self.write_offset_bytes,
            metadata=self.metadata,
            server_side_encryption=self.server_side_encryption,
            storage_class=self.storage_class,
            website_redirect_location=self.website_redirect_location,
            sse_customer_algorithm=self.sse_customer_algorithm,
            sse_customer_key=self.sse_customer_key,
            sse_customer_key_md5=self.sse_customer_key_md5,
            sse_kms_key_id=self.sse_kms_key_id,
            sse_kms_encryption_context=self.sse_kms_encryption_context,
            bucket_key_enabled=self.bucket_key_enabled,
            request_payer=self.request_payer,
            tagging=self.tagging,
            object_lock_mode=self.object_lock_mode,
            object_lock_retain_until_date=self.object_lock_retain_until_date,
            object_lock_legal_hold_status=self.object_lock_legal_hold_status,
            expected_bucket_owner=self.expected_bucket_owner,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.acl == other.acl and
            self.body == other.body and
            self.bucket == other.bucket and
            self.cache_control == other.cache_control and
            self.content_disposition == other.content_disposition and
            self.content_encoding == other.content_encoding and
            self.content_language == other.content_language and
            self.content_length == other.content_length and
            self.content_md5 == other.content_md5 and
            self.content_type == other.content_type and
            self.checksum_algorithm == other.checksum_algorithm and
            self.checksum_crc32 == other.checksum_crc32 and
            self.checksum_crc32c == other.checksum_crc32c and
            self.checksum_crc64_nvme == other.checksum_crc64_nvme and
            self.checksum_sha1 == other.checksum_sha1 and
            self.checksum_sha256 == other.checksum_sha256 and
            self.expires == other.expires and
            self.if_match == other.if_match and
            self.if_none_match == other.if_none_match and
            self.grant_full_control == other.grant_full_control and
            self.grant_read == other.grant_read and
            self.grant_read_acp == other.grant_read_acp and
            self.grant_write_acp == other.grant_write_acp and
            self.key == other.key and
            self.write_offset_bytes == other.write_offset_bytes and
            self.metadata == other.metadata and
            self.server_side_encryption == other.server_side_encryption and
            self.storage_class == other.storage_class and
            self.website_redirect_location == other.website_redirect_location and
            self.sse_customer_algorithm == other.sse_customer_algorithm and
            self.sse_customer_key == other.sse_customer_key and
            self.sse_customer_key_md5 == other.sse_customer_key_md5 and
            self.sse_kms_key_id == other.sse_kms_key_id and
            self.sse_kms_encryption_context == other.sse_kms_encryption_context and
            self.bucket_key_enabled == other.bucket_key_enabled and
            self.request_payer == other.request_payer and
            self.tagging == other.tagging and
            self.object_lock_mode == other.object_lock_mode and
            self.object_lock_retain_until_date == other.object_lock_retain_until_date and
            self.object_lock_legal_hold_status == other.object_lock_legal_hold_status and
            self.expected_bucket_owner == other.expected_bucket_owner
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'acl',
        'body',
        'bucket',
        'cache_control',
        'content_disposition',
        'content_encoding',
        'content_language',
        'content_length',
        'content_md5',
        'content_type',
        'checksum_algorithm',
        'checksum_crc32',
        'checksum_crc32c',
        'checksum_crc64_nvme',
        'checksum_sha1',
        'checksum_sha256',
        'expires',
        'if_match',
        'if_none_match',
        'grant_full_control',
        'grant_read',
        'grant_read_acp',
        'grant_write_acp',
        'key',
        'write_offset_bytes',
        'metadata',
        'server_side_encryption',
        'storage_class',
        'website_redirect_location',
        'sse_customer_algorithm',
        'sse_customer_key',
        'sse_customer_key_md5',
        'sse_kms_key_id',
        'sse_kms_encryption_context',
        'bucket_key_enabled',
        'request_payer',
        'tagging',
        'object_lock_mode',
        'object_lock_retain_until_date',
        'object_lock_legal_hold_status',
        'expected_bucket_owner',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'acl',
        'body',
        'bucket',
        'cache_control',
        'content_disposition',
        'content_encoding',
        'content_language',
        'content_length',
        'content_md5',
        'content_type',
        'checksum_algorithm',
        'checksum_crc32',
        'checksum_crc32c',
        'checksum_crc64_nvme',
        'checksum_sha1',
        'checksum_sha256',
        'expires',
        'if_match',
        'if_none_match',
        'grant_full_control',
        'grant_read',
        'grant_read_acp',
        'grant_write_acp',
        'key',
        'write_offset_bytes',
        'metadata',
        'server_side_encryption',
        'storage_class',
        'website_redirect_location',
        'sse_customer_algorithm',
        'sse_customer_key',
        'sse_customer_key_md5',
        'sse_kms_key_id',
        'sse_kms_encryption_context',
        'bucket_key_enabled',
        'request_payer',
        'tagging',
        'object_lock_mode',
        'object_lock_retain_until_date',
        'object_lock_legal_hold_status',
        'expected_bucket_owner',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.acl,
            self.body,
            self.bucket,
            self.cache_control,
            self.content_disposition,
            self.content_encoding,
            self.content_language,
            self.content_length,
            self.content_md5,
            self.content_type,
            self.checksum_algorithm,
            self.checksum_crc32,
            self.checksum_crc32c,
            self.checksum_crc64_nvme,
            self.checksum_sha1,
            self.checksum_sha256,
            self.expires,
            self.if_match,
            self.if_none_match,
            self.grant_full_control,
            self.grant_read,
            self.grant_read_acp,
            self.grant_write_acp,
            self.key,
            self.write_offset_bytes,
            self.metadata,
            self.server_side_encryption,
            self.storage_class,
            self.website_redirect_location,
            self.sse_customer_algorithm,
            self.sse_customer_key,
            self.sse_customer_key_md5,
            self.sse_kms_key_id,
            self.sse_kms_encryption_context,
            self.bucket_key_enabled,
            self.request_payer,
            self.tagging,
            self.object_lock_mode,
            self.object_lock_retain_until_date,
            self.object_lock_legal_hold_status,
            self.expected_bucket_owner,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        acl: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        body: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        bucket: __dataclass__init__fields__3__annotation,
        cache_control: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        content_disposition: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        content_encoding: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        content_language: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        content_length: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        content_md5: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        content_type: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        checksum_algorithm: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        checksum_crc32: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        checksum_crc32c: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        checksum_crc64_nvme: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        checksum_sha1: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        checksum_sha256: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        expires: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        if_match: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        if_none_match: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        grant_full_control: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        grant_read: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
        grant_read_acp: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
        grant_write_acp: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
        key: __dataclass__init__fields__24__annotation,
        write_offset_bytes: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
        metadata: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
        server_side_encryption: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
        storage_class: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
        website_redirect_location: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
        sse_customer_algorithm: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
        sse_customer_key: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
        sse_customer_key_md5: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
        sse_kms_key_id: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
        sse_kms_encryption_context: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
        bucket_key_enabled: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
        request_payer: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
        tagging: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
        object_lock_mode: __dataclass__init__fields__38__annotation = __dataclass__init__fields__38__default,
        object_lock_retain_until_date: __dataclass__init__fields__39__annotation = __dataclass__init__fields__39__default,
        object_lock_legal_hold_status: __dataclass__init__fields__40__annotation = __dataclass__init__fields__40__default,
        expected_bucket_owner: __dataclass__init__fields__41__annotation = __dataclass__init__fields__41__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'acl', acl)
        __dataclass__object_setattr(self, 'body', body)
        __dataclass__object_setattr(self, 'bucket', bucket)
        __dataclass__object_setattr(self, 'cache_control', cache_control)
        __dataclass__object_setattr(self, 'content_disposition', content_disposition)
        __dataclass__object_setattr(self, 'content_encoding', content_encoding)
        __dataclass__object_setattr(self, 'content_language', content_language)
        __dataclass__object_setattr(self, 'content_length', content_length)
        __dataclass__object_setattr(self, 'content_md5', content_md5)
        __dataclass__object_setattr(self, 'content_type', content_type)
        __dataclass__object_setattr(self, 'checksum_algorithm', checksum_algorithm)
        __dataclass__object_setattr(self, 'checksum_crc32', checksum_crc32)
        __dataclass__object_setattr(self, 'checksum_crc32c', checksum_crc32c)
        __dataclass__object_setattr(self, 'checksum_crc64_nvme', checksum_crc64_nvme)
        __dataclass__object_setattr(self, 'checksum_sha1', checksum_sha1)
        __dataclass__object_setattr(self, 'checksum_sha256', checksum_sha256)
        __dataclass__object_setattr(self, 'expires', expires)
        __dataclass__object_setattr(self, 'if_match', if_match)
        __dataclass__object_setattr(self, 'if_none_match', if_none_match)
        __dataclass__object_setattr(self, 'grant_full_control', grant_full_control)
        __dataclass__object_setattr(self, 'grant_read', grant_read)
        __dataclass__object_setattr(self, 'grant_read_acp', grant_read_acp)
        __dataclass__object_setattr(self, 'grant_write_acp', grant_write_acp)
        __dataclass__object_setattr(self, 'key', key)
        __dataclass__object_setattr(self, 'write_offset_bytes', write_offset_bytes)
        __dataclass__object_setattr(self, 'metadata', metadata)
        __dataclass__object_setattr(self, 'server_side_encryption', server_side_encryption)
        __dataclass__object_setattr(self, 'storage_class', storage_class)
        __dataclass__object_setattr(self, 'website_redirect_location', website_redirect_location)
        __dataclass__object_setattr(self, 'sse_customer_algorithm', sse_customer_algorithm)
        __dataclass__object_setattr(self, 'sse_customer_key', sse_customer_key)
        __dataclass__object_setattr(self, 'sse_customer_key_md5', sse_customer_key_md5)
        __dataclass__object_setattr(self, 'sse_kms_key_id', sse_kms_key_id)
        __dataclass__object_setattr(self, 'sse_kms_encryption_context', sse_kms_encryption_context)
        __dataclass__object_setattr(self, 'bucket_key_enabled', bucket_key_enabled)
        __dataclass__object_setattr(self, 'request_payer', request_payer)
        __dataclass__object_setattr(self, 'tagging', tagging)
        __dataclass__object_setattr(self, 'object_lock_mode', object_lock_mode)
        __dataclass__object_setattr(self, 'object_lock_retain_until_date', object_lock_retain_until_date)
        __dataclass__object_setattr(self, 'object_lock_legal_hold_status', object_lock_legal_hold_status)
        __dataclass__object_setattr(self, 'expected_bucket_owner', expected_bucket_owner)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"acl={self.acl!r}")
        parts.append(f"body={self.body!r}")
        parts.append(f"bucket={self.bucket!r}")
        parts.append(f"cache_control={self.cache_control!r}")
        parts.append(f"content_disposition={self.content_disposition!r}")
        parts.append(f"content_encoding={self.content_encoding!r}")
        parts.append(f"content_language={self.content_language!r}")
        parts.append(f"content_length={self.content_length!r}")
        parts.append(f"content_md5={self.content_md5!r}")
        parts.append(f"content_type={self.content_type!r}")
        parts.append(f"checksum_algorithm={self.checksum_algorithm!r}")
        parts.append(f"checksum_crc32={self.checksum_crc32!r}")
        parts.append(f"checksum_crc32c={self.checksum_crc32c!r}")
        parts.append(f"checksum_crc64_nvme={self.checksum_crc64_nvme!r}")
        parts.append(f"checksum_sha1={self.checksum_sha1!r}")
        parts.append(f"checksum_sha256={self.checksum_sha256!r}")
        parts.append(f"expires={self.expires!r}")
        parts.append(f"if_match={self.if_match!r}")
        parts.append(f"if_none_match={self.if_none_match!r}")
        parts.append(f"grant_full_control={self.grant_full_control!r}")
        parts.append(f"grant_read={self.grant_read!r}")
        parts.append(f"grant_read_acp={self.grant_read_acp!r}")
        parts.append(f"grant_write_acp={self.grant_write_acp!r}")
        parts.append(f"key={self.key!r}")
        parts.append(f"write_offset_bytes={self.write_offset_bytes!r}")
        parts.append(f"metadata={self.metadata!r}")
        parts.append(f"server_side_encryption={self.server_side_encryption!r}")
        parts.append(f"storage_class={self.storage_class!r}")
        parts.append(f"website_redirect_location={self.website_redirect_location!r}")
        parts.append(f"sse_customer_algorithm={self.sse_customer_algorithm!r}")
        parts.append(f"sse_customer_key={self.sse_customer_key!r}")
        parts.append(f"sse_customer_key_md5={self.sse_customer_key_md5!r}")
        parts.append(f"sse_kms_key_id={self.sse_kms_key_id!r}")
        parts.append(f"sse_kms_encryption_context={self.sse_kms_encryption_context!r}")
        parts.append(f"bucket_key_enabled={self.bucket_key_enabled!r}")
        parts.append(f"request_payer={self.request_payer!r}")
        parts.append(f"tagging={self.tagging!r}")
        parts.append(f"object_lock_mode={self.object_lock_mode!r}")
        parts.append(f"object_lock_retain_until_date={self.object_lock_retain_until_date!r}")
        parts.append(f"object_lock_legal_hold_status={self.object_lock_legal_hold_status!r}")
        parts.append(f"expected_bucket_owner={self.expected_bucket_owner!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('buckets', 'owner', 'continuation_token', 'prefix')), EqPlan(fields=('buckets', 'owner"
    "', 'continuation_token', 'prefix')), FrozenPlan(fields=('__shape__', 'buckets', 'owner', 'continuation_token', 'pr"
    "efix'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('buckets', 'owner', 'continuation_token'"
    ", 'prefix'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0."
    "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='buckets', annotation=OpRef(name='init.fields.1.annot"
    "ation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type="
    "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='owner', annotation=OpRef(na"
    "me='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cont"
    "inuation_token', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None), InitPlan.Field(name='prefix', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='in"
    "it.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
    ", validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('buckets', 'owner', 'continu"
    "ation_token', 'prefix'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan("
    "fields=(ReprPlan.Field(name='buckets', kw_only=True, fn=None), ReprPlan.Field(name='owner', kw_only=True, fn=None)"
    ", ReprPlan.Field(name='continuation_token', kw_only=True, fn=None), ReprPlan.Field(name='prefix', kw_only=True, fn"
    "=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fListBucketsOutput(
    *,
    __dataclass__cls,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            buckets=self.buckets,
            owner=self.owner,
            continuation_token=self.continuation_token,
            prefix=self.prefix,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.buckets == other.buckets and
            self.owner == other.owner and
            self.continuation_token == other.continuation_token and
            self.prefix == other.prefix
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'buckets',
        'owner',
        'continuation_token',
        'prefix',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'buckets',
        'owner',
        'continuation_token',
        'prefix',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.buckets,
            self.owner,
            self.continuation_token,
            self.prefix,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        buckets: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        owner: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        continuation_token: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        prefix: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'buckets', buckets)
        __dataclass__object_setattr(self, 'owner', owner)
        __dataclass__object_setattr(self, 'continuation_token', continuation_token)
        __dataclass__object_setattr(self, 'prefix', prefix)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"buckets={self.buckets!r}")
        parts.append(f"owner={self.owner!r}")
        parts.append(f"continuation_token={self.continuation_token!r}")
        parts.append(f"prefix={self.prefix!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('is_truncated', 'contents', 'name', 'prefix', 'delimiter', 'max_keys', 'common_prefixe"
    "s', 'encoding_type', 'key_count', 'continuation_token', 'next_continuation_token', 'start_after', 'request_charged"
    "')), EqPlan(fields=('is_truncated', 'contents', 'name', 'prefix', 'delimiter', 'max_keys', 'common_prefixes', 'enc"
    "oding_type', 'key_count', 'continuation_token', 'next_continuation_token', 'start_after', 'request_charged')), Fro"
    "zenPlan(fields=('__shape__', 'is_truncated', 'contents', 'name', 'prefix', 'delimiter', 'max_keys', 'common_prefix"
    "es', 'encoding_type', 'key_count', 'continuation_token', 'next_continuation_token', 'start_after', 'request_charge"
    "d'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('is_truncated', 'contents', 'name', 'prefix"
    "', 'delimiter', 'max_keys', 'common_prefixes', 'encoding_type', 'key_count', 'continuation_token', 'next_continuat"
    "ion_token', 'start_after', 'request_charged'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', ann"
    "otation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='is_truncated', ann"
    "otation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None,"
    " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
    "Field(name='contents', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defaul"
    "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name"
    "='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='prefix', annotation=OpRef(name='init.fields.4.annotati"
    "on'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='delimiter', annotation=OpRef(n"
    "ame='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max"
    "_keys', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='common_prefixes', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='in"
    "it.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
    ", validate=None, check_type=None), InitPlan.Field(name='encoding_type', annotation=OpRef(name='init.fields.8.annot"
    "ation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type="
    "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='key_count', annotation=OpRe"
    "f(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "continuation_token', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.defaul"
    "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='next_continuation_token', annotation=OpRef(name='init.fields.11.annotation')"
    ", default=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='start_after', annotation=OpRef(na"
    "me='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True, ov"
    "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='re"
    "quest_charged', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13.default'), "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None)), self_param='self', std_params=(), kw_only_params=('is_truncated', 'contents', 'name', 'prefix', 'deli"
    "miter', 'max_keys', 'common_prefixes', 'encoding_type', 'key_count', 'continuation_token', 'next_continuation_toke"
    "n', 'start_after', 'request_charged'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns="
    "()), ReprPlan(fields=(ReprPlan.Field(name='is_truncated', kw_only=True, fn=None), ReprPlan.Field(name='contents', "
    "kw_only=True, fn=None), ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='prefix', kw_only="
    "True, fn=None), ReprPlan.Field(name='delimiter', kw_only=True, fn=None), ReprPlan.Field(name='max_keys', kw_only=T"
    "rue, fn=None), ReprPlan.Field(name='common_prefixes', kw_only=True, fn=None), ReprPlan.Field(name='encoding_type',"
    " kw_only=True, fn=None), ReprPlan.Field(name='key_count', kw_only=True, fn=None), ReprPlan.Field(name='continuatio"
    "n_token', kw_only=True, fn=None), ReprPlan.Field(name='next_continuation_token', kw_only=True, fn=None), ReprPlan."
    "Field(name='start_after', kw_only=True, fn=None), ReprPlan.Field(name='request_charged', kw_only=True, fn=None)), "
    "id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ominfra_2fclouds_2faws_2fmodels_2fservices_2fs3_2fListObjectsV2Output(
    *,
    __dataclass__cls,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            is_truncated=self.is_truncated,
            contents=self.contents,
            name=self.name,
            prefix=self.prefix,
            delimiter=self.delimiter,
            max_keys=self.max_keys,
            common_prefixes=self.common_prefixes,
            encoding_type=self.encoding_type,
            key_count=self.key_count,
            continuation_token=self.continuation_token,
            next_continuation_token=self.next_continuation_token,
            start_after=self.start_after,
            request_charged=self.request_charged,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.is_truncated == other.is_truncated and
            self.contents == other.contents and
            self.name == other.name and
            self.prefix == other.prefix and
            self.delimiter == other.delimiter and
            self.max_keys == other.max_keys and
            self.common_prefixes == other.common_prefixes and
            self.encoding_type == other.encoding_type and
            self.key_count == other.key_count and
            self.continuation_token == other.continuation_token and
            self.next_continuation_token == other.next_continuation_token and
            self.start_after == other.start_after and
            self.request_charged == other.request_charged
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '__shape__',
        'is_truncated',
        'contents',
        'name',
        'prefix',
        'delimiter',
        'max_keys',
        'common_prefixes',
        'encoding_type',
        'key_count',
        'continuation_token',
        'next_continuation_token',
        'start_after',
        'request_charged',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '__shape__',
        'is_truncated',
        'contents',
        'name',
        'prefix',
        'delimiter',
        'max_keys',
        'common_prefixes',
        'encoding_type',
        'key_count',
        'continuation_token',
        'next_continuation_token',
        'start_after',
        'request_charged',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.is_truncated,
            self.contents,
            self.name,
            self.prefix,
            self.delimiter,
            self.max_keys,
            self.common_prefixes,
            self.encoding_type,
            self.key_count,
            self.continuation_token,
            self.next_continuation_token,
            self.start_after,
            self.request_charged,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        is_truncated: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        contents: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        name: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        prefix: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        delimiter: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        max_keys: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        common_prefixes: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        encoding_type: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        key_count: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        continuation_token: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        next_continuation_token: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        start_after: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        request_charged: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'is_truncated', is_truncated)
        __dataclass__object_setattr(self, 'contents', contents)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'prefix', prefix)
        __dataclass__object_setattr(self, 'delimiter', delimiter)
        __dataclass__object_setattr(self, 'max_keys', max_keys)
        __dataclass__object_setattr(self, 'common_prefixes', common_prefixes)
        __dataclass__object_setattr(self, 'encoding_type', encoding_type)
        __dataclass__object_setattr(self, 'key_count', key_count)
        __dataclass__object_setattr(self, 'continuation_token', continuation_token)
        __dataclass__object_setattr(self, 'next_continuation_token', next_continuation_token)
        __dataclass__object_setattr(self, 'start_after', start_after)
        __dataclass__object_setattr(self, 'request_charged', request_charged)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"is_truncated={self.is_truncated!r}")
        parts.append(f"contents={self.contents!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"prefix={self.prefix!r}")
        parts.append(f"delimiter={self.delimiter!r}")
        parts.append(f"max_keys={self.max_keys!r}")
        parts.append(f"common_prefixes={self.common_prefixes!r}")
        parts.append(f"encoding_type={self.encoding_type!r}")
        parts.append(f"key_count={self.key_count!r}")
        parts.append(f"continuation_token={self.continuation_token!r}")
        parts.append(f"next_continuation_token={self.next_continuation_token!r}")
        parts.append(f"start_after={self.start_after!r}")
        parts.append(f"request_charged={self.request_charged!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)
