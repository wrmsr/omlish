# @omlish-generated
# type: ignore
# ruff: noqa
# flake8: noqa
import dataclasses
import reprlib
import types


##


REGISTRY = {}


def _register(**kwargs):
    def inner(fn):
        REGISTRY[kwargs['plan_repr']] = (kwargs, fn)
        return fn
    return inner


##


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('allocation_id', 'association_id', 'domain', 'network_interface_id', 'network_inte"
        "rface_owner_id', 'private_ip_address', 'tags', 'public_ipv4_pool', 'network_border_group', 'customer_owned_ip'"
        ", 'customer_owned_ipv4_pool', 'carrier_ip', 'subnet_id', 'service_managed', 'instance_id', 'public_ip')), EqPl"
        "an(fields=('allocation_id', 'association_id', 'domain', 'network_interface_id', 'network_interface_owner_id', "
        "'private_ip_address', 'tags', 'public_ipv4_pool', 'network_border_group', 'customer_owned_ip', 'customer_owned"
        "_ipv4_pool', 'carrier_ip', 'subnet_id', 'service_managed', 'instance_id', 'public_ip')), FrozenPlan(fields=('_"
        "_shape__', 'allocation_id', 'association_id', 'domain', 'network_interface_id', 'network_interface_owner_id', "
        "'private_ip_address', 'tags', 'public_ipv4_pool', 'network_border_group', 'customer_owned_ip', 'customer_owned"
        "_ipv4_pool', 'carrier_ip', 'subnet_id', 'service_managed', 'instance_id', 'public_ip'), allow_dynamic_dunder_a"
        "ttrs=False), HashPlan(action='add', fields=('allocation_id', 'association_id', 'domain', 'network_interface_id"
        "', 'network_interface_owner_id', 'private_ip_address', 'tags', 'public_ipv4_pool', 'network_border_group', 'cu"
        "stomer_owned_ip', 'customer_owned_ipv4_pool', 'carrier_ip', 'subnet_id', 'service_managed', 'instance_id', 'pu"
        "blic_ip'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields."
        "0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR,"
        " coerce=None, validate=None, check_type=None), InitPlan.Field(name='allocation_id', annotation=OpRef(name='ini"
        "t.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ass"
        "ociation_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), "
        "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
        "eck_type=None), InitPlan.Field(name='domain', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef"
        "(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_interface_id', annotation=OpRef(n"
        "ame='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='network_interface_owner_id', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init."
        "fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
        "e, validate=None, check_type=None), InitPlan.Field(name='private_ip_address', annotation=OpRef(name='init.fiel"
        "ds.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags', an"
        "notation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory="
        "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
        "InitPlan.Field(name='public_ipv4_pool', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name="
        "'init.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None), InitPlan.Field(name='network_border_group', annotation=OpRef(name='i"
        "nit.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='c"
        "ustomer_owned_ip', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.defa"
        "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
        "one, check_type=None), InitPlan.Field(name='customer_owned_ipv4_pool', annotation=OpRef(name='init.fields.11.a"
        "nnotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='carrier_ip', a"
        "nnotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_facto"
        "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
        "), InitPlan.Field(name='subnet_id', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='in"
        "it.fields.13.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='service_managed', annotation=OpRef(name='init.fie"
        "lds.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=F"
        "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instan"
        "ce_id', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='public_ip', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef"
        "(name='init.fields.16.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
        "E, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('allocatio"
        "n_id', 'association_id', 'domain', 'network_interface_id', 'network_interface_owner_id', 'private_ip_address',"
        " 'tags', 'public_ipv4_pool', 'network_border_group', 'customer_owned_ip', 'customer_owned_ipv4_pool', 'carrier"
        "_ip', 'subnet_id', 'service_managed', 'instance_id', 'public_ip'), frozen=True, slots=False, post_init_params="
        "None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='allocation_id', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='association_id', kw_only=True, fn=None), ReprPlan.Field(name='domain', kw_only=True,"
        " fn=None), ReprPlan.Field(name='network_interface_id', kw_only=True, fn=None), ReprPlan.Field(name='network_in"
        "terface_owner_id', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_address', kw_only=True, fn=None), R"
        "eprPlan.Field(name='tags', kw_only=True, fn=None), ReprPlan.Field(name='public_ipv4_pool', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='network_border_group', kw_only=True, fn=None), ReprPlan.Field(name='customer_owned_i"
        "p', kw_only=True, fn=None), ReprPlan.Field(name='customer_owned_ipv4_pool', kw_only=True, fn=None), ReprPlan.F"
        "ield(name='carrier_ip', kw_only=True, fn=None), ReprPlan.Field(name='subnet_id', kw_only=True, fn=None), ReprP"
        "lan.Field(name='service_managed', kw_only=True, fn=None), ReprPlan.Field(name='instance_id', kw_only=True, fn="
        "None), ReprPlan.Field(name='public_ip', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='db1126f8ac107695f46b0eb4548009951a2add6f',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Address'),
    ),
)
def _process_dataclass__db1126f8ac107695f46b0eb4548009951a2add6f():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                allocation_id=self.allocation_id,
                association_id=self.association_id,
                domain=self.domain,
                network_interface_id=self.network_interface_id,
                network_interface_owner_id=self.network_interface_owner_id,
                private_ip_address=self.private_ip_address,
                tags=self.tags,
                public_ipv4_pool=self.public_ipv4_pool,
                network_border_group=self.network_border_group,
                customer_owned_ip=self.customer_owned_ip,
                customer_owned_ipv4_pool=self.customer_owned_ipv4_pool,
                carrier_ip=self.carrier_ip,
                subnet_id=self.subnet_id,
                service_managed=self.service_managed,
                instance_id=self.instance_id,
                public_ip=self.public_ip,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.allocation_id == other.allocation_id and
                self.association_id == other.association_id and
                self.domain == other.domain and
                self.network_interface_id == other.network_interface_id and
                self.network_interface_owner_id == other.network_interface_owner_id and
                self.private_ip_address == other.private_ip_address and
                self.tags == other.tags and
                self.public_ipv4_pool == other.public_ipv4_pool and
                self.network_border_group == other.network_border_group and
                self.customer_owned_ip == other.customer_owned_ip and
                self.customer_owned_ipv4_pool == other.customer_owned_ipv4_pool and
                self.carrier_ip == other.carrier_ip and
                self.subnet_id == other.subnet_id and
                self.service_managed == other.service_managed and
                self.instance_id == other.instance_id and
                self.public_ip == other.public_ip
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'allocation_id',
            'association_id',
            'domain',
            'network_interface_id',
            'network_interface_owner_id',
            'private_ip_address',
            'tags',
            'public_ipv4_pool',
            'network_border_group',
            'customer_owned_ip',
            'customer_owned_ipv4_pool',
            'carrier_ip',
            'subnet_id',
            'service_managed',
            'instance_id',
            'public_ip',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'allocation_id',
            'association_id',
            'domain',
            'network_interface_id',
            'network_interface_owner_id',
            'private_ip_address',
            'tags',
            'public_ipv4_pool',
            'network_border_group',
            'customer_owned_ip',
            'customer_owned_ipv4_pool',
            'carrier_ip',
            'subnet_id',
            'service_managed',
            'instance_id',
            'public_ip',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.allocation_id,
                self.association_id,
                self.domain,
                self.network_interface_id,
                self.network_interface_owner_id,
                self.private_ip_address,
                self.tags,
                self.public_ipv4_pool,
                self.network_border_group,
                self.customer_owned_ip,
                self.customer_owned_ipv4_pool,
                self.carrier_ip,
                self.subnet_id,
                self.service_managed,
                self.instance_id,
                self.public_ip,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            allocation_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            association_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            domain: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            network_interface_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            network_interface_owner_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            private_ip_address: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            tags: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            public_ipv4_pool: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            network_border_group: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            customer_owned_ip: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            customer_owned_ipv4_pool: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            carrier_ip: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            subnet_id: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            service_managed: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            instance_id: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            public_ip: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'allocation_id', allocation_id)
            __dataclass__object_setattr(self, 'association_id', association_id)
            __dataclass__object_setattr(self, 'domain', domain)
            __dataclass__object_setattr(self, 'network_interface_id', network_interface_id)
            __dataclass__object_setattr(self, 'network_interface_owner_id', network_interface_owner_id)
            __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'public_ipv4_pool', public_ipv4_pool)
            __dataclass__object_setattr(self, 'network_border_group', network_border_group)
            __dataclass__object_setattr(self, 'customer_owned_ip', customer_owned_ip)
            __dataclass__object_setattr(self, 'customer_owned_ipv4_pool', customer_owned_ipv4_pool)
            __dataclass__object_setattr(self, 'carrier_ip', carrier_ip)
            __dataclass__object_setattr(self, 'subnet_id', subnet_id)
            __dataclass__object_setattr(self, 'service_managed', service_managed)
            __dataclass__object_setattr(self, 'instance_id', instance_id)
            __dataclass__object_setattr(self, 'public_ip', public_ip)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"allocation_id={self.allocation_id!r}")
            parts.append(f"association_id={self.association_id!r}")
            parts.append(f"domain={self.domain!r}")
            parts.append(f"network_interface_id={self.network_interface_id!r}")
            parts.append(f"network_interface_owner_id={self.network_interface_owner_id!r}")
            parts.append(f"private_ip_address={self.private_ip_address!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"public_ipv4_pool={self.public_ipv4_pool!r}")
            parts.append(f"network_border_group={self.network_border_group!r}")
            parts.append(f"customer_owned_ip={self.customer_owned_ip!r}")
            parts.append(f"customer_owned_ipv4_pool={self.customer_owned_ipv4_pool!r}")
            parts.append(f"carrier_ip={self.carrier_ip!r}")
            parts.append(f"subnet_id={self.subnet_id!r}")
            parts.append(f"service_managed={self.service_managed!r}")
            parts.append(f"instance_id={self.instance_id!r}")
            parts.append(f"public_ip={self.public_ip!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ena_srd_enabled', 'ena_srd_udp_specification')), EqPlan(fields=('ena_srd_enabled'"
        ", 'ena_srd_udp_specification')), FrozenPlan(fields=('__shape__', 'ena_srd_enabled', 'ena_srd_udp_specification"
        "'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ena_srd_enabled', 'ena_srd_udp_specific"
        "ation'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0."
        "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, c"
        "oerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_srd_enabled', annotation=OpRef(name='ini"
        "t.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena"
        "_srd_udp_specification', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('ena_srd_enabled', 'ena_srd_udp_"
        "specification'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fiel"
        "ds=(ReprPlan.Field(name='ena_srd_enabled', kw_only=True, fn=None), ReprPlan.Field(name='ena_srd_udp_specificat"
        "ion', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='665dc09fab514fa0dfe68075b016a3e79a47a7ad',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'AttachmentEnaSrdSpecification'),
        ('ominfra.clouds.aws.models.services.ec2', 'EnaSrdSpecificationRequest'),
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceAttachmentEnaSrdSpecification'),
    ),
)
def _process_dataclass__665dc09fab514fa0dfe68075b016a3e79a47a7ad():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ena_srd_enabled=self.ena_srd_enabled,
                ena_srd_udp_specification=self.ena_srd_udp_specification,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ena_srd_enabled == other.ena_srd_enabled and
                self.ena_srd_udp_specification == other.ena_srd_udp_specification
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ena_srd_enabled',
            'ena_srd_udp_specification',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ena_srd_enabled',
            'ena_srd_udp_specification',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ena_srd_enabled,
                self.ena_srd_udp_specification,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ena_srd_enabled: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            ena_srd_udp_specification: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ena_srd_enabled', ena_srd_enabled)
            __dataclass__object_setattr(self, 'ena_srd_udp_specification', ena_srd_udp_specification)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ena_srd_enabled={self.ena_srd_enabled!r}")
            parts.append(f"ena_srd_udp_specification={self.ena_srd_udp_specification!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ena_srd_udp_enabled',)), EqPlan(fields=('ena_srd_udp_enabled',)), FrozenPlan(fiel"
        "ds=('__shape__', 'ena_srd_udp_enabled'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('en"
        "a_srd_udp_enabled',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='i"
        "nit.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType"
        ".CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_srd_udp_enabled', annotatio"
        "n=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_p"
        "aram='self', std_params=(), kw_only_params=('ena_srd_udp_enabled',), frozen=True, slots=False, post_init_param"
        "s=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ena_srd_udp_enabled', kw_only=Tru"
        "e, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='5a79dae371ff101fec6f7ecde39b38153b14fcee',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'AttachmentEnaSrdUdpSpecification'),
        ('ominfra.clouds.aws.models.services.ec2', 'EnaSrdUdpSpecificationRequest'),
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceAttachmentEnaSrdUdpSpecification'),
    ),
)
def _process_dataclass__5a79dae371ff101fec6f7ecde39b38153b14fcee():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ena_srd_udp_enabled=self.ena_srd_udp_enabled,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ena_srd_udp_enabled == other.ena_srd_udp_enabled
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ena_srd_udp_enabled',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ena_srd_udp_enabled',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ena_srd_udp_enabled,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ena_srd_udp_enabled: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ena_srd_udp_enabled', ena_srd_udp_enabled)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ena_srd_udp_enabled={self.ena_srd_udp_enabled!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ebs', 'no_device', 'device_name', 'virtual_name')), EqPlan(fields=('ebs', 'no_dev"
        "ice', 'device_name', 'virtual_name')), FrozenPlan(fields=('__shape__', 'ebs', 'no_device', 'device_name', 'vir"
        "tual_name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ebs', 'no_device', 'device_nam"
        "e', 'virtual_name'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='in"
        "it.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType."
        "CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ebs', annotation=OpRef(name='ini"
        "t.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='no_"
        "device', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), defau"
        "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
        "ype=None), InitPlan.Field(name='device_name', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef"
        "(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='virtual_name', annotation=OpRef(name='ini"
        "t.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_"
        "params=(), kw_only_params=('ebs', 'no_device', 'device_name', 'virtual_name'), frozen=True, slots=False, post_"
        "init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ebs', kw_only=True, fn="
        "None), ReprPlan.Field(name='no_device', kw_only=True, fn=None), ReprPlan.Field(name='device_name', kw_only=Tru"
        "e, fn=None), ReprPlan.Field(name='virtual_name', kw_only=True, fn=None)), id=False, terse=False, default_fn=No"
        "ne)))"
    ),
    plan_repr_sha1='694128aac38488f2fdd926dd2d61b92a7e4d2fff',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'BlockDeviceMapping'),
    ),
)
def _process_dataclass__694128aac38488f2fdd926dd2d61b92a7e4d2fff():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ebs=self.ebs,
                no_device=self.no_device,
                device_name=self.device_name,
                virtual_name=self.virtual_name,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ebs == other.ebs and
                self.no_device == other.no_device and
                self.device_name == other.device_name and
                self.virtual_name == other.virtual_name
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ebs',
            'no_device',
            'device_name',
            'virtual_name',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ebs',
            'no_device',
            'device_name',
            'virtual_name',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ebs,
                self.no_device,
                self.device_name,
                self.virtual_name,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ebs: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            no_device: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            device_name: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            virtual_name: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ebs', ebs)
            __dataclass__object_setattr(self, 'no_device', no_device)
            __dataclass__object_setattr(self, 'device_name', device_name)
            __dataclass__object_setattr(self, 'virtual_name', virtual_name)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ebs={self.ebs!r}")
            parts.append(f"no_device={self.no_device!r}")
            parts.append(f"device_name={self.device_name!r}")
            parts.append(f"virtual_name={self.virtual_name!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('internet_gateway_block_mode',)), EqPlan(fields=('internet_gateway_block_mode',)),"
        " FrozenPlan(fields=('__shape__', 'internet_gateway_block_mode'), allow_dynamic_dunder_attrs=False), HashPlan(a"
        "ction='add', fields=('internet_gateway_block_mode',), cache=False), InitPlan(fields=(InitPlan.Field(name='__sh"
        "ape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, over"
        "ride=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
        "'internet_gateway_block_mode', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fie"
        "lds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('internet_gateway_block_mo"
        "de',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPl"
        "an.Field(name='internet_gateway_block_mode', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)"
        "))"
    ),
    plan_repr_sha1='2feec5bda78e1c5735d34c1b7c47c422c88aaffe',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'BlockPublicAccessStates'),
    ),
)
def _process_dataclass__2feec5bda78e1c5735d34c1b7c47c422c88aaffe():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                internet_gateway_block_mode=self.internet_gateway_block_mode,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.internet_gateway_block_mode == other.internet_gateway_block_mode
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'internet_gateway_block_mode',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'internet_gateway_block_mode',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.internet_gateway_block_mode,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            internet_gateway_block_mode: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'internet_gateway_block_mode', internet_gateway_block_mode)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"internet_gateway_block_mode={self.internet_gateway_block_mode!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('capacity_reservation_preference', 'capacity_reservation_target')), EqPlan(fields="
        "('capacity_reservation_preference', 'capacity_reservation_target')), FrozenPlan(fields=('__shape__', 'capacity"
        "_reservation_preference', 'capacity_reservation_target'), allow_dynamic_dunder_attrs=False), HashPlan(action='"
        "add', fields=('capacity_reservation_preference', 'capacity_reservation_target'), cache=False), InitPlan(fields"
        "=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fa"
        "ctory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type="
        "None), InitPlan.Field(name='capacity_reservation_preference', annotation=OpRef(name='init.fields.1.annotation'"
        "), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='capacity_reservation_targ"
        "et', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None)), self_param='self', std_params=(), kw_only_params=('capacity_reservation_preference', 'capacity_reserva"
        "tion_target'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields"
        "=(ReprPlan.Field(name='capacity_reservation_preference', kw_only=True, fn=None), ReprPlan.Field(name='capacity"
        "_reservation_target', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='917bc38bfc6f2d040d348ed036cdd76106ba7d55',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CapacityReservationSpecification'),
        ('ominfra.clouds.aws.models.services.ec2', 'CapacityReservationSpecificationResponse'),
    ),
)
def _process_dataclass__917bc38bfc6f2d040d348ed036cdd76106ba7d55():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                capacity_reservation_preference=self.capacity_reservation_preference,
                capacity_reservation_target=self.capacity_reservation_target,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.capacity_reservation_preference == other.capacity_reservation_preference and
                self.capacity_reservation_target == other.capacity_reservation_target
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'capacity_reservation_preference',
            'capacity_reservation_target',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'capacity_reservation_preference',
            'capacity_reservation_target',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.capacity_reservation_preference,
                self.capacity_reservation_target,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            capacity_reservation_preference: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            capacity_reservation_target: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'capacity_reservation_preference', capacity_reservation_preference)
            __dataclass__object_setattr(self, 'capacity_reservation_target', capacity_reservation_target)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"capacity_reservation_preference={self.capacity_reservation_preference!r}")
            parts.append(f"capacity_reservation_target={self.capacity_reservation_target!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('capacity_reservation_id', 'capacity_reservation_resource_group_arn')), EqPlan(fie"
        "lds=('capacity_reservation_id', 'capacity_reservation_resource_group_arn')), FrozenPlan(fields=('__shape__', '"
        "capacity_reservation_id', 'capacity_reservation_resource_group_arn'), allow_dynamic_dunder_attrs=False), HashP"
        "lan(action='add', fields=('capacity_reservation_id', 'capacity_reservation_resource_group_arn'), cache=False),"
        " InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default="
        "None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=N"
        "one, check_type=None), InitPlan.Field(name='capacity_reservation_id', annotation=OpRef(name='init.fields.1.ann"
        "otation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='capacity_reservat"
        "ion_resource_group_arn', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('capacity_reservation_id', 'capa"
        "city_reservation_resource_group_arn'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_"
        "fns=()), ReprPlan(fields=(ReprPlan.Field(name='capacity_reservation_id', kw_only=True, fn=None), ReprPlan.Fiel"
        "d(name='capacity_reservation_resource_group_arn', kw_only=True, fn=None)), id=False, terse=False, default_fn=N"
        "one)))"
    ),
    plan_repr_sha1='045209aeb87ab83d8d5340fd2caacf0f856dd39d',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CapacityReservationTarget'),
        ('ominfra.clouds.aws.models.services.ec2', 'CapacityReservationTargetResponse'),
    ),
)
def _process_dataclass__045209aeb87ab83d8d5340fd2caacf0f856dd39d():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                capacity_reservation_id=self.capacity_reservation_id,
                capacity_reservation_resource_group_arn=self.capacity_reservation_resource_group_arn,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.capacity_reservation_id == other.capacity_reservation_id and
                self.capacity_reservation_resource_group_arn == other.capacity_reservation_resource_group_arn
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'capacity_reservation_id',
            'capacity_reservation_resource_group_arn',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'capacity_reservation_id',
            'capacity_reservation_resource_group_arn',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.capacity_reservation_id,
                self.capacity_reservation_resource_group_arn,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            capacity_reservation_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            capacity_reservation_resource_group_arn: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'capacity_reservation_id', capacity_reservation_id)
            __dataclass__object_setattr(self, 'capacity_reservation_resource_group_arn', capacity_reservation_resource_group_arn)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"capacity_reservation_id={self.capacity_reservation_id!r}")
            parts.append(f"capacity_reservation_resource_group_arn={self.capacity_reservation_resource_group_arn!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('tcp_established_timeout', 'udp_stream_timeout', 'udp_timeout')), EqPlan(fields=('"
        "tcp_established_timeout', 'udp_stream_timeout', 'udp_timeout')), FrozenPlan(fields=('__shape__', 'tcp_establis"
        "hed_timeout', 'udp_stream_timeout', 'udp_timeout'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', "
        "fields=('tcp_established_timeout', 'udp_stream_timeout', 'udp_timeout'), cache=False), InitPlan(fields=(InitPl"
        "an.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='tcp_established_timeout', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef"
        "(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='udp_stream_timeout', annotation=OpRef(nam"
        "e='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='udp_timeout', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None)), self_param='self', std_params=(), kw_only_params=('tcp_established_timeout', 'udp_stream_t"
        "imeout', 'udp_timeout'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
        "lan(fields=(ReprPlan.Field(name='tcp_established_timeout', kw_only=True, fn=None), ReprPlan.Field(name='udp_st"
        "ream_timeout', kw_only=True, fn=None), ReprPlan.Field(name='udp_timeout', kw_only=True, fn=None)), id=False, t"
        "erse=False, default_fn=None)))"
    ),
    plan_repr_sha1='7966b5342926406c3075c21a6670466e44b592e4',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'ConnectionTrackingConfiguration'),
        ('ominfra.clouds.aws.models.services.ec2', 'ConnectionTrackingSpecificationRequest'),
        ('ominfra.clouds.aws.models.services.ec2', 'ConnectionTrackingSpecificationResponse'),
    ),
)
def _process_dataclass__7966b5342926406c3075c21a6670466e44b592e4():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                tcp_established_timeout=self.tcp_established_timeout,
                udp_stream_timeout=self.udp_stream_timeout,
                udp_timeout=self.udp_timeout,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.tcp_established_timeout == other.tcp_established_timeout and
                self.udp_stream_timeout == other.udp_stream_timeout and
                self.udp_timeout == other.udp_timeout
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'tcp_established_timeout',
            'udp_stream_timeout',
            'udp_timeout',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'tcp_established_timeout',
            'udp_stream_timeout',
            'udp_timeout',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.tcp_established_timeout,
                self.udp_stream_timeout,
                self.udp_timeout,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            tcp_established_timeout: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            udp_stream_timeout: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            udp_timeout: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'tcp_established_timeout', tcp_established_timeout)
            __dataclass__object_setattr(self, 'udp_stream_timeout', udp_stream_timeout)
            __dataclass__object_setattr(self, 'udp_timeout', udp_timeout)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"tcp_established_timeout={self.tcp_established_timeout!r}")
            parts.append(f"udp_stream_timeout={self.udp_stream_timeout!r}")
            parts.append(f"udp_timeout={self.udp_timeout!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('core_count', 'threads_per_core', 'amd_sev_snp')), EqPlan(fields=('core_count', 't"
        "hreads_per_core', 'amd_sev_snp')), FrozenPlan(fields=('__shape__', 'core_count', 'threads_per_core', 'amd_sev_"
        "snp'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('core_count', 'threads_per_core', 'am"
        "d_sev_snp'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.field"
        "s.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VA"
        "R, coerce=None, validate=None, check_type=None), InitPlan.Field(name='core_count', annotation=OpRef(name='init"
        ".fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override"
        "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='thre"
        "ads_per_core', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None), InitPlan.Field(name='amd_sev_snp', annotation=OpRef(name='init.fields.3.annotation'), default"
        "=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
        "STANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('core"
        "_count', 'threads_per_core', 'amd_sev_snp'), frozen=True, slots=False, post_init_params=None, init_fns=(), val"
        "idate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='core_count', kw_only=True, fn=None), ReprPlan.Field(name="
        "'threads_per_core', kw_only=True, fn=None), ReprPlan.Field(name='amd_sev_snp', kw_only=True, fn=None)), id=Fal"
        "se, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='f309cd6072681bb44dd6795348d4642efe3a7e7c',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CpuOptions'),
        ('ominfra.clouds.aws.models.services.ec2', 'CpuOptionsRequest'),
    ),
)
def _process_dataclass__f309cd6072681bb44dd6795348d4642efe3a7e7c():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                core_count=self.core_count,
                threads_per_core=self.threads_per_core,
                amd_sev_snp=self.amd_sev_snp,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.core_count == other.core_count and
                self.threads_per_core == other.threads_per_core and
                self.amd_sev_snp == other.amd_sev_snp
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'core_count',
            'threads_per_core',
            'amd_sev_snp',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'core_count',
            'threads_per_core',
            'amd_sev_snp',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.core_count,
                self.threads_per_core,
                self.amd_sev_snp,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            core_count: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            threads_per_core: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            amd_sev_snp: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'core_count', core_count)
            __dataclass__object_setattr(self, 'threads_per_core', threads_per_core)
            __dataclass__object_setattr(self, 'amd_sev_snp', amd_sev_snp)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"core_count={self.core_count!r}")
            parts.append(f"threads_per_core={self.threads_per_core!r}")
            parts.append(f"amd_sev_snp={self.amd_sev_snp!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('destination_prefix_list_id', 'vpc_endpoint_id', 'transit_gateway_id', 'local_gate"
        "way_id', 'carrier_gateway_id', 'core_network_arn', 'odb_network_arn', 'dry_run', 'route_table_id', 'destinatio"
        "n_cidr_block', 'gateway_id', 'destination_ipv6_cidr_block', 'egress_only_internet_gateway_id', 'instance_id', "
        "'network_interface_id', 'vpc_peering_connection_id', 'nat_gateway_id')), EqPlan(fields=('destination_prefix_li"
        "st_id', 'vpc_endpoint_id', 'transit_gateway_id', 'local_gateway_id', 'carrier_gateway_id', 'core_network_arn',"
        " 'odb_network_arn', 'dry_run', 'route_table_id', 'destination_cidr_block', 'gateway_id', 'destination_ipv6_cid"
        "r_block', 'egress_only_internet_gateway_id', 'instance_id', 'network_interface_id', 'vpc_peering_connection_id"
        "', 'nat_gateway_id')), FrozenPlan(fields=('__shape__', 'destination_prefix_list_id', 'vpc_endpoint_id', 'trans"
        "it_gateway_id', 'local_gateway_id', 'carrier_gateway_id', 'core_network_arn', 'odb_network_arn', 'dry_run', 'r"
        "oute_table_id', 'destination_cidr_block', 'gateway_id', 'destination_ipv6_cidr_block', 'egress_only_internet_g"
        "ateway_id', 'instance_id', 'network_interface_id', 'vpc_peering_connection_id', 'nat_gateway_id'), allow_dynam"
        "ic_dunder_attrs=False), HashPlan(action='add', fields=('destination_prefix_list_id', 'vpc_endpoint_id', 'trans"
        "it_gateway_id', 'local_gateway_id', 'carrier_gateway_id', 'core_network_arn', 'odb_network_arn', 'dry_run', 'r"
        "oute_table_id', 'destination_cidr_block', 'gateway_id', 'destination_ipv6_cidr_block', 'egress_only_internet_g"
        "ateway_id', 'instance_id', 'network_interface_id', 'vpc_peering_connection_id', 'nat_gateway_id'), cache=False"
        "), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defaul"
        "t=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate"
        "=None, check_type=None), InitPlan.Field(name='destination_prefix_list_id', annotation=OpRef(name='init.fields."
        "1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_endpoint"
        "_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='transit_gateway_id', annotation=OpRef(name='init.fields.3.annotation'), default=O"
        "pRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='local_gateway_id', annotation=OpRef(n"
        "ame='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='carrier_gateway_id', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None), InitPlan.Field(name='core_network_arn', annotation=OpRef(name='init.fields.6.annot"
        "ation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='odb_network_arn', a"
        "nnotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory"
        "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
        " InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fi"
        "elds.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='route_table_id', annotation=OpRef(name='init.fields.9.a"
        "nnotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='destination_cidr_block', annotation=OpRef(name"
        "='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='gateway_id', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='destination_ipv6_cidr_block', annotation=OpRef(name='init.fields.12."
        "annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='egress_only_i"
        "nternet_gateway_id', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13.de"
        "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
        "=None, check_type=None), InitPlan.Field(name='instance_id', annotation=OpRef(name='init.fields.14.annotation')"
        ", default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_interface_id', an"
        "notation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='vpc_peering_connection_id', annotation=OpRef(name='init.fields.16.annotation'), default"
        "=OpRef(name='init.fields.16.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
        "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='nat_gateway_id', annotation=OpRef("
        "name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='"
        "self', std_params=(), kw_only_params=('destination_prefix_list_id', 'vpc_endpoint_id', 'transit_gateway_id', '"
        "local_gateway_id', 'carrier_gateway_id', 'core_network_arn', 'odb_network_arn', 'dry_run', 'route_table_id', '"
        "destination_cidr_block', 'gateway_id', 'destination_ipv6_cidr_block', 'egress_only_internet_gateway_id', 'inst"
        "ance_id', 'network_interface_id', 'vpc_peering_connection_id', 'nat_gateway_id'), frozen=True, slots=False, po"
        "st_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='destination_prefix_l"
        "ist_id', kw_only=True, fn=None), ReprPlan.Field(name='vpc_endpoint_id', kw_only=True, fn=None), ReprPlan.Field"
        "(name='transit_gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='local_gateway_id', kw_only=True, fn=N"
        "one), ReprPlan.Field(name='carrier_gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='core_network_arn'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='odb_network_arn', kw_only=True, fn=None), ReprPlan.Field(name='"
        "dry_run', kw_only=True, fn=None), ReprPlan.Field(name='route_table_id', kw_only=True, fn=None), ReprPlan.Field"
        "(name='destination_cidr_block', kw_only=True, fn=None), ReprPlan.Field(name='gateway_id', kw_only=True, fn=Non"
        "e), ReprPlan.Field(name='destination_ipv6_cidr_block', kw_only=True, fn=None), ReprPlan.Field(name='egress_onl"
        "y_internet_gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='instance_id', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='network_interface_id', kw_only=True, fn=None), ReprPlan.Field(name='vpc_peering_connection_i"
        "d', kw_only=True, fn=None), ReprPlan.Field(name='nat_gateway_id', kw_only=True, fn=None)), id=False, terse=Fal"
        "se, default_fn=None)))"
    ),
    plan_repr_sha1='d80b3f6d522d7ad8f1bac2b374a92de1e4414478',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CreateRouteRequest'),
    ),
)
def _process_dataclass__d80b3f6d522d7ad8f1bac2b374a92de1e4414478():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                destination_prefix_list_id=self.destination_prefix_list_id,
                vpc_endpoint_id=self.vpc_endpoint_id,
                transit_gateway_id=self.transit_gateway_id,
                local_gateway_id=self.local_gateway_id,
                carrier_gateway_id=self.carrier_gateway_id,
                core_network_arn=self.core_network_arn,
                odb_network_arn=self.odb_network_arn,
                dry_run=self.dry_run,
                route_table_id=self.route_table_id,
                destination_cidr_block=self.destination_cidr_block,
                gateway_id=self.gateway_id,
                destination_ipv6_cidr_block=self.destination_ipv6_cidr_block,
                egress_only_internet_gateway_id=self.egress_only_internet_gateway_id,
                instance_id=self.instance_id,
                network_interface_id=self.network_interface_id,
                vpc_peering_connection_id=self.vpc_peering_connection_id,
                nat_gateway_id=self.nat_gateway_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.destination_prefix_list_id == other.destination_prefix_list_id and
                self.vpc_endpoint_id == other.vpc_endpoint_id and
                self.transit_gateway_id == other.transit_gateway_id and
                self.local_gateway_id == other.local_gateway_id and
                self.carrier_gateway_id == other.carrier_gateway_id and
                self.core_network_arn == other.core_network_arn and
                self.odb_network_arn == other.odb_network_arn and
                self.dry_run == other.dry_run and
                self.route_table_id == other.route_table_id and
                self.destination_cidr_block == other.destination_cidr_block and
                self.gateway_id == other.gateway_id and
                self.destination_ipv6_cidr_block == other.destination_ipv6_cidr_block and
                self.egress_only_internet_gateway_id == other.egress_only_internet_gateway_id and
                self.instance_id == other.instance_id and
                self.network_interface_id == other.network_interface_id and
                self.vpc_peering_connection_id == other.vpc_peering_connection_id and
                self.nat_gateway_id == other.nat_gateway_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'destination_prefix_list_id',
            'vpc_endpoint_id',
            'transit_gateway_id',
            'local_gateway_id',
            'carrier_gateway_id',
            'core_network_arn',
            'odb_network_arn',
            'dry_run',
            'route_table_id',
            'destination_cidr_block',
            'gateway_id',
            'destination_ipv6_cidr_block',
            'egress_only_internet_gateway_id',
            'instance_id',
            'network_interface_id',
            'vpc_peering_connection_id',
            'nat_gateway_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'destination_prefix_list_id',
            'vpc_endpoint_id',
            'transit_gateway_id',
            'local_gateway_id',
            'carrier_gateway_id',
            'core_network_arn',
            'odb_network_arn',
            'dry_run',
            'route_table_id',
            'destination_cidr_block',
            'gateway_id',
            'destination_ipv6_cidr_block',
            'egress_only_internet_gateway_id',
            'instance_id',
            'network_interface_id',
            'vpc_peering_connection_id',
            'nat_gateway_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.destination_prefix_list_id,
                self.vpc_endpoint_id,
                self.transit_gateway_id,
                self.local_gateway_id,
                self.carrier_gateway_id,
                self.core_network_arn,
                self.odb_network_arn,
                self.dry_run,
                self.route_table_id,
                self.destination_cidr_block,
                self.gateway_id,
                self.destination_ipv6_cidr_block,
                self.egress_only_internet_gateway_id,
                self.instance_id,
                self.network_interface_id,
                self.vpc_peering_connection_id,
                self.nat_gateway_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            destination_prefix_list_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            vpc_endpoint_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            transit_gateway_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            local_gateway_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            carrier_gateway_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            core_network_arn: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            odb_network_arn: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            dry_run: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            route_table_id: __dataclass__init__fields__9__annotation,
            destination_cidr_block: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            gateway_id: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            destination_ipv6_cidr_block: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            egress_only_internet_gateway_id: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            instance_id: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            network_interface_id: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            vpc_peering_connection_id: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            nat_gateway_id: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'destination_prefix_list_id', destination_prefix_list_id)
            __dataclass__object_setattr(self, 'vpc_endpoint_id', vpc_endpoint_id)
            __dataclass__object_setattr(self, 'transit_gateway_id', transit_gateway_id)
            __dataclass__object_setattr(self, 'local_gateway_id', local_gateway_id)
            __dataclass__object_setattr(self, 'carrier_gateway_id', carrier_gateway_id)
            __dataclass__object_setattr(self, 'core_network_arn', core_network_arn)
            __dataclass__object_setattr(self, 'odb_network_arn', odb_network_arn)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'route_table_id', route_table_id)
            __dataclass__object_setattr(self, 'destination_cidr_block', destination_cidr_block)
            __dataclass__object_setattr(self, 'gateway_id', gateway_id)
            __dataclass__object_setattr(self, 'destination_ipv6_cidr_block', destination_ipv6_cidr_block)
            __dataclass__object_setattr(self, 'egress_only_internet_gateway_id', egress_only_internet_gateway_id)
            __dataclass__object_setattr(self, 'instance_id', instance_id)
            __dataclass__object_setattr(self, 'network_interface_id', network_interface_id)
            __dataclass__object_setattr(self, 'vpc_peering_connection_id', vpc_peering_connection_id)
            __dataclass__object_setattr(self, 'nat_gateway_id', nat_gateway_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"destination_prefix_list_id={self.destination_prefix_list_id!r}")
            parts.append(f"vpc_endpoint_id={self.vpc_endpoint_id!r}")
            parts.append(f"transit_gateway_id={self.transit_gateway_id!r}")
            parts.append(f"local_gateway_id={self.local_gateway_id!r}")
            parts.append(f"carrier_gateway_id={self.carrier_gateway_id!r}")
            parts.append(f"core_network_arn={self.core_network_arn!r}")
            parts.append(f"odb_network_arn={self.odb_network_arn!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"route_table_id={self.route_table_id!r}")
            parts.append(f"destination_cidr_block={self.destination_cidr_block!r}")
            parts.append(f"gateway_id={self.gateway_id!r}")
            parts.append(f"destination_ipv6_cidr_block={self.destination_ipv6_cidr_block!r}")
            parts.append(f"egress_only_internet_gateway_id={self.egress_only_internet_gateway_id!r}")
            parts.append(f"instance_id={self.instance_id!r}")
            parts.append(f"network_interface_id={self.network_interface_id!r}")
            parts.append(f"vpc_peering_connection_id={self.vpc_peering_connection_id!r}")
            parts.append(f"nat_gateway_id={self.nat_gateway_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('return_',)), EqPlan(fields=('return_',)), FrozenPlan(fields=('__shape__', 'return"
        "_'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('return_',), cache=False), InitPlan(fie"
        "lds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default"
        "_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_ty"
        "pe=None), InitPlan.Field(name='return_', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name"
        "='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('return_',), fro"
        "zen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(n"
        "ame='return_', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='9aa5b3dde66636e77903283ad91eb34d6cb27b20',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CreateRouteResult'),
    ),
)
def _process_dataclass__9aa5b3dde66636e77903283ad91eb34d6cb27b20():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                return_=self.return_,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.return_ == other.return_
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'return_',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'return_',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.return_,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            return_: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'return_', return_)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"return_={self.return_!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('tag_specifications', 'client_token', 'dry_run', 'vpc_id')), EqPlan(fields=('tag_s"
        "pecifications', 'client_token', 'dry_run', 'vpc_id')), FrozenPlan(fields=('__shape__', 'tag_specifications', '"
        "client_token', 'dry_run', 'vpc_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('tag_sp"
        "ecifications', 'client_token', 'dry_run', 'vpc_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='__sha"
        "pe__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "tag_specifications', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defa"
        "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
        "one, check_type=None), InitPlan.Field(name='client_token', annotation=OpRef(name='init.fields.2.annotation'), "
        "default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(n"
        "ame='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='vpc_id', annotation=OpRef(name='init.fields.4.annotation'), default=None, default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='se"
        "lf', std_params=(), kw_only_params=('tag_specifications', 'client_token', 'dry_run', 'vpc_id'), frozen=True, s"
        "lots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='tag_sp"
        "ecifications', kw_only=True, fn=None), ReprPlan.Field(name='client_token', kw_only=True, fn=None), ReprPlan.Fi"
        "eld(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None)), id=False, t"
        "erse=False, default_fn=None)))"
    ),
    plan_repr_sha1='dea68351d63e2b1ddc527efbcd2431a54e2d0877',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CreateRouteTableRequest'),
    ),
)
def _process_dataclass__dea68351d63e2b1ddc527efbcd2431a54e2d0877():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                tag_specifications=self.tag_specifications,
                client_token=self.client_token,
                dry_run=self.dry_run,
                vpc_id=self.vpc_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.tag_specifications == other.tag_specifications and
                self.client_token == other.client_token and
                self.dry_run == other.dry_run and
                self.vpc_id == other.vpc_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'tag_specifications',
            'client_token',
            'dry_run',
            'vpc_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'tag_specifications',
            'client_token',
            'dry_run',
            'vpc_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.tag_specifications,
                self.client_token,
                self.dry_run,
                self.vpc_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            tag_specifications: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            client_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            dry_run: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            vpc_id: __dataclass__init__fields__4__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'tag_specifications', tag_specifications)
            __dataclass__object_setattr(self, 'client_token', client_token)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"tag_specifications={self.tag_specifications!r}")
            parts.append(f"client_token={self.client_token!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('route_table', 'client_token')), EqPlan(fields=('route_table', 'client_token')), F"
        "rozenPlan(fields=('__shape__', 'route_table', 'client_token'), allow_dynamic_dunder_attrs=False), HashPlan(act"
        "ion='add', fields=('route_table', 'client_token'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape"
        "__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ro"
        "ute_table', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
        "k_type=None), InitPlan.Field(name='client_token', annotation=OpRef(name='init.fields.2.annotation'), default=O"
        "pRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('route_"
        "table', 'client_token'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
        "lan(fields=(ReprPlan.Field(name='route_table', kw_only=True, fn=None), ReprPlan.Field(name='client_token', kw_"
        "only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='582754ca145127aaf3528d004fb3082a11a878aa',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CreateRouteTableResult'),
    ),
)
def _process_dataclass__582754ca145127aaf3528d004fb3082a11a878aa():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                route_table=self.route_table,
                client_token=self.client_token,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.route_table == other.route_table and
                self.client_token == other.client_token
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'route_table',
            'client_token',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'route_table',
            'client_token',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.route_table,
                self.client_token,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            route_table: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            client_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'route_table', route_table)
            __dataclass__object_setattr(self, 'client_token', client_token)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"route_table={self.route_table!r}")
            parts.append(f"client_token={self.client_token!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('description', 'group_name', 'vpc_id', 'tag_specifications', 'dry_run')), EqPlan(f"
        "ields=('description', 'group_name', 'vpc_id', 'tag_specifications', 'dry_run')), FrozenPlan(fields=('__shape__"
        "', 'description', 'group_name', 'vpc_id', 'tag_specifications', 'dry_run'), allow_dynamic_dunder_attrs=False),"
        " HashPlan(action='add', fields=('description', 'group_name', 'vpc_id', 'tag_specifications', 'dry_run'), cache"
        "=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), "
        "default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='description', annotation=OpRef(name='init.fields.1.annotat"
        "ion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='group_name', annotation=OpRef(name='init.fields.2.an"
        "notation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.3.a"
        "nnotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tag_specificati"
        "ons', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='"
        "init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
        "e=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('description', 'gr"
        "oup_name', 'vpc_id', 'tag_specifications', 'dry_run'), frozen=True, slots=False, post_init_params=None, init_f"
        "ns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='description', kw_only=True, fn=None), ReprPlan."
        "Field(name='group_name', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPla"
        "n.Field(name='tag_specifications', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=Non"
        "e)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='6761001676719ee7d82d5f2ef1929b36fb933be8',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CreateSecurityGroupRequest'),
    ),
)
def _process_dataclass__6761001676719ee7d82d5f2ef1929b36fb933be8():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                description=self.description,
                group_name=self.group_name,
                vpc_id=self.vpc_id,
                tag_specifications=self.tag_specifications,
                dry_run=self.dry_run,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.description == other.description and
                self.group_name == other.group_name and
                self.vpc_id == other.vpc_id and
                self.tag_specifications == other.tag_specifications and
                self.dry_run == other.dry_run
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'description',
            'group_name',
            'vpc_id',
            'tag_specifications',
            'dry_run',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'description',
            'group_name',
            'vpc_id',
            'tag_specifications',
            'dry_run',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.description,
                self.group_name,
                self.vpc_id,
                self.tag_specifications,
                self.dry_run,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            description: __dataclass__init__fields__1__annotation,
            group_name: __dataclass__init__fields__2__annotation,
            vpc_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            tag_specifications: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            dry_run: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'group_name', group_name)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'tag_specifications', tag_specifications)
            __dataclass__object_setattr(self, 'dry_run', dry_run)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"description={self.description!r}")
            parts.append(f"group_name={self.group_name!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"tag_specifications={self.tag_specifications!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('group_id', 'tags', 'security_group_arn')), EqPlan(fields=('group_id', 'tags', 'se"
        "curity_group_arn')), FrozenPlan(fields=('__shape__', 'group_id', 'tags', 'security_group_arn'), allow_dynamic_"
        "dunder_attrs=False), HashPlan(action='add', fields=('group_id', 'tags', 'security_group_arn'), cache=False), I"
        "nitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=No"
        "ne, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='group_id', annotation=OpRef(name='init.fields.1.annotation'), defaul"
        "t=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
        "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='init"
        ".fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override"
        "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='secu"
        "rity_group_arn', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None)), self_param='self', std_params=(), kw_only_params=('group_id', 'tags', 'security_group_arn'"
        "), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.F"
        "ield(name='group_id', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=True, fn=None), ReprPlan.Fie"
        "ld(name='security_group_arn', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='b95b4bb68c708e0fe14cdbbc23446dad9ba20de1',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CreateSecurityGroupResult'),
    ),
)
def _process_dataclass__b95b4bb68c708e0fe14cdbbc23446dad9ba20de1():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                group_id=self.group_id,
                tags=self.tags,
                security_group_arn=self.security_group_arn,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.group_id == other.group_id and
                self.tags == other.tags and
                self.security_group_arn == other.security_group_arn
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'group_id',
            'tags',
            'security_group_arn',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'group_id',
            'tags',
            'security_group_arn',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.group_id,
                self.tags,
                self.security_group_arn,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            group_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            tags: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            security_group_arn: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'group_id', group_id)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'security_group_arn', security_group_arn)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"group_id={self.group_id!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"security_group_arn={self.security_group_arn!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('cpu_credits',)), EqPlan(fields=('cpu_credits',)), FrozenPlan(fields=('__shape__',"
        " 'cpu_credits'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('cpu_credits',), cache=Fals"
        "e), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defau"
        "lt=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='cpu_credits', annotation=OpRef(name='init.fields.1.annotation')"
        ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('cpu_credits',), frozen=Tru"
        "e, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='cp"
        "u_credits', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d9f48cde06e7389dca07aabc1f82e684870460cf',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'CreditSpecificationRequest'),
    ),
)
def _process_dataclass__d9f48cde06e7389dca07aabc1f82e684870460cf():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                cpu_credits=self.cpu_credits,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.cpu_credits == other.cpu_credits
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'cpu_credits',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'cpu_credits',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.cpu_credits,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            cpu_credits: __dataclass__init__fields__1__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'cpu_credits', cpu_credits)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"cpu_credits={self.cpu_credits!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('destination_prefix_list_id', 'dry_run', 'route_table_id', 'destination_cidr_block"
        "', 'destination_ipv6_cidr_block')), EqPlan(fields=('destination_prefix_list_id', 'dry_run', 'route_table_id', "
        "'destination_cidr_block', 'destination_ipv6_cidr_block')), FrozenPlan(fields=('__shape__', 'destination_prefix"
        "_list_id', 'dry_run', 'route_table_id', 'destination_cidr_block', 'destination_ipv6_cidr_block'), allow_dynami"
        "c_dunder_attrs=False), HashPlan(action='add', fields=('destination_prefix_list_id', 'dry_run', 'route_table_id"
        "', 'destination_cidr_block', 'destination_ipv6_cidr_block'), cache=False), InitPlan(fields=(InitPlan.Field(nam"
        "e='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='destination_prefix_list_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='in"
        "it.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.2.ann"
        "otation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='route_table_id', "
        "annotation=OpRef(name='init.fields.3.annotation'), default=None, default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='destinat"
        "ion_cidr_block', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='destination_ipv6_cidr_block', annotation=OpRef(name='init.fields.5.ann"
        "otation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_"
        "only_params=('destination_prefix_list_id', 'dry_run', 'route_table_id', 'destination_cidr_block', 'destination"
        "_ipv6_cidr_block'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(f"
        "ields=(ReprPlan.Field(name='destination_prefix_list_id', kw_only=True, fn=None), ReprPlan.Field(name='dry_run'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='route_table_id', kw_only=True, fn=None), ReprPlan.Field(name='d"
        "estination_cidr_block', kw_only=True, fn=None), ReprPlan.Field(name='destination_ipv6_cidr_block', kw_only=Tru"
        "e, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='96794c88f56323f67ace2ae29045cc03327d5c41',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DeleteRouteRequest'),
    ),
)
def _process_dataclass__96794c88f56323f67ace2ae29045cc03327d5c41():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                destination_prefix_list_id=self.destination_prefix_list_id,
                dry_run=self.dry_run,
                route_table_id=self.route_table_id,
                destination_cidr_block=self.destination_cidr_block,
                destination_ipv6_cidr_block=self.destination_ipv6_cidr_block,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.destination_prefix_list_id == other.destination_prefix_list_id and
                self.dry_run == other.dry_run and
                self.route_table_id == other.route_table_id and
                self.destination_cidr_block == other.destination_cidr_block and
                self.destination_ipv6_cidr_block == other.destination_ipv6_cidr_block
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'destination_prefix_list_id',
            'dry_run',
            'route_table_id',
            'destination_cidr_block',
            'destination_ipv6_cidr_block',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'destination_prefix_list_id',
            'dry_run',
            'route_table_id',
            'destination_cidr_block',
            'destination_ipv6_cidr_block',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.destination_prefix_list_id,
                self.dry_run,
                self.route_table_id,
                self.destination_cidr_block,
                self.destination_ipv6_cidr_block,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            destination_prefix_list_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            dry_run: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            route_table_id: __dataclass__init__fields__3__annotation,
            destination_cidr_block: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            destination_ipv6_cidr_block: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'destination_prefix_list_id', destination_prefix_list_id)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'route_table_id', route_table_id)
            __dataclass__object_setattr(self, 'destination_cidr_block', destination_cidr_block)
            __dataclass__object_setattr(self, 'destination_ipv6_cidr_block', destination_ipv6_cidr_block)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"destination_prefix_list_id={self.destination_prefix_list_id!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"route_table_id={self.route_table_id!r}")
            parts.append(f"destination_cidr_block={self.destination_cidr_block!r}")
            parts.append(f"destination_ipv6_cidr_block={self.destination_ipv6_cidr_block!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('dry_run', 'route_table_id')), EqPlan(fields=('dry_run', 'route_table_id')), Froze"
        "nPlan(fields=('__shape__', 'dry_run', 'route_table_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='a"
        "dd', fields=('dry_run', 'route_table_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', ann"
        "otation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False,"
        " field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', "
        "annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='route_table_id', annotation=OpRef(name='init.fields.2.annotation'), default=None, defau"
        "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
        "ype=None)), self_param='self', std_params=(), kw_only_params=('dry_run', 'route_table_id'), frozen=True, slots"
        "=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='dry_run', "
        "kw_only=True, fn=None), ReprPlan.Field(name='route_table_id', kw_only=True, fn=None)), id=False, terse=False, "
        "default_fn=None)))"
    ),
    plan_repr_sha1='71e4b4e0f9919133a1bf7f7a493d96671919406d',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DeleteRouteTableRequest'),
    ),
)
def _process_dataclass__71e4b4e0f9919133a1bf7f7a493d96671919406d():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                dry_run=self.dry_run,
                route_table_id=self.route_table_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.dry_run == other.dry_run and
                self.route_table_id == other.route_table_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'dry_run',
            'route_table_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'dry_run',
            'route_table_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.dry_run,
                self.route_table_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            dry_run: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            route_table_id: __dataclass__init__fields__2__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'route_table_id', route_table_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"route_table_id={self.route_table_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('group_id', 'group_name', 'dry_run')), EqPlan(fields=('group_id', 'group_name', 'd"
        "ry_run')), FrozenPlan(fields=('__shape__', 'group_id', 'group_name', 'dry_run'), allow_dynamic_dunder_attrs=Fa"
        "lse), HashPlan(action='add', fields=('group_id', 'group_name', 'dry_run'), cache=False), InitPlan(fields=(Init"
        "Plan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory="
        "None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),"
        " InitPlan.Field(name='group_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.f"
        "ields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='group_name', annotation=OpRef(name='init.fields.2.anno"
        "tation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotati"
        "on=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_"
        "param='self', std_params=(), kw_only_params=('group_id', 'group_name', 'dry_run'), frozen=True, slots=False, p"
        "ost_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='group_id', kw_only="
        "True, fn=None), ReprPlan.Field(name='group_name', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_on"
        "ly=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='8dce2cc8aa2d92ebd569fffa8ed82a243f1a1bc2',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DeleteSecurityGroupRequest'),
    ),
)
def _process_dataclass__8dce2cc8aa2d92ebd569fffa8ed82a243f1a1bc2():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                group_id=self.group_id,
                group_name=self.group_name,
                dry_run=self.dry_run,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.group_id == other.group_id and
                self.group_name == other.group_name and
                self.dry_run == other.dry_run
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'group_id',
            'group_name',
            'dry_run',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'group_id',
            'group_name',
            'dry_run',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.group_id,
                self.group_name,
                self.dry_run,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            group_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            group_name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            dry_run: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'group_id', group_id)
            __dataclass__object_setattr(self, 'group_name', group_name)
            __dataclass__object_setattr(self, 'dry_run', dry_run)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"group_id={self.group_id!r}")
            parts.append(f"group_name={self.group_name!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('return_', 'group_id')), EqPlan(fields=('return_', 'group_id')), FrozenPlan(fields"
        "=('__shape__', 'return_', 'group_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('retu"
        "rn_', 'group_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init"
        ".fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CL"
        "ASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='return_', annotation=OpRef(name='i"
        "nit.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='g"
        "roup_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None)), self_param='self', std_params=(), kw_only_params=('return_', 'group_id'), frozen=True, slots=Fals"
        "e, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='return_', kw_on"
        "ly=True, fn=None), ReprPlan.Field(name='group_id', kw_only=True, fn=None)), id=False, terse=False, default_fn="
        "None)))"
    ),
    plan_repr_sha1='5afbe7bbec3a5065ddc8f2d5773563e9771995a3',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DeleteSecurityGroupResult'),
    ),
)
def _process_dataclass__5afbe7bbec3a5065ddc8f2d5773563e9771995a3():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                return_=self.return_,
                group_id=self.group_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.return_ == other.return_ and
                self.group_id == other.group_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'return_',
            'group_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'return_',
            'group_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.return_,
                self.group_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            return_: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            group_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'return_', return_)
            __dataclass__object_setattr(self, 'group_id', group_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"return_={self.return_!r}")
            parts.append(f"group_id={self.group_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('public_ips', 'dry_run', 'filters', 'allocation_ids')), EqPlan(fields=('public_ips"
        "', 'dry_run', 'filters', 'allocation_ids')), FrozenPlan(fields=('__shape__', 'public_ips', 'dry_run', 'filters"
        "', 'allocation_ids'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('public_ips', 'dry_run"
        "', 'filters', 'allocation_ids'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=Op"
        "Ref(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_ips', annotat"
        "ion=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None,"
        " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
        "lan.Field(name='dry_run', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None), InitPlan.Field(name='filters', annotation=OpRef(name='init.fields.3.annotation'), "
        "default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='allocation_ids', annotation="
        "OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_par"
        "am='self', std_params=(), kw_only_params=('public_ips', 'dry_run', 'filters', 'allocation_ids'), frozen=True, "
        "slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='publi"
        "c_ips', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='fi"
        "lters', kw_only=True, fn=None), ReprPlan.Field(name='allocation_ids', kw_only=True, fn=None)), id=False, terse"
        "=False, default_fn=None)))"
    ),
    plan_repr_sha1='d2e4d44d054c756027bfa674782dd7a1a3096885',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeAddressesRequest'),
    ),
)
def _process_dataclass__d2e4d44d054c756027bfa674782dd7a1a3096885():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                public_ips=self.public_ips,
                dry_run=self.dry_run,
                filters=self.filters,
                allocation_ids=self.allocation_ids,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.public_ips == other.public_ips and
                self.dry_run == other.dry_run and
                self.filters == other.filters and
                self.allocation_ids == other.allocation_ids
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'public_ips',
            'dry_run',
            'filters',
            'allocation_ids',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'public_ips',
            'dry_run',
            'filters',
            'allocation_ids',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.public_ips,
                self.dry_run,
                self.filters,
                self.allocation_ids,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            public_ips: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            dry_run: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            filters: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            allocation_ids: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'public_ips', public_ips)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'filters', filters)
            __dataclass__object_setattr(self, 'allocation_ids', allocation_ids)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"public_ips={self.public_ips!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"filters={self.filters!r}")
            parts.append(f"allocation_ids={self.allocation_ids!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('addresses',)), EqPlan(fields=('addresses',)), FrozenPlan(fields=('__shape__', 'ad"
        "dresses'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('addresses',), cache=False), Init"
        "Plan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None,"
        " default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='addresses', annotation=OpRef(name='init.fields.1.annotation'), default="
        "OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('addre"
        "sses',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Repr"
        "Plan.Field(name='addresses', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='8bd2366327ae9973345c3c715d2d93e36ac27f11',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeAddressesResult'),
    ),
)
def _process_dataclass__8bd2366327ae9973345c3c715d2d93e36ac27f11():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                addresses=self.addresses,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.addresses == other.addresses
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'addresses',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'addresses',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.addresses,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            addresses: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'addresses', addresses)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"addresses={self.addresses!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('executable_users', 'image_ids', 'owners', 'include_deprecated', 'include_disabled"
        "', 'max_results', 'next_token', 'dry_run', 'filters')), EqPlan(fields=('executable_users', 'image_ids', 'owner"
        "s', 'include_deprecated', 'include_disabled', 'max_results', 'next_token', 'dry_run', 'filters')), FrozenPlan("
        "fields=('__shape__', 'executable_users', 'image_ids', 'owners', 'include_deprecated', 'include_disabled', 'max"
        "_results', 'next_token', 'dry_run', 'filters'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fiel"
        "ds=('executable_users', 'image_ids', 'owners', 'include_deprecated', 'include_disabled', 'max_results', 'next_"
        "token', 'dry_run', 'filters'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRe"
        "f(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type="
        "FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='executable_users', ann"
        "otation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='image_ids', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fi"
        "elds.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='owners', annotation=OpRef(name='init.fields.3.annotatio"
        "n'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type="
        "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='include_deprecated', an"
        "notation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory="
        "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
        "InitPlan.Field(name='include_disabled', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name="
        "'init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None), InitPlan.Field(name='max_results', annotation=OpRef(name='init.field"
        "s.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False"
        ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token"
        "', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='ini"
        "t.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
        "one, validate=None, check_type=None), InitPlan.Field(name='filters', annotation=OpRef(name='init.fields.9.anno"
        "tation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_o"
        "nly_params=('executable_users', 'image_ids', 'owners', 'include_deprecated', 'include_disabled', 'max_results'"
        ", 'next_token', 'dry_run', 'filters'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_"
        "fns=()), ReprPlan(fields=(ReprPlan.Field(name='executable_users', kw_only=True, fn=None), ReprPlan.Field(name="
        "'image_ids', kw_only=True, fn=None), ReprPlan.Field(name='owners', kw_only=True, fn=None), ReprPlan.Field(name"
        "='include_deprecated', kw_only=True, fn=None), ReprPlan.Field(name='include_disabled', kw_only=True, fn=None),"
        " ReprPlan.Field(name='max_results', kw_only=True, fn=None), ReprPlan.Field(name='next_token', kw_only=True, fn"
        "=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn"
        "=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='888cdb8e577e74f9db2d2232e85293bb88592258',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeImagesRequest'),
    ),
)
def _process_dataclass__888cdb8e577e74f9db2d2232e85293bb88592258():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                executable_users=self.executable_users,
                image_ids=self.image_ids,
                owners=self.owners,
                include_deprecated=self.include_deprecated,
                include_disabled=self.include_disabled,
                max_results=self.max_results,
                next_token=self.next_token,
                dry_run=self.dry_run,
                filters=self.filters,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.executable_users == other.executable_users and
                self.image_ids == other.image_ids and
                self.owners == other.owners and
                self.include_deprecated == other.include_deprecated and
                self.include_disabled == other.include_disabled and
                self.max_results == other.max_results and
                self.next_token == other.next_token and
                self.dry_run == other.dry_run and
                self.filters == other.filters
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'executable_users',
            'image_ids',
            'owners',
            'include_deprecated',
            'include_disabled',
            'max_results',
            'next_token',
            'dry_run',
            'filters',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'executable_users',
            'image_ids',
            'owners',
            'include_deprecated',
            'include_disabled',
            'max_results',
            'next_token',
            'dry_run',
            'filters',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.executable_users,
                self.image_ids,
                self.owners,
                self.include_deprecated,
                self.include_disabled,
                self.max_results,
                self.next_token,
                self.dry_run,
                self.filters,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            executable_users: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            image_ids: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            owners: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            include_deprecated: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            include_disabled: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            max_results: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            next_token: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            dry_run: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            filters: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'executable_users', executable_users)
            __dataclass__object_setattr(self, 'image_ids', image_ids)
            __dataclass__object_setattr(self, 'owners', owners)
            __dataclass__object_setattr(self, 'include_deprecated', include_deprecated)
            __dataclass__object_setattr(self, 'include_disabled', include_disabled)
            __dataclass__object_setattr(self, 'max_results', max_results)
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'filters', filters)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"executable_users={self.executable_users!r}")
            parts.append(f"image_ids={self.image_ids!r}")
            parts.append(f"owners={self.owners!r}")
            parts.append(f"include_deprecated={self.include_deprecated!r}")
            parts.append(f"include_disabled={self.include_disabled!r}")
            parts.append(f"max_results={self.max_results!r}")
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"filters={self.filters!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('next_token', 'images')), EqPlan(fields=('next_token', 'images')), FrozenPlan(fiel"
        "ds=('__shape__', 'next_token', 'images'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('n"
        "ext_token', 'images'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='"
        "init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef("
        "name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='images', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None)), self_param='self', std_params=(), kw_only_params=('next_token', 'images'), frozen=True, slot"
        "s=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='next_toke"
        "n', kw_only=True, fn=None), ReprPlan.Field(name='images', kw_only=True, fn=None)), id=False, terse=False, defa"
        "ult_fn=None)))"
    ),
    plan_repr_sha1='9e25e98278bf5baa0fa863c9a231781780c532e1',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeImagesResult'),
    ),
)
def _process_dataclass__9e25e98278bf5baa0fa863c9a231781780c532e1():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                next_token=self.next_token,
                images=self.images,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.next_token == other.next_token and
                self.images == other.images
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'next_token',
            'images',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'next_token',
            'images',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.next_token,
                self.images,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            images: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'images', images)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"images={self.images!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('dry_run', 'instance_types', 'filters', 'max_results', 'next_token')), EqPlan(fiel"
        "ds=('dry_run', 'instance_types', 'filters', 'max_results', 'next_token')), FrozenPlan(fields=('__shape__', 'dr"
        "y_run', 'instance_types', 'filters', 'max_results', 'next_token'), allow_dynamic_dunder_attrs=False), HashPlan"
        "(action='add', fields=('dry_run', 'instance_types', 'filters', 'max_results', 'next_token'), cache=False), Ini"
        "tPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None"
        ", default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.1.annotation'), default=O"
        "pRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_types', annotation=OpRef(nam"
        "e='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='filters', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), d"
        "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='max_results', annotation=OpRef(name='init.fields.4.annotation'), default=O"
        "pRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='i"
        "nit.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', st"
        "d_params=(), kw_only_params=('dry_run', 'instance_types', 'filters', 'max_results', 'next_token'), frozen=True"
        ", slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='dry"
        "_run', kw_only=True, fn=None), ReprPlan.Field(name='instance_types', kw_only=True, fn=None), ReprPlan.Field(na"
        "me='filters', kw_only=True, fn=None), ReprPlan.Field(name='max_results', kw_only=True, fn=None), ReprPlan.Fiel"
        "d(name='next_token', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='2bd409abcc1fe65745575c019ddf571add03c9e8',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeInstanceTypesRequest'),
    ),
)
def _process_dataclass__2bd409abcc1fe65745575c019ddf571add03c9e8():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                dry_run=self.dry_run,
                instance_types=self.instance_types,
                filters=self.filters,
                max_results=self.max_results,
                next_token=self.next_token,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.dry_run == other.dry_run and
                self.instance_types == other.instance_types and
                self.filters == other.filters and
                self.max_results == other.max_results and
                self.next_token == other.next_token
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'dry_run',
            'instance_types',
            'filters',
            'max_results',
            'next_token',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'dry_run',
            'instance_types',
            'filters',
            'max_results',
            'next_token',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.dry_run,
                self.instance_types,
                self.filters,
                self.max_results,
                self.next_token,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            dry_run: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            instance_types: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            filters: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            max_results: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            next_token: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'instance_types', instance_types)
            __dataclass__object_setattr(self, 'filters', filters)
            __dataclass__object_setattr(self, 'max_results', max_results)
            __dataclass__object_setattr(self, 'next_token', next_token)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"instance_types={self.instance_types!r}")
            parts.append(f"filters={self.filters!r}")
            parts.append(f"max_results={self.max_results!r}")
            parts.append(f"next_token={self.next_token!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('instance_types', 'next_token')), EqPlan(fields=('instance_types', 'next_token')),"
        " FrozenPlan(fields=('__shape__', 'instance_types', 'next_token'), allow_dynamic_dunder_attrs=False), HashPlan("
        "action='add', fields=('instance_types', 'next_token'), cache=False), InitPlan(fields=(InitPlan.Field(name='__s"
        "hape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='instance_types', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.2.annotation'), defa"
        "ult=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('i"
        "nstance_types', 'next_token'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
        " ReprPlan(fields=(ReprPlan.Field(name='instance_types', kw_only=True, fn=None), ReprPlan.Field(name='next_toke"
        "n', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='ad278adb314f3f74b95f1b0515ed1bb994d5624e',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeInstanceTypesResult'),
    ),
)
def _process_dataclass__ad278adb314f3f74b95f1b0515ed1bb994d5624e():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                instance_types=self.instance_types,
                next_token=self.next_token,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.instance_types == other.instance_types and
                self.next_token == other.next_token
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'instance_types',
            'next_token',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'instance_types',
            'next_token',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.instance_types,
                self.next_token,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            instance_types: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            next_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'instance_types', instance_types)
            __dataclass__object_setattr(self, 'next_token', next_token)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"instance_types={self.instance_types!r}")
            parts.append(f"next_token={self.next_token!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('instance_ids', 'dry_run', 'filters', 'next_token', 'max_results')), EqPlan(fields"
        "=('instance_ids', 'dry_run', 'filters', 'next_token', 'max_results')), FrozenPlan(fields=('__shape__', 'instan"
        "ce_ids', 'dry_run', 'filters', 'next_token', 'max_results'), allow_dynamic_dunder_attrs=False), HashPlan(actio"
        "n='add', fields=('instance_ids', 'dry_run', 'filters', 'next_token', 'max_results'), cache=False), InitPlan(fi"
        "elds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, defaul"
        "t_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_t"
        "ype=None), InitPlan.Field(name='instance_ids', annotation=OpRef(name='init.fields.1.annotation'), default=OpRe"
        "f(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
        "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fi"
        "elds.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='filters"
        "', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='"
        "init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
        "e=None, validate=None, check_type=None), InitPlan.Field(name='max_results', annotation=OpRef(name='init.fields"
        ".5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=("
        "), kw_only_params=('instance_ids', 'dry_run', 'filters', 'next_token', 'max_results'), frozen=True, slots=Fals"
        "e, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='instance_ids', "
        "kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='filters', "
        "kw_only=True, fn=None), ReprPlan.Field(name='next_token', kw_only=True, fn=None), ReprPlan.Field(name='max_res"
        "ults', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='19c58eb9baa56cb23a597ed75f00bf082871babf',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeInstancesRequest'),
    ),
)
def _process_dataclass__19c58eb9baa56cb23a597ed75f00bf082871babf():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                instance_ids=self.instance_ids,
                dry_run=self.dry_run,
                filters=self.filters,
                next_token=self.next_token,
                max_results=self.max_results,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.instance_ids == other.instance_ids and
                self.dry_run == other.dry_run and
                self.filters == other.filters and
                self.next_token == other.next_token and
                self.max_results == other.max_results
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'dry_run',
            'filters',
            'next_token',
            'max_results',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'dry_run',
            'filters',
            'next_token',
            'max_results',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.instance_ids,
                self.dry_run,
                self.filters,
                self.next_token,
                self.max_results,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            instance_ids: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            dry_run: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            filters: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            next_token: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            max_results: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'instance_ids', instance_ids)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'filters', filters)
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'max_results', max_results)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"instance_ids={self.instance_ids!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"filters={self.filters!r}")
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"max_results={self.max_results!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('next_token', 'reservations')), EqPlan(fields=('next_token', 'reservations')), Fro"
        "zenPlan(fields=('__shape__', 'next_token', 'reservations'), allow_dynamic_dunder_attrs=False), HashPlan(action"
        "='add', fields=('next_token', 'reservations'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__',"
        " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_t"
        "oken', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default"
        "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='reservations', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef("
        "name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
        " coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('next_token'"
        ", 'reservations'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fi"
        "elds=(ReprPlan.Field(name='next_token', kw_only=True, fn=None), ReprPlan.Field(name='reservations', kw_only=Tr"
        "ue, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='571588aff087d2499ca9b2a48d5254f0219fd6b0',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeInstancesResult'),
    ),
)
def _process_dataclass__571588aff087d2499ca9b2a48d5254f0219fd6b0():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                next_token=self.next_token,
                reservations=self.reservations,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.next_token == other.next_token and
                self.reservations == other.reservations
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'next_token',
            'reservations',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'next_token',
            'reservations',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.next_token,
                self.reservations,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            reservations: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'reservations', reservations)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"reservations={self.reservations!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('next_token', 'max_results', 'dry_run', 'internet_gateway_ids', 'filters')), EqPla"
        "n(fields=('next_token', 'max_results', 'dry_run', 'internet_gateway_ids', 'filters')), FrozenPlan(fields=('__s"
        "hape__', 'next_token', 'max_results', 'dry_run', 'internet_gateway_ids', 'filters'), allow_dynamic_dunder_attr"
        "s=False), HashPlan(action='add', fields=('next_token', 'max_results', 'dry_run', 'internet_gateway_ids', 'filt"
        "ers'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.an"
        "notation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.field"
        "s.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False"
        ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_result"
        "s', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_fa"
        "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
        "one), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='in"
        "it.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='internet_gateway_ids', annotation=OpRef(name='init"
        ".fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override"
        "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='filt"
        "ers', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None)), self_param='self', std_params=(), kw_only_params=('next_token', 'max_results', 'dry_run', 'internet_g"
        "ateway_ids', 'filters'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
        "lan(fields=(ReprPlan.Field(name='next_token', kw_only=True, fn=None), ReprPlan.Field(name='max_results', kw_on"
        "ly=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='internet_gatewa"
        "y_ids', kw_only=True, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn=None)), id=False, terse=False,"
        " default_fn=None)))"
    ),
    plan_repr_sha1='b03db18cab42cf448c5be8bcbfd53886cb044431',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeInternetGatewaysRequest'),
    ),
)
def _process_dataclass__b03db18cab42cf448c5be8bcbfd53886cb044431():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                next_token=self.next_token,
                max_results=self.max_results,
                dry_run=self.dry_run,
                internet_gateway_ids=self.internet_gateway_ids,
                filters=self.filters,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.next_token == other.next_token and
                self.max_results == other.max_results and
                self.dry_run == other.dry_run and
                self.internet_gateway_ids == other.internet_gateway_ids and
                self.filters == other.filters
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'next_token',
            'max_results',
            'dry_run',
            'internet_gateway_ids',
            'filters',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'next_token',
            'max_results',
            'dry_run',
            'internet_gateway_ids',
            'filters',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.next_token,
                self.max_results,
                self.dry_run,
                self.internet_gateway_ids,
                self.filters,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            max_results: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            dry_run: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            internet_gateway_ids: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            filters: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'max_results', max_results)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'internet_gateway_ids', internet_gateway_ids)
            __dataclass__object_setattr(self, 'filters', filters)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"max_results={self.max_results!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"internet_gateway_ids={self.internet_gateway_ids!r}")
            parts.append(f"filters={self.filters!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('internet_gateways', 'next_token')), EqPlan(fields=('internet_gateways', 'next_tok"
        "en')), FrozenPlan(fields=('__shape__', 'internet_gateways', 'next_token'), allow_dynamic_dunder_attrs=False), "
        "HashPlan(action='add', fields=('internet_gateways', 'next_token'), cache=False), InitPlan(fields=(InitPlan.Fie"
        "ld(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, in"
        "it=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='internet_gateways', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init."
        "fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
        "e, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.2.ann"
        "otation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_"
        "only_params=('internet_gateways', 'next_token'), frozen=True, slots=False, post_init_params=None, init_fns=(),"
        " validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='internet_gateways', kw_only=True, fn=None), ReprPlan."
        "Field(name='next_token', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='251cd990b64c55e68eb2b64e92e5badd57f6ae93',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeInternetGatewaysResult'),
    ),
)
def _process_dataclass__251cd990b64c55e68eb2b64e92e5badd57f6ae93():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                internet_gateways=self.internet_gateways,
                next_token=self.next_token,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.internet_gateways == other.internet_gateways and
                self.next_token == other.next_token
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'internet_gateways',
            'next_token',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'internet_gateways',
            'next_token',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.internet_gateways,
                self.next_token,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            internet_gateways: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            next_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'internet_gateways', internet_gateways)
            __dataclass__object_setattr(self, 'next_token', next_token)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"internet_gateways={self.internet_gateways!r}")
            parts.append(f"next_token={self.next_token!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('key_names', 'key_pair_ids', 'include_public_key', 'dry_run', 'filters')), EqPlan("
        "fields=('key_names', 'key_pair_ids', 'include_public_key', 'dry_run', 'filters')), FrozenPlan(fields=('__shape"
        "__', 'key_names', 'key_pair_ids', 'include_public_key', 'dry_run', 'filters'), allow_dynamic_dunder_attrs=Fals"
        "e), HashPlan(action='add', fields=('key_names', 'key_pair_ids', 'include_public_key', 'dry_run', 'filters'), c"
        "ache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation"
        "'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='key_names', annotation=OpRef(name='init.fields.1.annot"
        "ation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='key_pair_ids', anno"
        "tation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='include_public_key', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name="
        "'init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.4."
        "annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='filters', anno"
        "tation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), s"
        "elf_param='self', std_params=(), kw_only_params=('key_names', 'key_pair_ids', 'include_public_key', 'dry_run',"
        " 'filters'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=("
        "ReprPlan.Field(name='key_names', kw_only=True, fn=None), ReprPlan.Field(name='key_pair_ids', kw_only=True, fn="
        "None), ReprPlan.Field(name='include_public_key', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_onl"
        "y=True, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn=None)), id=False, terse=False, default_fn=No"
        "ne)))"
    ),
    plan_repr_sha1='1fd36fa9dc2507c1276ccc642c36fd762eb7e331',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeKeyPairsRequest'),
    ),
)
def _process_dataclass__1fd36fa9dc2507c1276ccc642c36fd762eb7e331():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                key_names=self.key_names,
                key_pair_ids=self.key_pair_ids,
                include_public_key=self.include_public_key,
                dry_run=self.dry_run,
                filters=self.filters,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.key_names == other.key_names and
                self.key_pair_ids == other.key_pair_ids and
                self.include_public_key == other.include_public_key and
                self.dry_run == other.dry_run and
                self.filters == other.filters
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'key_names',
            'key_pair_ids',
            'include_public_key',
            'dry_run',
            'filters',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'key_names',
            'key_pair_ids',
            'include_public_key',
            'dry_run',
            'filters',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.key_names,
                self.key_pair_ids,
                self.include_public_key,
                self.dry_run,
                self.filters,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            key_names: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            key_pair_ids: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            include_public_key: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            dry_run: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            filters: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'key_names', key_names)
            __dataclass__object_setattr(self, 'key_pair_ids', key_pair_ids)
            __dataclass__object_setattr(self, 'include_public_key', include_public_key)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'filters', filters)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"key_names={self.key_names!r}")
            parts.append(f"key_pair_ids={self.key_pair_ids!r}")
            parts.append(f"include_public_key={self.include_public_key!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"filters={self.filters!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('key_pairs',)), EqPlan(fields=('key_pairs',)), FrozenPlan(fields=('__shape__', 'ke"
        "y_pairs'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('key_pairs',), cache=False), Init"
        "Plan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None,"
        " default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='key_pairs', annotation=OpRef(name='init.fields.1.annotation'), default="
        "OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('key_p"
        "airs',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Repr"
        "Plan.Field(name='key_pairs', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='4b49492b20c45bb1a0965b2b0e07bf000df295d7',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeKeyPairsResult'),
    ),
)
def _process_dataclass__4b49492b20c45bb1a0965b2b0e07bf000df295d7():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                key_pairs=self.key_pairs,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.key_pairs == other.key_pairs
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'key_pairs',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'key_pairs',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.key_pairs,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            key_pairs: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'key_pairs', key_pairs)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"key_pairs={self.key_pairs!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('next_token', 'max_results', 'dry_run', 'network_interface_ids', 'filters')), EqPl"
        "an(fields=('next_token', 'max_results', 'dry_run', 'network_interface_ids', 'filters')), FrozenPlan(fields=('_"
        "_shape__', 'next_token', 'max_results', 'dry_run', 'network_interface_ids', 'filters'), allow_dynamic_dunder_a"
        "ttrs=False), HashPlan(action='add', fields=('next_token', 'max_results', 'dry_run', 'network_interface_ids', '"
        "filters'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields."
        "0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR,"
        " coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.f"
        "ields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=F"
        "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_re"
        "sults', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), defaul"
        "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
        "pe=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name"
        "='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='network_interface_ids', annotation=OpRef(name="
        "'init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
        "'filters', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), def"
        "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
        "_type=None)), self_param='self', std_params=(), kw_only_params=('next_token', 'max_results', 'dry_run', 'netwo"
        "rk_interface_ids', 'filters'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
        " ReprPlan(fields=(ReprPlan.Field(name='next_token', kw_only=True, fn=None), ReprPlan.Field(name='max_results',"
        " kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='network_i"
        "nterface_ids', kw_only=True, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn=None)), id=False, terse"
        "=False, default_fn=None)))"
    ),
    plan_repr_sha1='b91d9c5662c7bfe568a38413ef5d6e2c620d11b9',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeNetworkInterfacesRequest'),
    ),
)
def _process_dataclass__b91d9c5662c7bfe568a38413ef5d6e2c620d11b9():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                next_token=self.next_token,
                max_results=self.max_results,
                dry_run=self.dry_run,
                network_interface_ids=self.network_interface_ids,
                filters=self.filters,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.next_token == other.next_token and
                self.max_results == other.max_results and
                self.dry_run == other.dry_run and
                self.network_interface_ids == other.network_interface_ids and
                self.filters == other.filters
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'next_token',
            'max_results',
            'dry_run',
            'network_interface_ids',
            'filters',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'next_token',
            'max_results',
            'dry_run',
            'network_interface_ids',
            'filters',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.next_token,
                self.max_results,
                self.dry_run,
                self.network_interface_ids,
                self.filters,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            max_results: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            dry_run: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            network_interface_ids: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            filters: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'max_results', max_results)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'network_interface_ids', network_interface_ids)
            __dataclass__object_setattr(self, 'filters', filters)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"max_results={self.max_results!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"network_interface_ids={self.network_interface_ids!r}")
            parts.append(f"filters={self.filters!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('network_interfaces', 'next_token')), EqPlan(fields=('network_interfaces', 'next_t"
        "oken')), FrozenPlan(fields=('__shape__', 'network_interfaces', 'next_token'), allow_dynamic_dunder_attrs=False"
        "), HashPlan(action='add', fields=('network_interfaces', 'next_token'), cache=False), InitPlan(fields=(InitPlan"
        ".Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None"
        ", init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='network_interfaces', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='"
        "init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
        "e=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields."
        "2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=()"
        ", kw_only_params=('network_interfaces', 'next_token'), frozen=True, slots=False, post_init_params=None, init_f"
        "ns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='network_interfaces', kw_only=True, fn=None), Re"
        "prPlan.Field(name='next_token', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='96615f8e1de0943f167f88126f4035d2d2ddb900',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeNetworkInterfacesResult'),
    ),
)
def _process_dataclass__96615f8e1de0943f167f88126f4035d2d2ddb900():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                network_interfaces=self.network_interfaces,
                next_token=self.next_token,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.network_interfaces == other.network_interfaces and
                self.next_token == other.next_token
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'network_interfaces',
            'next_token',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'network_interfaces',
            'next_token',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.network_interfaces,
                self.next_token,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            network_interfaces: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            next_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'network_interfaces', network_interfaces)
            __dataclass__object_setattr(self, 'next_token', next_token)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"network_interfaces={self.network_interfaces!r}")
            parts.append(f"next_token={self.next_token!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('next_token', 'max_results', 'dry_run', 'route_table_ids', 'filters')), EqPlan(fie"
        "lds=('next_token', 'max_results', 'dry_run', 'route_table_ids', 'filters')), FrozenPlan(fields=('__shape__', '"
        "next_token', 'max_results', 'dry_run', 'route_table_ids', 'filters'), allow_dynamic_dunder_attrs=False), HashP"
        "lan(action='add', fields=('next_token', 'max_results', 'dry_run', 'route_table_ids', 'filters'), cache=False),"
        " InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default="
        "None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=N"
        "one, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.1.annotation'), de"
        "fault=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_results', annotation=OpRef"
        "(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='dry_run', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='route_table_ids', annotation=OpRef(name='init.fields.4.annotation'), d"
        "efault=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='filters', annotation=OpRef(na"
        "me='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self"
        "', std_params=(), kw_only_params=('next_token', 'max_results', 'dry_run', 'route_table_ids', 'filters'), froze"
        "n=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
        "e='next_token', kw_only=True, fn=None), ReprPlan.Field(name='max_results', kw_only=True, fn=None), ReprPlan.Fi"
        "eld(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='route_table_ids', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='filters', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='60ae60e5642c31ca058ee94cba2574ae2c983166',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeRouteTablesRequest'),
    ),
)
def _process_dataclass__60ae60e5642c31ca058ee94cba2574ae2c983166():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                next_token=self.next_token,
                max_results=self.max_results,
                dry_run=self.dry_run,
                route_table_ids=self.route_table_ids,
                filters=self.filters,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.next_token == other.next_token and
                self.max_results == other.max_results and
                self.dry_run == other.dry_run and
                self.route_table_ids == other.route_table_ids and
                self.filters == other.filters
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'next_token',
            'max_results',
            'dry_run',
            'route_table_ids',
            'filters',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'next_token',
            'max_results',
            'dry_run',
            'route_table_ids',
            'filters',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.next_token,
                self.max_results,
                self.dry_run,
                self.route_table_ids,
                self.filters,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            max_results: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            dry_run: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            route_table_ids: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            filters: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'max_results', max_results)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'route_table_ids', route_table_ids)
            __dataclass__object_setattr(self, 'filters', filters)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"max_results={self.max_results!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"route_table_ids={self.route_table_ids!r}")
            parts.append(f"filters={self.filters!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('route_tables', 'next_token')), EqPlan(fields=('route_tables', 'next_token')), Fro"
        "zenPlan(fields=('__shape__', 'route_tables', 'next_token'), allow_dynamic_dunder_attrs=False), HashPlan(action"
        "='add', fields=('route_tables', 'next_token'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__',"
        " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='route_"
        "tables', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), defau"
        "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
        "ype=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef("
        "name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
        " coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('route_table"
        "s', 'next_token'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fi"
        "elds=(ReprPlan.Field(name='route_tables', kw_only=True, fn=None), ReprPlan.Field(name='next_token', kw_only=Tr"
        "ue, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='293e22721dacc741ea9c3a0f5dae702ad9468e87',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeRouteTablesResult'),
    ),
)
def _process_dataclass__293e22721dacc741ea9c3a0f5dae702ad9468e87():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                route_tables=self.route_tables,
                next_token=self.next_token,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.route_tables == other.route_tables and
                self.next_token == other.next_token
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'route_tables',
            'next_token',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'route_tables',
            'next_token',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.route_tables,
                self.next_token,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            route_tables: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            next_token: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'route_tables', route_tables)
            __dataclass__object_setattr(self, 'next_token', next_token)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"route_tables={self.route_tables!r}")
            parts.append(f"next_token={self.next_token!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('group_ids', 'group_names', 'next_token', 'max_results', 'dry_run', 'filters')), E"
        "qPlan(fields=('group_ids', 'group_names', 'next_token', 'max_results', 'dry_run', 'filters')), FrozenPlan(fiel"
        "ds=('__shape__', 'group_ids', 'group_names', 'next_token', 'max_results', 'dry_run', 'filters'), allow_dynamic"
        "_dunder_attrs=False), HashPlan(action='add', fields=('group_ids', 'group_names', 'next_token', 'max_results', "
        "'dry_run', 'filters'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='"
        "init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_ids', annotation=OpRef(n"
        "ame='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='group_names', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='init.fields.3.annotation'), defa"
        "ult=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_results', annotation=OpRef(n"
        "ame='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='dry_run', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None), InitPlan.Field(name='filters', annotation=OpRef(name='init.fields.6.annotation'), default=OpR"
        "ef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('group_id"
        "s', 'group_names', 'next_token', 'max_results', 'dry_run', 'filters'), frozen=True, slots=False, post_init_par"
        "ams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='group_ids', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='group_names', kw_only=True, fn=None), ReprPlan.Field(name='next_token', kw_only=True"
        ", fn=None), ReprPlan.Field(name='max_results', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only="
        "True, fn=None), ReprPlan.Field(name='filters', kw_only=True, fn=None)), id=False, terse=False, default_fn=None"
        ")))"
    ),
    plan_repr_sha1='00d5a06f8a67111c73bc3b7f92f2c26b2c8935c7',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeSecurityGroupsRequest'),
    ),
)
def _process_dataclass__00d5a06f8a67111c73bc3b7f92f2c26b2c8935c7():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                group_ids=self.group_ids,
                group_names=self.group_names,
                next_token=self.next_token,
                max_results=self.max_results,
                dry_run=self.dry_run,
                filters=self.filters,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.group_ids == other.group_ids and
                self.group_names == other.group_names and
                self.next_token == other.next_token and
                self.max_results == other.max_results and
                self.dry_run == other.dry_run and
                self.filters == other.filters
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'group_ids',
            'group_names',
            'next_token',
            'max_results',
            'dry_run',
            'filters',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'group_ids',
            'group_names',
            'next_token',
            'max_results',
            'dry_run',
            'filters',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.group_ids,
                self.group_names,
                self.next_token,
                self.max_results,
                self.dry_run,
                self.filters,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            group_ids: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            group_names: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            next_token: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            max_results: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            dry_run: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            filters: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'group_ids', group_ids)
            __dataclass__object_setattr(self, 'group_names', group_names)
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'max_results', max_results)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'filters', filters)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"group_ids={self.group_ids!r}")
            parts.append(f"group_names={self.group_names!r}")
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"max_results={self.max_results!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"filters={self.filters!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('next_token', 'security_groups')), EqPlan(fields=('next_token', 'security_groups')"
        "), FrozenPlan(fields=('__shape__', 'next_token', 'security_groups'), allow_dynamic_dunder_attrs=False), HashPl"
        "an(action='add', fields=('next_token', 'security_groups'), cache=False), InitPlan(fields=(InitPlan.Field(name="
        "'__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True,"
        " override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='next_token', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='security_groups', annotation=OpRef(name='init.fields.2.annotation'),"
        " default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_param"
        "s=('next_token', 'security_groups'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fn"
        "s=()), ReprPlan(fields=(ReprPlan.Field(name='next_token', kw_only=True, fn=None), ReprPlan.Field(name='securit"
        "y_groups', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='64bdc1aa50f0496ab696721dd6c679c10dd92687',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeSecurityGroupsResult'),
    ),
)
def _process_dataclass__64bdc1aa50f0496ab696721dd6c679c10dd92687():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                next_token=self.next_token,
                security_groups=self.security_groups,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.next_token == other.next_token and
                self.security_groups == other.security_groups
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'next_token',
            'security_groups',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'next_token',
            'security_groups',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.next_token,
                self.security_groups,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            security_groups: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'security_groups', security_groups)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"security_groups={self.security_groups!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('filters', 'subnet_ids', 'next_token', 'max_results', 'dry_run')), EqPlan(fields=("
        "'filters', 'subnet_ids', 'next_token', 'max_results', 'dry_run')), FrozenPlan(fields=('__shape__', 'filters', "
        "'subnet_ids', 'next_token', 'max_results', 'dry_run'), allow_dynamic_dunder_attrs=False), HashPlan(action='add"
        "', fields=('filters', 'subnet_ids', 'next_token', 'max_results', 'dry_run'), cache=False), InitPlan(fields=(In"
        "itPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factor"
        "y=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None"
        "), InitPlan.Field(name='filters', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init."
        "fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
        "e, validate=None, check_type=None), InitPlan.Field(name='subnet_ids', annotation=OpRef(name='init.fields.2.ann"
        "otation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', anno"
        "tation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='max_results', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.f"
        "ields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.5.annotat"
        "ion'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only"
        "_params=('filters', 'subnet_ids', 'next_token', 'max_results', 'dry_run'), frozen=True, slots=False, post_init"
        "_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='filters', kw_only=True, fn="
        "None), ReprPlan.Field(name='subnet_ids', kw_only=True, fn=None), ReprPlan.Field(name='next_token', kw_only=Tru"
        "e, fn=None), ReprPlan.Field(name='max_results', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only"
        "=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d877c5731a33eef1abbb55f28cce22256c852312',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeSubnetsRequest'),
    ),
)
def _process_dataclass__d877c5731a33eef1abbb55f28cce22256c852312():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                filters=self.filters,
                subnet_ids=self.subnet_ids,
                next_token=self.next_token,
                max_results=self.max_results,
                dry_run=self.dry_run,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.filters == other.filters and
                self.subnet_ids == other.subnet_ids and
                self.next_token == other.next_token and
                self.max_results == other.max_results and
                self.dry_run == other.dry_run
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'filters',
            'subnet_ids',
            'next_token',
            'max_results',
            'dry_run',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'filters',
            'subnet_ids',
            'next_token',
            'max_results',
            'dry_run',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.filters,
                self.subnet_ids,
                self.next_token,
                self.max_results,
                self.dry_run,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            filters: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            subnet_ids: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            next_token: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            max_results: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            dry_run: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'filters', filters)
            __dataclass__object_setattr(self, 'subnet_ids', subnet_ids)
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'max_results', max_results)
            __dataclass__object_setattr(self, 'dry_run', dry_run)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"filters={self.filters!r}")
            parts.append(f"subnet_ids={self.subnet_ids!r}")
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"max_results={self.max_results!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('next_token', 'subnets')), EqPlan(fields=('next_token', 'subnets')), FrozenPlan(fi"
        "elds=('__shape__', 'next_token', 'subnets'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields="
        "('next_token', 'subnets'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(na"
        "me='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=Op"
        "Ref(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init="
        "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
        "eld(name='subnets', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None)), self_param='self', std_params=(), kw_only_params=('next_token', 'subnets'), frozen=True"
        ", slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='nex"
        "t_token', kw_only=True, fn=None), ReprPlan.Field(name='subnets', kw_only=True, fn=None)), id=False, terse=Fals"
        "e, default_fn=None)))"
    ),
    plan_repr_sha1='fe250f783ecfe9530c43243559d68cf3aea75b7c',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeSubnetsResult'),
    ),
)
def _process_dataclass__fe250f783ecfe9530c43243559d68cf3aea75b7c():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                next_token=self.next_token,
                subnets=self.subnets,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.next_token == other.next_token and
                self.subnets == other.subnets
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'next_token',
            'subnets',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'next_token',
            'subnets',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.next_token,
                self.subnets,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            subnets: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'subnets', subnets)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"subnets={self.subnets!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('filters', 'vpc_ids', 'next_token', 'max_results', 'dry_run')), EqPlan(fields=('fi"
        "lters', 'vpc_ids', 'next_token', 'max_results', 'dry_run')), FrozenPlan(fields=('__shape__', 'filters', 'vpc_i"
        "ds', 'next_token', 'max_results', 'dry_run'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields"
        "=('filters', 'vpc_ids', 'next_token', 'max_results', 'dry_run'), cache=False), InitPlan(fields=(InitPlan.Field"
        "(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init"
        "=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='filters', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.def"
        "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
        "None, check_type=None), InitPlan.Field(name='vpc_ids', annotation=OpRef(name='init.fields.2.annotation'), defa"
        "ult=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(na"
        "me='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='max_results', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default"
        "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
        ", check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fields.5.annotation'), default="
        "OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('filte"
        "rs', 'vpc_ids', 'next_token', 'max_results', 'dry_run'), frozen=True, slots=False, post_init_params=None, init"
        "_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='filters', kw_only=True, fn=None), ReprPlan.Fi"
        "eld(name='vpc_ids', kw_only=True, fn=None), ReprPlan.Field(name='next_token', kw_only=True, fn=None), ReprPlan"
        ".Field(name='max_results', kw_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None)), id="
        "False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='cf7570e9b1968a56c54a998eaf8d69fc36327954',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeVpcsRequest'),
    ),
)
def _process_dataclass__cf7570e9b1968a56c54a998eaf8d69fc36327954():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                filters=self.filters,
                vpc_ids=self.vpc_ids,
                next_token=self.next_token,
                max_results=self.max_results,
                dry_run=self.dry_run,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.filters == other.filters and
                self.vpc_ids == other.vpc_ids and
                self.next_token == other.next_token and
                self.max_results == other.max_results and
                self.dry_run == other.dry_run
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'filters',
            'vpc_ids',
            'next_token',
            'max_results',
            'dry_run',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'filters',
            'vpc_ids',
            'next_token',
            'max_results',
            'dry_run',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.filters,
                self.vpc_ids,
                self.next_token,
                self.max_results,
                self.dry_run,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            filters: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            vpc_ids: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            next_token: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            max_results: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            dry_run: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'filters', filters)
            __dataclass__object_setattr(self, 'vpc_ids', vpc_ids)
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'max_results', max_results)
            __dataclass__object_setattr(self, 'dry_run', dry_run)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"filters={self.filters!r}")
            parts.append(f"vpc_ids={self.vpc_ids!r}")
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"max_results={self.max_results!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('next_token', 'vpcs')), EqPlan(fields=('next_token', 'vpcs')), FrozenPlan(fields=("
        "'__shape__', 'next_token', 'vpcs'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('next_to"
        "ken', 'vpcs'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fie"
        "lds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_"
        "VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='next_token', annotation=OpRef(name='in"
        "it.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vp"
        "cs', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None)), self_param='self', std_params=(), kw_only_params=('next_token', 'vpcs'), frozen=True, slots=False, pos"
        "t_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='next_token', kw_only="
        "True, fn=None), ReprPlan.Field(name='vpcs', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='dc682e377d184de1251ca50f451df77defad2270',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DescribeVpcsResult'),
    ),
)
def _process_dataclass__dc682e377d184de1251ca50f451df77defad2270():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                next_token=self.next_token,
                vpcs=self.vpcs,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.next_token == other.next_token and
                self.vpcs == other.vpcs
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'next_token',
            'vpcs',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'next_token',
            'vpcs',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.next_token,
                self.vpcs,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            next_token: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            vpcs: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'next_token', next_token)
            __dataclass__object_setattr(self, 'vpcs', vpcs)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"next_token={self.next_token!r}")
            parts.append(f"vpcs={self.vpcs!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('size_in_gb', 'count', 'type')), EqPlan(fields=('size_in_gb', 'count', 'type')), F"
        "rozenPlan(fields=('__shape__', 'size_in_gb', 'count', 'type'), allow_dynamic_dunder_attrs=False), HashPlan(act"
        "ion='add', fields=('size_in_gb', 'count', 'type'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape"
        "__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='si"
        "ze_in_gb', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), def"
        "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
        "_type=None), InitPlan.Field(name='count', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(nam"
        "e='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.3.a"
        "nnotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), k"
        "w_only_params=('size_in_gb', 'count', 'type'), frozen=True, slots=False, post_init_params=None, init_fns=(), v"
        "alidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='size_in_gb', kw_only=True, fn=None), ReprPlan.Field(nam"
        "e='count', kw_only=True, fn=None), ReprPlan.Field(name='type', kw_only=True, fn=None)), id=False, terse=False,"
        " default_fn=None)))"
    ),
    plan_repr_sha1='0e4d14f08b2bf721ea85332e6840f6f9f2badb03',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'DiskInfo'),
    ),
)
def _process_dataclass__0e4d14f08b2bf721ea85332e6840f6f9f2badb03():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                size_in_gb=self.size_in_gb,
                count=self.count,
                type=self.type,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.size_in_gb == other.size_in_gb and
                self.count == other.count and
                self.type == other.type
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'size_in_gb',
            'count',
            'type',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'size_in_gb',
            'count',
            'type',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.size_in_gb,
                self.count,
                self.type,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            size_in_gb: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            count: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            type: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'size_in_gb', size_in_gb)
            __dataclass__object_setattr(self, 'count', count)
            __dataclass__object_setattr(self, 'type', type)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"size_in_gb={self.size_in_gb!r}")
            parts.append(f"count={self.count!r}")
            parts.append(f"type={self.type!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('delete_on_termination', 'iops', 'snapshot_id', 'volume_size', 'volume_type', 'kms"
        "_key_id', 'throughput', 'outpost_arn', 'availability_zone', 'encrypted', 'volume_initialization_rate', 'availa"
        "bility_zone_id')), EqPlan(fields=('delete_on_termination', 'iops', 'snapshot_id', 'volume_size', 'volume_type'"
        ", 'kms_key_id', 'throughput', 'outpost_arn', 'availability_zone', 'encrypted', 'volume_initialization_rate', '"
        "availability_zone_id')), FrozenPlan(fields=('__shape__', 'delete_on_termination', 'iops', 'snapshot_id', 'volu"
        "me_size', 'volume_type', 'kms_key_id', 'throughput', 'outpost_arn', 'availability_zone', 'encrypted', 'volume_"
        "initialization_rate', 'availability_zone_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', field"
        "s=('delete_on_termination', 'iops', 'snapshot_id', 'volume_size', 'volume_type', 'kms_key_id', 'throughput', '"
        "outpost_arn', 'availability_zone', 'encrypted', 'volume_initialization_rate', 'availability_zone_id'), cache=F"
        "alse), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), de"
        "fault=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='delete_on_termination', annotation=OpRef(name='init.fields.1"
        ".annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='iops', annota"
        "tion=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='snapshot_id', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fie"
        "lds.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='volume_size', annotation=OpRef(name='init.fields.4.annot"
        "ation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='volume_type', annot"
        "ation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='kms_key_id', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fie"
        "lds.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='throughput', annotation=OpRef(name='init.fields.7.annota"
        "tion'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='outpost_arn', annota"
        "tion=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='availability_zone', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='in"
        "it.fields.9.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='encrypted', annotation=OpRef(name='init.fields.10."
        "annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='volume_initia"
        "lization_rate', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default"
        "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
        ", check_type=None), InitPlan.Field(name='availability_zone_id', annotation=OpRef(name='init.fields.12.annotati"
        "on'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only"
        "_params=('delete_on_termination', 'iops', 'snapshot_id', 'volume_size', 'volume_type', 'kms_key_id', 'throughp"
        "ut', 'outpost_arn', 'availability_zone', 'encrypted', 'volume_initialization_rate', 'availability_zone_id'), f"
        "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field"
        "(name='delete_on_termination', kw_only=True, fn=None), ReprPlan.Field(name='iops', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='snapshot_id', kw_only=True, fn=None), ReprPlan.Field(name='volume_size', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='volume_type', kw_only=True, fn=None), ReprPlan.Field(name='kms_key_id', kw_only=True"
        ", fn=None), ReprPlan.Field(name='throughput', kw_only=True, fn=None), ReprPlan.Field(name='outpost_arn', kw_on"
        "ly=True, fn=None), ReprPlan.Field(name='availability_zone', kw_only=True, fn=None), ReprPlan.Field(name='encry"
        "pted', kw_only=True, fn=None), ReprPlan.Field(name='volume_initialization_rate', kw_only=True, fn=None), ReprP"
        "lan.Field(name='availability_zone_id', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='16c0b384718e3d82c8fe94582190fd670ad7af6e',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'EbsBlockDevice'),
    ),
)
def _process_dataclass__16c0b384718e3d82c8fe94582190fd670ad7af6e():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                delete_on_termination=self.delete_on_termination,
                iops=self.iops,
                snapshot_id=self.snapshot_id,
                volume_size=self.volume_size,
                volume_type=self.volume_type,
                kms_key_id=self.kms_key_id,
                throughput=self.throughput,
                outpost_arn=self.outpost_arn,
                availability_zone=self.availability_zone,
                encrypted=self.encrypted,
                volume_initialization_rate=self.volume_initialization_rate,
                availability_zone_id=self.availability_zone_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.delete_on_termination == other.delete_on_termination and
                self.iops == other.iops and
                self.snapshot_id == other.snapshot_id and
                self.volume_size == other.volume_size and
                self.volume_type == other.volume_type and
                self.kms_key_id == other.kms_key_id and
                self.throughput == other.throughput and
                self.outpost_arn == other.outpost_arn and
                self.availability_zone == other.availability_zone and
                self.encrypted == other.encrypted and
                self.volume_initialization_rate == other.volume_initialization_rate and
                self.availability_zone_id == other.availability_zone_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'delete_on_termination',
            'iops',
            'snapshot_id',
            'volume_size',
            'volume_type',
            'kms_key_id',
            'throughput',
            'outpost_arn',
            'availability_zone',
            'encrypted',
            'volume_initialization_rate',
            'availability_zone_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'delete_on_termination',
            'iops',
            'snapshot_id',
            'volume_size',
            'volume_type',
            'kms_key_id',
            'throughput',
            'outpost_arn',
            'availability_zone',
            'encrypted',
            'volume_initialization_rate',
            'availability_zone_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.delete_on_termination,
                self.iops,
                self.snapshot_id,
                self.volume_size,
                self.volume_type,
                self.kms_key_id,
                self.throughput,
                self.outpost_arn,
                self.availability_zone,
                self.encrypted,
                self.volume_initialization_rate,
                self.availability_zone_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            delete_on_termination: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            iops: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            snapshot_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            volume_size: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            volume_type: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            kms_key_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            throughput: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            outpost_arn: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            availability_zone: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            encrypted: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            volume_initialization_rate: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            availability_zone_id: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'delete_on_termination', delete_on_termination)
            __dataclass__object_setattr(self, 'iops', iops)
            __dataclass__object_setattr(self, 'snapshot_id', snapshot_id)
            __dataclass__object_setattr(self, 'volume_size', volume_size)
            __dataclass__object_setattr(self, 'volume_type', volume_type)
            __dataclass__object_setattr(self, 'kms_key_id', kms_key_id)
            __dataclass__object_setattr(self, 'throughput', throughput)
            __dataclass__object_setattr(self, 'outpost_arn', outpost_arn)
            __dataclass__object_setattr(self, 'availability_zone', availability_zone)
            __dataclass__object_setattr(self, 'encrypted', encrypted)
            __dataclass__object_setattr(self, 'volume_initialization_rate', volume_initialization_rate)
            __dataclass__object_setattr(self, 'availability_zone_id', availability_zone_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"delete_on_termination={self.delete_on_termination!r}")
            parts.append(f"iops={self.iops!r}")
            parts.append(f"snapshot_id={self.snapshot_id!r}")
            parts.append(f"volume_size={self.volume_size!r}")
            parts.append(f"volume_type={self.volume_type!r}")
            parts.append(f"kms_key_id={self.kms_key_id!r}")
            parts.append(f"throughput={self.throughput!r}")
            parts.append(f"outpost_arn={self.outpost_arn!r}")
            parts.append(f"availability_zone={self.availability_zone!r}")
            parts.append(f"encrypted={self.encrypted!r}")
            parts.append(f"volume_initialization_rate={self.volume_initialization_rate!r}")
            parts.append(f"availability_zone_id={self.availability_zone_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ebs_optimized_support', 'encryption_support', 'ebs_optimized_info', 'nvme_support"
        "', 'maximum_ebs_attachments', 'attachment_limit_type')), EqPlan(fields=('ebs_optimized_support', 'encryption_s"
        "upport', 'ebs_optimized_info', 'nvme_support', 'maximum_ebs_attachments', 'attachment_limit_type')), FrozenPla"
        "n(fields=('__shape__', 'ebs_optimized_support', 'encryption_support', 'ebs_optimized_info', 'nvme_support', 'm"
        "aximum_ebs_attachments', 'attachment_limit_type'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', f"
        "ields=('ebs_optimized_support', 'encryption_support', 'ebs_optimized_info', 'nvme_support', 'maximum_ebs_attac"
        "hments', 'attachment_limit_type'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation="
        "OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ebs_optimized_supp"
        "ort', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='encryption_support', annotation=OpRef(name='init.fields.2.annotation'), default=O"
        "pRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ebs_optimized_info', annotation=OpRef"
        "(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='nvme_support', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.def"
        "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
        "None, check_type=None), InitPlan.Field(name='maximum_ebs_attachments', annotation=OpRef(name='init.fields.5.an"
        "notation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, fiel"
        "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='attachment_limit"
        "_type', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), defaul"
        "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
        "pe=None)), self_param='self', std_params=(), kw_only_params=('ebs_optimized_support', 'encryption_support', 'e"
        "bs_optimized_info', 'nvme_support', 'maximum_ebs_attachments', 'attachment_limit_type'), frozen=True, slots=Fa"
        "lse, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ebs_optimized"
        "_support', kw_only=True, fn=None), ReprPlan.Field(name='encryption_support', kw_only=True, fn=None), ReprPlan."
        "Field(name='ebs_optimized_info', kw_only=True, fn=None), ReprPlan.Field(name='nvme_support', kw_only=True, fn="
        "None), ReprPlan.Field(name='maximum_ebs_attachments', kw_only=True, fn=None), ReprPlan.Field(name='attachment_"
        "limit_type', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='537a23d4158e2fdeb7190c4a89f243a4bde76bb6',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'EbsInfo'),
    ),
)
def _process_dataclass__537a23d4158e2fdeb7190c4a89f243a4bde76bb6():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ebs_optimized_support=self.ebs_optimized_support,
                encryption_support=self.encryption_support,
                ebs_optimized_info=self.ebs_optimized_info,
                nvme_support=self.nvme_support,
                maximum_ebs_attachments=self.maximum_ebs_attachments,
                attachment_limit_type=self.attachment_limit_type,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ebs_optimized_support == other.ebs_optimized_support and
                self.encryption_support == other.encryption_support and
                self.ebs_optimized_info == other.ebs_optimized_info and
                self.nvme_support == other.nvme_support and
                self.maximum_ebs_attachments == other.maximum_ebs_attachments and
                self.attachment_limit_type == other.attachment_limit_type
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ebs_optimized_support',
            'encryption_support',
            'ebs_optimized_info',
            'nvme_support',
            'maximum_ebs_attachments',
            'attachment_limit_type',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ebs_optimized_support',
            'encryption_support',
            'ebs_optimized_info',
            'nvme_support',
            'maximum_ebs_attachments',
            'attachment_limit_type',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ebs_optimized_support,
                self.encryption_support,
                self.ebs_optimized_info,
                self.nvme_support,
                self.maximum_ebs_attachments,
                self.attachment_limit_type,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ebs_optimized_support: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            encryption_support: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            ebs_optimized_info: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            nvme_support: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            maximum_ebs_attachments: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            attachment_limit_type: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ebs_optimized_support', ebs_optimized_support)
            __dataclass__object_setattr(self, 'encryption_support', encryption_support)
            __dataclass__object_setattr(self, 'ebs_optimized_info', ebs_optimized_info)
            __dataclass__object_setattr(self, 'nvme_support', nvme_support)
            __dataclass__object_setattr(self, 'maximum_ebs_attachments', maximum_ebs_attachments)
            __dataclass__object_setattr(self, 'attachment_limit_type', attachment_limit_type)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ebs_optimized_support={self.ebs_optimized_support!r}")
            parts.append(f"encryption_support={self.encryption_support!r}")
            parts.append(f"ebs_optimized_info={self.ebs_optimized_info!r}")
            parts.append(f"nvme_support={self.nvme_support!r}")
            parts.append(f"maximum_ebs_attachments={self.maximum_ebs_attachments!r}")
            parts.append(f"attachment_limit_type={self.attachment_limit_type!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('attach_time', 'delete_on_termination', 'status', 'volume_id', 'associated_resourc"
        "e', 'volume_owner_id', 'operator')), EqPlan(fields=('attach_time', 'delete_on_termination', 'status', 'volume_"
        "id', 'associated_resource', 'volume_owner_id', 'operator')), FrozenPlan(fields=('__shape__', 'attach_time', 'd"
        "elete_on_termination', 'status', 'volume_id', 'associated_resource', 'volume_owner_id', 'operator'), allow_dyn"
        "amic_dunder_attrs=False), HashPlan(action='add', fields=('attach_time', 'delete_on_termination', 'status', 'vo"
        "lume_id', 'associated_resource', 'volume_owner_id', 'operator'), cache=False), InitPlan(fields=(InitPlan.Field"
        "(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init"
        "=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='attach_time', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None), InitPlan.Field(name='delete_on_termination', annotation=OpRef(name='init.fields.2."
        "annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='status', annot"
        "ation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='volume_id', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fiel"
        "ds.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None), InitPlan.Field(name='associated_resource', annotation=OpRef(name='init.fields."
        "5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='volume_owner"
        "_id', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='operator', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name="
        "'init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('attach_time', 'd"
        "elete_on_termination', 'status', 'volume_id', 'associated_resource', 'volume_owner_id', 'operator'), frozen=Tr"
        "ue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='a"
        "ttach_time', kw_only=True, fn=None), ReprPlan.Field(name='delete_on_termination', kw_only=True, fn=None), Repr"
        "Plan.Field(name='status', kw_only=True, fn=None), ReprPlan.Field(name='volume_id', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='associated_resource', kw_only=True, fn=None), ReprPlan.Field(name='volume_owner_id', kw_only"
        "=True, fn=None), ReprPlan.Field(name='operator', kw_only=True, fn=None)), id=False, terse=False, default_fn=No"
        "ne)))"
    ),
    plan_repr_sha1='efd31e877496bbd3d9214c4b87b5775f30e0bd24',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'EbsInstanceBlockDevice'),
    ),
)
def _process_dataclass__efd31e877496bbd3d9214c4b87b5775f30e0bd24():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                attach_time=self.attach_time,
                delete_on_termination=self.delete_on_termination,
                status=self.status,
                volume_id=self.volume_id,
                associated_resource=self.associated_resource,
                volume_owner_id=self.volume_owner_id,
                operator=self.operator,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.attach_time == other.attach_time and
                self.delete_on_termination == other.delete_on_termination and
                self.status == other.status and
                self.volume_id == other.volume_id and
                self.associated_resource == other.associated_resource and
                self.volume_owner_id == other.volume_owner_id and
                self.operator == other.operator
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'attach_time',
            'delete_on_termination',
            'status',
            'volume_id',
            'associated_resource',
            'volume_owner_id',
            'operator',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'attach_time',
            'delete_on_termination',
            'status',
            'volume_id',
            'associated_resource',
            'volume_owner_id',
            'operator',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.attach_time,
                self.delete_on_termination,
                self.status,
                self.volume_id,
                self.associated_resource,
                self.volume_owner_id,
                self.operator,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            attach_time: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            delete_on_termination: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            status: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            volume_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            associated_resource: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            volume_owner_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            operator: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'attach_time', attach_time)
            __dataclass__object_setattr(self, 'delete_on_termination', delete_on_termination)
            __dataclass__object_setattr(self, 'status', status)
            __dataclass__object_setattr(self, 'volume_id', volume_id)
            __dataclass__object_setattr(self, 'associated_resource', associated_resource)
            __dataclass__object_setattr(self, 'volume_owner_id', volume_owner_id)
            __dataclass__object_setattr(self, 'operator', operator)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"attach_time={self.attach_time!r}")
            parts.append(f"delete_on_termination={self.delete_on_termination!r}")
            parts.append(f"status={self.status!r}")
            parts.append(f"volume_id={self.volume_id!r}")
            parts.append(f"associated_resource={self.associated_resource!r}")
            parts.append(f"volume_owner_id={self.volume_owner_id!r}")
            parts.append(f"operator={self.operator!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('baseline_bandwidth_in_mbips', 'baseline_throughput_in_mbps', 'baseline_iops', 'ma"
        "ximum_bandwidth_in_mbips', 'maximum_throughput_in_mbps', 'maximum_iops')), EqPlan(fields=('baseline_bandwidth_"
        "in_mbips', 'baseline_throughput_in_mbps', 'baseline_iops', 'maximum_bandwidth_in_mbips', 'maximum_throughput_i"
        "n_mbps', 'maximum_iops')), FrozenPlan(fields=('__shape__', 'baseline_bandwidth_in_mbips', 'baseline_throughput"
        "_in_mbps', 'baseline_iops', 'maximum_bandwidth_in_mbips', 'maximum_throughput_in_mbps', 'maximum_iops'), allow"
        "_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('baseline_bandwidth_in_mbips', 'baseline_throughp"
        "ut_in_mbps', 'baseline_iops', 'maximum_bandwidth_in_mbips', 'maximum_throughput_in_mbps', 'maximum_iops'), cac"
        "he=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation')"
        ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='baseline_bandwidth_in_mbips', annotation=OpRef(name='ini"
        "t.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='bas"
        "eline_throughput_in_mbps', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields."
        "2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='baseline_iops', annotation=OpRef(name='init.fields.3.annotat"
        "ion'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maximum_bandwidth_in_"
        "mbips', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), defaul"
        "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
        "pe=None), InitPlan.Field(name='maximum_throughput_in_mbps', annotation=OpRef(name='init.fields.5.annotation'),"
        " default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maximum_iops', annotation=O"
        "pRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init"
        "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_para"
        "m='self', std_params=(), kw_only_params=('baseline_bandwidth_in_mbips', 'baseline_throughput_in_mbps', 'baseli"
        "ne_iops', 'maximum_bandwidth_in_mbips', 'maximum_throughput_in_mbps', 'maximum_iops'), frozen=True, slots=Fals"
        "e, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='baseline_bandwi"
        "dth_in_mbips', kw_only=True, fn=None), ReprPlan.Field(name='baseline_throughput_in_mbps', kw_only=True, fn=Non"
        "e), ReprPlan.Field(name='baseline_iops', kw_only=True, fn=None), ReprPlan.Field(name='maximum_bandwidth_in_mbi"
        "ps', kw_only=True, fn=None), ReprPlan.Field(name='maximum_throughput_in_mbps', kw_only=True, fn=None), ReprPla"
        "n.Field(name='maximum_iops', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='51006c1b622c9ec07035558b55fb10d01681ba12',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'EbsOptimizedInfo'),
    ),
)
def _process_dataclass__51006c1b622c9ec07035558b55fb10d01681ba12():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                baseline_bandwidth_in_mbips=self.baseline_bandwidth_in_mbips,
                baseline_throughput_in_mbps=self.baseline_throughput_in_mbps,
                baseline_iops=self.baseline_iops,
                maximum_bandwidth_in_mbips=self.maximum_bandwidth_in_mbips,
                maximum_throughput_in_mbps=self.maximum_throughput_in_mbps,
                maximum_iops=self.maximum_iops,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.baseline_bandwidth_in_mbips == other.baseline_bandwidth_in_mbips and
                self.baseline_throughput_in_mbps == other.baseline_throughput_in_mbps and
                self.baseline_iops == other.baseline_iops and
                self.maximum_bandwidth_in_mbips == other.maximum_bandwidth_in_mbips and
                self.maximum_throughput_in_mbps == other.maximum_throughput_in_mbps and
                self.maximum_iops == other.maximum_iops
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'baseline_bandwidth_in_mbips',
            'baseline_throughput_in_mbps',
            'baseline_iops',
            'maximum_bandwidth_in_mbips',
            'maximum_throughput_in_mbps',
            'maximum_iops',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'baseline_bandwidth_in_mbips',
            'baseline_throughput_in_mbps',
            'baseline_iops',
            'maximum_bandwidth_in_mbips',
            'maximum_throughput_in_mbps',
            'maximum_iops',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.baseline_bandwidth_in_mbips,
                self.baseline_throughput_in_mbps,
                self.baseline_iops,
                self.maximum_bandwidth_in_mbips,
                self.maximum_throughput_in_mbps,
                self.maximum_iops,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            baseline_bandwidth_in_mbips: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            baseline_throughput_in_mbps: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            baseline_iops: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            maximum_bandwidth_in_mbips: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            maximum_throughput_in_mbps: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            maximum_iops: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'baseline_bandwidth_in_mbips', baseline_bandwidth_in_mbips)
            __dataclass__object_setattr(self, 'baseline_throughput_in_mbps', baseline_throughput_in_mbps)
            __dataclass__object_setattr(self, 'baseline_iops', baseline_iops)
            __dataclass__object_setattr(self, 'maximum_bandwidth_in_mbips', maximum_bandwidth_in_mbips)
            __dataclass__object_setattr(self, 'maximum_throughput_in_mbps', maximum_throughput_in_mbps)
            __dataclass__object_setattr(self, 'maximum_iops', maximum_iops)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"baseline_bandwidth_in_mbips={self.baseline_bandwidth_in_mbips!r}")
            parts.append(f"baseline_throughput_in_mbps={self.baseline_throughput_in_mbps!r}")
            parts.append(f"baseline_iops={self.baseline_iops!r}")
            parts.append(f"maximum_bandwidth_in_mbips={self.maximum_bandwidth_in_mbips!r}")
            parts.append(f"maximum_throughput_in_mbps={self.maximum_throughput_in_mbps!r}")
            parts.append(f"maximum_iops={self.maximum_iops!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('maximum_efa_interfaces',)), EqPlan(fields=('maximum_efa_interfaces',)), FrozenPla"
        "n(fields=('__shape__', 'maximum_efa_interfaces'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fi"
        "elds=('maximum_efa_interfaces',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=O"
        "pRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maximum_efa_interfa"
        "ces', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None)), self_param='self', std_params=(), kw_only_params=('maximum_efa_interfaces',), frozen=True, slots=Fals"
        "e, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='maximum_efa_int"
        "erfaces', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='f903ef18eed410fa657136064564ce91a649daee',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'EfaInfo'),
    ),
)
def _process_dataclass__f903ef18eed410fa657136064564ce91a649daee():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                maximum_efa_interfaces=self.maximum_efa_interfaces,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.maximum_efa_interfaces == other.maximum_efa_interfaces
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'maximum_efa_interfaces',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'maximum_efa_interfaces',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.maximum_efa_interfaces,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            maximum_efa_interfaces: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'maximum_efa_interfaces', maximum_efa_interfaces)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"maximum_efa_interfaces={self.maximum_efa_interfaces!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('elastic_gpu_id', 'elastic_gpu_association_id', 'elastic_gpu_association_state', '"
        "elastic_gpu_association_time')), EqPlan(fields=('elastic_gpu_id', 'elastic_gpu_association_id', 'elastic_gpu_a"
        "ssociation_state', 'elastic_gpu_association_time')), FrozenPlan(fields=('__shape__', 'elastic_gpu_id', 'elasti"
        "c_gpu_association_id', 'elastic_gpu_association_state', 'elastic_gpu_association_time'), allow_dynamic_dunder_"
        "attrs=False), HashPlan(action='add', fields=('elastic_gpu_id', 'elastic_gpu_association_id', 'elastic_gpu_asso"
        "ciation_state', 'elastic_gpu_association_time'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__"
        "', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override="
        "False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='elas"
        "tic_gpu_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), d"
        "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='elastic_gpu_association_id', annotation=OpRef(name='init.fields.2.annotati"
        "on'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type"
        "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='elastic_gpu_associatio"
        "n_state', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='elastic_gpu_association_time', annotation=OpRef(name='init.fields.4.annotatio"
        "n'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type="
        "FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_p"
        "arams=('elastic_gpu_id', 'elastic_gpu_association_id', 'elastic_gpu_association_state', 'elastic_gpu_associati"
        "on_time'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Re"
        "prPlan.Field(name='elastic_gpu_id', kw_only=True, fn=None), ReprPlan.Field(name='elastic_gpu_association_id', "
        "kw_only=True, fn=None), ReprPlan.Field(name='elastic_gpu_association_state', kw_only=True, fn=None), ReprPlan."
        "Field(name='elastic_gpu_association_time', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='f30d75dad1fb5a55a81dc40317df8e7e42201245',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'ElasticGpuAssociation'),
    ),
)
def _process_dataclass__f30d75dad1fb5a55a81dc40317df8e7e42201245():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                elastic_gpu_id=self.elastic_gpu_id,
                elastic_gpu_association_id=self.elastic_gpu_association_id,
                elastic_gpu_association_state=self.elastic_gpu_association_state,
                elastic_gpu_association_time=self.elastic_gpu_association_time,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.elastic_gpu_id == other.elastic_gpu_id and
                self.elastic_gpu_association_id == other.elastic_gpu_association_id and
                self.elastic_gpu_association_state == other.elastic_gpu_association_state and
                self.elastic_gpu_association_time == other.elastic_gpu_association_time
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'elastic_gpu_id',
            'elastic_gpu_association_id',
            'elastic_gpu_association_state',
            'elastic_gpu_association_time',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'elastic_gpu_id',
            'elastic_gpu_association_id',
            'elastic_gpu_association_state',
            'elastic_gpu_association_time',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.elastic_gpu_id,
                self.elastic_gpu_association_id,
                self.elastic_gpu_association_state,
                self.elastic_gpu_association_time,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            elastic_gpu_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            elastic_gpu_association_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            elastic_gpu_association_state: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            elastic_gpu_association_time: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'elastic_gpu_id', elastic_gpu_id)
            __dataclass__object_setattr(self, 'elastic_gpu_association_id', elastic_gpu_association_id)
            __dataclass__object_setattr(self, 'elastic_gpu_association_state', elastic_gpu_association_state)
            __dataclass__object_setattr(self, 'elastic_gpu_association_time', elastic_gpu_association_time)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"elastic_gpu_id={self.elastic_gpu_id!r}")
            parts.append(f"elastic_gpu_association_id={self.elastic_gpu_association_id!r}")
            parts.append(f"elastic_gpu_association_state={self.elastic_gpu_association_state!r}")
            parts.append(f"elastic_gpu_association_time={self.elastic_gpu_association_time!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('type',)), EqPlan(fields=('type',)), FrozenPlan(fields=('__shape__', 'type'), allo"
        "w_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('type',), cache=False), InitPlan(fields=(InitPla"
        "n.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='type', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), se"
        "lf_param='self', std_params=(), kw_only_params=('type',), frozen=True, slots=False, post_init_params=None, ini"
        "t_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='type', kw_only=True, fn=None),), id=False, t"
        "erse=False, default_fn=None)))"
    ),
    plan_repr_sha1='f6090dfb9aefee115aacb52174a1d6ede3fcc318',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'ElasticGpuSpecification'),
    ),
)
def _process_dataclass__f6090dfb9aefee115aacb52174a1d6ede3fcc318():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                type=self.type,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.type == other.type
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'type',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'type',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.type,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            type: __dataclass__init__fields__1__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'type', type)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"type={self.type!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('type', 'count')), EqPlan(fields=('type', 'count')), FrozenPlan(fields=('__shape__"
        "', 'type', 'count'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('type', 'count'), cache"
        "=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), "
        "default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.1.annotation'), "
        "default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='count', annotation=OpRef(name='init.fields.2.annotation'), "
        "default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params"
        "=('type', 'count'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(f"
        "ields=(ReprPlan.Field(name='type', kw_only=True, fn=None), ReprPlan.Field(name='count', kw_only=True, fn=None)"
        "), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='ea86637d45790a9ba24b794df89ae7899e5d8876',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'ElasticInferenceAccelerator'),
    ),
)
def _process_dataclass__ea86637d45790a9ba24b794df89ae7899e5d8876():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                type=self.type,
                count=self.count,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.type == other.type and
                self.count == other.count
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'type',
            'count',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'type',
            'count',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.type,
                self.count,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            type: __dataclass__init__fields__1__annotation,
            count: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'type', type)
            __dataclass__object_setattr(self, 'count', count)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"type={self.type!r}")
            parts.append(f"count={self.count!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('elastic_inference_accelerator_arn', 'elastic_inference_accelerator_association_id"
        "', 'elastic_inference_accelerator_association_state', 'elastic_inference_accelerator_association_time')), EqPl"
        "an(fields=('elastic_inference_accelerator_arn', 'elastic_inference_accelerator_association_id', 'elastic_infer"
        "ence_accelerator_association_state', 'elastic_inference_accelerator_association_time')), FrozenPlan(fields=('_"
        "_shape__', 'elastic_inference_accelerator_arn', 'elastic_inference_accelerator_association_id', 'elastic_infer"
        "ence_accelerator_association_state', 'elastic_inference_accelerator_association_time'), allow_dynamic_dunder_a"
        "ttrs=False), HashPlan(action='add', fields=('elastic_inference_accelerator_arn', 'elastic_inference_accelerato"
        "r_association_id', 'elastic_inference_accelerator_association_state', 'elastic_inference_accelerator_associati"
        "on_time'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields."
        "0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR,"
        " coerce=None, validate=None, check_type=None), InitPlan.Field(name='elastic_inference_accelerator_arn', annota"
        "tion=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='elastic_inference_accelerator_association_id', annotation=OpRef(name='init.fields.2.annotatio"
        "n'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type="
        "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='elastic_inference_accel"
        "erator_association_state', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields."
        "3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='elastic_inference_accelerator_association_time', annotation="
        "OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_par"
        "am='self', std_params=(), kw_only_params=('elastic_inference_accelerator_arn', 'elastic_inference_accelerator_"
        "association_id', 'elastic_inference_accelerator_association_state', 'elastic_inference_accelerator_association"
        "_time'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Repr"
        "Plan.Field(name='elastic_inference_accelerator_arn', kw_only=True, fn=None), ReprPlan.Field(name='elastic_infe"
        "rence_accelerator_association_id', kw_only=True, fn=None), ReprPlan.Field(name='elastic_inference_accelerator_"
        "association_state', kw_only=True, fn=None), ReprPlan.Field(name='elastic_inference_accelerator_association_tim"
        "e', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='38372d55a38969f4bb824633424abf668717c1f4',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'ElasticInferenceAcceleratorAssociation'),
    ),
)
def _process_dataclass__38372d55a38969f4bb824633424abf668717c1f4():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                elastic_inference_accelerator_arn=self.elastic_inference_accelerator_arn,
                elastic_inference_accelerator_association_id=self.elastic_inference_accelerator_association_id,
                elastic_inference_accelerator_association_state=self.elastic_inference_accelerator_association_state,
                elastic_inference_accelerator_association_time=self.elastic_inference_accelerator_association_time,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.elastic_inference_accelerator_arn == other.elastic_inference_accelerator_arn and
                self.elastic_inference_accelerator_association_id == other.elastic_inference_accelerator_association_id and
                self.elastic_inference_accelerator_association_state == other.elastic_inference_accelerator_association_state and
                self.elastic_inference_accelerator_association_time == other.elastic_inference_accelerator_association_time
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'elastic_inference_accelerator_arn',
            'elastic_inference_accelerator_association_id',
            'elastic_inference_accelerator_association_state',
            'elastic_inference_accelerator_association_time',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'elastic_inference_accelerator_arn',
            'elastic_inference_accelerator_association_id',
            'elastic_inference_accelerator_association_state',
            'elastic_inference_accelerator_association_time',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.elastic_inference_accelerator_arn,
                self.elastic_inference_accelerator_association_id,
                self.elastic_inference_accelerator_association_state,
                self.elastic_inference_accelerator_association_time,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            elastic_inference_accelerator_arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            elastic_inference_accelerator_association_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            elastic_inference_accelerator_association_state: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            elastic_inference_accelerator_association_time: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'elastic_inference_accelerator_arn', elastic_inference_accelerator_arn)
            __dataclass__object_setattr(self, 'elastic_inference_accelerator_association_id', elastic_inference_accelerator_association_id)
            __dataclass__object_setattr(self, 'elastic_inference_accelerator_association_state', elastic_inference_accelerator_association_state)
            __dataclass__object_setattr(self, 'elastic_inference_accelerator_association_time', elastic_inference_accelerator_association_time)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"elastic_inference_accelerator_arn={self.elastic_inference_accelerator_arn!r}")
            parts.append(f"elastic_inference_accelerator_association_id={self.elastic_inference_accelerator_association_id!r}")
            parts.append(f"elastic_inference_accelerator_association_state={self.elastic_inference_accelerator_association_state!r}")
            parts.append(f"elastic_inference_accelerator_association_time={self.elastic_inference_accelerator_association_time!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('enabled',)), EqPlan(fields=('enabled',)), FrozenPlan(fields=('__shape__', 'enable"
        "d'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('enabled',), cache=False), InitPlan(fie"
        "lds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default"
        "_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_ty"
        "pe=None), InitPlan.Field(name='enabled', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name"
        "='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('enabled',), fro"
        "zen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(n"
        "ame='enabled', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='bf29f91bc455fecb2ff96fc4818097e80745770c',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'EnclaveOptions'),
        ('ominfra.clouds.aws.models.services.ec2', 'EnclaveOptionsRequest'),
    ),
)
def _process_dataclass__bf29f91bc455fecb2ff96fc4818097e80745770c():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                enabled=self.enabled,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.enabled == other.enabled
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'enabled',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'enabled',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.enabled,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            enabled: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'enabled', enabled)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"enabled={self.enabled!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('name', 'values')), EqPlan(fields=('name', 'values')), FrozenPlan(fields=('__shape"
        "__', 'name', 'values'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'values'), c"
        "ache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation"
        "'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation"
        "'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=F"
        "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='values', annotation=OpRe"
        "f(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='"
        "self', std_params=(), kw_only_params=('name', 'values'), frozen=True, slots=False, post_init_params=None, init"
        "_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field"
        "(name='values', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='ee43e7a1aa970fe321ca99f2a70e7310b221e1aa',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Filter'),
    ),
)
def _process_dataclass__ee43e7a1aa970fe321ca99f2a70e7310b221e1aa():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                name=self.name,
                values=self.values,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.name == other.name and
                self.values == other.values
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'name',
            'values',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'name',
            'values',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.name,
                self.values,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            values: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'name', name)
            __dataclass__object_setattr(self, 'values', values)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"name={self.name!r}")
            parts.append(f"values={self.values!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('name', 'manufacturer', 'count', 'memory_info')), EqPlan(fields=('name', 'manufact"
        "urer', 'count', 'memory_info')), FrozenPlan(fields=('__shape__', 'name', 'manufacturer', 'count', 'memory_info"
        "'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'manufacturer', 'count', 'memory"
        "_info'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0."
        "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, c"
        "oerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1."
        "annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='manufacturer',"
        " annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_facto"
        "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
        "), InitPlan.Field(name='count', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fi"
        "elds.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='memory_info', annotation=OpRef(name='init.fields.4.anno"
        "tation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_o"
        "nly_params=('name', 'manufacturer', 'count', 'memory_info'), frozen=True, slots=False, post_init_params=None, "
        "init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.F"
        "ield(name='manufacturer', kw_only=True, fn=None), ReprPlan.Field(name='count', kw_only=True, fn=None), ReprPla"
        "n.Field(name='memory_info', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='918337ad51941fcd8bd3f26ae88abd374c057231',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'FpgaDeviceInfo'),
        ('ominfra.clouds.aws.models.services.ec2', 'GpuDeviceInfo'),
    ),
)
def _process_dataclass__918337ad51941fcd8bd3f26ae88abd374c057231():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                name=self.name,
                manufacturer=self.manufacturer,
                count=self.count,
                memory_info=self.memory_info,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.name == other.name and
                self.manufacturer == other.manufacturer and
                self.count == other.count and
                self.memory_info == other.memory_info
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'name',
            'manufacturer',
            'count',
            'memory_info',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'name',
            'manufacturer',
            'count',
            'memory_info',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.name,
                self.manufacturer,
                self.count,
                self.memory_info,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            manufacturer: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            count: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            memory_info: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'name', name)
            __dataclass__object_setattr(self, 'manufacturer', manufacturer)
            __dataclass__object_setattr(self, 'count', count)
            __dataclass__object_setattr(self, 'memory_info', memory_info)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"name={self.name!r}")
            parts.append(f"manufacturer={self.manufacturer!r}")
            parts.append(f"count={self.count!r}")
            parts.append(f"memory_info={self.memory_info!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('size_in_mi_b',)), EqPlan(fields=('size_in_mi_b',)), FrozenPlan(fields=('__shape__"
        "', 'size_in_mi_b'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('size_in_mi_b',), cache="
        "False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), d"
        "efault=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='size_in_mi_b', annotation=OpRef(name='init.fields.1.annotat"
        "ion'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only"
        "_params=('size_in_mi_b',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Rep"
        "rPlan(fields=(ReprPlan.Field(name='size_in_mi_b', kw_only=True, fn=None),), id=False, terse=False, default_fn="
        "None)))"
    ),
    plan_repr_sha1='9a0c4e3e2d7a9d7db1c242fbe40ecb8b8b1d2361',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'FpgaDeviceMemoryInfo'),
        ('ominfra.clouds.aws.models.services.ec2', 'GpuDeviceMemoryInfo'),
        ('ominfra.clouds.aws.models.services.ec2', 'InferenceDeviceMemoryInfo'),
        ('ominfra.clouds.aws.models.services.ec2', 'MediaDeviceMemoryInfo'),
        ('ominfra.clouds.aws.models.services.ec2', 'MemoryInfo'),
        ('ominfra.clouds.aws.models.services.ec2', 'NeuronDeviceMemoryInfo'),
    ),
)
def _process_dataclass__9a0c4e3e2d7a9d7db1c242fbe40ecb8b8b1d2361():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                size_in_mi_b=self.size_in_mi_b,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.size_in_mi_b == other.size_in_mi_b
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'size_in_mi_b',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'size_in_mi_b',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.size_in_mi_b,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            size_in_mi_b: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'size_in_mi_b', size_in_mi_b)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"size_in_mi_b={self.size_in_mi_b!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('fpgas', 'total_fpga_memory_in_mi_b')), EqPlan(fields=('fpgas', 'total_fpga_memory"
        "_in_mi_b')), FrozenPlan(fields=('__shape__', 'fpgas', 'total_fpga_memory_in_mi_b'), allow_dynamic_dunder_attrs"
        "=False), HashPlan(action='add', fields=('fpgas', 'total_fpga_memory_in_mi_b'), cache=False), InitPlan(fields=("
        "InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='fpgas', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init."
        "fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
        "e, validate=None, check_type=None), InitPlan.Field(name='total_fpga_memory_in_mi_b', annotation=OpRef(name='in"
        "it.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std"
        "_params=(), kw_only_params=('fpgas', 'total_fpga_memory_in_mi_b'), frozen=True, slots=False, post_init_params="
        "None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='fpgas', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='total_fpga_memory_in_mi_b', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)"
        "))"
    ),
    plan_repr_sha1='b47f98d2dfe23b3a2cf6a92d0f4c034225e81fae',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'FpgaInfo'),
    ),
)
def _process_dataclass__b47f98d2dfe23b3a2cf6a92d0f4c034225e81fae():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                fpgas=self.fpgas,
                total_fpga_memory_in_mi_b=self.total_fpga_memory_in_mi_b,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.fpgas == other.fpgas and
                self.total_fpga_memory_in_mi_b == other.total_fpga_memory_in_mi_b
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'fpgas',
            'total_fpga_memory_in_mi_b',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'fpgas',
            'total_fpga_memory_in_mi_b',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.fpgas,
                self.total_fpga_memory_in_mi_b,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            fpgas: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            total_fpga_memory_in_mi_b: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'fpgas', fpgas)
            __dataclass__object_setattr(self, 'total_fpga_memory_in_mi_b', total_fpga_memory_in_mi_b)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"fpgas={self.fpgas!r}")
            parts.append(f"total_fpga_memory_in_mi_b={self.total_fpga_memory_in_mi_b!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('gpus', 'total_gpu_memory_in_mi_b')), EqPlan(fields=('gpus', 'total_gpu_memory_in_"
        "mi_b')), FrozenPlan(fields=('__shape__', 'gpus', 'total_gpu_memory_in_mi_b'), allow_dynamic_dunder_attrs=False"
        "), HashPlan(action='add', fields=('gpus', 'total_gpu_memory_in_mi_b'), cache=False), InitPlan(fields=(InitPlan"
        ".Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None"
        ", init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='gpus', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='total_gpu_memory_in_mi_b', annotation=OpRef(name='init.fields."
        "2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=()"
        ", kw_only_params=('gpus', 'total_gpu_memory_in_mi_b'), frozen=True, slots=False, post_init_params=None, init_f"
        "ns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='gpus', kw_only=True, fn=None), ReprPlan.Field(n"
        "ame='total_gpu_memory_in_mi_b', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='716db2b453a7379781d728ae63db1a6fd30a0069',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'GpuInfo'),
    ),
)
def _process_dataclass__716db2b453a7379781d728ae63db1a6fd30a0069():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                gpus=self.gpus,
                total_gpu_memory_in_mi_b=self.total_gpu_memory_in_mi_b,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.gpus == other.gpus and
                self.total_gpu_memory_in_mi_b == other.total_gpu_memory_in_mi_b
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'gpus',
            'total_gpu_memory_in_mi_b',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'gpus',
            'total_gpu_memory_in_mi_b',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.gpus,
                self.total_gpu_memory_in_mi_b,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            gpus: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            total_gpu_memory_in_mi_b: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'gpus', gpus)
            __dataclass__object_setattr(self, 'total_gpu_memory_in_mi_b', total_gpu_memory_in_mi_b)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"gpus={self.gpus!r}")
            parts.append(f"total_gpu_memory_in_mi_b={self.total_gpu_memory_in_mi_b!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('group_id', 'group_name')), EqPlan(fields=('group_id', 'group_name')), FrozenPlan("
        "fields=('__shape__', 'group_id', 'group_name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fiel"
        "ds=('group_id', 'group_name'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRe"
        "f(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type="
        "FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_id', annotation="
        "OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='group_name', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('group_id', 'group_name'), froze"
        "n=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
        "e='group_id', kw_only=True, fn=None), ReprPlan.Field(name='group_name', kw_only=True, fn=None)), id=False, ter"
        "se=False, default_fn=None)))"
    ),
    plan_repr_sha1='be5230305c7479cce885630743068b6dd28216ec',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'GroupIdentifier'),
    ),
)
def _process_dataclass__be5230305c7479cce885630743068b6dd28216ec():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                group_id=self.group_id,
                group_name=self.group_name,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.group_id == other.group_id and
                self.group_name == other.group_name
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'group_id',
            'group_name',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'group_id',
            'group_name',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.group_id,
                self.group_name,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            group_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            group_name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'group_id', group_id)
            __dataclass__object_setattr(self, 'group_name', group_name)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"group_id={self.group_id!r}")
            parts.append(f"group_name={self.group_name!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('configured',)), EqPlan(fields=('configured',)), FrozenPlan(fields=('__shape__', '"
        "configured'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('configured',), cache=False), "
        "InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=N"
        "one, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='configured', annotation=OpRef(name='init.fields.1.annotation'), def"
        "ault=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('"
        "configured',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields"
        "=(ReprPlan.Field(name='configured', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='bfb29a4d3541281cf2ad9adb1c9aa94bee08ff4d',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'HibernationOptions'),
        ('ominfra.clouds.aws.models.services.ec2', 'HibernationOptionsRequest'),
    ),
)
def _process_dataclass__bfb29a4d3541281cf2ad9adb1c9aa94bee08ff4d():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                configured=self.configured,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.configured == other.configured
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'configured',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'configured',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.configured,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            configured: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'configured', configured)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"configured={self.configured!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('arn', 'id')), EqPlan(fields=('arn', 'id')), FrozenPlan(fields=('__shape__', 'arn'"
        ", 'id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('arn', 'id'), cache=False), InitPla"
        "n(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='arn', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(nam"
        "e='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='id', annotation=OpRef(name='init.fields.2.ann"
        "otation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_"
        "only_params=('arn', 'id'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Rep"
        "rPlan(fields=(ReprPlan.Field(name='arn', kw_only=True, fn=None), ReprPlan.Field(name='id', kw_only=True, fn=No"
        "ne)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='26074b459cb2fb0408156461ee64ccdb2fce7cad',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'IamInstanceProfile'),
    ),
)
def _process_dataclass__26074b459cb2fb0408156461ee64ccdb2fce7cad():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                arn=self.arn,
                id=self.id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.arn == other.arn and
                self.id == other.id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'arn',
            'id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'arn',
            'id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.arn,
                self.id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'arn', arn)
            __dataclass__object_setattr(self, 'id', id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"arn={self.arn!r}")
            parts.append(f"id={self.id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('arn', 'name')), EqPlan(fields=('arn', 'name')), FrozenPlan(fields=('__shape__', '"
        "arn', 'name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('arn', 'name'), cache=False),"
        " InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default="
        "None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=N"
        "one, check_type=None), InitPlan.Field(name='arn', annotation=OpRef(name='init.fields.1.annotation'), default=O"
        "pRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fi"
        "elds.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_para"
        "ms=(), kw_only_params=('arn', 'name'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_"
        "fns=()), ReprPlan(fields=(ReprPlan.Field(name='arn', kw_only=True, fn=None), ReprPlan.Field(name='name', kw_on"
        "ly=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='393cef70a0276465bcd054e4c1e3f3361f57d405',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'IamInstanceProfileSpecification'),
    ),
)
def _process_dataclass__393cef70a0276465bcd054e4c1e3f3361f57d405():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                arn=self.arn,
                name=self.name,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.arn == other.arn and
                self.name == other.name
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'arn',
            'name',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'arn',
            'name',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.arn,
                self.name,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'arn', arn)
            __dataclass__object_setattr(self, 'name', name)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"arn={self.arn!r}")
            parts.append(f"name={self.name!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('platform_details', 'usage_operation', 'block_device_mappings', 'description', 'en"
        "a_support', 'hypervisor', 'image_owner_alias', 'name', 'root_device_name', 'root_device_type', 'sriov_net_supp"
        "ort', 'state_reason', 'tags', 'virtualization_type', 'boot_mode', 'tpm_support', 'deprecation_time', 'imds_sup"
        "port', 'source_instance_id', 'deregistration_protection', 'last_launched_time', 'image_allowed', 'source_image"
        "_id', 'source_image_region', 'free_tier_eligible', 'image_id', 'image_location', 'state', 'owner_id', 'creatio"
        "n_date', 'public', 'product_codes', 'architecture', 'image_type', 'kernel_id', 'ramdisk_id', 'platform')), EqP"
        "lan(fields=('platform_details', 'usage_operation', 'block_device_mappings', 'description', 'ena_support', 'hyp"
        "ervisor', 'image_owner_alias', 'name', 'root_device_name', 'root_device_type', 'sriov_net_support', 'state_rea"
        "son', 'tags', 'virtualization_type', 'boot_mode', 'tpm_support', 'deprecation_time', 'imds_support', 'source_i"
        "nstance_id', 'deregistration_protection', 'last_launched_time', 'image_allowed', 'source_image_id', 'source_im"
        "age_region', 'free_tier_eligible', 'image_id', 'image_location', 'state', 'owner_id', 'creation_date', 'public"
        "', 'product_codes', 'architecture', 'image_type', 'kernel_id', 'ramdisk_id', 'platform')), FrozenPlan(fields=("
        "'__shape__', 'platform_details', 'usage_operation', 'block_device_mappings', 'description', 'ena_support', 'hy"
        "pervisor', 'image_owner_alias', 'name', 'root_device_name', 'root_device_type', 'sriov_net_support', 'state_re"
        "ason', 'tags', 'virtualization_type', 'boot_mode', 'tpm_support', 'deprecation_time', 'imds_support', 'source_"
        "instance_id', 'deregistration_protection', 'last_launched_time', 'image_allowed', 'source_image_id', 'source_i"
        "mage_region', 'free_tier_eligible', 'image_id', 'image_location', 'state', 'owner_id', 'creation_date', 'publi"
        "c', 'product_codes', 'architecture', 'image_type', 'kernel_id', 'ramdisk_id', 'platform'), allow_dynamic_dunde"
        "r_attrs=False), HashPlan(action='add', fields=('platform_details', 'usage_operation', 'block_device_mappings',"
        " 'description', 'ena_support', 'hypervisor', 'image_owner_alias', 'name', 'root_device_name', 'root_device_typ"
        "e', 'sriov_net_support', 'state_reason', 'tags', 'virtualization_type', 'boot_mode', 'tpm_support', 'deprecati"
        "on_time', 'imds_support', 'source_instance_id', 'deregistration_protection', 'last_launched_time', 'image_allo"
        "wed', 'source_image_id', 'source_image_region', 'free_tier_eligible', 'image_id', 'image_location', 'state', '"
        "owner_id', 'creation_date', 'public', 'product_codes', 'architecture', 'image_type', 'kernel_id', 'ramdisk_id'"
        ", 'platform'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fie"
        "lds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_"
        "VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='platform_details', annotation=OpRef(na"
        "me='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='usage_operation', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.def"
        "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
        "None, check_type=None), InitPlan.Field(name='block_device_mappings', annotation=OpRef(name='init.fields.3.anno"
        "tation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='description', anno"
        "tation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='ena_support', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.f"
        "ields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='hypervisor', annotation=OpRef(name='init.fields.6.anno"
        "tation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='image_owner_alias'"
        ", annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fi"
        "elds.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='root_device_name', annotation=OpRef(name='init.fields.9"
        ".annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='root_device_t"
        "ype', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), defaul"
        "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
        "pe=None), InitPlan.Field(name='sriov_net_support', annotation=OpRef(name='init.fields.11.annotation'), default"
        "=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
        "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state_reason', annotation=OpRef(na"
        "me='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='tags', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None), InitPlan.Field(name='virtualization_type', annotation=OpRef(name='init.fields.14.annotation')"
        ", default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='boot_mode', annotation=Op"
        "Ref(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='tpm_support', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef(name='init.fields."
        "16.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='deprecation_time', annotation=OpRef(name='init.fields.17.an"
        "notation'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='imds_support', "
        "annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.18.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='source_instance_id', annotation=OpRef(name='init.fields.19.annotation'), default=OpRe"
        "f(name='init.fields.19.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='deregistration_protection', annotation="
        "OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.fields.20.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='last_launched_time', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='ini"
        "t.fields.21.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='image_allowed', annotation=OpRef(name='init.fields"
        ".22.annotation'), default=OpRef(name='init.fields.22.default'), default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='source_im"
        "age_id', annotation=OpRef(name='init.fields.23.annotation'), default=OpRef(name='init.fields.23.default'), def"
        "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
        "_type=None), InitPlan.Field(name='source_image_region', annotation=OpRef(name='init.fields.24.annotation'), de"
        "fault=OpRef(name='init.fields.24.default'), default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='free_tier_eligible', annotati"
        "on=OpRef(name='init.fields.25.annotation'), default=OpRef(name='init.fields.25.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='image_id', annotation=OpRef(name='init.fields.26.annotation'), default=OpRef(name='init.field"
        "s.26.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None), InitPlan.Field(name='image_location', annotation=OpRef(name='init.fields.27.an"
        "notation'), default=OpRef(name='init.fields.27.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state', annotat"
        "ion=OpRef(name='init.fields.28.annotation'), default=OpRef(name='init.fields.28.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='owner_id', annotation=OpRef(name='init.fields.29.annotation'), default=OpRef(name='init.fiel"
        "ds.29.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='creation_date', annotation=OpRef(name='init.fields.30.an"
        "notation'), default=OpRef(name='init.fields.30.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public', annota"
        "tion=OpRef(name='init.fields.31.annotation'), default=OpRef(name='init.fields.31.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='product_codes', annotation=OpRef(name='init.fields.32.annotation'), default=OpRef(name='ini"
        "t.fields.32.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='architecture', annotation=OpRef(name='init.fields."
        "33.annotation'), default=OpRef(name='init.fields.33.default'), default_factory=None, init=True, override=False"
        ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='image_type"
        "', annotation=OpRef(name='init.fields.34.annotation'), default=OpRef(name='init.fields.34.default'), default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None), InitPlan.Field(name='kernel_id', annotation=OpRef(name='init.fields.35.annotation'), default=OpRef(name"
        "='init.fields.35.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='ramdisk_id', annotation=OpRef(name='init.fiel"
        "ds.36.annotation'), default=OpRef(name='init.fields.36.default'), default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='platfor"
        "m', annotation=OpRef(name='init.fields.37.annotation'), default=OpRef(name='init.fields.37.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None)), self_param='self', std_params=(), kw_only_params=('platform_details', 'usage_operation', 'block_devic"
        "e_mappings', 'description', 'ena_support', 'hypervisor', 'image_owner_alias', 'name', 'root_device_name', 'roo"
        "t_device_type', 'sriov_net_support', 'state_reason', 'tags', 'virtualization_type', 'boot_mode', 'tpm_support'"
        ", 'deprecation_time', 'imds_support', 'source_instance_id', 'deregistration_protection', 'last_launched_time',"
        " 'image_allowed', 'source_image_id', 'source_image_region', 'free_tier_eligible', 'image_id', 'image_location'"
        ", 'state', 'owner_id', 'creation_date', 'public', 'product_codes', 'architecture', 'image_type', 'kernel_id', "
        "'ramdisk_id', 'platform'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Rep"
        "rPlan(fields=(ReprPlan.Field(name='platform_details', kw_only=True, fn=None), ReprPlan.Field(name='usage_opera"
        "tion', kw_only=True, fn=None), ReprPlan.Field(name='block_device_mappings', kw_only=True, fn=None), ReprPlan.F"
        "ield(name='description', kw_only=True, fn=None), ReprPlan.Field(name='ena_support', kw_only=True, fn=None), Re"
        "prPlan.Field(name='hypervisor', kw_only=True, fn=None), ReprPlan.Field(name='image_owner_alias', kw_only=True,"
        " fn=None), ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='root_device_name', kw_only"
        "=True, fn=None), ReprPlan.Field(name='root_device_type', kw_only=True, fn=None), ReprPlan.Field(name='sriov_ne"
        "t_support', kw_only=True, fn=None), ReprPlan.Field(name='state_reason', kw_only=True, fn=None), ReprPlan.Field"
        "(name='tags', kw_only=True, fn=None), ReprPlan.Field(name='virtualization_type', kw_only=True, fn=None), ReprP"
        "lan.Field(name='boot_mode', kw_only=True, fn=None), ReprPlan.Field(name='tpm_support', kw_only=True, fn=None),"
        " ReprPlan.Field(name='deprecation_time', kw_only=True, fn=None), ReprPlan.Field(name='imds_support', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='source_instance_id', kw_only=True, fn=None), ReprPlan.Field(name='deregist"
        "ration_protection', kw_only=True, fn=None), ReprPlan.Field(name='last_launched_time', kw_only=True, fn=None), "
        "ReprPlan.Field(name='image_allowed', kw_only=True, fn=None), ReprPlan.Field(name='source_image_id', kw_only=Tr"
        "ue, fn=None), ReprPlan.Field(name='source_image_region', kw_only=True, fn=None), ReprPlan.Field(name='free_tie"
        "r_eligible', kw_only=True, fn=None), ReprPlan.Field(name='image_id', kw_only=True, fn=None), ReprPlan.Field(na"
        "me='image_location', kw_only=True, fn=None), ReprPlan.Field(name='state', kw_only=True, fn=None), ReprPlan.Fie"
        "ld(name='owner_id', kw_only=True, fn=None), ReprPlan.Field(name='creation_date', kw_only=True, fn=None), ReprP"
        "lan.Field(name='public', kw_only=True, fn=None), ReprPlan.Field(name='product_codes', kw_only=True, fn=None), "
        "ReprPlan.Field(name='architecture', kw_only=True, fn=None), ReprPlan.Field(name='image_type', kw_only=True, fn"
        "=None), ReprPlan.Field(name='kernel_id', kw_only=True, fn=None), ReprPlan.Field(name='ramdisk_id', kw_only=Tru"
        "e, fn=None), ReprPlan.Field(name='platform', kw_only=True, fn=None)), id=False, terse=False, default_fn=None))"
        ")"
    ),
    plan_repr_sha1='fe5045a4d78c719e770d3dfad1430428ecab7dfe',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__24__annotation',
        '__dataclass__init__fields__24__default',
        '__dataclass__init__fields__25__annotation',
        '__dataclass__init__fields__25__default',
        '__dataclass__init__fields__26__annotation',
        '__dataclass__init__fields__26__default',
        '__dataclass__init__fields__27__annotation',
        '__dataclass__init__fields__27__default',
        '__dataclass__init__fields__28__annotation',
        '__dataclass__init__fields__28__default',
        '__dataclass__init__fields__29__annotation',
        '__dataclass__init__fields__29__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__30__annotation',
        '__dataclass__init__fields__30__default',
        '__dataclass__init__fields__31__annotation',
        '__dataclass__init__fields__31__default',
        '__dataclass__init__fields__32__annotation',
        '__dataclass__init__fields__32__default',
        '__dataclass__init__fields__33__annotation',
        '__dataclass__init__fields__33__default',
        '__dataclass__init__fields__34__annotation',
        '__dataclass__init__fields__34__default',
        '__dataclass__init__fields__35__annotation',
        '__dataclass__init__fields__35__default',
        '__dataclass__init__fields__36__annotation',
        '__dataclass__init__fields__36__default',
        '__dataclass__init__fields__37__annotation',
        '__dataclass__init__fields__37__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Image'),
    ),
)
def _process_dataclass__fe5045a4d78c719e770d3dfad1430428ecab7dfe():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__24__annotation,
        __dataclass__init__fields__24__default,
        __dataclass__init__fields__25__annotation,
        __dataclass__init__fields__25__default,
        __dataclass__init__fields__26__annotation,
        __dataclass__init__fields__26__default,
        __dataclass__init__fields__27__annotation,
        __dataclass__init__fields__27__default,
        __dataclass__init__fields__28__annotation,
        __dataclass__init__fields__28__default,
        __dataclass__init__fields__29__annotation,
        __dataclass__init__fields__29__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__30__annotation,
        __dataclass__init__fields__30__default,
        __dataclass__init__fields__31__annotation,
        __dataclass__init__fields__31__default,
        __dataclass__init__fields__32__annotation,
        __dataclass__init__fields__32__default,
        __dataclass__init__fields__33__annotation,
        __dataclass__init__fields__33__default,
        __dataclass__init__fields__34__annotation,
        __dataclass__init__fields__34__default,
        __dataclass__init__fields__35__annotation,
        __dataclass__init__fields__35__default,
        __dataclass__init__fields__36__annotation,
        __dataclass__init__fields__36__default,
        __dataclass__init__fields__37__annotation,
        __dataclass__init__fields__37__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                platform_details=self.platform_details,
                usage_operation=self.usage_operation,
                block_device_mappings=self.block_device_mappings,
                description=self.description,
                ena_support=self.ena_support,
                hypervisor=self.hypervisor,
                image_owner_alias=self.image_owner_alias,
                name=self.name,
                root_device_name=self.root_device_name,
                root_device_type=self.root_device_type,
                sriov_net_support=self.sriov_net_support,
                state_reason=self.state_reason,
                tags=self.tags,
                virtualization_type=self.virtualization_type,
                boot_mode=self.boot_mode,
                tpm_support=self.tpm_support,
                deprecation_time=self.deprecation_time,
                imds_support=self.imds_support,
                source_instance_id=self.source_instance_id,
                deregistration_protection=self.deregistration_protection,
                last_launched_time=self.last_launched_time,
                image_allowed=self.image_allowed,
                source_image_id=self.source_image_id,
                source_image_region=self.source_image_region,
                free_tier_eligible=self.free_tier_eligible,
                image_id=self.image_id,
                image_location=self.image_location,
                state=self.state,
                owner_id=self.owner_id,
                creation_date=self.creation_date,
                public=self.public,
                product_codes=self.product_codes,
                architecture=self.architecture,
                image_type=self.image_type,
                kernel_id=self.kernel_id,
                ramdisk_id=self.ramdisk_id,
                platform=self.platform,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.platform_details == other.platform_details and
                self.usage_operation == other.usage_operation and
                self.block_device_mappings == other.block_device_mappings and
                self.description == other.description and
                self.ena_support == other.ena_support and
                self.hypervisor == other.hypervisor and
                self.image_owner_alias == other.image_owner_alias and
                self.name == other.name and
                self.root_device_name == other.root_device_name and
                self.root_device_type == other.root_device_type and
                self.sriov_net_support == other.sriov_net_support and
                self.state_reason == other.state_reason and
                self.tags == other.tags and
                self.virtualization_type == other.virtualization_type and
                self.boot_mode == other.boot_mode and
                self.tpm_support == other.tpm_support and
                self.deprecation_time == other.deprecation_time and
                self.imds_support == other.imds_support and
                self.source_instance_id == other.source_instance_id and
                self.deregistration_protection == other.deregistration_protection and
                self.last_launched_time == other.last_launched_time and
                self.image_allowed == other.image_allowed and
                self.source_image_id == other.source_image_id and
                self.source_image_region == other.source_image_region and
                self.free_tier_eligible == other.free_tier_eligible and
                self.image_id == other.image_id and
                self.image_location == other.image_location and
                self.state == other.state and
                self.owner_id == other.owner_id and
                self.creation_date == other.creation_date and
                self.public == other.public and
                self.product_codes == other.product_codes and
                self.architecture == other.architecture and
                self.image_type == other.image_type and
                self.kernel_id == other.kernel_id and
                self.ramdisk_id == other.ramdisk_id and
                self.platform == other.platform
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'platform_details',
            'usage_operation',
            'block_device_mappings',
            'description',
            'ena_support',
            'hypervisor',
            'image_owner_alias',
            'name',
            'root_device_name',
            'root_device_type',
            'sriov_net_support',
            'state_reason',
            'tags',
            'virtualization_type',
            'boot_mode',
            'tpm_support',
            'deprecation_time',
            'imds_support',
            'source_instance_id',
            'deregistration_protection',
            'last_launched_time',
            'image_allowed',
            'source_image_id',
            'source_image_region',
            'free_tier_eligible',
            'image_id',
            'image_location',
            'state',
            'owner_id',
            'creation_date',
            'public',
            'product_codes',
            'architecture',
            'image_type',
            'kernel_id',
            'ramdisk_id',
            'platform',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'platform_details',
            'usage_operation',
            'block_device_mappings',
            'description',
            'ena_support',
            'hypervisor',
            'image_owner_alias',
            'name',
            'root_device_name',
            'root_device_type',
            'sriov_net_support',
            'state_reason',
            'tags',
            'virtualization_type',
            'boot_mode',
            'tpm_support',
            'deprecation_time',
            'imds_support',
            'source_instance_id',
            'deregistration_protection',
            'last_launched_time',
            'image_allowed',
            'source_image_id',
            'source_image_region',
            'free_tier_eligible',
            'image_id',
            'image_location',
            'state',
            'owner_id',
            'creation_date',
            'public',
            'product_codes',
            'architecture',
            'image_type',
            'kernel_id',
            'ramdisk_id',
            'platform',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.platform_details,
                self.usage_operation,
                self.block_device_mappings,
                self.description,
                self.ena_support,
                self.hypervisor,
                self.image_owner_alias,
                self.name,
                self.root_device_name,
                self.root_device_type,
                self.sriov_net_support,
                self.state_reason,
                self.tags,
                self.virtualization_type,
                self.boot_mode,
                self.tpm_support,
                self.deprecation_time,
                self.imds_support,
                self.source_instance_id,
                self.deregistration_protection,
                self.last_launched_time,
                self.image_allowed,
                self.source_image_id,
                self.source_image_region,
                self.free_tier_eligible,
                self.image_id,
                self.image_location,
                self.state,
                self.owner_id,
                self.creation_date,
                self.public,
                self.product_codes,
                self.architecture,
                self.image_type,
                self.kernel_id,
                self.ramdisk_id,
                self.platform,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            platform_details: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            usage_operation: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            block_device_mappings: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            description: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            ena_support: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            hypervisor: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            image_owner_alias: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            name: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            root_device_name: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            root_device_type: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            sriov_net_support: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            state_reason: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            tags: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            virtualization_type: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            boot_mode: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            tpm_support: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            deprecation_time: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            imds_support: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            source_instance_id: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            deregistration_protection: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            last_launched_time: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            image_allowed: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            source_image_id: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
            source_image_region: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
            free_tier_eligible: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
            image_id: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
            image_location: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
            state: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
            owner_id: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
            creation_date: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
            public: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
            product_codes: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
            architecture: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
            image_type: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
            kernel_id: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
            ramdisk_id: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
            platform: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'platform_details', platform_details)
            __dataclass__object_setattr(self, 'usage_operation', usage_operation)
            __dataclass__object_setattr(self, 'block_device_mappings', block_device_mappings)
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'ena_support', ena_support)
            __dataclass__object_setattr(self, 'hypervisor', hypervisor)
            __dataclass__object_setattr(self, 'image_owner_alias', image_owner_alias)
            __dataclass__object_setattr(self, 'name', name)
            __dataclass__object_setattr(self, 'root_device_name', root_device_name)
            __dataclass__object_setattr(self, 'root_device_type', root_device_type)
            __dataclass__object_setattr(self, 'sriov_net_support', sriov_net_support)
            __dataclass__object_setattr(self, 'state_reason', state_reason)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'virtualization_type', virtualization_type)
            __dataclass__object_setattr(self, 'boot_mode', boot_mode)
            __dataclass__object_setattr(self, 'tpm_support', tpm_support)
            __dataclass__object_setattr(self, 'deprecation_time', deprecation_time)
            __dataclass__object_setattr(self, 'imds_support', imds_support)
            __dataclass__object_setattr(self, 'source_instance_id', source_instance_id)
            __dataclass__object_setattr(self, 'deregistration_protection', deregistration_protection)
            __dataclass__object_setattr(self, 'last_launched_time', last_launched_time)
            __dataclass__object_setattr(self, 'image_allowed', image_allowed)
            __dataclass__object_setattr(self, 'source_image_id', source_image_id)
            __dataclass__object_setattr(self, 'source_image_region', source_image_region)
            __dataclass__object_setattr(self, 'free_tier_eligible', free_tier_eligible)
            __dataclass__object_setattr(self, 'image_id', image_id)
            __dataclass__object_setattr(self, 'image_location', image_location)
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'owner_id', owner_id)
            __dataclass__object_setattr(self, 'creation_date', creation_date)
            __dataclass__object_setattr(self, 'public', public)
            __dataclass__object_setattr(self, 'product_codes', product_codes)
            __dataclass__object_setattr(self, 'architecture', architecture)
            __dataclass__object_setattr(self, 'image_type', image_type)
            __dataclass__object_setattr(self, 'kernel_id', kernel_id)
            __dataclass__object_setattr(self, 'ramdisk_id', ramdisk_id)
            __dataclass__object_setattr(self, 'platform', platform)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"platform_details={self.platform_details!r}")
            parts.append(f"usage_operation={self.usage_operation!r}")
            parts.append(f"block_device_mappings={self.block_device_mappings!r}")
            parts.append(f"description={self.description!r}")
            parts.append(f"ena_support={self.ena_support!r}")
            parts.append(f"hypervisor={self.hypervisor!r}")
            parts.append(f"image_owner_alias={self.image_owner_alias!r}")
            parts.append(f"name={self.name!r}")
            parts.append(f"root_device_name={self.root_device_name!r}")
            parts.append(f"root_device_type={self.root_device_type!r}")
            parts.append(f"sriov_net_support={self.sriov_net_support!r}")
            parts.append(f"state_reason={self.state_reason!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"virtualization_type={self.virtualization_type!r}")
            parts.append(f"boot_mode={self.boot_mode!r}")
            parts.append(f"tpm_support={self.tpm_support!r}")
            parts.append(f"deprecation_time={self.deprecation_time!r}")
            parts.append(f"imds_support={self.imds_support!r}")
            parts.append(f"source_instance_id={self.source_instance_id!r}")
            parts.append(f"deregistration_protection={self.deregistration_protection!r}")
            parts.append(f"last_launched_time={self.last_launched_time!r}")
            parts.append(f"image_allowed={self.image_allowed!r}")
            parts.append(f"source_image_id={self.source_image_id!r}")
            parts.append(f"source_image_region={self.source_image_region!r}")
            parts.append(f"free_tier_eligible={self.free_tier_eligible!r}")
            parts.append(f"image_id={self.image_id!r}")
            parts.append(f"image_location={self.image_location!r}")
            parts.append(f"state={self.state!r}")
            parts.append(f"owner_id={self.owner_id!r}")
            parts.append(f"creation_date={self.creation_date!r}")
            parts.append(f"public={self.public!r}")
            parts.append(f"product_codes={self.product_codes!r}")
            parts.append(f"architecture={self.architecture!r}")
            parts.append(f"image_type={self.image_type!r}")
            parts.append(f"kernel_id={self.kernel_id!r}")
            parts.append(f"ramdisk_id={self.ramdisk_id!r}")
            parts.append(f"platform={self.platform!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('accelerators', 'total_inference_memory_in_mi_b')), EqPlan(fields=('accelerators',"
        " 'total_inference_memory_in_mi_b')), FrozenPlan(fields=('__shape__', 'accelerators', 'total_inference_memory_i"
        "n_mi_b'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('accelerators', 'total_inference_m"
        "emory_in_mi_b'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.f"
        "ields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLAS"
        "S_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='accelerators', annotation=OpRef(name"
        "='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, ov"
        "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='total_inference_memory_in_mi_b', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init"
        ".fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('accelerators', 'total"
        "_inference_memory_in_mi_b'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), R"
        "eprPlan(fields=(ReprPlan.Field(name='accelerators', kw_only=True, fn=None), ReprPlan.Field(name='total_inferen"
        "ce_memory_in_mi_b', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='b6cdadd468d96d55e67c5c44dca06681ea9dd5f3',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InferenceAcceleratorInfo'),
    ),
)
def _process_dataclass__b6cdadd468d96d55e67c5c44dca06681ea9dd5f3():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                accelerators=self.accelerators,
                total_inference_memory_in_mi_b=self.total_inference_memory_in_mi_b,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.accelerators == other.accelerators and
                self.total_inference_memory_in_mi_b == other.total_inference_memory_in_mi_b
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'accelerators',
            'total_inference_memory_in_mi_b',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'accelerators',
            'total_inference_memory_in_mi_b',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.accelerators,
                self.total_inference_memory_in_mi_b,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            accelerators: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            total_inference_memory_in_mi_b: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'accelerators', accelerators)
            __dataclass__object_setattr(self, 'total_inference_memory_in_mi_b', total_inference_memory_in_mi_b)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"accelerators={self.accelerators!r}")
            parts.append(f"total_inference_memory_in_mi_b={self.total_inference_memory_in_mi_b!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('count', 'name', 'manufacturer', 'memory_info')), EqPlan(fields=('count', 'name', "
        "'manufacturer', 'memory_info')), FrozenPlan(fields=('__shape__', 'count', 'name', 'manufacturer', 'memory_info"
        "'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('count', 'name', 'manufacturer', 'memory"
        "_info'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0."
        "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, c"
        "oerce=None, validate=None, check_type=None), InitPlan.Field(name='count', annotation=OpRef(name='init.fields.1"
        ".annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annota"
        "tion=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='manufacturer', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fi"
        "elds.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='memory_info', annotation=OpRef(name='init.fields.4.anno"
        "tation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_o"
        "nly_params=('count', 'name', 'manufacturer', 'memory_info'), frozen=True, slots=False, post_init_params=None, "
        "init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='count', kw_only=True, fn=None), ReprPlan."
        "Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='manufacturer', kw_only=True, fn=None), ReprPla"
        "n.Field(name='memory_info', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='c61c1debd6c8733c987556e95fc6934a226ef909',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InferenceDeviceInfo'),
        ('ominfra.clouds.aws.models.services.ec2', 'MediaDeviceInfo'),
    ),
)
def _process_dataclass__c61c1debd6c8733c987556e95fc6934a226ef909():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                count=self.count,
                name=self.name,
                manufacturer=self.manufacturer,
                memory_info=self.memory_info,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.count == other.count and
                self.name == other.name and
                self.manufacturer == other.manufacturer and
                self.memory_info == other.memory_info
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'count',
            'name',
            'manufacturer',
            'memory_info',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'count',
            'name',
            'manufacturer',
            'memory_info',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.count,
                self.name,
                self.manufacturer,
                self.memory_info,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            count: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            manufacturer: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            memory_info: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'count', count)
            __dataclass__object_setattr(self, 'name', name)
            __dataclass__object_setattr(self, 'manufacturer', manufacturer)
            __dataclass__object_setattr(self, 'memory_info', memory_info)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"count={self.count!r}")
            parts.append(f"name={self.name!r}")
            parts.append(f"manufacturer={self.manufacturer!r}")
            parts.append(f"memory_info={self.memory_info!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('architecture', 'block_device_mappings', 'client_token', 'ebs_optimized', 'ena_sup"
        "port', 'hypervisor', 'iam_instance_profile', 'instance_lifecycle', 'elastic_gpu_associations', 'elastic_infere"
        "nce_accelerator_associations', 'network_interfaces', 'outpost_arn', 'root_device_name', 'root_device_type', 's"
        "ecurity_groups', 'source_dest_check', 'spot_instance_request_id', 'sriov_net_support', 'state_reason', 'tags',"
        " 'virtualization_type', 'cpu_options', 'capacity_block_id', 'capacity_reservation_id', 'capacity_reservation_s"
        "pecification', 'hibernation_options', 'licenses', 'metadata_options', 'enclave_options', 'boot_mode', 'platfor"
        "m_details', 'usage_operation', 'usage_operation_update_time', 'private_dns_name_options', 'ipv6_address', 'tpm"
        "_support', 'maintenance_options', 'current_instance_boot_mode', 'network_performance_options', 'operator', 'in"
        "stance_id', 'image_id', 'state', 'private_dns_name', 'public_dns_name', 'state_transition_reason', 'key_name',"
        " 'ami_launch_index', 'product_codes', 'instance_type', 'launch_time', 'placement', 'kernel_id', 'ramdisk_id', "
        "'platform', 'monitoring', 'subnet_id', 'vpc_id', 'private_ip_address', 'public_ip_address')), EqPlan(fields=('"
        "architecture', 'block_device_mappings', 'client_token', 'ebs_optimized', 'ena_support', 'hypervisor', 'iam_ins"
        "tance_profile', 'instance_lifecycle', 'elastic_gpu_associations', 'elastic_inference_accelerator_associations'"
        ", 'network_interfaces', 'outpost_arn', 'root_device_name', 'root_device_type', 'security_groups', 'source_dest"
        "_check', 'spot_instance_request_id', 'sriov_net_support', 'state_reason', 'tags', 'virtualization_type', 'cpu_"
        "options', 'capacity_block_id', 'capacity_reservation_id', 'capacity_reservation_specification', 'hibernation_o"
        "ptions', 'licenses', 'metadata_options', 'enclave_options', 'boot_mode', 'platform_details', 'usage_operation'"
        ", 'usage_operation_update_time', 'private_dns_name_options', 'ipv6_address', 'tpm_support', 'maintenance_optio"
        "ns', 'current_instance_boot_mode', 'network_performance_options', 'operator', 'instance_id', 'image_id', 'stat"
        "e', 'private_dns_name', 'public_dns_name', 'state_transition_reason', 'key_name', 'ami_launch_index', 'product"
        "_codes', 'instance_type', 'launch_time', 'placement', 'kernel_id', 'ramdisk_id', 'platform', 'monitoring', 'su"
        "bnet_id', 'vpc_id', 'private_ip_address', 'public_ip_address')), FrozenPlan(fields=('__shape__', 'architecture"
        "', 'block_device_mappings', 'client_token', 'ebs_optimized', 'ena_support', 'hypervisor', 'iam_instance_profil"
        "e', 'instance_lifecycle', 'elastic_gpu_associations', 'elastic_inference_accelerator_associations', 'network_i"
        "nterfaces', 'outpost_arn', 'root_device_name', 'root_device_type', 'security_groups', 'source_dest_check', 'sp"
        "ot_instance_request_id', 'sriov_net_support', 'state_reason', 'tags', 'virtualization_type', 'cpu_options', 'c"
        "apacity_block_id', 'capacity_reservation_id', 'capacity_reservation_specification', 'hibernation_options', 'li"
        "censes', 'metadata_options', 'enclave_options', 'boot_mode', 'platform_details', 'usage_operation', 'usage_ope"
        "ration_update_time', 'private_dns_name_options', 'ipv6_address', 'tpm_support', 'maintenance_options', 'curren"
        "t_instance_boot_mode', 'network_performance_options', 'operator', 'instance_id', 'image_id', 'state', 'private"
        "_dns_name', 'public_dns_name', 'state_transition_reason', 'key_name', 'ami_launch_index', 'product_codes', 'in"
        "stance_type', 'launch_time', 'placement', 'kernel_id', 'ramdisk_id', 'platform', 'monitoring', 'subnet_id', 'v"
        "pc_id', 'private_ip_address', 'public_ip_address'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', "
        "fields=('architecture', 'block_device_mappings', 'client_token', 'ebs_optimized', 'ena_support', 'hypervisor',"
        " 'iam_instance_profile', 'instance_lifecycle', 'elastic_gpu_associations', 'elastic_inference_accelerator_asso"
        "ciations', 'network_interfaces', 'outpost_arn', 'root_device_name', 'root_device_type', 'security_groups', 'so"
        "urce_dest_check', 'spot_instance_request_id', 'sriov_net_support', 'state_reason', 'tags', 'virtualization_typ"
        "e', 'cpu_options', 'capacity_block_id', 'capacity_reservation_id', 'capacity_reservation_specification', 'hibe"
        "rnation_options', 'licenses', 'metadata_options', 'enclave_options', 'boot_mode', 'platform_details', 'usage_o"
        "peration', 'usage_operation_update_time', 'private_dns_name_options', 'ipv6_address', 'tpm_support', 'maintena"
        "nce_options', 'current_instance_boot_mode', 'network_performance_options', 'operator', 'instance_id', 'image_i"
        "d', 'state', 'private_dns_name', 'public_dns_name', 'state_transition_reason', 'key_name', 'ami_launch_index',"
        " 'product_codes', 'instance_type', 'launch_time', 'placement', 'kernel_id', 'ramdisk_id', 'platform', 'monitor"
        "ing', 'subnet_id', 'vpc_id', 'private_ip_address', 'public_ip_address'), cache=False), InitPlan(fields=(InitPl"
        "an.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='architecture', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init"
        ".fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='block_device_mappings', annotation=OpRef(name='init."
        "fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override="
        "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='clien"
        "t_token', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='ebs_optimized', annotation=OpRef(name='init.fields.4.annotation'), default=Op"
        "Ref(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
        "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_support', annotation=OpRef(name='i"
        "nit.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='h"
        "ypervisor', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
        "k_type=None), InitPlan.Field(name='iam_instance_profile', annotation=OpRef(name='init.fields.7.annotation'), d"
        "efault=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_lifecycle', annotati"
        "on=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='elastic_gpu_associations', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(nam"
        "e='init.fields.9.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='elastic_inference_accelerator_associations', "
        "annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='network_interfaces', annotation=OpRef(name='init.fields.11.annotation'), default=OpRe"
        "f(name='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='outpost_arn', annotation=OpRef(name='in"
        "it.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True, over"
        "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "root_device_name', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13.defa"
        "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
        "one, check_type=None), InitPlan.Field(name='root_device_type', annotation=OpRef(name='init.fields.14.annotatio"
        "n'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=False, field_type"
        "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='security_groups', anno"
        "tation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), default_factory="
        "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
        "InitPlan.Field(name='source_dest_check', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef(nam"
        "e='init.fields.16.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
        "oerce=None, validate=None, check_type=None), InitPlan.Field(name='spot_instance_request_id', annotation=OpRef("
        "name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='sriov_net_support', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.field"
        "s.18.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None), InitPlan.Field(name='state_reason', annotation=OpRef(name='init.fields.19.anno"
        "tation'), default=OpRef(name='init.fields.19.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags', annotation"
        "=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.fields.20.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='virtualization_type', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='i"
        "nit.fields.21.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
        "e=None, validate=None, check_type=None), InitPlan.Field(name='cpu_options', annotation=OpRef(name='init.fields"
        ".22.annotation'), default=OpRef(name='init.fields.22.default'), default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='capacity_"
        "block_id', annotation=OpRef(name='init.fields.23.annotation'), default=OpRef(name='init.fields.23.default'), d"
        "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='capacity_reservation_id', annotation=OpRef(name='init.fields.24.annotation"
        "'), default=OpRef(name='init.fields.24.default'), default_factory=None, init=True, override=False, field_type="
        "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='capacity_reservation_sp"
        "ecification', annotation=OpRef(name='init.fields.25.annotation'), default=OpRef(name='init.fields.25.default')"
        ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='hibernation_options', annotation=OpRef(name='init.fields.26.annotation'"
        "), default=OpRef(name='init.fields.26.default'), default_factory=None, init=True, override=False, field_type=F"
        "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='licenses', annotation=Op"
        "Ref(name='init.fields.27.annotation'), default=OpRef(name='init.fields.27.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='metadata_options', annotation=OpRef(name='init.fields.28.annotation'), default=OpRef(name='init.fi"
        "elds.28.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='enclave_options', annotation=OpRef(name='init.fields.2"
        "9.annotation'), default=OpRef(name='init.fields.29.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='boot_mode',"
        " annotation=OpRef(name='init.fields.30.annotation'), default=OpRef(name='init.fields.30.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='platform_details', annotation=OpRef(name='init.fields.31.annotation'), default=OpRef"
        "(name='init.fields.31.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
        "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='usage_operation', annotation=OpRef(name="
        "'init.fields.32.annotation'), default=OpRef(name='init.fields.32.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='usage_operation_update_time', annotation=OpRef(name='init.fields.33.annotation'), default=OpRef(name='init."
        "fields.33.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='private_dns_name_options', annotation=OpRef(name='in"
        "it.fields.34.annotation'), default=OpRef(name='init.fields.34.default'), default_factory=None, init=True, over"
        "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "ipv6_address', annotation=OpRef(name='init.fields.35.annotation'), default=OpRef(name='init.fields.35.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='tpm_support', annotation=OpRef(name='init.fields.36.annotation'), defa"
        "ult=OpRef(name='init.fields.36.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maintenance_options', annotatio"
        "n=OpRef(name='init.fields.37.annotation'), default=OpRef(name='init.fields.37.default'), default_factory=None,"
        " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
        "lan.Field(name='current_instance_boot_mode', annotation=OpRef(name='init.fields.38.annotation'), default=OpRef"
        "(name='init.fields.38.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
        "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_performance_options', annotation"
        "=OpRef(name='init.fields.39.annotation'), default=OpRef(name='init.fields.39.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='operator', annotation=OpRef(name='init.fields.40.annotation'), default=OpRef(name='init.fields."
        "40.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='instance_id', annotation=OpRef(name='init.fields.41.annotat"
        "ion'), default=OpRef(name='init.fields.41.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='image_id', annotatio"
        "n=OpRef(name='init.fields.42.annotation'), default=OpRef(name='init.fields.42.default'), default_factory=None,"
        " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
        "lan.Field(name='state', annotation=OpRef(name='init.fields.43.annotation'), default=OpRef(name='init.fields.43"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None), InitPlan.Field(name='private_dns_name', annotation=OpRef(name='init.fields.44.anno"
        "tation'), default=OpRef(name='init.fields.44.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_dns_name',"
        " annotation=OpRef(name='init.fields.45.annotation'), default=OpRef(name='init.fields.45.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='state_transition_reason', annotation=OpRef(name='init.fields.46.annotation'), defaul"
        "t=OpRef(name='init.fields.46.default'), default_factory=None, init=True, override=False, field_type=FieldType."
        "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='key_name', annotation=OpRef(name="
        "'init.fields.47.annotation'), default=OpRef(name='init.fields.47.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='ami_launch_index', annotation=OpRef(name='init.fields.48.annotation'), default=OpRef(name='init.fields.48.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='product_codes', annotation=OpRef(name='init.fields.49.annotatio"
        "n'), default=OpRef(name='init.fields.49.default'), default_factory=None, init=True, override=False, field_type"
        "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_type', annota"
        "tion=OpRef(name='init.fields.50.annotation'), default=OpRef(name='init.fields.50.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='launch_time', annotation=OpRef(name='init.fields.51.annotation'), default=OpRef(name='init."
        "fields.51.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='placement', annotation=OpRef(name='init.fields.52.an"
        "notation'), default=OpRef(name='init.fields.52.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='kernel_id', ann"
        "otation=OpRef(name='init.fields.53.annotation'), default=OpRef(name='init.fields.53.default'), default_factory"
        "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
        " InitPlan.Field(name='ramdisk_id', annotation=OpRef(name='init.fields.54.annotation'), default=OpRef(name='ini"
        "t.fields.54.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='platform', annotation=OpRef(name='init.fields.55.a"
        "nnotation'), default=OpRef(name='init.fields.55.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='monitoring', a"
        "nnotation=OpRef(name='init.fields.56.annotation'), default=OpRef(name='init.fields.56.default'), default_facto"
        "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
        "), InitPlan.Field(name='subnet_id', annotation=OpRef(name='init.fields.57.annotation'), default=OpRef(name='in"
        "it.fields.57.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.58.an"
        "notation'), default=OpRef(name='init.fields.58.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='private_ip_addr"
        "ess', annotation=OpRef(name='init.fields.59.annotation'), default=OpRef(name='init.fields.59.default'), defaul"
        "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
        "pe=None), InitPlan.Field(name='public_ip_address', annotation=OpRef(name='init.fields.60.annotation'), default"
        "=OpRef(name='init.fields.60.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
        "NSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('arc"
        "hitecture', 'block_device_mappings', 'client_token', 'ebs_optimized', 'ena_support', 'hypervisor', 'iam_instan"
        "ce_profile', 'instance_lifecycle', 'elastic_gpu_associations', 'elastic_inference_accelerator_associations', '"
        "network_interfaces', 'outpost_arn', 'root_device_name', 'root_device_type', 'security_groups', 'source_dest_ch"
        "eck', 'spot_instance_request_id', 'sriov_net_support', 'state_reason', 'tags', 'virtualization_type', 'cpu_opt"
        "ions', 'capacity_block_id', 'capacity_reservation_id', 'capacity_reservation_specification', 'hibernation_opti"
        "ons', 'licenses', 'metadata_options', 'enclave_options', 'boot_mode', 'platform_details', 'usage_operation', '"
        "usage_operation_update_time', 'private_dns_name_options', 'ipv6_address', 'tpm_support', 'maintenance_options'"
        ", 'current_instance_boot_mode', 'network_performance_options', 'operator', 'instance_id', 'image_id', 'state',"
        " 'private_dns_name', 'public_dns_name', 'state_transition_reason', 'key_name', 'ami_launch_index', 'product_co"
        "des', 'instance_type', 'launch_time', 'placement', 'kernel_id', 'ramdisk_id', 'platform', 'monitoring', 'subne"
        "t_id', 'vpc_id', 'private_ip_address', 'public_ip_address'), frozen=True, slots=False, post_init_params=None, "
        "init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='architecture', kw_only=True, fn=None), Re"
        "prPlan.Field(name='block_device_mappings', kw_only=True, fn=None), ReprPlan.Field(name='client_token', kw_only"
        "=True, fn=None), ReprPlan.Field(name='ebs_optimized', kw_only=True, fn=None), ReprPlan.Field(name='ena_support"
        "', kw_only=True, fn=None), ReprPlan.Field(name='hypervisor', kw_only=True, fn=None), ReprPlan.Field(name='iam_"
        "instance_profile', kw_only=True, fn=None), ReprPlan.Field(name='instance_lifecycle', kw_only=True, fn=None), R"
        "eprPlan.Field(name='elastic_gpu_associations', kw_only=True, fn=None), ReprPlan.Field(name='elastic_inference_"
        "accelerator_associations', kw_only=True, fn=None), ReprPlan.Field(name='network_interfaces', kw_only=True, fn="
        "None), ReprPlan.Field(name='outpost_arn', kw_only=True, fn=None), ReprPlan.Field(name='root_device_name', kw_o"
        "nly=True, fn=None), ReprPlan.Field(name='root_device_type', kw_only=True, fn=None), ReprPlan.Field(name='secur"
        "ity_groups', kw_only=True, fn=None), ReprPlan.Field(name='source_dest_check', kw_only=True, fn=None), ReprPlan"
        ".Field(name='spot_instance_request_id', kw_only=True, fn=None), ReprPlan.Field(name='sriov_net_support', kw_on"
        "ly=True, fn=None), ReprPlan.Field(name='state_reason', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_"
        "only=True, fn=None), ReprPlan.Field(name='virtualization_type', kw_only=True, fn=None), ReprPlan.Field(name='c"
        "pu_options', kw_only=True, fn=None), ReprPlan.Field(name='capacity_block_id', kw_only=True, fn=None), ReprPlan"
        ".Field(name='capacity_reservation_id', kw_only=True, fn=None), ReprPlan.Field(name='capacity_reservation_speci"
        "fication', kw_only=True, fn=None), ReprPlan.Field(name='hibernation_options', kw_only=True, fn=None), ReprPlan"
        ".Field(name='licenses', kw_only=True, fn=None), ReprPlan.Field(name='metadata_options', kw_only=True, fn=None)"
        ", ReprPlan.Field(name='enclave_options', kw_only=True, fn=None), ReprPlan.Field(name='boot_mode', kw_only=True"
        ", fn=None), ReprPlan.Field(name='platform_details', kw_only=True, fn=None), ReprPlan.Field(name='usage_operati"
        "on', kw_only=True, fn=None), ReprPlan.Field(name='usage_operation_update_time', kw_only=True, fn=None), ReprPl"
        "an.Field(name='private_dns_name_options', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_address', kw_only="
        "True, fn=None), ReprPlan.Field(name='tpm_support', kw_only=True, fn=None), ReprPlan.Field(name='maintenance_op"
        "tions', kw_only=True, fn=None), ReprPlan.Field(name='current_instance_boot_mode', kw_only=True, fn=None), Repr"
        "Plan.Field(name='network_performance_options', kw_only=True, fn=None), ReprPlan.Field(name='operator', kw_only"
        "=True, fn=None), ReprPlan.Field(name='instance_id', kw_only=True, fn=None), ReprPlan.Field(name='image_id', kw"
        "_only=True, fn=None), ReprPlan.Field(name='state', kw_only=True, fn=None), ReprPlan.Field(name='private_dns_na"
        "me', kw_only=True, fn=None), ReprPlan.Field(name='public_dns_name', kw_only=True, fn=None), ReprPlan.Field(nam"
        "e='state_transition_reason', kw_only=True, fn=None), ReprPlan.Field(name='key_name', kw_only=True, fn=None), R"
        "eprPlan.Field(name='ami_launch_index', kw_only=True, fn=None), ReprPlan.Field(name='product_codes', kw_only=Tr"
        "ue, fn=None), ReprPlan.Field(name='instance_type', kw_only=True, fn=None), ReprPlan.Field(name='launch_time', "
        "kw_only=True, fn=None), ReprPlan.Field(name='placement', kw_only=True, fn=None), ReprPlan.Field(name='kernel_i"
        "d', kw_only=True, fn=None), ReprPlan.Field(name='ramdisk_id', kw_only=True, fn=None), ReprPlan.Field(name='pla"
        "tform', kw_only=True, fn=None), ReprPlan.Field(name='monitoring', kw_only=True, fn=None), ReprPlan.Field(name="
        "'subnet_id', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPlan.Field(name"
        "='private_ip_address', kw_only=True, fn=None), ReprPlan.Field(name='public_ip_address', kw_only=True, fn=None)"
        "), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d45987ff0590fa3929458ba88230e38e2606ca1b',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__24__annotation',
        '__dataclass__init__fields__24__default',
        '__dataclass__init__fields__25__annotation',
        '__dataclass__init__fields__25__default',
        '__dataclass__init__fields__26__annotation',
        '__dataclass__init__fields__26__default',
        '__dataclass__init__fields__27__annotation',
        '__dataclass__init__fields__27__default',
        '__dataclass__init__fields__28__annotation',
        '__dataclass__init__fields__28__default',
        '__dataclass__init__fields__29__annotation',
        '__dataclass__init__fields__29__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__30__annotation',
        '__dataclass__init__fields__30__default',
        '__dataclass__init__fields__31__annotation',
        '__dataclass__init__fields__31__default',
        '__dataclass__init__fields__32__annotation',
        '__dataclass__init__fields__32__default',
        '__dataclass__init__fields__33__annotation',
        '__dataclass__init__fields__33__default',
        '__dataclass__init__fields__34__annotation',
        '__dataclass__init__fields__34__default',
        '__dataclass__init__fields__35__annotation',
        '__dataclass__init__fields__35__default',
        '__dataclass__init__fields__36__annotation',
        '__dataclass__init__fields__36__default',
        '__dataclass__init__fields__37__annotation',
        '__dataclass__init__fields__37__default',
        '__dataclass__init__fields__38__annotation',
        '__dataclass__init__fields__38__default',
        '__dataclass__init__fields__39__annotation',
        '__dataclass__init__fields__39__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__40__annotation',
        '__dataclass__init__fields__40__default',
        '__dataclass__init__fields__41__annotation',
        '__dataclass__init__fields__41__default',
        '__dataclass__init__fields__42__annotation',
        '__dataclass__init__fields__42__default',
        '__dataclass__init__fields__43__annotation',
        '__dataclass__init__fields__43__default',
        '__dataclass__init__fields__44__annotation',
        '__dataclass__init__fields__44__default',
        '__dataclass__init__fields__45__annotation',
        '__dataclass__init__fields__45__default',
        '__dataclass__init__fields__46__annotation',
        '__dataclass__init__fields__46__default',
        '__dataclass__init__fields__47__annotation',
        '__dataclass__init__fields__47__default',
        '__dataclass__init__fields__48__annotation',
        '__dataclass__init__fields__48__default',
        '__dataclass__init__fields__49__annotation',
        '__dataclass__init__fields__49__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__50__annotation',
        '__dataclass__init__fields__50__default',
        '__dataclass__init__fields__51__annotation',
        '__dataclass__init__fields__51__default',
        '__dataclass__init__fields__52__annotation',
        '__dataclass__init__fields__52__default',
        '__dataclass__init__fields__53__annotation',
        '__dataclass__init__fields__53__default',
        '__dataclass__init__fields__54__annotation',
        '__dataclass__init__fields__54__default',
        '__dataclass__init__fields__55__annotation',
        '__dataclass__init__fields__55__default',
        '__dataclass__init__fields__56__annotation',
        '__dataclass__init__fields__56__default',
        '__dataclass__init__fields__57__annotation',
        '__dataclass__init__fields__57__default',
        '__dataclass__init__fields__58__annotation',
        '__dataclass__init__fields__58__default',
        '__dataclass__init__fields__59__annotation',
        '__dataclass__init__fields__59__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__60__annotation',
        '__dataclass__init__fields__60__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Instance'),
    ),
)
def _process_dataclass__d45987ff0590fa3929458ba88230e38e2606ca1b():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__24__annotation,
        __dataclass__init__fields__24__default,
        __dataclass__init__fields__25__annotation,
        __dataclass__init__fields__25__default,
        __dataclass__init__fields__26__annotation,
        __dataclass__init__fields__26__default,
        __dataclass__init__fields__27__annotation,
        __dataclass__init__fields__27__default,
        __dataclass__init__fields__28__annotation,
        __dataclass__init__fields__28__default,
        __dataclass__init__fields__29__annotation,
        __dataclass__init__fields__29__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__30__annotation,
        __dataclass__init__fields__30__default,
        __dataclass__init__fields__31__annotation,
        __dataclass__init__fields__31__default,
        __dataclass__init__fields__32__annotation,
        __dataclass__init__fields__32__default,
        __dataclass__init__fields__33__annotation,
        __dataclass__init__fields__33__default,
        __dataclass__init__fields__34__annotation,
        __dataclass__init__fields__34__default,
        __dataclass__init__fields__35__annotation,
        __dataclass__init__fields__35__default,
        __dataclass__init__fields__36__annotation,
        __dataclass__init__fields__36__default,
        __dataclass__init__fields__37__annotation,
        __dataclass__init__fields__37__default,
        __dataclass__init__fields__38__annotation,
        __dataclass__init__fields__38__default,
        __dataclass__init__fields__39__annotation,
        __dataclass__init__fields__39__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__40__annotation,
        __dataclass__init__fields__40__default,
        __dataclass__init__fields__41__annotation,
        __dataclass__init__fields__41__default,
        __dataclass__init__fields__42__annotation,
        __dataclass__init__fields__42__default,
        __dataclass__init__fields__43__annotation,
        __dataclass__init__fields__43__default,
        __dataclass__init__fields__44__annotation,
        __dataclass__init__fields__44__default,
        __dataclass__init__fields__45__annotation,
        __dataclass__init__fields__45__default,
        __dataclass__init__fields__46__annotation,
        __dataclass__init__fields__46__default,
        __dataclass__init__fields__47__annotation,
        __dataclass__init__fields__47__default,
        __dataclass__init__fields__48__annotation,
        __dataclass__init__fields__48__default,
        __dataclass__init__fields__49__annotation,
        __dataclass__init__fields__49__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__50__annotation,
        __dataclass__init__fields__50__default,
        __dataclass__init__fields__51__annotation,
        __dataclass__init__fields__51__default,
        __dataclass__init__fields__52__annotation,
        __dataclass__init__fields__52__default,
        __dataclass__init__fields__53__annotation,
        __dataclass__init__fields__53__default,
        __dataclass__init__fields__54__annotation,
        __dataclass__init__fields__54__default,
        __dataclass__init__fields__55__annotation,
        __dataclass__init__fields__55__default,
        __dataclass__init__fields__56__annotation,
        __dataclass__init__fields__56__default,
        __dataclass__init__fields__57__annotation,
        __dataclass__init__fields__57__default,
        __dataclass__init__fields__58__annotation,
        __dataclass__init__fields__58__default,
        __dataclass__init__fields__59__annotation,
        __dataclass__init__fields__59__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__60__annotation,
        __dataclass__init__fields__60__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                architecture=self.architecture,
                block_device_mappings=self.block_device_mappings,
                client_token=self.client_token,
                ebs_optimized=self.ebs_optimized,
                ena_support=self.ena_support,
                hypervisor=self.hypervisor,
                iam_instance_profile=self.iam_instance_profile,
                instance_lifecycle=self.instance_lifecycle,
                elastic_gpu_associations=self.elastic_gpu_associations,
                elastic_inference_accelerator_associations=self.elastic_inference_accelerator_associations,
                network_interfaces=self.network_interfaces,
                outpost_arn=self.outpost_arn,
                root_device_name=self.root_device_name,
                root_device_type=self.root_device_type,
                security_groups=self.security_groups,
                source_dest_check=self.source_dest_check,
                spot_instance_request_id=self.spot_instance_request_id,
                sriov_net_support=self.sriov_net_support,
                state_reason=self.state_reason,
                tags=self.tags,
                virtualization_type=self.virtualization_type,
                cpu_options=self.cpu_options,
                capacity_block_id=self.capacity_block_id,
                capacity_reservation_id=self.capacity_reservation_id,
                capacity_reservation_specification=self.capacity_reservation_specification,
                hibernation_options=self.hibernation_options,
                licenses=self.licenses,
                metadata_options=self.metadata_options,
                enclave_options=self.enclave_options,
                boot_mode=self.boot_mode,
                platform_details=self.platform_details,
                usage_operation=self.usage_operation,
                usage_operation_update_time=self.usage_operation_update_time,
                private_dns_name_options=self.private_dns_name_options,
                ipv6_address=self.ipv6_address,
                tpm_support=self.tpm_support,
                maintenance_options=self.maintenance_options,
                current_instance_boot_mode=self.current_instance_boot_mode,
                network_performance_options=self.network_performance_options,
                operator=self.operator,
                instance_id=self.instance_id,
                image_id=self.image_id,
                state=self.state,
                private_dns_name=self.private_dns_name,
                public_dns_name=self.public_dns_name,
                state_transition_reason=self.state_transition_reason,
                key_name=self.key_name,
                ami_launch_index=self.ami_launch_index,
                product_codes=self.product_codes,
                instance_type=self.instance_type,
                launch_time=self.launch_time,
                placement=self.placement,
                kernel_id=self.kernel_id,
                ramdisk_id=self.ramdisk_id,
                platform=self.platform,
                monitoring=self.monitoring,
                subnet_id=self.subnet_id,
                vpc_id=self.vpc_id,
                private_ip_address=self.private_ip_address,
                public_ip_address=self.public_ip_address,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.architecture == other.architecture and
                self.block_device_mappings == other.block_device_mappings and
                self.client_token == other.client_token and
                self.ebs_optimized == other.ebs_optimized and
                self.ena_support == other.ena_support and
                self.hypervisor == other.hypervisor and
                self.iam_instance_profile == other.iam_instance_profile and
                self.instance_lifecycle == other.instance_lifecycle and
                self.elastic_gpu_associations == other.elastic_gpu_associations and
                self.elastic_inference_accelerator_associations == other.elastic_inference_accelerator_associations and
                self.network_interfaces == other.network_interfaces and
                self.outpost_arn == other.outpost_arn and
                self.root_device_name == other.root_device_name and
                self.root_device_type == other.root_device_type and
                self.security_groups == other.security_groups and
                self.source_dest_check == other.source_dest_check and
                self.spot_instance_request_id == other.spot_instance_request_id and
                self.sriov_net_support == other.sriov_net_support and
                self.state_reason == other.state_reason and
                self.tags == other.tags and
                self.virtualization_type == other.virtualization_type and
                self.cpu_options == other.cpu_options and
                self.capacity_block_id == other.capacity_block_id and
                self.capacity_reservation_id == other.capacity_reservation_id and
                self.capacity_reservation_specification == other.capacity_reservation_specification and
                self.hibernation_options == other.hibernation_options and
                self.licenses == other.licenses and
                self.metadata_options == other.metadata_options and
                self.enclave_options == other.enclave_options and
                self.boot_mode == other.boot_mode and
                self.platform_details == other.platform_details and
                self.usage_operation == other.usage_operation and
                self.usage_operation_update_time == other.usage_operation_update_time and
                self.private_dns_name_options == other.private_dns_name_options and
                self.ipv6_address == other.ipv6_address and
                self.tpm_support == other.tpm_support and
                self.maintenance_options == other.maintenance_options and
                self.current_instance_boot_mode == other.current_instance_boot_mode and
                self.network_performance_options == other.network_performance_options and
                self.operator == other.operator and
                self.instance_id == other.instance_id and
                self.image_id == other.image_id and
                self.state == other.state and
                self.private_dns_name == other.private_dns_name and
                self.public_dns_name == other.public_dns_name and
                self.state_transition_reason == other.state_transition_reason and
                self.key_name == other.key_name and
                self.ami_launch_index == other.ami_launch_index and
                self.product_codes == other.product_codes and
                self.instance_type == other.instance_type and
                self.launch_time == other.launch_time and
                self.placement == other.placement and
                self.kernel_id == other.kernel_id and
                self.ramdisk_id == other.ramdisk_id and
                self.platform == other.platform and
                self.monitoring == other.monitoring and
                self.subnet_id == other.subnet_id and
                self.vpc_id == other.vpc_id and
                self.private_ip_address == other.private_ip_address and
                self.public_ip_address == other.public_ip_address
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'architecture',
            'block_device_mappings',
            'client_token',
            'ebs_optimized',
            'ena_support',
            'hypervisor',
            'iam_instance_profile',
            'instance_lifecycle',
            'elastic_gpu_associations',
            'elastic_inference_accelerator_associations',
            'network_interfaces',
            'outpost_arn',
            'root_device_name',
            'root_device_type',
            'security_groups',
            'source_dest_check',
            'spot_instance_request_id',
            'sriov_net_support',
            'state_reason',
            'tags',
            'virtualization_type',
            'cpu_options',
            'capacity_block_id',
            'capacity_reservation_id',
            'capacity_reservation_specification',
            'hibernation_options',
            'licenses',
            'metadata_options',
            'enclave_options',
            'boot_mode',
            'platform_details',
            'usage_operation',
            'usage_operation_update_time',
            'private_dns_name_options',
            'ipv6_address',
            'tpm_support',
            'maintenance_options',
            'current_instance_boot_mode',
            'network_performance_options',
            'operator',
            'instance_id',
            'image_id',
            'state',
            'private_dns_name',
            'public_dns_name',
            'state_transition_reason',
            'key_name',
            'ami_launch_index',
            'product_codes',
            'instance_type',
            'launch_time',
            'placement',
            'kernel_id',
            'ramdisk_id',
            'platform',
            'monitoring',
            'subnet_id',
            'vpc_id',
            'private_ip_address',
            'public_ip_address',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'architecture',
            'block_device_mappings',
            'client_token',
            'ebs_optimized',
            'ena_support',
            'hypervisor',
            'iam_instance_profile',
            'instance_lifecycle',
            'elastic_gpu_associations',
            'elastic_inference_accelerator_associations',
            'network_interfaces',
            'outpost_arn',
            'root_device_name',
            'root_device_type',
            'security_groups',
            'source_dest_check',
            'spot_instance_request_id',
            'sriov_net_support',
            'state_reason',
            'tags',
            'virtualization_type',
            'cpu_options',
            'capacity_block_id',
            'capacity_reservation_id',
            'capacity_reservation_specification',
            'hibernation_options',
            'licenses',
            'metadata_options',
            'enclave_options',
            'boot_mode',
            'platform_details',
            'usage_operation',
            'usage_operation_update_time',
            'private_dns_name_options',
            'ipv6_address',
            'tpm_support',
            'maintenance_options',
            'current_instance_boot_mode',
            'network_performance_options',
            'operator',
            'instance_id',
            'image_id',
            'state',
            'private_dns_name',
            'public_dns_name',
            'state_transition_reason',
            'key_name',
            'ami_launch_index',
            'product_codes',
            'instance_type',
            'launch_time',
            'placement',
            'kernel_id',
            'ramdisk_id',
            'platform',
            'monitoring',
            'subnet_id',
            'vpc_id',
            'private_ip_address',
            'public_ip_address',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.architecture,
                self.block_device_mappings,
                self.client_token,
                self.ebs_optimized,
                self.ena_support,
                self.hypervisor,
                self.iam_instance_profile,
                self.instance_lifecycle,
                self.elastic_gpu_associations,
                self.elastic_inference_accelerator_associations,
                self.network_interfaces,
                self.outpost_arn,
                self.root_device_name,
                self.root_device_type,
                self.security_groups,
                self.source_dest_check,
                self.spot_instance_request_id,
                self.sriov_net_support,
                self.state_reason,
                self.tags,
                self.virtualization_type,
                self.cpu_options,
                self.capacity_block_id,
                self.capacity_reservation_id,
                self.capacity_reservation_specification,
                self.hibernation_options,
                self.licenses,
                self.metadata_options,
                self.enclave_options,
                self.boot_mode,
                self.platform_details,
                self.usage_operation,
                self.usage_operation_update_time,
                self.private_dns_name_options,
                self.ipv6_address,
                self.tpm_support,
                self.maintenance_options,
                self.current_instance_boot_mode,
                self.network_performance_options,
                self.operator,
                self.instance_id,
                self.image_id,
                self.state,
                self.private_dns_name,
                self.public_dns_name,
                self.state_transition_reason,
                self.key_name,
                self.ami_launch_index,
                self.product_codes,
                self.instance_type,
                self.launch_time,
                self.placement,
                self.kernel_id,
                self.ramdisk_id,
                self.platform,
                self.monitoring,
                self.subnet_id,
                self.vpc_id,
                self.private_ip_address,
                self.public_ip_address,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            architecture: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            block_device_mappings: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            client_token: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            ebs_optimized: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            ena_support: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            hypervisor: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            iam_instance_profile: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            instance_lifecycle: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            elastic_gpu_associations: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            elastic_inference_accelerator_associations: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            network_interfaces: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            outpost_arn: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            root_device_name: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            root_device_type: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            security_groups: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            source_dest_check: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            spot_instance_request_id: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            sriov_net_support: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            state_reason: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            tags: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            virtualization_type: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            cpu_options: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            capacity_block_id: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
            capacity_reservation_id: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
            capacity_reservation_specification: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
            hibernation_options: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
            licenses: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
            metadata_options: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
            enclave_options: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
            boot_mode: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
            platform_details: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
            usage_operation: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
            usage_operation_update_time: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
            private_dns_name_options: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
            ipv6_address: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
            tpm_support: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
            maintenance_options: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
            current_instance_boot_mode: __dataclass__init__fields__38__annotation = __dataclass__init__fields__38__default,
            network_performance_options: __dataclass__init__fields__39__annotation = __dataclass__init__fields__39__default,
            operator: __dataclass__init__fields__40__annotation = __dataclass__init__fields__40__default,
            instance_id: __dataclass__init__fields__41__annotation = __dataclass__init__fields__41__default,
            image_id: __dataclass__init__fields__42__annotation = __dataclass__init__fields__42__default,
            state: __dataclass__init__fields__43__annotation = __dataclass__init__fields__43__default,
            private_dns_name: __dataclass__init__fields__44__annotation = __dataclass__init__fields__44__default,
            public_dns_name: __dataclass__init__fields__45__annotation = __dataclass__init__fields__45__default,
            state_transition_reason: __dataclass__init__fields__46__annotation = __dataclass__init__fields__46__default,
            key_name: __dataclass__init__fields__47__annotation = __dataclass__init__fields__47__default,
            ami_launch_index: __dataclass__init__fields__48__annotation = __dataclass__init__fields__48__default,
            product_codes: __dataclass__init__fields__49__annotation = __dataclass__init__fields__49__default,
            instance_type: __dataclass__init__fields__50__annotation = __dataclass__init__fields__50__default,
            launch_time: __dataclass__init__fields__51__annotation = __dataclass__init__fields__51__default,
            placement: __dataclass__init__fields__52__annotation = __dataclass__init__fields__52__default,
            kernel_id: __dataclass__init__fields__53__annotation = __dataclass__init__fields__53__default,
            ramdisk_id: __dataclass__init__fields__54__annotation = __dataclass__init__fields__54__default,
            platform: __dataclass__init__fields__55__annotation = __dataclass__init__fields__55__default,
            monitoring: __dataclass__init__fields__56__annotation = __dataclass__init__fields__56__default,
            subnet_id: __dataclass__init__fields__57__annotation = __dataclass__init__fields__57__default,
            vpc_id: __dataclass__init__fields__58__annotation = __dataclass__init__fields__58__default,
            private_ip_address: __dataclass__init__fields__59__annotation = __dataclass__init__fields__59__default,
            public_ip_address: __dataclass__init__fields__60__annotation = __dataclass__init__fields__60__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'architecture', architecture)
            __dataclass__object_setattr(self, 'block_device_mappings', block_device_mappings)
            __dataclass__object_setattr(self, 'client_token', client_token)
            __dataclass__object_setattr(self, 'ebs_optimized', ebs_optimized)
            __dataclass__object_setattr(self, 'ena_support', ena_support)
            __dataclass__object_setattr(self, 'hypervisor', hypervisor)
            __dataclass__object_setattr(self, 'iam_instance_profile', iam_instance_profile)
            __dataclass__object_setattr(self, 'instance_lifecycle', instance_lifecycle)
            __dataclass__object_setattr(self, 'elastic_gpu_associations', elastic_gpu_associations)
            __dataclass__object_setattr(self, 'elastic_inference_accelerator_associations', elastic_inference_accelerator_associations)
            __dataclass__object_setattr(self, 'network_interfaces', network_interfaces)
            __dataclass__object_setattr(self, 'outpost_arn', outpost_arn)
            __dataclass__object_setattr(self, 'root_device_name', root_device_name)
            __dataclass__object_setattr(self, 'root_device_type', root_device_type)
            __dataclass__object_setattr(self, 'security_groups', security_groups)
            __dataclass__object_setattr(self, 'source_dest_check', source_dest_check)
            __dataclass__object_setattr(self, 'spot_instance_request_id', spot_instance_request_id)
            __dataclass__object_setattr(self, 'sriov_net_support', sriov_net_support)
            __dataclass__object_setattr(self, 'state_reason', state_reason)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'virtualization_type', virtualization_type)
            __dataclass__object_setattr(self, 'cpu_options', cpu_options)
            __dataclass__object_setattr(self, 'capacity_block_id', capacity_block_id)
            __dataclass__object_setattr(self, 'capacity_reservation_id', capacity_reservation_id)
            __dataclass__object_setattr(self, 'capacity_reservation_specification', capacity_reservation_specification)
            __dataclass__object_setattr(self, 'hibernation_options', hibernation_options)
            __dataclass__object_setattr(self, 'licenses', licenses)
            __dataclass__object_setattr(self, 'metadata_options', metadata_options)
            __dataclass__object_setattr(self, 'enclave_options', enclave_options)
            __dataclass__object_setattr(self, 'boot_mode', boot_mode)
            __dataclass__object_setattr(self, 'platform_details', platform_details)
            __dataclass__object_setattr(self, 'usage_operation', usage_operation)
            __dataclass__object_setattr(self, 'usage_operation_update_time', usage_operation_update_time)
            __dataclass__object_setattr(self, 'private_dns_name_options', private_dns_name_options)
            __dataclass__object_setattr(self, 'ipv6_address', ipv6_address)
            __dataclass__object_setattr(self, 'tpm_support', tpm_support)
            __dataclass__object_setattr(self, 'maintenance_options', maintenance_options)
            __dataclass__object_setattr(self, 'current_instance_boot_mode', current_instance_boot_mode)
            __dataclass__object_setattr(self, 'network_performance_options', network_performance_options)
            __dataclass__object_setattr(self, 'operator', operator)
            __dataclass__object_setattr(self, 'instance_id', instance_id)
            __dataclass__object_setattr(self, 'image_id', image_id)
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'private_dns_name', private_dns_name)
            __dataclass__object_setattr(self, 'public_dns_name', public_dns_name)
            __dataclass__object_setattr(self, 'state_transition_reason', state_transition_reason)
            __dataclass__object_setattr(self, 'key_name', key_name)
            __dataclass__object_setattr(self, 'ami_launch_index', ami_launch_index)
            __dataclass__object_setattr(self, 'product_codes', product_codes)
            __dataclass__object_setattr(self, 'instance_type', instance_type)
            __dataclass__object_setattr(self, 'launch_time', launch_time)
            __dataclass__object_setattr(self, 'placement', placement)
            __dataclass__object_setattr(self, 'kernel_id', kernel_id)
            __dataclass__object_setattr(self, 'ramdisk_id', ramdisk_id)
            __dataclass__object_setattr(self, 'platform', platform)
            __dataclass__object_setattr(self, 'monitoring', monitoring)
            __dataclass__object_setattr(self, 'subnet_id', subnet_id)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)
            __dataclass__object_setattr(self, 'public_ip_address', public_ip_address)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"architecture={self.architecture!r}")
            parts.append(f"block_device_mappings={self.block_device_mappings!r}")
            parts.append(f"client_token={self.client_token!r}")
            parts.append(f"ebs_optimized={self.ebs_optimized!r}")
            parts.append(f"ena_support={self.ena_support!r}")
            parts.append(f"hypervisor={self.hypervisor!r}")
            parts.append(f"iam_instance_profile={self.iam_instance_profile!r}")
            parts.append(f"instance_lifecycle={self.instance_lifecycle!r}")
            parts.append(f"elastic_gpu_associations={self.elastic_gpu_associations!r}")
            parts.append(f"elastic_inference_accelerator_associations={self.elastic_inference_accelerator_associations!r}")
            parts.append(f"network_interfaces={self.network_interfaces!r}")
            parts.append(f"outpost_arn={self.outpost_arn!r}")
            parts.append(f"root_device_name={self.root_device_name!r}")
            parts.append(f"root_device_type={self.root_device_type!r}")
            parts.append(f"security_groups={self.security_groups!r}")
            parts.append(f"source_dest_check={self.source_dest_check!r}")
            parts.append(f"spot_instance_request_id={self.spot_instance_request_id!r}")
            parts.append(f"sriov_net_support={self.sriov_net_support!r}")
            parts.append(f"state_reason={self.state_reason!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"virtualization_type={self.virtualization_type!r}")
            parts.append(f"cpu_options={self.cpu_options!r}")
            parts.append(f"capacity_block_id={self.capacity_block_id!r}")
            parts.append(f"capacity_reservation_id={self.capacity_reservation_id!r}")
            parts.append(f"capacity_reservation_specification={self.capacity_reservation_specification!r}")
            parts.append(f"hibernation_options={self.hibernation_options!r}")
            parts.append(f"licenses={self.licenses!r}")
            parts.append(f"metadata_options={self.metadata_options!r}")
            parts.append(f"enclave_options={self.enclave_options!r}")
            parts.append(f"boot_mode={self.boot_mode!r}")
            parts.append(f"platform_details={self.platform_details!r}")
            parts.append(f"usage_operation={self.usage_operation!r}")
            parts.append(f"usage_operation_update_time={self.usage_operation_update_time!r}")
            parts.append(f"private_dns_name_options={self.private_dns_name_options!r}")
            parts.append(f"ipv6_address={self.ipv6_address!r}")
            parts.append(f"tpm_support={self.tpm_support!r}")
            parts.append(f"maintenance_options={self.maintenance_options!r}")
            parts.append(f"current_instance_boot_mode={self.current_instance_boot_mode!r}")
            parts.append(f"network_performance_options={self.network_performance_options!r}")
            parts.append(f"operator={self.operator!r}")
            parts.append(f"instance_id={self.instance_id!r}")
            parts.append(f"image_id={self.image_id!r}")
            parts.append(f"state={self.state!r}")
            parts.append(f"private_dns_name={self.private_dns_name!r}")
            parts.append(f"public_dns_name={self.public_dns_name!r}")
            parts.append(f"state_transition_reason={self.state_transition_reason!r}")
            parts.append(f"key_name={self.key_name!r}")
            parts.append(f"ami_launch_index={self.ami_launch_index!r}")
            parts.append(f"product_codes={self.product_codes!r}")
            parts.append(f"instance_type={self.instance_type!r}")
            parts.append(f"launch_time={self.launch_time!r}")
            parts.append(f"placement={self.placement!r}")
            parts.append(f"kernel_id={self.kernel_id!r}")
            parts.append(f"ramdisk_id={self.ramdisk_id!r}")
            parts.append(f"platform={self.platform!r}")
            parts.append(f"monitoring={self.monitoring!r}")
            parts.append(f"subnet_id={self.subnet_id!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"private_ip_address={self.private_ip_address!r}")
            parts.append(f"public_ip_address={self.public_ip_address!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('device_name', 'ebs')), EqPlan(fields=('device_name', 'ebs')), FrozenPlan(fields=("
        "'__shape__', 'device_name', 'ebs'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('device_"
        "name', 'ebs'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fie"
        "lds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_"
        "VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='device_name', annotation=OpRef(name='i"
        "nit.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='e"
        "bs', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None)), self_param='self', std_params=(), kw_only_params=('device_name', 'ebs'), frozen=True, slots=False, pos"
        "t_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='device_name', kw_only"
        "=True, fn=None), ReprPlan.Field(name='ebs', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='242f4d6904080879b4d8ec0ef8f3b5f67e9fedcd',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceBlockDeviceMapping'),
    ),
)
def _process_dataclass__242f4d6904080879b4d8ec0ef8f3b5f67e9fedcd():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                device_name=self.device_name,
                ebs=self.ebs,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.device_name == other.device_name and
                self.ebs == other.ebs
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'device_name',
            'ebs',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'device_name',
            'ebs',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.device_name,
                self.ebs,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            device_name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            ebs: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'device_name', device_name)
            __dataclass__object_setattr(self, 'ebs', ebs)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"device_name={self.device_name!r}")
            parts.append(f"ebs={self.ebs!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ipv4_prefix',)), EqPlan(fields=('ipv4_prefix',)), FrozenPlan(fields=('__shape__',"
        " 'ipv4_prefix'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ipv4_prefix',), cache=Fals"
        "e), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defau"
        "lt=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='ipv4_prefix', annotation=OpRef(name='init.fields.1.annotation')"
        ", default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fie"
        "ldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_para"
        "ms=('ipv4_prefix',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan("
        "fields=(ReprPlan.Field(name='ipv4_prefix', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='ab20a40c4e4ec96dead82de9d24b8b611ba8974c',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceIpv4Prefix'),
        ('ominfra.clouds.aws.models.services.ec2', 'Ipv4PrefixSpecification'),
        ('ominfra.clouds.aws.models.services.ec2', 'Ipv4PrefixSpecificationRequest'),
    ),
)
def _process_dataclass__ab20a40c4e4ec96dead82de9d24b8b611ba8974c():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ipv4_prefix=self.ipv4_prefix,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ipv4_prefix == other.ipv4_prefix
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ipv4_prefix',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ipv4_prefix',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ipv4_prefix,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ipv4_prefix: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ipv4_prefix', ipv4_prefix)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ipv4_prefix={self.ipv4_prefix!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ipv6_address', 'is_primary_ipv6')), EqPlan(fields=('ipv6_address', 'is_primary_ip"
        "v6')), FrozenPlan(fields=('__shape__', 'ipv6_address', 'is_primary_ipv6'), allow_dynamic_dunder_attrs=False), "
        "HashPlan(action='add', fields=('ipv6_address', 'is_primary_ipv6'), cache=False), InitPlan(fields=(InitPlan.Fie"
        "ld(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, in"
        "it=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='ipv6_address', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.field"
        "s.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='is_primary_ipv6', annotation=OpRef(name='init.fields.2.ann"
        "otation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_"
        "only_params=('ipv6_address', 'is_primary_ipv6'), frozen=True, slots=False, post_init_params=None, init_fns=(),"
        " validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ipv6_address', kw_only=True, fn=None), ReprPlan.Field"
        "(name='is_primary_ipv6', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='e3df2f77bf1c5ec8f5f1bdbae450a2fb046dfb07',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceIpv6Address'),
    ),
)
def _process_dataclass__e3df2f77bf1c5ec8f5f1bdbae450a2fb046dfb07():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ipv6_address=self.ipv6_address,
                is_primary_ipv6=self.is_primary_ipv6,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ipv6_address == other.ipv6_address and
                self.is_primary_ipv6 == other.is_primary_ipv6
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ipv6_address',
            'is_primary_ipv6',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ipv6_address',
            'is_primary_ipv6',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ipv6_address,
                self.is_primary_ipv6,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ipv6_address: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            is_primary_ipv6: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ipv6_address', ipv6_address)
            __dataclass__object_setattr(self, 'is_primary_ipv6', is_primary_ipv6)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ipv6_address={self.ipv6_address!r}")
            parts.append(f"is_primary_ipv6={self.is_primary_ipv6!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ipv6_prefix',)), EqPlan(fields=('ipv6_prefix',)), FrozenPlan(fields=('__shape__',"
        " 'ipv6_prefix'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ipv6_prefix',), cache=Fals"
        "e), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defau"
        "lt=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='ipv6_prefix', annotation=OpRef(name='init.fields.1.annotation')"
        ", default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fie"
        "ldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_para"
        "ms=('ipv6_prefix',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan("
        "fields=(ReprPlan.Field(name='ipv6_prefix', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='f4ee721ce3a60e7873bb18fb8b8c7733eca2c287',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceIpv6Prefix'),
        ('ominfra.clouds.aws.models.services.ec2', 'Ipv6PrefixSpecification'),
        ('ominfra.clouds.aws.models.services.ec2', 'Ipv6PrefixSpecificationRequest'),
    ),
)
def _process_dataclass__f4ee721ce3a60e7873bb18fb8b8c7733eca2c287():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ipv6_prefix=self.ipv6_prefix,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ipv6_prefix == other.ipv6_prefix
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ipv6_prefix',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ipv6_prefix',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ipv6_prefix,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ipv6_prefix: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ipv6_prefix', ipv6_prefix)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ipv6_prefix={self.ipv6_prefix!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('auto_recovery', 'reboot_migration')), EqPlan(fields=('auto_recovery', 'reboot_mig"
        "ration')), FrozenPlan(fields=('__shape__', 'auto_recovery', 'reboot_migration'), allow_dynamic_dunder_attrs=Fa"
        "lse), HashPlan(action='add', fields=('auto_recovery', 'reboot_migration'), cache=False), InitPlan(fields=(Init"
        "Plan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory="
        "None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None),"
        " InitPlan.Field(name='auto_recovery', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='i"
        "nit.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='reboot_migration', annotation=OpRef(name='init.fi"
        "elds.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_para"
        "ms=(), kw_only_params=('auto_recovery', 'reboot_migration'), frozen=True, slots=False, post_init_params=None, "
        "init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='auto_recovery', kw_only=True, fn=None), R"
        "eprPlan.Field(name='reboot_migration', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='e0c3340e1914e0150760c77299541042e47c75d9',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceMaintenanceOptions'),
    ),
)
def _process_dataclass__e0c3340e1914e0150760c77299541042e47c75d9():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                auto_recovery=self.auto_recovery,
                reboot_migration=self.reboot_migration,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.auto_recovery == other.auto_recovery and
                self.reboot_migration == other.reboot_migration
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'auto_recovery',
            'reboot_migration',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'auto_recovery',
            'reboot_migration',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.auto_recovery,
                self.reboot_migration,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            auto_recovery: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            reboot_migration: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'auto_recovery', auto_recovery)
            __dataclass__object_setattr(self, 'reboot_migration', reboot_migration)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"auto_recovery={self.auto_recovery!r}")
            parts.append(f"reboot_migration={self.reboot_migration!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('auto_recovery',)), EqPlan(fields=('auto_recovery',)), FrozenPlan(fields=('__shape"
        "__', 'auto_recovery'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('auto_recovery',), ca"
        "che=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'"
        "), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='auto_recovery', annotation=OpRef(name='init.fields.1.an"
        "notation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fiel"
        "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw"
        "_only_params=('auto_recovery',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()"
        "), ReprPlan(fields=(ReprPlan.Field(name='auto_recovery', kw_only=True, fn=None),), id=False, terse=False, defa"
        "ult_fn=None)))"
    ),
    plan_repr_sha1='e05b242f8b4f9fce5a4bc4e5d5aa74dd579c9667',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceMaintenanceOptionsRequest'),
    ),
)
def _process_dataclass__e05b242f8b4f9fce5a4bc4e5d5aa74dd579c9667():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                auto_recovery=self.auto_recovery,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.auto_recovery == other.auto_recovery
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'auto_recovery',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'auto_recovery',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.auto_recovery,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            auto_recovery: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'auto_recovery', auto_recovery)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"auto_recovery={self.auto_recovery!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('market_type', 'spot_options')), EqPlan(fields=('market_type', 'spot_options')), F"
        "rozenPlan(fields=('__shape__', 'market_type', 'spot_options'), allow_dynamic_dunder_attrs=False), HashPlan(act"
        "ion='add', fields=('market_type', 'spot_options'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape"
        "__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ma"
        "rket_type', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
        "k_type=None), InitPlan.Field(name='spot_options', annotation=OpRef(name='init.fields.2.annotation'), default=O"
        "pRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('market"
        "_type', 'spot_options'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
        "lan(fields=(ReprPlan.Field(name='market_type', kw_only=True, fn=None), ReprPlan.Field(name='spot_options', kw_"
        "only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='bd26d720ea503182d9d997ea2d4ffcd48eb89f62',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceMarketOptionsRequest'),
    ),
)
def _process_dataclass__bd26d720ea503182d9d997ea2d4ffcd48eb89f62():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                market_type=self.market_type,
                spot_options=self.spot_options,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.market_type == other.market_type and
                self.spot_options == other.spot_options
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'market_type',
            'spot_options',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'market_type',
            'spot_options',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.market_type,
                self.spot_options,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            market_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            spot_options: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'market_type', market_type)
            __dataclass__object_setattr(self, 'spot_options', spot_options)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"market_type={self.market_type!r}")
            parts.append(f"spot_options={self.spot_options!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('http_tokens', 'http_put_response_hop_limit', 'http_endpoint', 'http_protocol_ipv6"
        "', 'instance_metadata_tags')), EqPlan(fields=('http_tokens', 'http_put_response_hop_limit', 'http_endpoint', '"
        "http_protocol_ipv6', 'instance_metadata_tags')), FrozenPlan(fields=('__shape__', 'http_tokens', 'http_put_resp"
        "onse_hop_limit', 'http_endpoint', 'http_protocol_ipv6', 'instance_metadata_tags'), allow_dynamic_dunder_attrs="
        "False), HashPlan(action='add', fields=('http_tokens', 'http_put_response_hop_limit', 'http_endpoint', 'http_pr"
        "otocol_ipv6', 'instance_metadata_tags'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annot"
        "ation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='http_tokens'"
        ", annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='http_put_response_hop_limit', annotation=OpRef(name='init.fields.2.annotation'), defa"
        "ult=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='http_endpoint', annotation=OpRef"
        "(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='http_protocol_ipv6', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields"
        ".4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='instance_metadata_tags', annotation=OpRef(name='init.fields"
        ".5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=("
        "), kw_only_params=('http_tokens', 'http_put_response_hop_limit', 'http_endpoint', 'http_protocol_ipv6', 'insta"
        "nce_metadata_tags'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan("
        "fields=(ReprPlan.Field(name='http_tokens', kw_only=True, fn=None), ReprPlan.Field(name='http_put_response_hop_"
        "limit', kw_only=True, fn=None), ReprPlan.Field(name='http_endpoint', kw_only=True, fn=None), ReprPlan.Field(na"
        "me='http_protocol_ipv6', kw_only=True, fn=None), ReprPlan.Field(name='instance_metadata_tags', kw_only=True, f"
        "n=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='3e4817a067658e230deaa09e6f1a8cc25225d31c',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceMetadataOptionsRequest'),
    ),
)
def _process_dataclass__3e4817a067658e230deaa09e6f1a8cc25225d31c():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                http_tokens=self.http_tokens,
                http_put_response_hop_limit=self.http_put_response_hop_limit,
                http_endpoint=self.http_endpoint,
                http_protocol_ipv6=self.http_protocol_ipv6,
                instance_metadata_tags=self.instance_metadata_tags,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.http_tokens == other.http_tokens and
                self.http_put_response_hop_limit == other.http_put_response_hop_limit and
                self.http_endpoint == other.http_endpoint and
                self.http_protocol_ipv6 == other.http_protocol_ipv6 and
                self.instance_metadata_tags == other.instance_metadata_tags
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'http_tokens',
            'http_put_response_hop_limit',
            'http_endpoint',
            'http_protocol_ipv6',
            'instance_metadata_tags',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'http_tokens',
            'http_put_response_hop_limit',
            'http_endpoint',
            'http_protocol_ipv6',
            'instance_metadata_tags',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.http_tokens,
                self.http_put_response_hop_limit,
                self.http_endpoint,
                self.http_protocol_ipv6,
                self.instance_metadata_tags,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            http_tokens: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            http_put_response_hop_limit: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            http_endpoint: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            http_protocol_ipv6: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            instance_metadata_tags: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'http_tokens', http_tokens)
            __dataclass__object_setattr(self, 'http_put_response_hop_limit', http_put_response_hop_limit)
            __dataclass__object_setattr(self, 'http_endpoint', http_endpoint)
            __dataclass__object_setattr(self, 'http_protocol_ipv6', http_protocol_ipv6)
            __dataclass__object_setattr(self, 'instance_metadata_tags', instance_metadata_tags)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"http_tokens={self.http_tokens!r}")
            parts.append(f"http_put_response_hop_limit={self.http_put_response_hop_limit!r}")
            parts.append(f"http_endpoint={self.http_endpoint!r}")
            parts.append(f"http_protocol_ipv6={self.http_protocol_ipv6!r}")
            parts.append(f"instance_metadata_tags={self.instance_metadata_tags!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('state', 'http_tokens', 'http_put_response_hop_limit', 'http_endpoint', 'http_prot"
        "ocol_ipv6', 'instance_metadata_tags')), EqPlan(fields=('state', 'http_tokens', 'http_put_response_hop_limit', "
        "'http_endpoint', 'http_protocol_ipv6', 'instance_metadata_tags')), FrozenPlan(fields=('__shape__', 'state', 'h"
        "ttp_tokens', 'http_put_response_hop_limit', 'http_endpoint', 'http_protocol_ipv6', 'instance_metadata_tags'), "
        "allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('state', 'http_tokens', 'http_put_response_h"
        "op_limit', 'http_endpoint', 'http_protocol_ipv6', 'instance_metadata_tags'), cache=False), InitPlan(fields=(In"
        "itPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factor"
        "y=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None"
        "), InitPlan.Field(name='state', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fi"
        "elds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='http_tokens', annotation=OpRef(name='init.fields.2.anno"
        "tation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='http_put_response_"
        "hop_limit', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
        "k_type=None), InitPlan.Field(name='http_endpoint', annotation=OpRef(name='init.fields.4.annotation'), default="
        "OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='http_protocol_ipv6', annotation=OpRe"
        "f(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='instance_metadata_tags', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.f"
        "ields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
        ", validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('state', 'http_tokens', "
        "'http_put_response_hop_limit', 'http_endpoint', 'http_protocol_ipv6', 'instance_metadata_tags'), frozen=True, "
        "slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='state"
        "', kw_only=True, fn=None), ReprPlan.Field(name='http_tokens', kw_only=True, fn=None), ReprPlan.Field(name='htt"
        "p_put_response_hop_limit', kw_only=True, fn=None), ReprPlan.Field(name='http_endpoint', kw_only=True, fn=None)"
        ", ReprPlan.Field(name='http_protocol_ipv6', kw_only=True, fn=None), ReprPlan.Field(name='instance_metadata_tag"
        "s', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='7fe2772dae2af5a3470bca87c58b0fc1e277591f',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceMetadataOptionsResponse'),
    ),
)
def _process_dataclass__7fe2772dae2af5a3470bca87c58b0fc1e277591f():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                state=self.state,
                http_tokens=self.http_tokens,
                http_put_response_hop_limit=self.http_put_response_hop_limit,
                http_endpoint=self.http_endpoint,
                http_protocol_ipv6=self.http_protocol_ipv6,
                instance_metadata_tags=self.instance_metadata_tags,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.state == other.state and
                self.http_tokens == other.http_tokens and
                self.http_put_response_hop_limit == other.http_put_response_hop_limit and
                self.http_endpoint == other.http_endpoint and
                self.http_protocol_ipv6 == other.http_protocol_ipv6 and
                self.instance_metadata_tags == other.instance_metadata_tags
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'state',
            'http_tokens',
            'http_put_response_hop_limit',
            'http_endpoint',
            'http_protocol_ipv6',
            'instance_metadata_tags',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'state',
            'http_tokens',
            'http_put_response_hop_limit',
            'http_endpoint',
            'http_protocol_ipv6',
            'instance_metadata_tags',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.state,
                self.http_tokens,
                self.http_put_response_hop_limit,
                self.http_endpoint,
                self.http_protocol_ipv6,
                self.instance_metadata_tags,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            state: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            http_tokens: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            http_put_response_hop_limit: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            http_endpoint: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            http_protocol_ipv6: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            instance_metadata_tags: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'http_tokens', http_tokens)
            __dataclass__object_setattr(self, 'http_put_response_hop_limit', http_put_response_hop_limit)
            __dataclass__object_setattr(self, 'http_endpoint', http_endpoint)
            __dataclass__object_setattr(self, 'http_protocol_ipv6', http_protocol_ipv6)
            __dataclass__object_setattr(self, 'instance_metadata_tags', instance_metadata_tags)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"state={self.state!r}")
            parts.append(f"http_tokens={self.http_tokens!r}")
            parts.append(f"http_put_response_hop_limit={self.http_put_response_hop_limit!r}")
            parts.append(f"http_endpoint={self.http_endpoint!r}")
            parts.append(f"http_protocol_ipv6={self.http_protocol_ipv6!r}")
            parts.append(f"instance_metadata_tags={self.instance_metadata_tags!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('association', 'attachment', 'description', 'groups', 'ipv6_addresses', 'mac_addre"
        "ss', 'network_interface_id', 'owner_id', 'private_dns_name', 'private_ip_address', 'private_ip_addresses', 'so"
        "urce_dest_check', 'status', 'subnet_id', 'vpc_id', 'interface_type', 'ipv4_prefixes', 'ipv6_prefixes', 'connec"
        "tion_tracking_configuration', 'operator')), EqPlan(fields=('association', 'attachment', 'description', 'groups"
        "', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'owner_id', 'private_dns_name', 'private_ip_addres"
        "s', 'private_ip_addresses', 'source_dest_check', 'status', 'subnet_id', 'vpc_id', 'interface_type', 'ipv4_pref"
        "ixes', 'ipv6_prefixes', 'connection_tracking_configuration', 'operator')), FrozenPlan(fields=('__shape__', 'as"
        "sociation', 'attachment', 'description', 'groups', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'o"
        "wner_id', 'private_dns_name', 'private_ip_address', 'private_ip_addresses', 'source_dest_check', 'status', 'su"
        "bnet_id', 'vpc_id', 'interface_type', 'ipv4_prefixes', 'ipv6_prefixes', 'connection_tracking_configuration', '"
        "operator'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('association', 'attachment', 'de"
        "scription', 'groups', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'owner_id', 'private_dns_name',"
        " 'private_ip_address', 'private_ip_addresses', 'source_dest_check', 'status', 'subnet_id', 'vpc_id', 'interfac"
        "e_type', 'ipv4_prefixes', 'ipv6_prefixes', 'connection_tracking_configuration', 'operator'), cache=False), Ini"
        "tPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None"
        ", default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='association', annotation=OpRef(name='init.fields.1.annotation'), defau"
        "lt=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType."
        "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='attachment', annotation=OpRef(nam"
        "e='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='description', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='groups', annotation=OpRef(name='init.fields.4.annotation'), default=Op"
        "Ref(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
        "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_addresses', annotation=OpRef(name"
        "='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, ov"
        "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='mac_address', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default')"
        ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='network_interface_id', annotation=OpRef(name='init.fields.7.annotation'"
        "), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='owner_id', annotation=OpR"
        "ef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
        "ld(name='private_dns_name', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields"
        ".9.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='private_ip_address', annotation=OpRef(name='init.fields.10."
        "annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='private_ip_ad"
        "dresses', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
        "k_type=None), InitPlan.Field(name='source_dest_check', annotation=OpRef(name='init.fields.12.annotation'), def"
        "ault=OpRef(name='init.fields.12.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='status', annotation=OpRef(name"
        "='init.fields.13.annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='subnet_id', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default"
        "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
        ", check_type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.15.annotation'), default="
        "OpRef(name='init.fields.15.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
        "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='interface_type', annotation=OpRef(n"
        "ame='init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='ipv4_prefixes', annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='ipv6_prefixes', annotation=OpRef(name='init.fields.18.annotati"
        "on'), default=OpRef(name='init.fields.18.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='connection_tracking_c"
        "onfiguration', annotation=OpRef(name='init.fields.19.annotation'), default=OpRef(name='init.fields.19.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='operator', annotation=OpRef(name='init.fields.20.annotation'), default"
        "=OpRef(name='init.fields.20.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
        "NSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('ass"
        "ociation', 'attachment', 'description', 'groups', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'ow"
        "ner_id', 'private_dns_name', 'private_ip_address', 'private_ip_addresses', 'source_dest_check', 'status', 'sub"
        "net_id', 'vpc_id', 'interface_type', 'ipv4_prefixes', 'ipv6_prefixes', 'connection_tracking_configuration', 'o"
        "perator'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Re"
        "prPlan.Field(name='association', kw_only=True, fn=None), ReprPlan.Field(name='attachment', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='description', kw_only=True, fn=None), ReprPlan.Field(name='groups', kw_only=True, fn"
        "=None), ReprPlan.Field(name='ipv6_addresses', kw_only=True, fn=None), ReprPlan.Field(name='mac_address', kw_on"
        "ly=True, fn=None), ReprPlan.Field(name='network_interface_id', kw_only=True, fn=None), ReprPlan.Field(name='ow"
        "ner_id', kw_only=True, fn=None), ReprPlan.Field(name='private_dns_name', kw_only=True, fn=None), ReprPlan.Fiel"
        "d(name='private_ip_address', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_addresses', kw_only=True,"
        " fn=None), ReprPlan.Field(name='source_dest_check', kw_only=True, fn=None), ReprPlan.Field(name='status', kw_o"
        "nly=True, fn=None), ReprPlan.Field(name='subnet_id', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_"
        "only=True, fn=None), ReprPlan.Field(name='interface_type', kw_only=True, fn=None), ReprPlan.Field(name='ipv4_p"
        "refixes', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_prefixes', kw_only=True, fn=None), ReprPlan.Field("
        "name='connection_tracking_configuration', kw_only=True, fn=None), ReprPlan.Field(name='operator', kw_only=True"
        ", fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='a70987d10ed61c28e98fe9fa21edba13d707ac39',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceNetworkInterface'),
    ),
)
def _process_dataclass__a70987d10ed61c28e98fe9fa21edba13d707ac39():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                association=self.association,
                attachment=self.attachment,
                description=self.description,
                groups=self.groups,
                ipv6_addresses=self.ipv6_addresses,
                mac_address=self.mac_address,
                network_interface_id=self.network_interface_id,
                owner_id=self.owner_id,
                private_dns_name=self.private_dns_name,
                private_ip_address=self.private_ip_address,
                private_ip_addresses=self.private_ip_addresses,
                source_dest_check=self.source_dest_check,
                status=self.status,
                subnet_id=self.subnet_id,
                vpc_id=self.vpc_id,
                interface_type=self.interface_type,
                ipv4_prefixes=self.ipv4_prefixes,
                ipv6_prefixes=self.ipv6_prefixes,
                connection_tracking_configuration=self.connection_tracking_configuration,
                operator=self.operator,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.association == other.association and
                self.attachment == other.attachment and
                self.description == other.description and
                self.groups == other.groups and
                self.ipv6_addresses == other.ipv6_addresses and
                self.mac_address == other.mac_address and
                self.network_interface_id == other.network_interface_id and
                self.owner_id == other.owner_id and
                self.private_dns_name == other.private_dns_name and
                self.private_ip_address == other.private_ip_address and
                self.private_ip_addresses == other.private_ip_addresses and
                self.source_dest_check == other.source_dest_check and
                self.status == other.status and
                self.subnet_id == other.subnet_id and
                self.vpc_id == other.vpc_id and
                self.interface_type == other.interface_type and
                self.ipv4_prefixes == other.ipv4_prefixes and
                self.ipv6_prefixes == other.ipv6_prefixes and
                self.connection_tracking_configuration == other.connection_tracking_configuration and
                self.operator == other.operator
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'association',
            'attachment',
            'description',
            'groups',
            'ipv6_addresses',
            'mac_address',
            'network_interface_id',
            'owner_id',
            'private_dns_name',
            'private_ip_address',
            'private_ip_addresses',
            'source_dest_check',
            'status',
            'subnet_id',
            'vpc_id',
            'interface_type',
            'ipv4_prefixes',
            'ipv6_prefixes',
            'connection_tracking_configuration',
            'operator',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'association',
            'attachment',
            'description',
            'groups',
            'ipv6_addresses',
            'mac_address',
            'network_interface_id',
            'owner_id',
            'private_dns_name',
            'private_ip_address',
            'private_ip_addresses',
            'source_dest_check',
            'status',
            'subnet_id',
            'vpc_id',
            'interface_type',
            'ipv4_prefixes',
            'ipv6_prefixes',
            'connection_tracking_configuration',
            'operator',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.association,
                self.attachment,
                self.description,
                self.groups,
                self.ipv6_addresses,
                self.mac_address,
                self.network_interface_id,
                self.owner_id,
                self.private_dns_name,
                self.private_ip_address,
                self.private_ip_addresses,
                self.source_dest_check,
                self.status,
                self.subnet_id,
                self.vpc_id,
                self.interface_type,
                self.ipv4_prefixes,
                self.ipv6_prefixes,
                self.connection_tracking_configuration,
                self.operator,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            association: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            attachment: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            description: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            groups: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            ipv6_addresses: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            mac_address: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            network_interface_id: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            owner_id: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            private_dns_name: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            private_ip_address: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            private_ip_addresses: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            source_dest_check: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            status: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            subnet_id: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            vpc_id: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            interface_type: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            ipv4_prefixes: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            ipv6_prefixes: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            connection_tracking_configuration: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            operator: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'association', association)
            __dataclass__object_setattr(self, 'attachment', attachment)
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'groups', groups)
            __dataclass__object_setattr(self, 'ipv6_addresses', ipv6_addresses)
            __dataclass__object_setattr(self, 'mac_address', mac_address)
            __dataclass__object_setattr(self, 'network_interface_id', network_interface_id)
            __dataclass__object_setattr(self, 'owner_id', owner_id)
            __dataclass__object_setattr(self, 'private_dns_name', private_dns_name)
            __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)
            __dataclass__object_setattr(self, 'private_ip_addresses', private_ip_addresses)
            __dataclass__object_setattr(self, 'source_dest_check', source_dest_check)
            __dataclass__object_setattr(self, 'status', status)
            __dataclass__object_setattr(self, 'subnet_id', subnet_id)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'interface_type', interface_type)
            __dataclass__object_setattr(self, 'ipv4_prefixes', ipv4_prefixes)
            __dataclass__object_setattr(self, 'ipv6_prefixes', ipv6_prefixes)
            __dataclass__object_setattr(self, 'connection_tracking_configuration', connection_tracking_configuration)
            __dataclass__object_setattr(self, 'operator', operator)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"association={self.association!r}")
            parts.append(f"attachment={self.attachment!r}")
            parts.append(f"description={self.description!r}")
            parts.append(f"groups={self.groups!r}")
            parts.append(f"ipv6_addresses={self.ipv6_addresses!r}")
            parts.append(f"mac_address={self.mac_address!r}")
            parts.append(f"network_interface_id={self.network_interface_id!r}")
            parts.append(f"owner_id={self.owner_id!r}")
            parts.append(f"private_dns_name={self.private_dns_name!r}")
            parts.append(f"private_ip_address={self.private_ip_address!r}")
            parts.append(f"private_ip_addresses={self.private_ip_addresses!r}")
            parts.append(f"source_dest_check={self.source_dest_check!r}")
            parts.append(f"status={self.status!r}")
            parts.append(f"subnet_id={self.subnet_id!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"interface_type={self.interface_type!r}")
            parts.append(f"ipv4_prefixes={self.ipv4_prefixes!r}")
            parts.append(f"ipv6_prefixes={self.ipv6_prefixes!r}")
            parts.append(f"connection_tracking_configuration={self.connection_tracking_configuration!r}")
            parts.append(f"operator={self.operator!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('carrier_ip', 'customer_owned_ip', 'ip_owner_id', 'public_dns_name', 'public_ip'))"
        ", EqPlan(fields=('carrier_ip', 'customer_owned_ip', 'ip_owner_id', 'public_dns_name', 'public_ip')), FrozenPla"
        "n(fields=('__shape__', 'carrier_ip', 'customer_owned_ip', 'ip_owner_id', 'public_dns_name', 'public_ip'), allo"
        "w_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('carrier_ip', 'customer_owned_ip', 'ip_owner_id'"
        ", 'public_dns_name', 'public_ip'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation="
        "OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='carrier_ip', annot"
        "ation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='customer_owned_ip', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='i"
        "nit.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='ip_owner_id', annotation=OpRef(name='init.fields."
        "3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_dns_n"
        "ame', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='public_ip', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name"
        "='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('carrier_ip', 'c"
        "ustomer_owned_ip', 'ip_owner_id', 'public_dns_name', 'public_ip'), frozen=True, slots=False, post_init_params="
        "None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='carrier_ip', kw_only=True, fn=None)"
        ", ReprPlan.Field(name='customer_owned_ip', kw_only=True, fn=None), ReprPlan.Field(name='ip_owner_id', kw_only="
        "True, fn=None), ReprPlan.Field(name='public_dns_name', kw_only=True, fn=None), ReprPlan.Field(name='public_ip'"
        ", kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d8aaeba5664396a6bcbc2471a59e31cdc447f2fb',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceNetworkInterfaceAssociation'),
    ),
)
def _process_dataclass__d8aaeba5664396a6bcbc2471a59e31cdc447f2fb():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                carrier_ip=self.carrier_ip,
                customer_owned_ip=self.customer_owned_ip,
                ip_owner_id=self.ip_owner_id,
                public_dns_name=self.public_dns_name,
                public_ip=self.public_ip,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.carrier_ip == other.carrier_ip and
                self.customer_owned_ip == other.customer_owned_ip and
                self.ip_owner_id == other.ip_owner_id and
                self.public_dns_name == other.public_dns_name and
                self.public_ip == other.public_ip
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'carrier_ip',
            'customer_owned_ip',
            'ip_owner_id',
            'public_dns_name',
            'public_ip',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'carrier_ip',
            'customer_owned_ip',
            'ip_owner_id',
            'public_dns_name',
            'public_ip',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.carrier_ip,
                self.customer_owned_ip,
                self.ip_owner_id,
                self.public_dns_name,
                self.public_ip,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            carrier_ip: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            customer_owned_ip: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            ip_owner_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            public_dns_name: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            public_ip: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'carrier_ip', carrier_ip)
            __dataclass__object_setattr(self, 'customer_owned_ip', customer_owned_ip)
            __dataclass__object_setattr(self, 'ip_owner_id', ip_owner_id)
            __dataclass__object_setattr(self, 'public_dns_name', public_dns_name)
            __dataclass__object_setattr(self, 'public_ip', public_ip)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"carrier_ip={self.carrier_ip!r}")
            parts.append(f"customer_owned_ip={self.customer_owned_ip!r}")
            parts.append(f"ip_owner_id={self.ip_owner_id!r}")
            parts.append(f"public_dns_name={self.public_dns_name!r}")
            parts.append(f"public_ip={self.public_ip!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('attach_time', 'attachment_id', 'delete_on_termination', 'device_index', 'status',"
        " 'network_card_index', 'ena_srd_specification', 'ena_queue_count')), EqPlan(fields=('attach_time', 'attachment"
        "_id', 'delete_on_termination', 'device_index', 'status', 'network_card_index', 'ena_srd_specification', 'ena_q"
        "ueue_count')), FrozenPlan(fields=('__shape__', 'attach_time', 'attachment_id', 'delete_on_termination', 'devic"
        "e_index', 'status', 'network_card_index', 'ena_srd_specification', 'ena_queue_count'), allow_dynamic_dunder_at"
        "trs=False), HashPlan(action='add', fields=('attach_time', 'attachment_id', 'delete_on_termination', 'device_in"
        "dex', 'status', 'network_card_index', 'ena_srd_specification', 'ena_queue_count'), cache=False), InitPlan(fiel"
        "ds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_"
        "factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='attach_time', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(n"
        "ame='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
        "coerce=None, validate=None, check_type=None), InitPlan.Field(name='attachment_id', annotation=OpRef(name='init"
        ".fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override"
        "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dele"
        "te_on_termination', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='device_index', annotation=OpRef(name='init.fields.4.annotation'), d"
        "efault=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='status', annotation=OpRef(nam"
        "e='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='network_card_index', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='ena_srd_specification', annotation=OpRef(name='init.fields.7.an"
        "notation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, fiel"
        "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_queue_count'"
        ", annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e)), self_param='self', std_params=(), kw_only_params=('attach_time', 'attachment_id', 'delete_on_termination'"
        ", 'device_index', 'status', 'network_card_index', 'ena_srd_specification', 'ena_queue_count'), frozen=True, sl"
        "ots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='attach_"
        "time', kw_only=True, fn=None), ReprPlan.Field(name='attachment_id', kw_only=True, fn=None), ReprPlan.Field(nam"
        "e='delete_on_termination', kw_only=True, fn=None), ReprPlan.Field(name='device_index', kw_only=True, fn=None),"
        " ReprPlan.Field(name='status', kw_only=True, fn=None), ReprPlan.Field(name='network_card_index', kw_only=True,"
        " fn=None), ReprPlan.Field(name='ena_srd_specification', kw_only=True, fn=None), ReprPlan.Field(name='ena_queue"
        "_count', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d3168df540d7e8ab8fa773b5212bd293a057edb3',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceNetworkInterfaceAttachment'),
    ),
)
def _process_dataclass__d3168df540d7e8ab8fa773b5212bd293a057edb3():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                attach_time=self.attach_time,
                attachment_id=self.attachment_id,
                delete_on_termination=self.delete_on_termination,
                device_index=self.device_index,
                status=self.status,
                network_card_index=self.network_card_index,
                ena_srd_specification=self.ena_srd_specification,
                ena_queue_count=self.ena_queue_count,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.attach_time == other.attach_time and
                self.attachment_id == other.attachment_id and
                self.delete_on_termination == other.delete_on_termination and
                self.device_index == other.device_index and
                self.status == other.status and
                self.network_card_index == other.network_card_index and
                self.ena_srd_specification == other.ena_srd_specification and
                self.ena_queue_count == other.ena_queue_count
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'attach_time',
            'attachment_id',
            'delete_on_termination',
            'device_index',
            'status',
            'network_card_index',
            'ena_srd_specification',
            'ena_queue_count',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'attach_time',
            'attachment_id',
            'delete_on_termination',
            'device_index',
            'status',
            'network_card_index',
            'ena_srd_specification',
            'ena_queue_count',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.attach_time,
                self.attachment_id,
                self.delete_on_termination,
                self.device_index,
                self.status,
                self.network_card_index,
                self.ena_srd_specification,
                self.ena_queue_count,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            attach_time: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            attachment_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            delete_on_termination: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            device_index: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            status: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            network_card_index: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            ena_srd_specification: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            ena_queue_count: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'attach_time', attach_time)
            __dataclass__object_setattr(self, 'attachment_id', attachment_id)
            __dataclass__object_setattr(self, 'delete_on_termination', delete_on_termination)
            __dataclass__object_setattr(self, 'device_index', device_index)
            __dataclass__object_setattr(self, 'status', status)
            __dataclass__object_setattr(self, 'network_card_index', network_card_index)
            __dataclass__object_setattr(self, 'ena_srd_specification', ena_srd_specification)
            __dataclass__object_setattr(self, 'ena_queue_count', ena_queue_count)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"attach_time={self.attach_time!r}")
            parts.append(f"attachment_id={self.attachment_id!r}")
            parts.append(f"delete_on_termination={self.delete_on_termination!r}")
            parts.append(f"device_index={self.device_index!r}")
            parts.append(f"status={self.status!r}")
            parts.append(f"network_card_index={self.network_card_index!r}")
            parts.append(f"ena_srd_specification={self.ena_srd_specification!r}")
            parts.append(f"ena_queue_count={self.ena_queue_count!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('associate_public_ip_address', 'delete_on_termination', 'description', 'device_ind"
        "ex', 'groups', 'ipv6_address_count', 'ipv6_addresses', 'network_interface_id', 'private_ip_address', 'private_"
        "ip_addresses', 'secondary_private_ip_address_count', 'subnet_id', 'associate_carrier_ip_address', 'interface_t"
        "ype', 'network_card_index', 'ipv4_prefixes', 'ipv4_prefix_count', 'ipv6_prefixes', 'ipv6_prefix_count', 'prima"
        "ry_ipv6', 'ena_srd_specification', 'connection_tracking_specification', 'ena_queue_count')), EqPlan(fields=('a"
        "ssociate_public_ip_address', 'delete_on_termination', 'description', 'device_index', 'groups', 'ipv6_address_c"
        "ount', 'ipv6_addresses', 'network_interface_id', 'private_ip_address', 'private_ip_addresses', 'secondary_priv"
        "ate_ip_address_count', 'subnet_id', 'associate_carrier_ip_address', 'interface_type', 'network_card_index', 'i"
        "pv4_prefixes', 'ipv4_prefix_count', 'ipv6_prefixes', 'ipv6_prefix_count', 'primary_ipv6', 'ena_srd_specificati"
        "on', 'connection_tracking_specification', 'ena_queue_count')), FrozenPlan(fields=('__shape__', 'associate_publ"
        "ic_ip_address', 'delete_on_termination', 'description', 'device_index', 'groups', 'ipv6_address_count', 'ipv6_"
        "addresses', 'network_interface_id', 'private_ip_address', 'private_ip_addresses', 'secondary_private_ip_addres"
        "s_count', 'subnet_id', 'associate_carrier_ip_address', 'interface_type', 'network_card_index', 'ipv4_prefixes'"
        ", 'ipv4_prefix_count', 'ipv6_prefixes', 'ipv6_prefix_count', 'primary_ipv6', 'ena_srd_specification', 'connect"
        "ion_tracking_specification', 'ena_queue_count'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fie"
        "lds=('associate_public_ip_address', 'delete_on_termination', 'description', 'device_index', 'groups', 'ipv6_ad"
        "dress_count', 'ipv6_addresses', 'network_interface_id', 'private_ip_address', 'private_ip_addresses', 'seconda"
        "ry_private_ip_address_count', 'subnet_id', 'associate_carrier_ip_address', 'interface_type', 'network_card_ind"
        "ex', 'ipv4_prefixes', 'ipv4_prefix_count', 'ipv6_prefixes', 'ipv6_prefix_count', 'primary_ipv6', 'ena_srd_spec"
        "ification', 'connection_tracking_specification', 'ena_queue_count'), cache=False), InitPlan(fields=(InitPlan.F"
        "ield(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, "
        "init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitP"
        "lan.Field(name='associate_public_ip_address', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef"
        "(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='delete_on_termination', annotation=OpRef("
        "name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='description', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='device_index', annotation=OpRef(name='init.fields.4.annotation'), d"
        "efault=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='groups', annotation=OpRef(nam"
        "e='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='ipv6_address_count', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='ipv6_addresses', annotation=OpRef(name='init.fields.7.annotatio"
        "n'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type="
        "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_interface_id', "
        "annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='private_ip_address', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(n"
        "ame='init.fields.9.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
        "coerce=None, validate=None, check_type=None), InitPlan.Field(name='private_ip_addresses', annotation=OpRef(nam"
        "e='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='secondary_private_ip_address_count', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(na"
        "me='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
        "coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnet_id', annotation=OpRef(name='init.fie"
        "lds.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True, override=F"
        "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='associ"
        "ate_carrier_ip_address', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.1"
        "3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='interface_type', annotation=OpRef(name='init.fields.14.annot"
        "ation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_card_index"
        "', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None), InitPlan.Field(name='ipv4_prefixes', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef("
        "name='init.fields.16.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv4_prefix_count', annotation=OpRef(name"
        "='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='ipv6_prefixes', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.18.def"
        "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
        "None, check_type=None), InitPlan.Field(name='ipv6_prefix_count', annotation=OpRef(name='init.fields.19.annotat"
        "ion'), default=OpRef(name='init.fields.19.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='primary_ipv6', annot"
        "ation=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.fields.20.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='ena_srd_specification', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef("
        "name='init.fields.21.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='connection_tracking_specification', annot"
        "ation=OpRef(name='init.fields.22.annotation'), default=OpRef(name='init.fields.22.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='ena_queue_count', annotation=OpRef(name='init.fields.23.annotation'), default=OpRef(name='"
        "init.fields.23.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('associate_public"
        "_ip_address', 'delete_on_termination', 'description', 'device_index', 'groups', 'ipv6_address_count', 'ipv6_ad"
        "dresses', 'network_interface_id', 'private_ip_address', 'private_ip_addresses', 'secondary_private_ip_address_"
        "count', 'subnet_id', 'associate_carrier_ip_address', 'interface_type', 'network_card_index', 'ipv4_prefixes', "
        "'ipv4_prefix_count', 'ipv6_prefixes', 'ipv6_prefix_count', 'primary_ipv6', 'ena_srd_specification', 'connectio"
        "n_tracking_specification', 'ena_queue_count'), frozen=True, slots=False, post_init_params=None, init_fns=(), v"
        "alidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='associate_public_ip_address', kw_only=True, fn=None), R"
        "eprPlan.Field(name='delete_on_termination', kw_only=True, fn=None), ReprPlan.Field(name='description', kw_only"
        "=True, fn=None), ReprPlan.Field(name='device_index', kw_only=True, fn=None), ReprPlan.Field(name='groups', kw_"
        "only=True, fn=None), ReprPlan.Field(name='ipv6_address_count', kw_only=True, fn=None), ReprPlan.Field(name='ip"
        "v6_addresses', kw_only=True, fn=None), ReprPlan.Field(name='network_interface_id', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='private_ip_address', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_addresses', kw_"
        "only=True, fn=None), ReprPlan.Field(name='secondary_private_ip_address_count', kw_only=True, fn=None), ReprPla"
        "n.Field(name='subnet_id', kw_only=True, fn=None), ReprPlan.Field(name='associate_carrier_ip_address', kw_only="
        "True, fn=None), ReprPlan.Field(name='interface_type', kw_only=True, fn=None), ReprPlan.Field(name='network_car"
        "d_index', kw_only=True, fn=None), ReprPlan.Field(name='ipv4_prefixes', kw_only=True, fn=None), ReprPlan.Field("
        "name='ipv4_prefix_count', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_prefixes', kw_only=True, fn=None),"
        " ReprPlan.Field(name='ipv6_prefix_count', kw_only=True, fn=None), ReprPlan.Field(name='primary_ipv6', kw_only="
        "True, fn=None), ReprPlan.Field(name='ena_srd_specification', kw_only=True, fn=None), ReprPlan.Field(name='conn"
        "ection_tracking_specification', kw_only=True, fn=None), ReprPlan.Field(name='ena_queue_count', kw_only=True, f"
        "n=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d6ea01a33163f433cc27fd38db73e13a68f9e565',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceNetworkInterfaceSpecification'),
    ),
)
def _process_dataclass__d6ea01a33163f433cc27fd38db73e13a68f9e565():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                associate_public_ip_address=self.associate_public_ip_address,
                delete_on_termination=self.delete_on_termination,
                description=self.description,
                device_index=self.device_index,
                groups=self.groups,
                ipv6_address_count=self.ipv6_address_count,
                ipv6_addresses=self.ipv6_addresses,
                network_interface_id=self.network_interface_id,
                private_ip_address=self.private_ip_address,
                private_ip_addresses=self.private_ip_addresses,
                secondary_private_ip_address_count=self.secondary_private_ip_address_count,
                subnet_id=self.subnet_id,
                associate_carrier_ip_address=self.associate_carrier_ip_address,
                interface_type=self.interface_type,
                network_card_index=self.network_card_index,
                ipv4_prefixes=self.ipv4_prefixes,
                ipv4_prefix_count=self.ipv4_prefix_count,
                ipv6_prefixes=self.ipv6_prefixes,
                ipv6_prefix_count=self.ipv6_prefix_count,
                primary_ipv6=self.primary_ipv6,
                ena_srd_specification=self.ena_srd_specification,
                connection_tracking_specification=self.connection_tracking_specification,
                ena_queue_count=self.ena_queue_count,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.associate_public_ip_address == other.associate_public_ip_address and
                self.delete_on_termination == other.delete_on_termination and
                self.description == other.description and
                self.device_index == other.device_index and
                self.groups == other.groups and
                self.ipv6_address_count == other.ipv6_address_count and
                self.ipv6_addresses == other.ipv6_addresses and
                self.network_interface_id == other.network_interface_id and
                self.private_ip_address == other.private_ip_address and
                self.private_ip_addresses == other.private_ip_addresses and
                self.secondary_private_ip_address_count == other.secondary_private_ip_address_count and
                self.subnet_id == other.subnet_id and
                self.associate_carrier_ip_address == other.associate_carrier_ip_address and
                self.interface_type == other.interface_type and
                self.network_card_index == other.network_card_index and
                self.ipv4_prefixes == other.ipv4_prefixes and
                self.ipv4_prefix_count == other.ipv4_prefix_count and
                self.ipv6_prefixes == other.ipv6_prefixes and
                self.ipv6_prefix_count == other.ipv6_prefix_count and
                self.primary_ipv6 == other.primary_ipv6 and
                self.ena_srd_specification == other.ena_srd_specification and
                self.connection_tracking_specification == other.connection_tracking_specification and
                self.ena_queue_count == other.ena_queue_count
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'associate_public_ip_address',
            'delete_on_termination',
            'description',
            'device_index',
            'groups',
            'ipv6_address_count',
            'ipv6_addresses',
            'network_interface_id',
            'private_ip_address',
            'private_ip_addresses',
            'secondary_private_ip_address_count',
            'subnet_id',
            'associate_carrier_ip_address',
            'interface_type',
            'network_card_index',
            'ipv4_prefixes',
            'ipv4_prefix_count',
            'ipv6_prefixes',
            'ipv6_prefix_count',
            'primary_ipv6',
            'ena_srd_specification',
            'connection_tracking_specification',
            'ena_queue_count',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'associate_public_ip_address',
            'delete_on_termination',
            'description',
            'device_index',
            'groups',
            'ipv6_address_count',
            'ipv6_addresses',
            'network_interface_id',
            'private_ip_address',
            'private_ip_addresses',
            'secondary_private_ip_address_count',
            'subnet_id',
            'associate_carrier_ip_address',
            'interface_type',
            'network_card_index',
            'ipv4_prefixes',
            'ipv4_prefix_count',
            'ipv6_prefixes',
            'ipv6_prefix_count',
            'primary_ipv6',
            'ena_srd_specification',
            'connection_tracking_specification',
            'ena_queue_count',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.associate_public_ip_address,
                self.delete_on_termination,
                self.description,
                self.device_index,
                self.groups,
                self.ipv6_address_count,
                self.ipv6_addresses,
                self.network_interface_id,
                self.private_ip_address,
                self.private_ip_addresses,
                self.secondary_private_ip_address_count,
                self.subnet_id,
                self.associate_carrier_ip_address,
                self.interface_type,
                self.network_card_index,
                self.ipv4_prefixes,
                self.ipv4_prefix_count,
                self.ipv6_prefixes,
                self.ipv6_prefix_count,
                self.primary_ipv6,
                self.ena_srd_specification,
                self.connection_tracking_specification,
                self.ena_queue_count,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            associate_public_ip_address: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            delete_on_termination: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            description: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            device_index: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            groups: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            ipv6_address_count: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            ipv6_addresses: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            network_interface_id: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            private_ip_address: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            private_ip_addresses: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            secondary_private_ip_address_count: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            subnet_id: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            associate_carrier_ip_address: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            interface_type: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            network_card_index: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            ipv4_prefixes: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            ipv4_prefix_count: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            ipv6_prefixes: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            ipv6_prefix_count: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            primary_ipv6: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            ena_srd_specification: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            connection_tracking_specification: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            ena_queue_count: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'associate_public_ip_address', associate_public_ip_address)
            __dataclass__object_setattr(self, 'delete_on_termination', delete_on_termination)
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'device_index', device_index)
            __dataclass__object_setattr(self, 'groups', groups)
            __dataclass__object_setattr(self, 'ipv6_address_count', ipv6_address_count)
            __dataclass__object_setattr(self, 'ipv6_addresses', ipv6_addresses)
            __dataclass__object_setattr(self, 'network_interface_id', network_interface_id)
            __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)
            __dataclass__object_setattr(self, 'private_ip_addresses', private_ip_addresses)
            __dataclass__object_setattr(self, 'secondary_private_ip_address_count', secondary_private_ip_address_count)
            __dataclass__object_setattr(self, 'subnet_id', subnet_id)
            __dataclass__object_setattr(self, 'associate_carrier_ip_address', associate_carrier_ip_address)
            __dataclass__object_setattr(self, 'interface_type', interface_type)
            __dataclass__object_setattr(self, 'network_card_index', network_card_index)
            __dataclass__object_setattr(self, 'ipv4_prefixes', ipv4_prefixes)
            __dataclass__object_setattr(self, 'ipv4_prefix_count', ipv4_prefix_count)
            __dataclass__object_setattr(self, 'ipv6_prefixes', ipv6_prefixes)
            __dataclass__object_setattr(self, 'ipv6_prefix_count', ipv6_prefix_count)
            __dataclass__object_setattr(self, 'primary_ipv6', primary_ipv6)
            __dataclass__object_setattr(self, 'ena_srd_specification', ena_srd_specification)
            __dataclass__object_setattr(self, 'connection_tracking_specification', connection_tracking_specification)
            __dataclass__object_setattr(self, 'ena_queue_count', ena_queue_count)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"associate_public_ip_address={self.associate_public_ip_address!r}")
            parts.append(f"delete_on_termination={self.delete_on_termination!r}")
            parts.append(f"description={self.description!r}")
            parts.append(f"device_index={self.device_index!r}")
            parts.append(f"groups={self.groups!r}")
            parts.append(f"ipv6_address_count={self.ipv6_address_count!r}")
            parts.append(f"ipv6_addresses={self.ipv6_addresses!r}")
            parts.append(f"network_interface_id={self.network_interface_id!r}")
            parts.append(f"private_ip_address={self.private_ip_address!r}")
            parts.append(f"private_ip_addresses={self.private_ip_addresses!r}")
            parts.append(f"secondary_private_ip_address_count={self.secondary_private_ip_address_count!r}")
            parts.append(f"subnet_id={self.subnet_id!r}")
            parts.append(f"associate_carrier_ip_address={self.associate_carrier_ip_address!r}")
            parts.append(f"interface_type={self.interface_type!r}")
            parts.append(f"network_card_index={self.network_card_index!r}")
            parts.append(f"ipv4_prefixes={self.ipv4_prefixes!r}")
            parts.append(f"ipv4_prefix_count={self.ipv4_prefix_count!r}")
            parts.append(f"ipv6_prefixes={self.ipv6_prefixes!r}")
            parts.append(f"ipv6_prefix_count={self.ipv6_prefix_count!r}")
            parts.append(f"primary_ipv6={self.primary_ipv6!r}")
            parts.append(f"ena_srd_specification={self.ena_srd_specification!r}")
            parts.append(f"connection_tracking_specification={self.connection_tracking_specification!r}")
            parts.append(f"ena_queue_count={self.ena_queue_count!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('bandwidth_weighting',)), EqPlan(fields=('bandwidth_weighting',)), FrozenPlan(fiel"
        "ds=('__shape__', 'bandwidth_weighting'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ba"
        "ndwidth_weighting',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='i"
        "nit.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType"
        ".CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='bandwidth_weighting', annotatio"
        "n=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_p"
        "aram='self', std_params=(), kw_only_params=('bandwidth_weighting',), frozen=True, slots=False, post_init_param"
        "s=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='bandwidth_weighting', kw_only=Tru"
        "e, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='74995e6dde021b73d230df53469d42118e72a658',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceNetworkPerformanceOptions'),
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceNetworkPerformanceOptionsRequest'),
    ),
)
def _process_dataclass__74995e6dde021b73d230df53469d42118e72a658():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                bandwidth_weighting=self.bandwidth_weighting,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.bandwidth_weighting == other.bandwidth_weighting
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'bandwidth_weighting',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'bandwidth_weighting',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.bandwidth_weighting,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            bandwidth_weighting: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'bandwidth_weighting', bandwidth_weighting)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"bandwidth_weighting={self.bandwidth_weighting!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('association', 'primary', 'private_dns_name', 'private_ip_address')), EqPlan(field"
        "s=('association', 'primary', 'private_dns_name', 'private_ip_address')), FrozenPlan(fields=('__shape__', 'asso"
        "ciation', 'primary', 'private_dns_name', 'private_ip_address'), allow_dynamic_dunder_attrs=False), HashPlan(ac"
        "tion='add', fields=('association', 'primary', 'private_dns_name', 'private_ip_address'), cache=False), InitPla"
        "n(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='association', annotation=OpRef(name='init.fields.1.annotation'), default=O"
        "pRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='primary', annotation=OpRef(name='init"
        ".fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override"
        "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='priv"
        "ate_dns_name', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None), InitPlan.Field(name='private_ip_address', annotation=OpRef(name='init.fields.4.annotation'), "
        "default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params"
        "=('association', 'primary', 'private_dns_name', 'private_ip_address'), frozen=True, slots=False, post_init_par"
        "ams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='association', kw_only=True, fn="
        "None), ReprPlan.Field(name='primary', kw_only=True, fn=None), ReprPlan.Field(name='private_dns_name', kw_only="
        "True, fn=None), ReprPlan.Field(name='private_ip_address', kw_only=True, fn=None)), id=False, terse=False, defa"
        "ult_fn=None)))"
    ),
    plan_repr_sha1='8b22e4f30c55342a1e67e0793e5d4a8aabf425d6',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstancePrivateIpAddress'),
        ('ominfra.clouds.aws.models.services.ec2', 'NetworkInterfacePrivateIpAddress'),
    ),
)
def _process_dataclass__8b22e4f30c55342a1e67e0793e5d4a8aabf425d6():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                association=self.association,
                primary=self.primary,
                private_dns_name=self.private_dns_name,
                private_ip_address=self.private_ip_address,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.association == other.association and
                self.primary == other.primary and
                self.private_dns_name == other.private_dns_name and
                self.private_ip_address == other.private_ip_address
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'association',
            'primary',
            'private_dns_name',
            'private_ip_address',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'association',
            'primary',
            'private_dns_name',
            'private_ip_address',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.association,
                self.primary,
                self.private_dns_name,
                self.private_ip_address,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            association: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            primary: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            private_dns_name: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            private_ip_address: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'association', association)
            __dataclass__object_setattr(self, 'primary', primary)
            __dataclass__object_setattr(self, 'private_dns_name', private_dns_name)
            __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"association={self.association!r}")
            parts.append(f"primary={self.primary!r}")
            parts.append(f"private_dns_name={self.private_dns_name!r}")
            parts.append(f"private_ip_address={self.private_ip_address!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('code', 'name')), EqPlan(fields=('code', 'name')), FrozenPlan(fields=('__shape__',"
        " 'code', 'name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('code', 'name'), cache=Fal"
        "se), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), defa"
        "ult=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='code', annotation=OpRef(name='init.fields.1.annotation'), defa"
        "ult=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='in"
        "it.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std"
        "_params=(), kw_only_params=('code', 'name'), frozen=True, slots=False, post_init_params=None, init_fns=(), val"
        "idate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='code', kw_only=True, fn=None), ReprPlan.Field(name='name'"
        ", kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='ef87c4fd27d904caa46d66d1804e9d4beeecae25',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceState'),
    ),
)
def _process_dataclass__ef87c4fd27d904caa46d66d1804e9d4beeecae25():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                code=self.code,
                name=self.name,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.code == other.code and
                self.name == other.name
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'code',
            'name',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'code',
            'name',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.code,
                self.name,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            code: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'code', code)
            __dataclass__object_setattr(self, 'name', name)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"code={self.code!r}")
            parts.append(f"name={self.name!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('instance_id', 'current_state', 'previous_state')), EqPlan(fields=('instance_id', "
        "'current_state', 'previous_state')), FrozenPlan(fields=('__shape__', 'instance_id', 'current_state', 'previous"
        "_state'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('instance_id', 'current_state', 'p"
        "revious_state'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.f"
        "ields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLAS"
        "S_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_id', annotation=OpRef(name="
        "'init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
        "'current_state', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='previous_state', annotation=OpRef(name='init.fields.3.annotation'), de"
        "fault=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=("
        "'instance_id', 'current_state', 'previous_state'), frozen=True, slots=False, post_init_params=None, init_fns=("
        "), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='instance_id', kw_only=True, fn=None), ReprPlan.Fiel"
        "d(name='current_state', kw_only=True, fn=None), ReprPlan.Field(name='previous_state', kw_only=True, fn=None)),"
        " id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='b37870e1fb3b8b28bae14f82ea3a92213b6d8404',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceStateChange'),
    ),
)
def _process_dataclass__b37870e1fb3b8b28bae14f82ea3a92213b6d8404():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                instance_id=self.instance_id,
                current_state=self.current_state,
                previous_state=self.previous_state,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.instance_id == other.instance_id and
                self.current_state == other.current_state and
                self.previous_state == other.previous_state
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'instance_id',
            'current_state',
            'previous_state',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'instance_id',
            'current_state',
            'previous_state',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.instance_id,
                self.current_state,
                self.previous_state,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            instance_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            current_state: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            previous_state: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'instance_id', instance_id)
            __dataclass__object_setattr(self, 'current_state', current_state)
            __dataclass__object_setattr(self, 'previous_state', previous_state)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"instance_id={self.instance_id!r}")
            parts.append(f"current_state={self.current_state!r}")
            parts.append(f"previous_state={self.previous_state!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('total_size_in_gb', 'disks', 'nvme_support', 'encryption_support')), EqPlan(fields"
        "=('total_size_in_gb', 'disks', 'nvme_support', 'encryption_support')), FrozenPlan(fields=('__shape__', 'total_"
        "size_in_gb', 'disks', 'nvme_support', 'encryption_support'), allow_dynamic_dunder_attrs=False), HashPlan(actio"
        "n='add', fields=('total_size_in_gb', 'disks', 'nvme_support', 'encryption_support'), cache=False), InitPlan(fi"
        "elds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, defaul"
        "t_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_t"
        "ype=None), InitPlan.Field(name='total_size_in_gb', annotation=OpRef(name='init.fields.1.annotation'), default="
        "OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='disks', annotation=OpRef(name='init."
        "fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override="
        "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='nvme_"
        "support', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='encryption_support', annotation=OpRef(name='init.fields.4.annotation'), defau"
        "lt=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType."
        "INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('to"
        "tal_size_in_gb', 'disks', 'nvme_support', 'encryption_support'), frozen=True, slots=False, post_init_params=No"
        "ne, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='total_size_in_gb', kw_only=True, fn=N"
        "one), ReprPlan.Field(name='disks', kw_only=True, fn=None), ReprPlan.Field(name='nvme_support', kw_only=True, f"
        "n=None), ReprPlan.Field(name='encryption_support', kw_only=True, fn=None)), id=False, terse=False, default_fn="
        "None)))"
    ),
    plan_repr_sha1='327236ea672fda2b2703a334052e0713bf4d89b0',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceStorageInfo'),
    ),
)
def _process_dataclass__327236ea672fda2b2703a334052e0713bf4d89b0():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                total_size_in_gb=self.total_size_in_gb,
                disks=self.disks,
                nvme_support=self.nvme_support,
                encryption_support=self.encryption_support,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.total_size_in_gb == other.total_size_in_gb and
                self.disks == other.disks and
                self.nvme_support == other.nvme_support and
                self.encryption_support == other.encryption_support
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'total_size_in_gb',
            'disks',
            'nvme_support',
            'encryption_support',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'total_size_in_gb',
            'disks',
            'nvme_support',
            'encryption_support',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.total_size_in_gb,
                self.disks,
                self.nvme_support,
                self.encryption_support,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            total_size_in_gb: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            disks: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            nvme_support: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            encryption_support: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'total_size_in_gb', total_size_in_gb)
            __dataclass__object_setattr(self, 'disks', disks)
            __dataclass__object_setattr(self, 'nvme_support', nvme_support)
            __dataclass__object_setattr(self, 'encryption_support', encryption_support)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"total_size_in_gb={self.total_size_in_gb!r}")
            parts.append(f"disks={self.disks!r}")
            parts.append(f"nvme_support={self.nvme_support!r}")
            parts.append(f"encryption_support={self.encryption_support!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('instance_type', 'current_generation', 'free_tier_eligible', 'supported_usage_clas"
        "ses', 'supported_root_device_types', 'supported_virtualization_types', 'bare_metal', 'hypervisor', 'processor_"
        "info', 'v_cpu_info', 'memory_info', 'instance_storage_supported', 'instance_storage_info', 'ebs_info', 'networ"
        "k_info', 'gpu_info', 'fpga_info', 'placement_group_info', 'inference_accelerator_info', 'hibernation_supported"
        "', 'burstable_performance_supported', 'dedicated_hosts_supported', 'auto_recovery_supported', 'supported_boot_"
        "modes', 'nitro_enclaves_support', 'nitro_tpm_support', 'nitro_tpm_info', 'media_accelerator_info', 'neuron_inf"
        "o', 'phc_support', 'reboot_migration_support')), EqPlan(fields=('instance_type', 'current_generation', 'free_t"
        "ier_eligible', 'supported_usage_classes', 'supported_root_device_types', 'supported_virtualization_types', 'ba"
        "re_metal', 'hypervisor', 'processor_info', 'v_cpu_info', 'memory_info', 'instance_storage_supported', 'instanc"
        "e_storage_info', 'ebs_info', 'network_info', 'gpu_info', 'fpga_info', 'placement_group_info', 'inference_accel"
        "erator_info', 'hibernation_supported', 'burstable_performance_supported', 'dedicated_hosts_supported', 'auto_r"
        "ecovery_supported', 'supported_boot_modes', 'nitro_enclaves_support', 'nitro_tpm_support', 'nitro_tpm_info', '"
        "media_accelerator_info', 'neuron_info', 'phc_support', 'reboot_migration_support')), FrozenPlan(fields=('__sha"
        "pe__', 'instance_type', 'current_generation', 'free_tier_eligible', 'supported_usage_classes', 'supported_root"
        "_device_types', 'supported_virtualization_types', 'bare_metal', 'hypervisor', 'processor_info', 'v_cpu_info', "
        "'memory_info', 'instance_storage_supported', 'instance_storage_info', 'ebs_info', 'network_info', 'gpu_info', "
        "'fpga_info', 'placement_group_info', 'inference_accelerator_info', 'hibernation_supported', 'burstable_perform"
        "ance_supported', 'dedicated_hosts_supported', 'auto_recovery_supported', 'supported_boot_modes', 'nitro_enclav"
        "es_support', 'nitro_tpm_support', 'nitro_tpm_info', 'media_accelerator_info', 'neuron_info', 'phc_support', 'r"
        "eboot_migration_support'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('instance_type', "
        "'current_generation', 'free_tier_eligible', 'supported_usage_classes', 'supported_root_device_types', 'support"
        "ed_virtualization_types', 'bare_metal', 'hypervisor', 'processor_info', 'v_cpu_info', 'memory_info', 'instance"
        "_storage_supported', 'instance_storage_info', 'ebs_info', 'network_info', 'gpu_info', 'fpga_info', 'placement_"
        "group_info', 'inference_accelerator_info', 'hibernation_supported', 'burstable_performance_supported', 'dedica"
        "ted_hosts_supported', 'auto_recovery_supported', 'supported_boot_modes', 'nitro_enclaves_support', 'nitro_tpm_"
        "support', 'nitro_tpm_info', 'media_accelerator_info', 'neuron_info', 'phc_support', 'reboot_migration_support'"
        "), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annota"
        "tion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='instance_type', annotation=OpRef(name='init.fields"
        ".1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='current_gen"
        "eration', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='free_tier_eligible', annotation=OpRef(name='init.fields.3.annotation'), defau"
        "lt=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType."
        "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='supported_usage_classes', annotat"
        "ion=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None,"
        " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
        "lan.Field(name='supported_root_device_types', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef"
        "(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='supported_virtualization_types', annotati"
        "on=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='bare_metal', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields"
        ".7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='hypervisor', annotation=OpRef(name='init.fields.8.annotatio"
        "n'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type="
        "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='processor_info', annota"
        "tion=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='v_cpu_info', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fie"
        "lds.10.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='memory_info', annotation=OpRef(name='init.fields.11.ann"
        "otation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=False, fiel"
        "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_storage"
        "_supported', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None), InitPlan.Field(name='instance_storage_info', annotation=OpRef(name='init.fields.13.annotation"
        "'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=False, field_type="
        "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ebs_info', annotation=O"
        "pRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
        ".Field(name='network_info', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.field"
        "s.15.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None), InitPlan.Field(name='gpu_info', annotation=OpRef(name='init.fields.16.annotati"
        "on'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='fpga_info', annotatio"
        "n=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None,"
        " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
        "lan.Field(name='placement_group_info', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name="
        "'init.fields.18.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='inference_accelerator_info', annotation=OpRef("
        "name='init.fields.19.annotation'), default=OpRef(name='init.fields.19.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='hibernation_supported', annotation=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.f"
        "ields.20.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
        "e, validate=None, check_type=None), InitPlan.Field(name='burstable_performance_supported', annotation=OpRef(na"
        "me='init.fields.21.annotation'), default=OpRef(name='init.fields.21.default'), default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='dedicated_hosts_supported', annotation=OpRef(name='init.fields.22.annotation'), default=OpRef(name='init"
        ".fields.22.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
        "one, validate=None, check_type=None), InitPlan.Field(name='auto_recovery_supported', annotation=OpRef(name='in"
        "it.fields.23.annotation'), default=OpRef(name='init.fields.23.default'), default_factory=None, init=True, over"
        "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "supported_boot_modes', annotation=OpRef(name='init.fields.24.annotation'), default=OpRef(name='init.fields.24."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='nitro_enclaves_support', annotation=OpRef(name='init.fields.25"
        ".annotation'), default=OpRef(name='init.fields.25.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='nitro_tpm_su"
        "pport', annotation=OpRef(name='init.fields.26.annotation'), default=OpRef(name='init.fields.26.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='nitro_tpm_info', annotation=OpRef(name='init.fields.27.annotation'), default="
        "OpRef(name='init.fields.27.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
        "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='media_accelerator_info', annotation"
        "=OpRef(name='init.fields.28.annotation'), default=OpRef(name='init.fields.28.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='neuron_info', annotation=OpRef(name='init.fields.29.annotation'), default=OpRef(name='init.fiel"
        "ds.29.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='phc_support', annotation=OpRef(name='init.fields.30.anno"
        "tation'), default=OpRef(name='init.fields.30.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='reboot_migration_"
        "support', annotation=OpRef(name='init.fields.31.annotation'), default=OpRef(name='init.fields.31.default'), de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
        "k_type=None)), self_param='self', std_params=(), kw_only_params=('instance_type', 'current_generation', 'free_"
        "tier_eligible', 'supported_usage_classes', 'supported_root_device_types', 'supported_virtualization_types', 'b"
        "are_metal', 'hypervisor', 'processor_info', 'v_cpu_info', 'memory_info', 'instance_storage_supported', 'instan"
        "ce_storage_info', 'ebs_info', 'network_info', 'gpu_info', 'fpga_info', 'placement_group_info', 'inference_acce"
        "lerator_info', 'hibernation_supported', 'burstable_performance_supported', 'dedicated_hosts_supported', 'auto_"
        "recovery_supported', 'supported_boot_modes', 'nitro_enclaves_support', 'nitro_tpm_support', 'nitro_tpm_info', "
        "'media_accelerator_info', 'neuron_info', 'phc_support', 'reboot_migration_support'), frozen=True, slots=False,"
        " post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='instance_type', k"
        "w_only=True, fn=None), ReprPlan.Field(name='current_generation', kw_only=True, fn=None), ReprPlan.Field(name='"
        "free_tier_eligible', kw_only=True, fn=None), ReprPlan.Field(name='supported_usage_classes', kw_only=True, fn=N"
        "one), ReprPlan.Field(name='supported_root_device_types', kw_only=True, fn=None), ReprPlan.Field(name='supporte"
        "d_virtualization_types', kw_only=True, fn=None), ReprPlan.Field(name='bare_metal', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='hypervisor', kw_only=True, fn=None), ReprPlan.Field(name='processor_info', kw_only=True, fn="
        "None), ReprPlan.Field(name='v_cpu_info', kw_only=True, fn=None), ReprPlan.Field(name='memory_info', kw_only=Tr"
        "ue, fn=None), ReprPlan.Field(name='instance_storage_supported', kw_only=True, fn=None), ReprPlan.Field(name='i"
        "nstance_storage_info', kw_only=True, fn=None), ReprPlan.Field(name='ebs_info', kw_only=True, fn=None), ReprPla"
        "n.Field(name='network_info', kw_only=True, fn=None), ReprPlan.Field(name='gpu_info', kw_only=True, fn=None), R"
        "eprPlan.Field(name='fpga_info', kw_only=True, fn=None), ReprPlan.Field(name='placement_group_info', kw_only=Tr"
        "ue, fn=None), ReprPlan.Field(name='inference_accelerator_info', kw_only=True, fn=None), ReprPlan.Field(name='h"
        "ibernation_supported', kw_only=True, fn=None), ReprPlan.Field(name='burstable_performance_supported', kw_only="
        "True, fn=None), ReprPlan.Field(name='dedicated_hosts_supported', kw_only=True, fn=None), ReprPlan.Field(name='"
        "auto_recovery_supported', kw_only=True, fn=None), ReprPlan.Field(name='supported_boot_modes', kw_only=True, fn"
        "=None), ReprPlan.Field(name='nitro_enclaves_support', kw_only=True, fn=None), ReprPlan.Field(name='nitro_tpm_s"
        "upport', kw_only=True, fn=None), ReprPlan.Field(name='nitro_tpm_info', kw_only=True, fn=None), ReprPlan.Field("
        "name='media_accelerator_info', kw_only=True, fn=None), ReprPlan.Field(name='neuron_info', kw_only=True, fn=Non"
        "e), ReprPlan.Field(name='phc_support', kw_only=True, fn=None), ReprPlan.Field(name='reboot_migration_support',"
        " kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='56c553d8f420a0280fd167f1a8f110cec5d9f296',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__24__annotation',
        '__dataclass__init__fields__24__default',
        '__dataclass__init__fields__25__annotation',
        '__dataclass__init__fields__25__default',
        '__dataclass__init__fields__26__annotation',
        '__dataclass__init__fields__26__default',
        '__dataclass__init__fields__27__annotation',
        '__dataclass__init__fields__27__default',
        '__dataclass__init__fields__28__annotation',
        '__dataclass__init__fields__28__default',
        '__dataclass__init__fields__29__annotation',
        '__dataclass__init__fields__29__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__30__annotation',
        '__dataclass__init__fields__30__default',
        '__dataclass__init__fields__31__annotation',
        '__dataclass__init__fields__31__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InstanceTypeInfo'),
    ),
)
def _process_dataclass__56c553d8f420a0280fd167f1a8f110cec5d9f296():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__24__annotation,
        __dataclass__init__fields__24__default,
        __dataclass__init__fields__25__annotation,
        __dataclass__init__fields__25__default,
        __dataclass__init__fields__26__annotation,
        __dataclass__init__fields__26__default,
        __dataclass__init__fields__27__annotation,
        __dataclass__init__fields__27__default,
        __dataclass__init__fields__28__annotation,
        __dataclass__init__fields__28__default,
        __dataclass__init__fields__29__annotation,
        __dataclass__init__fields__29__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__30__annotation,
        __dataclass__init__fields__30__default,
        __dataclass__init__fields__31__annotation,
        __dataclass__init__fields__31__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                instance_type=self.instance_type,
                current_generation=self.current_generation,
                free_tier_eligible=self.free_tier_eligible,
                supported_usage_classes=self.supported_usage_classes,
                supported_root_device_types=self.supported_root_device_types,
                supported_virtualization_types=self.supported_virtualization_types,
                bare_metal=self.bare_metal,
                hypervisor=self.hypervisor,
                processor_info=self.processor_info,
                v_cpu_info=self.v_cpu_info,
                memory_info=self.memory_info,
                instance_storage_supported=self.instance_storage_supported,
                instance_storage_info=self.instance_storage_info,
                ebs_info=self.ebs_info,
                network_info=self.network_info,
                gpu_info=self.gpu_info,
                fpga_info=self.fpga_info,
                placement_group_info=self.placement_group_info,
                inference_accelerator_info=self.inference_accelerator_info,
                hibernation_supported=self.hibernation_supported,
                burstable_performance_supported=self.burstable_performance_supported,
                dedicated_hosts_supported=self.dedicated_hosts_supported,
                auto_recovery_supported=self.auto_recovery_supported,
                supported_boot_modes=self.supported_boot_modes,
                nitro_enclaves_support=self.nitro_enclaves_support,
                nitro_tpm_support=self.nitro_tpm_support,
                nitro_tpm_info=self.nitro_tpm_info,
                media_accelerator_info=self.media_accelerator_info,
                neuron_info=self.neuron_info,
                phc_support=self.phc_support,
                reboot_migration_support=self.reboot_migration_support,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.instance_type == other.instance_type and
                self.current_generation == other.current_generation and
                self.free_tier_eligible == other.free_tier_eligible and
                self.supported_usage_classes == other.supported_usage_classes and
                self.supported_root_device_types == other.supported_root_device_types and
                self.supported_virtualization_types == other.supported_virtualization_types and
                self.bare_metal == other.bare_metal and
                self.hypervisor == other.hypervisor and
                self.processor_info == other.processor_info and
                self.v_cpu_info == other.v_cpu_info and
                self.memory_info == other.memory_info and
                self.instance_storage_supported == other.instance_storage_supported and
                self.instance_storage_info == other.instance_storage_info and
                self.ebs_info == other.ebs_info and
                self.network_info == other.network_info and
                self.gpu_info == other.gpu_info and
                self.fpga_info == other.fpga_info and
                self.placement_group_info == other.placement_group_info and
                self.inference_accelerator_info == other.inference_accelerator_info and
                self.hibernation_supported == other.hibernation_supported and
                self.burstable_performance_supported == other.burstable_performance_supported and
                self.dedicated_hosts_supported == other.dedicated_hosts_supported and
                self.auto_recovery_supported == other.auto_recovery_supported and
                self.supported_boot_modes == other.supported_boot_modes and
                self.nitro_enclaves_support == other.nitro_enclaves_support and
                self.nitro_tpm_support == other.nitro_tpm_support and
                self.nitro_tpm_info == other.nitro_tpm_info and
                self.media_accelerator_info == other.media_accelerator_info and
                self.neuron_info == other.neuron_info and
                self.phc_support == other.phc_support and
                self.reboot_migration_support == other.reboot_migration_support
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'instance_type',
            'current_generation',
            'free_tier_eligible',
            'supported_usage_classes',
            'supported_root_device_types',
            'supported_virtualization_types',
            'bare_metal',
            'hypervisor',
            'processor_info',
            'v_cpu_info',
            'memory_info',
            'instance_storage_supported',
            'instance_storage_info',
            'ebs_info',
            'network_info',
            'gpu_info',
            'fpga_info',
            'placement_group_info',
            'inference_accelerator_info',
            'hibernation_supported',
            'burstable_performance_supported',
            'dedicated_hosts_supported',
            'auto_recovery_supported',
            'supported_boot_modes',
            'nitro_enclaves_support',
            'nitro_tpm_support',
            'nitro_tpm_info',
            'media_accelerator_info',
            'neuron_info',
            'phc_support',
            'reboot_migration_support',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'instance_type',
            'current_generation',
            'free_tier_eligible',
            'supported_usage_classes',
            'supported_root_device_types',
            'supported_virtualization_types',
            'bare_metal',
            'hypervisor',
            'processor_info',
            'v_cpu_info',
            'memory_info',
            'instance_storage_supported',
            'instance_storage_info',
            'ebs_info',
            'network_info',
            'gpu_info',
            'fpga_info',
            'placement_group_info',
            'inference_accelerator_info',
            'hibernation_supported',
            'burstable_performance_supported',
            'dedicated_hosts_supported',
            'auto_recovery_supported',
            'supported_boot_modes',
            'nitro_enclaves_support',
            'nitro_tpm_support',
            'nitro_tpm_info',
            'media_accelerator_info',
            'neuron_info',
            'phc_support',
            'reboot_migration_support',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.instance_type,
                self.current_generation,
                self.free_tier_eligible,
                self.supported_usage_classes,
                self.supported_root_device_types,
                self.supported_virtualization_types,
                self.bare_metal,
                self.hypervisor,
                self.processor_info,
                self.v_cpu_info,
                self.memory_info,
                self.instance_storage_supported,
                self.instance_storage_info,
                self.ebs_info,
                self.network_info,
                self.gpu_info,
                self.fpga_info,
                self.placement_group_info,
                self.inference_accelerator_info,
                self.hibernation_supported,
                self.burstable_performance_supported,
                self.dedicated_hosts_supported,
                self.auto_recovery_supported,
                self.supported_boot_modes,
                self.nitro_enclaves_support,
                self.nitro_tpm_support,
                self.nitro_tpm_info,
                self.media_accelerator_info,
                self.neuron_info,
                self.phc_support,
                self.reboot_migration_support,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            instance_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            current_generation: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            free_tier_eligible: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            supported_usage_classes: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            supported_root_device_types: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            supported_virtualization_types: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            bare_metal: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            hypervisor: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            processor_info: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            v_cpu_info: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            memory_info: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            instance_storage_supported: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            instance_storage_info: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            ebs_info: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            network_info: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            gpu_info: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            fpga_info: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            placement_group_info: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            inference_accelerator_info: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            hibernation_supported: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            burstable_performance_supported: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            dedicated_hosts_supported: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            auto_recovery_supported: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
            supported_boot_modes: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
            nitro_enclaves_support: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
            nitro_tpm_support: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
            nitro_tpm_info: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
            media_accelerator_info: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
            neuron_info: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
            phc_support: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
            reboot_migration_support: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'instance_type', instance_type)
            __dataclass__object_setattr(self, 'current_generation', current_generation)
            __dataclass__object_setattr(self, 'free_tier_eligible', free_tier_eligible)
            __dataclass__object_setattr(self, 'supported_usage_classes', supported_usage_classes)
            __dataclass__object_setattr(self, 'supported_root_device_types', supported_root_device_types)
            __dataclass__object_setattr(self, 'supported_virtualization_types', supported_virtualization_types)
            __dataclass__object_setattr(self, 'bare_metal', bare_metal)
            __dataclass__object_setattr(self, 'hypervisor', hypervisor)
            __dataclass__object_setattr(self, 'processor_info', processor_info)
            __dataclass__object_setattr(self, 'v_cpu_info', v_cpu_info)
            __dataclass__object_setattr(self, 'memory_info', memory_info)
            __dataclass__object_setattr(self, 'instance_storage_supported', instance_storage_supported)
            __dataclass__object_setattr(self, 'instance_storage_info', instance_storage_info)
            __dataclass__object_setattr(self, 'ebs_info', ebs_info)
            __dataclass__object_setattr(self, 'network_info', network_info)
            __dataclass__object_setattr(self, 'gpu_info', gpu_info)
            __dataclass__object_setattr(self, 'fpga_info', fpga_info)
            __dataclass__object_setattr(self, 'placement_group_info', placement_group_info)
            __dataclass__object_setattr(self, 'inference_accelerator_info', inference_accelerator_info)
            __dataclass__object_setattr(self, 'hibernation_supported', hibernation_supported)
            __dataclass__object_setattr(self, 'burstable_performance_supported', burstable_performance_supported)
            __dataclass__object_setattr(self, 'dedicated_hosts_supported', dedicated_hosts_supported)
            __dataclass__object_setattr(self, 'auto_recovery_supported', auto_recovery_supported)
            __dataclass__object_setattr(self, 'supported_boot_modes', supported_boot_modes)
            __dataclass__object_setattr(self, 'nitro_enclaves_support', nitro_enclaves_support)
            __dataclass__object_setattr(self, 'nitro_tpm_support', nitro_tpm_support)
            __dataclass__object_setattr(self, 'nitro_tpm_info', nitro_tpm_info)
            __dataclass__object_setattr(self, 'media_accelerator_info', media_accelerator_info)
            __dataclass__object_setattr(self, 'neuron_info', neuron_info)
            __dataclass__object_setattr(self, 'phc_support', phc_support)
            __dataclass__object_setattr(self, 'reboot_migration_support', reboot_migration_support)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"instance_type={self.instance_type!r}")
            parts.append(f"current_generation={self.current_generation!r}")
            parts.append(f"free_tier_eligible={self.free_tier_eligible!r}")
            parts.append(f"supported_usage_classes={self.supported_usage_classes!r}")
            parts.append(f"supported_root_device_types={self.supported_root_device_types!r}")
            parts.append(f"supported_virtualization_types={self.supported_virtualization_types!r}")
            parts.append(f"bare_metal={self.bare_metal!r}")
            parts.append(f"hypervisor={self.hypervisor!r}")
            parts.append(f"processor_info={self.processor_info!r}")
            parts.append(f"v_cpu_info={self.v_cpu_info!r}")
            parts.append(f"memory_info={self.memory_info!r}")
            parts.append(f"instance_storage_supported={self.instance_storage_supported!r}")
            parts.append(f"instance_storage_info={self.instance_storage_info!r}")
            parts.append(f"ebs_info={self.ebs_info!r}")
            parts.append(f"network_info={self.network_info!r}")
            parts.append(f"gpu_info={self.gpu_info!r}")
            parts.append(f"fpga_info={self.fpga_info!r}")
            parts.append(f"placement_group_info={self.placement_group_info!r}")
            parts.append(f"inference_accelerator_info={self.inference_accelerator_info!r}")
            parts.append(f"hibernation_supported={self.hibernation_supported!r}")
            parts.append(f"burstable_performance_supported={self.burstable_performance_supported!r}")
            parts.append(f"dedicated_hosts_supported={self.dedicated_hosts_supported!r}")
            parts.append(f"auto_recovery_supported={self.auto_recovery_supported!r}")
            parts.append(f"supported_boot_modes={self.supported_boot_modes!r}")
            parts.append(f"nitro_enclaves_support={self.nitro_enclaves_support!r}")
            parts.append(f"nitro_tpm_support={self.nitro_tpm_support!r}")
            parts.append(f"nitro_tpm_info={self.nitro_tpm_info!r}")
            parts.append(f"media_accelerator_info={self.media_accelerator_info!r}")
            parts.append(f"neuron_info={self.neuron_info!r}")
            parts.append(f"phc_support={self.phc_support!r}")
            parts.append(f"reboot_migration_support={self.reboot_migration_support!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('attachments', 'internet_gateway_id', 'owner_id', 'tags')), EqPlan(fields=('attach"
        "ments', 'internet_gateway_id', 'owner_id', 'tags')), FrozenPlan(fields=('__shape__', 'attachments', 'internet_"
        "gateway_id', 'owner_id', 'tags'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('attachmen"
        "ts', 'internet_gateway_id', 'owner_id', 'tags'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__"
        "', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override="
        "False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='atta"
        "chments', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='internet_gateway_id', annotation=OpRef(name='init.fields.2.annotation'), defa"
        "ult=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='owner_id', annotation=OpRef(name"
        "='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, ov"
        "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='tags', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), defau"
        "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
        "ype=None)), self_param='self', std_params=(), kw_only_params=('attachments', 'internet_gateway_id', 'owner_id'"
        ", 'tags'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Re"
        "prPlan.Field(name='attachments', kw_only=True, fn=None), ReprPlan.Field(name='internet_gateway_id', kw_only=Tr"
        "ue, fn=None), ReprPlan.Field(name='owner_id', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=True"
        ", fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='6a86d2b168af2b5ae6345c6175bf57264a7bf041',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InternetGateway'),
    ),
)
def _process_dataclass__6a86d2b168af2b5ae6345c6175bf57264a7bf041():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                attachments=self.attachments,
                internet_gateway_id=self.internet_gateway_id,
                owner_id=self.owner_id,
                tags=self.tags,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.attachments == other.attachments and
                self.internet_gateway_id == other.internet_gateway_id and
                self.owner_id == other.owner_id and
                self.tags == other.tags
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'attachments',
            'internet_gateway_id',
            'owner_id',
            'tags',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'attachments',
            'internet_gateway_id',
            'owner_id',
            'tags',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.attachments,
                self.internet_gateway_id,
                self.owner_id,
                self.tags,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            attachments: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            internet_gateway_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            owner_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            tags: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'attachments', attachments)
            __dataclass__object_setattr(self, 'internet_gateway_id', internet_gateway_id)
            __dataclass__object_setattr(self, 'owner_id', owner_id)
            __dataclass__object_setattr(self, 'tags', tags)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"attachments={self.attachments!r}")
            parts.append(f"internet_gateway_id={self.internet_gateway_id!r}")
            parts.append(f"owner_id={self.owner_id!r}")
            parts.append(f"tags={self.tags!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('state', 'vpc_id')), EqPlan(fields=('state', 'vpc_id')), FrozenPlan(fields=('__sha"
        "pe__', 'state', 'vpc_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('state', 'vpc_id'"
        "), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annota"
        "tion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='state', annotation=OpRef(name='init.fields.1.annot"
        "ation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_id', annotation"
        "=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_pa"
        "ram='self', std_params=(), kw_only_params=('state', 'vpc_id'), frozen=True, slots=False, post_init_params=None"
        ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='state', kw_only=True, fn=None), ReprPla"
        "n.Field(name='vpc_id', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='a446d5c3e2a71716b2a1d9876adc8b92652a2148',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'InternetGatewayAttachment'),
    ),
)
def _process_dataclass__a446d5c3e2a71716b2a1d9876adc8b92652a2148():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                state=self.state,
                vpc_id=self.vpc_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.state == other.state and
                self.vpc_id == other.vpc_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'state',
            'vpc_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'state',
            'vpc_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.state,
                self.vpc_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            state: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            vpc_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"state={self.state!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ip_protocol', 'from_port', 'to_port', 'user_id_group_pairs', 'ip_ranges', 'ipv6_r"
        "anges', 'prefix_list_ids')), EqPlan(fields=('ip_protocol', 'from_port', 'to_port', 'user_id_group_pairs', 'ip_"
        "ranges', 'ipv6_ranges', 'prefix_list_ids')), FrozenPlan(fields=('__shape__', 'ip_protocol', 'from_port', 'to_p"
        "ort', 'user_id_group_pairs', 'ip_ranges', 'ipv6_ranges', 'prefix_list_ids'), allow_dynamic_dunder_attrs=False)"
        ", HashPlan(action='add', fields=('ip_protocol', 'from_port', 'to_port', 'user_id_group_pairs', 'ip_ranges', 'i"
        "pv6_ranges', 'prefix_list_ids'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=Op"
        "Ref(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ip_protocol', annota"
        "tion=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='from_port', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.field"
        "s.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='to_port', annotation=OpRef(name='init.fields.3.annotation'"
        "), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='user_id_group_pairs', ann"
        "otation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='ip_ranges', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fi"
        "elds.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='ipv6_ranges', annotation=OpRef(name='init.fields.6.anno"
        "tation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='prefix_list_ids', "
        "annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        "), self_param='self', std_params=(), kw_only_params=('ip_protocol', 'from_port', 'to_port', 'user_id_group_pai"
        "rs', 'ip_ranges', 'ipv6_ranges', 'prefix_list_ids'), frozen=True, slots=False, post_init_params=None, init_fns"
        "=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ip_protocol', kw_only=True, fn=None), ReprPlan.Fi"
        "eld(name='from_port', kw_only=True, fn=None), ReprPlan.Field(name='to_port', kw_only=True, fn=None), ReprPlan."
        "Field(name='user_id_group_pairs', kw_only=True, fn=None), ReprPlan.Field(name='ip_ranges', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='ipv6_ranges', kw_only=True, fn=None), ReprPlan.Field(name='prefix_list_ids', kw_only"
        "=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='5d4d61028876e0a148997dc4f2bdd55c90513310',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'IpPermission'),
    ),
)
def _process_dataclass__5d4d61028876e0a148997dc4f2bdd55c90513310():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ip_protocol=self.ip_protocol,
                from_port=self.from_port,
                to_port=self.to_port,
                user_id_group_pairs=self.user_id_group_pairs,
                ip_ranges=self.ip_ranges,
                ipv6_ranges=self.ipv6_ranges,
                prefix_list_ids=self.prefix_list_ids,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ip_protocol == other.ip_protocol and
                self.from_port == other.from_port and
                self.to_port == other.to_port and
                self.user_id_group_pairs == other.user_id_group_pairs and
                self.ip_ranges == other.ip_ranges and
                self.ipv6_ranges == other.ipv6_ranges and
                self.prefix_list_ids == other.prefix_list_ids
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ip_protocol',
            'from_port',
            'to_port',
            'user_id_group_pairs',
            'ip_ranges',
            'ipv6_ranges',
            'prefix_list_ids',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ip_protocol',
            'from_port',
            'to_port',
            'user_id_group_pairs',
            'ip_ranges',
            'ipv6_ranges',
            'prefix_list_ids',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ip_protocol,
                self.from_port,
                self.to_port,
                self.user_id_group_pairs,
                self.ip_ranges,
                self.ipv6_ranges,
                self.prefix_list_ids,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ip_protocol: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            from_port: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            to_port: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            user_id_group_pairs: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            ip_ranges: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            ipv6_ranges: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            prefix_list_ids: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ip_protocol', ip_protocol)
            __dataclass__object_setattr(self, 'from_port', from_port)
            __dataclass__object_setattr(self, 'to_port', to_port)
            __dataclass__object_setattr(self, 'user_id_group_pairs', user_id_group_pairs)
            __dataclass__object_setattr(self, 'ip_ranges', ip_ranges)
            __dataclass__object_setattr(self, 'ipv6_ranges', ipv6_ranges)
            __dataclass__object_setattr(self, 'prefix_list_ids', prefix_list_ids)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ip_protocol={self.ip_protocol!r}")
            parts.append(f"from_port={self.from_port!r}")
            parts.append(f"to_port={self.to_port!r}")
            parts.append(f"user_id_group_pairs={self.user_id_group_pairs!r}")
            parts.append(f"ip_ranges={self.ip_ranges!r}")
            parts.append(f"ipv6_ranges={self.ipv6_ranges!r}")
            parts.append(f"prefix_list_ids={self.prefix_list_ids!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('description', 'cidr_ip')), EqPlan(fields=('description', 'cidr_ip')), FrozenPlan("
        "fields=('__shape__', 'description', 'cidr_ip'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fiel"
        "ds=('description', 'cidr_ip'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRe"
        "f(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type="
        "FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='description', annotati"
        "on=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='cidr_ip', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('description', 'cidr_ip'), froze"
        "n=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
        "e='description', kw_only=True, fn=None), ReprPlan.Field(name='cidr_ip', kw_only=True, fn=None)), id=False, ter"
        "se=False, default_fn=None)))"
    ),
    plan_repr_sha1='4660e5b1925be3722ad32bb3aa7b0aa078aa4ea0',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'IpRange'),
    ),
)
def _process_dataclass__4660e5b1925be3722ad32bb3aa7b0aa078aa4ea0():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                description=self.description,
                cidr_ip=self.cidr_ip,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.description == other.description and
                self.cidr_ip == other.cidr_ip
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'description',
            'cidr_ip',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'description',
            'cidr_ip',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.description,
                self.cidr_ip,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            description: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            cidr_ip: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'cidr_ip', cidr_ip)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"description={self.description!r}")
            parts.append(f"cidr_ip={self.cidr_ip!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('description', 'cidr_ipv6')), EqPlan(fields=('description', 'cidr_ipv6')), FrozenP"
        "lan(fields=('__shape__', 'description', 'cidr_ipv6'), allow_dynamic_dunder_attrs=False), HashPlan(action='add'"
        ", fields=('description', 'cidr_ipv6'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotat"
        "ion=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='description', "
        "annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='cidr_ipv6', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init"
        ".fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('description', 'cidr_i"
        "pv6'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPl"
        "an.Field(name='description', kw_only=True, fn=None), ReprPlan.Field(name='cidr_ipv6', kw_only=True, fn=None)),"
        " id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='7f5ef993e295e5e96fdb6ca03b3accafdafaf592',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Ipv6Range'),
    ),
)
def _process_dataclass__7f5ef993e295e5e96fdb6ca03b3accafdafaf592():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                description=self.description,
                cidr_ipv6=self.cidr_ipv6,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.description == other.description and
                self.cidr_ipv6 == other.cidr_ipv6
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'description',
            'cidr_ipv6',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'description',
            'cidr_ipv6',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.description,
                self.cidr_ipv6,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            description: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            cidr_ipv6: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'cidr_ipv6', cidr_ipv6)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"description={self.description!r}")
            parts.append(f"cidr_ipv6={self.cidr_ipv6!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('key_pair_id', 'key_type', 'tags', 'public_key', 'create_time', 'key_name', 'key_f"
        "ingerprint')), EqPlan(fields=('key_pair_id', 'key_type', 'tags', 'public_key', 'create_time', 'key_name', 'key"
        "_fingerprint')), FrozenPlan(fields=('__shape__', 'key_pair_id', 'key_type', 'tags', 'public_key', 'create_time"
        "', 'key_name', 'key_fingerprint'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('key_pair"
        "_id', 'key_type', 'tags', 'public_key', 'create_time', 'key_name', 'key_fingerprint'), cache=False), InitPlan("
        "fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check"
        "_type=None), InitPlan.Field(name='key_pair_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpR"
        "ef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='key_type', annotation=OpRef(name='init."
        "fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override="
        "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags'"
        ", annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='public_key', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='i"
        "nit.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='create_time', annotation=OpRef(name='init.fields."
        "5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='key_name', a"
        "nnotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory"
        "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
        " InitPlan.Field(name='key_fingerprint', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name="
        "'init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('key_pair_id', 'k"
        "ey_type', 'tags', 'public_key', 'create_time', 'key_name', 'key_fingerprint'), frozen=True, slots=False, post_"
        "init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='key_pair_id', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='key_type', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=Tru"
        "e, fn=None), ReprPlan.Field(name='public_key', kw_only=True, fn=None), ReprPlan.Field(name='create_time', kw_o"
        "nly=True, fn=None), ReprPlan.Field(name='key_name', kw_only=True, fn=None), ReprPlan.Field(name='key_fingerpri"
        "nt', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='fae65c63a6b266a4414221936efc1a9baf08ed28',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'KeyPairInfo'),
    ),
)
def _process_dataclass__fae65c63a6b266a4414221936efc1a9baf08ed28():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                key_pair_id=self.key_pair_id,
                key_type=self.key_type,
                tags=self.tags,
                public_key=self.public_key,
                create_time=self.create_time,
                key_name=self.key_name,
                key_fingerprint=self.key_fingerprint,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.key_pair_id == other.key_pair_id and
                self.key_type == other.key_type and
                self.tags == other.tags and
                self.public_key == other.public_key and
                self.create_time == other.create_time and
                self.key_name == other.key_name and
                self.key_fingerprint == other.key_fingerprint
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'key_pair_id',
            'key_type',
            'tags',
            'public_key',
            'create_time',
            'key_name',
            'key_fingerprint',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'key_pair_id',
            'key_type',
            'tags',
            'public_key',
            'create_time',
            'key_name',
            'key_fingerprint',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.key_pair_id,
                self.key_type,
                self.tags,
                self.public_key,
                self.create_time,
                self.key_name,
                self.key_fingerprint,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            key_pair_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            key_type: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            tags: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            public_key: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            create_time: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            key_name: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            key_fingerprint: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'key_pair_id', key_pair_id)
            __dataclass__object_setattr(self, 'key_type', key_type)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'public_key', public_key)
            __dataclass__object_setattr(self, 'create_time', create_time)
            __dataclass__object_setattr(self, 'key_name', key_name)
            __dataclass__object_setattr(self, 'key_fingerprint', key_fingerprint)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"key_pair_id={self.key_pair_id!r}")
            parts.append(f"key_type={self.key_type!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"public_key={self.public_key!r}")
            parts.append(f"create_time={self.create_time!r}")
            parts.append(f"key_name={self.key_name!r}")
            parts.append(f"key_fingerprint={self.key_fingerprint!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('launch_template_id', 'launch_template_name', 'version')), EqPlan(fields=('launch_"
        "template_id', 'launch_template_name', 'version')), FrozenPlan(fields=('__shape__', 'launch_template_id', 'laun"
        "ch_template_name', 'version'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('launch_templ"
        "ate_id', 'launch_template_name', 'version'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', a"
        "nnotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='launch_t"
        "emplate_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), d"
        "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='launch_template_name', annotation=OpRef(name='init.fields.2.annotation'), "
        "default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='version', annotation=OpRef(n"
        "ame='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='sel"
        "f', std_params=(), kw_only_params=('launch_template_id', 'launch_template_name', 'version'), frozen=True, slot"
        "s=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='launch_te"
        "mplate_id', kw_only=True, fn=None), ReprPlan.Field(name='launch_template_name', kw_only=True, fn=None), ReprPl"
        "an.Field(name='version', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='555a882d1a60f1e571d59e5fc7bb3508ed9a02a4',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'LaunchTemplateSpecification'),
    ),
)
def _process_dataclass__555a882d1a60f1e571d59e5fc7bb3508ed9a02a4():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                launch_template_id=self.launch_template_id,
                launch_template_name=self.launch_template_name,
                version=self.version,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.launch_template_id == other.launch_template_id and
                self.launch_template_name == other.launch_template_name and
                self.version == other.version
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'launch_template_id',
            'launch_template_name',
            'version',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'launch_template_id',
            'launch_template_name',
            'version',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.launch_template_id,
                self.launch_template_name,
                self.version,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            launch_template_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            launch_template_name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            version: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'launch_template_id', launch_template_id)
            __dataclass__object_setattr(self, 'launch_template_name', launch_template_name)
            __dataclass__object_setattr(self, 'version', version)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"launch_template_id={self.launch_template_id!r}")
            parts.append(f"launch_template_name={self.launch_template_name!r}")
            parts.append(f"version={self.version!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('license_configuration_arn',)), EqPlan(fields=('license_configuration_arn',)), Fro"
        "zenPlan(fields=('__shape__', 'license_configuration_arn'), allow_dynamic_dunder_attrs=False), HashPlan(action="
        "'add', fields=('license_configuration_arn',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', "
        "annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='license"
        "_configuration_arn', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defa"
        "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
        "one, check_type=None)), self_param='self', std_params=(), kw_only_params=('license_configuration_arn',), froze"
        "n=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
        "e='license_configuration_arn', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='60dc2293079a28718fcee879d22638a00a001c46',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'LicenseConfiguration'),
        ('ominfra.clouds.aws.models.services.ec2', 'LicenseConfigurationRequest'),
    ),
)
def _process_dataclass__60dc2293079a28718fcee879d22638a00a001c46():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                license_configuration_arn=self.license_configuration_arn,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.license_configuration_arn == other.license_configuration_arn
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'license_configuration_arn',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'license_configuration_arn',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.license_configuration_arn,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            license_configuration_arn: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'license_configuration_arn', license_configuration_arn)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"license_configuration_arn={self.license_configuration_arn!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('accelerators', 'total_media_memory_in_mi_b')), EqPlan(fields=('accelerators', 'to"
        "tal_media_memory_in_mi_b')), FrozenPlan(fields=('__shape__', 'accelerators', 'total_media_memory_in_mi_b'), al"
        "low_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('accelerators', 'total_media_memory_in_mi_b'),"
        " cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotati"
        "on'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='accelerators', annotation=OpRef(name='init.fields.1."
        "annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='total_media_me"
        "mory_in_mi_b', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None)), self_param='self', std_params=(), kw_only_params=('accelerators', 'total_media_memory_in_mi_"
        "b'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan"
        ".Field(name='accelerators', kw_only=True, fn=None), ReprPlan.Field(name='total_media_memory_in_mi_b', kw_only="
        "True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='1816aa36f8e31af294f8bb11e610a1475b85c07d',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'MediaAcceleratorInfo'),
    ),
)
def _process_dataclass__1816aa36f8e31af294f8bb11e610a1475b85c07d():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                accelerators=self.accelerators,
                total_media_memory_in_mi_b=self.total_media_memory_in_mi_b,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.accelerators == other.accelerators and
                self.total_media_memory_in_mi_b == other.total_media_memory_in_mi_b
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'accelerators',
            'total_media_memory_in_mi_b',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'accelerators',
            'total_media_memory_in_mi_b',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.accelerators,
                self.total_media_memory_in_mi_b,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            accelerators: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            total_media_memory_in_mi_b: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'accelerators', accelerators)
            __dataclass__object_setattr(self, 'total_media_memory_in_mi_b', total_media_memory_in_mi_b)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"accelerators={self.accelerators!r}")
            parts.append(f"total_media_memory_in_mi_b={self.total_media_memory_in_mi_b!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('state',)), EqPlan(fields=('state',)), FrozenPlan(fields=('__shape__', 'state'), a"
        "llow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('state',), cache=False), InitPlan(fields=(Ini"
        "tPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory"
        "=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='state', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fie"
        "lds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('state',), frozen=True, sl"
        "ots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='state',"
        " kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='a2a4416e2af8714bacfde725575818993950dd57',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Monitoring'),
    ),
)
def _process_dataclass__a2a4416e2af8714bacfde725575818993950dd57():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                state=self.state,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.state == other.state
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'state',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'state',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.state,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            state: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'state', state)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"state={self.state!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('network_card_index', 'network_performance', 'maximum_network_interfaces', 'baseli"
        "ne_bandwidth_in_gbips', 'peak_bandwidth_in_gbips', 'default_ena_queue_count_per_interface', 'maximum_ena_queue"
        "_count', 'maximum_ena_queue_count_per_interface')), EqPlan(fields=('network_card_index', 'network_performance'"
        ", 'maximum_network_interfaces', 'baseline_bandwidth_in_gbips', 'peak_bandwidth_in_gbips', 'default_ena_queue_c"
        "ount_per_interface', 'maximum_ena_queue_count', 'maximum_ena_queue_count_per_interface')), FrozenPlan(fields=("
        "'__shape__', 'network_card_index', 'network_performance', 'maximum_network_interfaces', 'baseline_bandwidth_in"
        "_gbips', 'peak_bandwidth_in_gbips', 'default_ena_queue_count_per_interface', 'maximum_ena_queue_count', 'maxim"
        "um_ena_queue_count_per_interface'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('network"
        "_card_index', 'network_performance', 'maximum_network_interfaces', 'baseline_bandwidth_in_gbips', 'peak_bandwi"
        "dth_in_gbips', 'default_ena_queue_count_per_interface', 'maximum_ena_queue_count', 'maximum_ena_queue_count_pe"
        "r_interface'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fie"
        "lds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_"
        "VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_card_index', annotation=OpRef("
        "name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='network_performance', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields"
        ".2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='maximum_network_interfaces', annotation=OpRef(name='init.fi"
        "elds.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='baselin"
        "e_bandwidth_in_gbips', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.de"
        "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
        "=None, check_type=None), InitPlan.Field(name='peak_bandwidth_in_gbips', annotation=OpRef(name='init.fields.5.a"
        "nnotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='default_ena_que"
        "ue_count_per_interface', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='maximum_ena_queue_count', annotation=OpRef(name='init.fields.7"
        ".annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maximum_ena_q"
        "ueue_count_per_interface', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields."
        "8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
        "date=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('network_card_index', 'network"
        "_performance', 'maximum_network_interfaces', 'baseline_bandwidth_in_gbips', 'peak_bandwidth_in_gbips', 'defaul"
        "t_ena_queue_count_per_interface', 'maximum_ena_queue_count', 'maximum_ena_queue_count_per_interface'), frozen="
        "True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name="
        "'network_card_index', kw_only=True, fn=None), ReprPlan.Field(name='network_performance', kw_only=True, fn=None"
        "), ReprPlan.Field(name='maximum_network_interfaces', kw_only=True, fn=None), ReprPlan.Field(name='baseline_ban"
        "dwidth_in_gbips', kw_only=True, fn=None), ReprPlan.Field(name='peak_bandwidth_in_gbips', kw_only=True, fn=None"
        "), ReprPlan.Field(name='default_ena_queue_count_per_interface', kw_only=True, fn=None), ReprPlan.Field(name='m"
        "aximum_ena_queue_count', kw_only=True, fn=None), ReprPlan.Field(name='maximum_ena_queue_count_per_interface', "
        "kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='b3bdb620818515b71cb12c278f10b24b6b186a1d',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NetworkCardInfo'),
    ),
)
def _process_dataclass__b3bdb620818515b71cb12c278f10b24b6b186a1d():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                network_card_index=self.network_card_index,
                network_performance=self.network_performance,
                maximum_network_interfaces=self.maximum_network_interfaces,
                baseline_bandwidth_in_gbips=self.baseline_bandwidth_in_gbips,
                peak_bandwidth_in_gbips=self.peak_bandwidth_in_gbips,
                default_ena_queue_count_per_interface=self.default_ena_queue_count_per_interface,
                maximum_ena_queue_count=self.maximum_ena_queue_count,
                maximum_ena_queue_count_per_interface=self.maximum_ena_queue_count_per_interface,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.network_card_index == other.network_card_index and
                self.network_performance == other.network_performance and
                self.maximum_network_interfaces == other.maximum_network_interfaces and
                self.baseline_bandwidth_in_gbips == other.baseline_bandwidth_in_gbips and
                self.peak_bandwidth_in_gbips == other.peak_bandwidth_in_gbips and
                self.default_ena_queue_count_per_interface == other.default_ena_queue_count_per_interface and
                self.maximum_ena_queue_count == other.maximum_ena_queue_count and
                self.maximum_ena_queue_count_per_interface == other.maximum_ena_queue_count_per_interface
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'network_card_index',
            'network_performance',
            'maximum_network_interfaces',
            'baseline_bandwidth_in_gbips',
            'peak_bandwidth_in_gbips',
            'default_ena_queue_count_per_interface',
            'maximum_ena_queue_count',
            'maximum_ena_queue_count_per_interface',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'network_card_index',
            'network_performance',
            'maximum_network_interfaces',
            'baseline_bandwidth_in_gbips',
            'peak_bandwidth_in_gbips',
            'default_ena_queue_count_per_interface',
            'maximum_ena_queue_count',
            'maximum_ena_queue_count_per_interface',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.network_card_index,
                self.network_performance,
                self.maximum_network_interfaces,
                self.baseline_bandwidth_in_gbips,
                self.peak_bandwidth_in_gbips,
                self.default_ena_queue_count_per_interface,
                self.maximum_ena_queue_count,
                self.maximum_ena_queue_count_per_interface,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            network_card_index: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            network_performance: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            maximum_network_interfaces: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            baseline_bandwidth_in_gbips: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            peak_bandwidth_in_gbips: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            default_ena_queue_count_per_interface: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            maximum_ena_queue_count: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            maximum_ena_queue_count_per_interface: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'network_card_index', network_card_index)
            __dataclass__object_setattr(self, 'network_performance', network_performance)
            __dataclass__object_setattr(self, 'maximum_network_interfaces', maximum_network_interfaces)
            __dataclass__object_setattr(self, 'baseline_bandwidth_in_gbips', baseline_bandwidth_in_gbips)
            __dataclass__object_setattr(self, 'peak_bandwidth_in_gbips', peak_bandwidth_in_gbips)
            __dataclass__object_setattr(self, 'default_ena_queue_count_per_interface', default_ena_queue_count_per_interface)
            __dataclass__object_setattr(self, 'maximum_ena_queue_count', maximum_ena_queue_count)
            __dataclass__object_setattr(self, 'maximum_ena_queue_count_per_interface', maximum_ena_queue_count_per_interface)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"network_card_index={self.network_card_index!r}")
            parts.append(f"network_performance={self.network_performance!r}")
            parts.append(f"maximum_network_interfaces={self.maximum_network_interfaces!r}")
            parts.append(f"baseline_bandwidth_in_gbips={self.baseline_bandwidth_in_gbips!r}")
            parts.append(f"peak_bandwidth_in_gbips={self.peak_bandwidth_in_gbips!r}")
            parts.append(f"default_ena_queue_count_per_interface={self.default_ena_queue_count_per_interface!r}")
            parts.append(f"maximum_ena_queue_count={self.maximum_ena_queue_count!r}")
            parts.append(f"maximum_ena_queue_count_per_interface={self.maximum_ena_queue_count_per_interface!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('network_performance', 'maximum_network_interfaces', 'maximum_network_cards', 'def"
        "ault_network_card_index', 'network_cards', 'ipv4_addresses_per_interface', 'ipv6_addresses_per_interface', 'ip"
        "v6_supported', 'ena_support', 'efa_supported', 'efa_info', 'encryption_in_transit_supported', 'ena_srd_support"
        "ed', 'bandwidth_weightings', 'flexible_ena_queues_support')), EqPlan(fields=('network_performance', 'maximum_n"
        "etwork_interfaces', 'maximum_network_cards', 'default_network_card_index', 'network_cards', 'ipv4_addresses_pe"
        "r_interface', 'ipv6_addresses_per_interface', 'ipv6_supported', 'ena_support', 'efa_supported', 'efa_info', 'e"
        "ncryption_in_transit_supported', 'ena_srd_supported', 'bandwidth_weightings', 'flexible_ena_queues_support')),"
        " FrozenPlan(fields=('__shape__', 'network_performance', 'maximum_network_interfaces', 'maximum_network_cards',"
        " 'default_network_card_index', 'network_cards', 'ipv4_addresses_per_interface', 'ipv6_addresses_per_interface'"
        ", 'ipv6_supported', 'ena_support', 'efa_supported', 'efa_info', 'encryption_in_transit_supported', 'ena_srd_su"
        "pported', 'bandwidth_weightings', 'flexible_ena_queues_support'), allow_dynamic_dunder_attrs=False), HashPlan("
        "action='add', fields=('network_performance', 'maximum_network_interfaces', 'maximum_network_cards', 'default_n"
        "etwork_card_index', 'network_cards', 'ipv4_addresses_per_interface', 'ipv6_addresses_per_interface', 'ipv6_sup"
        "ported', 'ena_support', 'efa_supported', 'efa_info', 'encryption_in_transit_supported', 'ena_srd_supported', '"
        "bandwidth_weightings', 'flexible_ena_queues_support'), cache=False), InitPlan(fields=(InitPlan.Field(name='__s"
        "hape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='network_performance', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='maximum_network_interfaces', annotation=OpRef(name='init.fields"
        ".2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maximum_net"
        "work_cards', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), d"
        "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
        "ck_type=None), InitPlan.Field(name='default_network_card_index', annotation=OpRef(name='init.fields.4.annotati"
        "on'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type"
        "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='network_cards', annota"
        "tion=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='ipv4_addresses_per_interface', annotation=OpRef(name='init.fields.6.annotation'), default=OpR"
        "ef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_addresses_per_interface', annotati"
        "on=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='ipv6_supported', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fi"
        "elds.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='ena_support', annotation=OpRef(name='init.fields.9.anno"
        "tation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='efa_supported', an"
        "notation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='efa_info', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init"
        ".fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
        "one, validate=None, check_type=None), InitPlan.Field(name='encryption_in_transit_supported', annotation=OpRef("
        "name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='ena_srd_supported', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.field"
        "s.13.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None), InitPlan.Field(name='bandwidth_weightings', annotation=OpRef(name='init.fields"
        ".14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='flexible_"
        "ena_queues_support', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.de"
        "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
        "=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('network_performance', 'maximum_ne"
        "twork_interfaces', 'maximum_network_cards', 'default_network_card_index', 'network_cards', 'ipv4_addresses_per"
        "_interface', 'ipv6_addresses_per_interface', 'ipv6_supported', 'ena_support', 'efa_supported', 'efa_info', 'en"
        "cryption_in_transit_supported', 'ena_srd_supported', 'bandwidth_weightings', 'flexible_ena_queues_support'), f"
        "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field"
        "(name='network_performance', kw_only=True, fn=None), ReprPlan.Field(name='maximum_network_interfaces', kw_only"
        "=True, fn=None), ReprPlan.Field(name='maximum_network_cards', kw_only=True, fn=None), ReprPlan.Field(name='def"
        "ault_network_card_index', kw_only=True, fn=None), ReprPlan.Field(name='network_cards', kw_only=True, fn=None),"
        " ReprPlan.Field(name='ipv4_addresses_per_interface', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_address"
        "es_per_interface', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_supported', kw_only=True, fn=None), ReprP"
        "lan.Field(name='ena_support', kw_only=True, fn=None), ReprPlan.Field(name='efa_supported', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='efa_info', kw_only=True, fn=None), ReprPlan.Field(name='encryption_in_transit_suppor"
        "ted', kw_only=True, fn=None), ReprPlan.Field(name='ena_srd_supported', kw_only=True, fn=None), ReprPlan.Field("
        "name='bandwidth_weightings', kw_only=True, fn=None), ReprPlan.Field(name='flexible_ena_queues_support', kw_onl"
        "y=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='fc2d8824c718501214ee28cadff7d9c4c450ab6b',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NetworkInfo'),
    ),
)
def _process_dataclass__fc2d8824c718501214ee28cadff7d9c4c450ab6b():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                network_performance=self.network_performance,
                maximum_network_interfaces=self.maximum_network_interfaces,
                maximum_network_cards=self.maximum_network_cards,
                default_network_card_index=self.default_network_card_index,
                network_cards=self.network_cards,
                ipv4_addresses_per_interface=self.ipv4_addresses_per_interface,
                ipv6_addresses_per_interface=self.ipv6_addresses_per_interface,
                ipv6_supported=self.ipv6_supported,
                ena_support=self.ena_support,
                efa_supported=self.efa_supported,
                efa_info=self.efa_info,
                encryption_in_transit_supported=self.encryption_in_transit_supported,
                ena_srd_supported=self.ena_srd_supported,
                bandwidth_weightings=self.bandwidth_weightings,
                flexible_ena_queues_support=self.flexible_ena_queues_support,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.network_performance == other.network_performance and
                self.maximum_network_interfaces == other.maximum_network_interfaces and
                self.maximum_network_cards == other.maximum_network_cards and
                self.default_network_card_index == other.default_network_card_index and
                self.network_cards == other.network_cards and
                self.ipv4_addresses_per_interface == other.ipv4_addresses_per_interface and
                self.ipv6_addresses_per_interface == other.ipv6_addresses_per_interface and
                self.ipv6_supported == other.ipv6_supported and
                self.ena_support == other.ena_support and
                self.efa_supported == other.efa_supported and
                self.efa_info == other.efa_info and
                self.encryption_in_transit_supported == other.encryption_in_transit_supported and
                self.ena_srd_supported == other.ena_srd_supported and
                self.bandwidth_weightings == other.bandwidth_weightings and
                self.flexible_ena_queues_support == other.flexible_ena_queues_support
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'network_performance',
            'maximum_network_interfaces',
            'maximum_network_cards',
            'default_network_card_index',
            'network_cards',
            'ipv4_addresses_per_interface',
            'ipv6_addresses_per_interface',
            'ipv6_supported',
            'ena_support',
            'efa_supported',
            'efa_info',
            'encryption_in_transit_supported',
            'ena_srd_supported',
            'bandwidth_weightings',
            'flexible_ena_queues_support',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'network_performance',
            'maximum_network_interfaces',
            'maximum_network_cards',
            'default_network_card_index',
            'network_cards',
            'ipv4_addresses_per_interface',
            'ipv6_addresses_per_interface',
            'ipv6_supported',
            'ena_support',
            'efa_supported',
            'efa_info',
            'encryption_in_transit_supported',
            'ena_srd_supported',
            'bandwidth_weightings',
            'flexible_ena_queues_support',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.network_performance,
                self.maximum_network_interfaces,
                self.maximum_network_cards,
                self.default_network_card_index,
                self.network_cards,
                self.ipv4_addresses_per_interface,
                self.ipv6_addresses_per_interface,
                self.ipv6_supported,
                self.ena_support,
                self.efa_supported,
                self.efa_info,
                self.encryption_in_transit_supported,
                self.ena_srd_supported,
                self.bandwidth_weightings,
                self.flexible_ena_queues_support,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            network_performance: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            maximum_network_interfaces: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            maximum_network_cards: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            default_network_card_index: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            network_cards: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            ipv4_addresses_per_interface: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            ipv6_addresses_per_interface: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            ipv6_supported: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            ena_support: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            efa_supported: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            efa_info: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            encryption_in_transit_supported: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            ena_srd_supported: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            bandwidth_weightings: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            flexible_ena_queues_support: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'network_performance', network_performance)
            __dataclass__object_setattr(self, 'maximum_network_interfaces', maximum_network_interfaces)
            __dataclass__object_setattr(self, 'maximum_network_cards', maximum_network_cards)
            __dataclass__object_setattr(self, 'default_network_card_index', default_network_card_index)
            __dataclass__object_setattr(self, 'network_cards', network_cards)
            __dataclass__object_setattr(self, 'ipv4_addresses_per_interface', ipv4_addresses_per_interface)
            __dataclass__object_setattr(self, 'ipv6_addresses_per_interface', ipv6_addresses_per_interface)
            __dataclass__object_setattr(self, 'ipv6_supported', ipv6_supported)
            __dataclass__object_setattr(self, 'ena_support', ena_support)
            __dataclass__object_setattr(self, 'efa_supported', efa_supported)
            __dataclass__object_setattr(self, 'efa_info', efa_info)
            __dataclass__object_setattr(self, 'encryption_in_transit_supported', encryption_in_transit_supported)
            __dataclass__object_setattr(self, 'ena_srd_supported', ena_srd_supported)
            __dataclass__object_setattr(self, 'bandwidth_weightings', bandwidth_weightings)
            __dataclass__object_setattr(self, 'flexible_ena_queues_support', flexible_ena_queues_support)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"network_performance={self.network_performance!r}")
            parts.append(f"maximum_network_interfaces={self.maximum_network_interfaces!r}")
            parts.append(f"maximum_network_cards={self.maximum_network_cards!r}")
            parts.append(f"default_network_card_index={self.default_network_card_index!r}")
            parts.append(f"network_cards={self.network_cards!r}")
            parts.append(f"ipv4_addresses_per_interface={self.ipv4_addresses_per_interface!r}")
            parts.append(f"ipv6_addresses_per_interface={self.ipv6_addresses_per_interface!r}")
            parts.append(f"ipv6_supported={self.ipv6_supported!r}")
            parts.append(f"ena_support={self.ena_support!r}")
            parts.append(f"efa_supported={self.efa_supported!r}")
            parts.append(f"efa_info={self.efa_info!r}")
            parts.append(f"encryption_in_transit_supported={self.encryption_in_transit_supported!r}")
            parts.append(f"ena_srd_supported={self.ena_srd_supported!r}")
            parts.append(f"bandwidth_weightings={self.bandwidth_weightings!r}")
            parts.append(f"flexible_ena_queues_support={self.flexible_ena_queues_support!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('association', 'attachment', 'availability_zone', 'connection_tracking_configurati"
        "on', 'description', 'groups', 'interface_type', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'outp"
        "ost_arn', 'owner_id', 'private_dns_name', 'public_dns_name', 'public_ip_dns_name_options', 'private_ip_address"
        "', 'private_ip_addresses', 'ipv4_prefixes', 'ipv6_prefixes', 'requester_id', 'requester_managed', 'source_dest"
        "_check', 'status', 'subnet_id', 'tag_set', 'vpc_id', 'deny_all_igw_traffic', 'ipv6_native', 'ipv6_address', 'o"
        "perator', 'associated_subnets', 'availability_zone_id')), EqPlan(fields=('association', 'attachment', 'availab"
        "ility_zone', 'connection_tracking_configuration', 'description', 'groups', 'interface_type', 'ipv6_addresses',"
        " 'mac_address', 'network_interface_id', 'outpost_arn', 'owner_id', 'private_dns_name', 'public_dns_name', 'pub"
        "lic_ip_dns_name_options', 'private_ip_address', 'private_ip_addresses', 'ipv4_prefixes', 'ipv6_prefixes', 'req"
        "uester_id', 'requester_managed', 'source_dest_check', 'status', 'subnet_id', 'tag_set', 'vpc_id', 'deny_all_ig"
        "w_traffic', 'ipv6_native', 'ipv6_address', 'operator', 'associated_subnets', 'availability_zone_id')), FrozenP"
        "lan(fields=('__shape__', 'association', 'attachment', 'availability_zone', 'connection_tracking_configuration'"
        ", 'description', 'groups', 'interface_type', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'outpost"
        "_arn', 'owner_id', 'private_dns_name', 'public_dns_name', 'public_ip_dns_name_options', 'private_ip_address', "
        "'private_ip_addresses', 'ipv4_prefixes', 'ipv6_prefixes', 'requester_id', 'requester_managed', 'source_dest_ch"
        "eck', 'status', 'subnet_id', 'tag_set', 'vpc_id', 'deny_all_igw_traffic', 'ipv6_native', 'ipv6_address', 'oper"
        "ator', 'associated_subnets', 'availability_zone_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add'"
        ", fields=('association', 'attachment', 'availability_zone', 'connection_tracking_configuration', 'description'"
        ", 'groups', 'interface_type', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'outpost_arn', 'owner_i"
        "d', 'private_dns_name', 'public_dns_name', 'public_ip_dns_name_options', 'private_ip_address', 'private_ip_add"
        "resses', 'ipv4_prefixes', 'ipv6_prefixes', 'requester_id', 'requester_managed', 'source_dest_check', 'status',"
        " 'subnet_id', 'tag_set', 'vpc_id', 'deny_all_igw_traffic', 'ipv6_native', 'ipv6_address', 'operator', 'associa"
        "ted_subnets', 'availability_zone_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotat"
        "ion=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='association', "
        "annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='attachment', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='ini"
        "t.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
        "one, validate=None, check_type=None), InitPlan.Field(name='availability_zone', annotation=OpRef(name='init.fie"
        "lds.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='connecti"
        "on_tracking_configuration', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields"
        ".4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='description', annotation=OpRef(name='init.fields.5.annotati"
        "on'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type"
        "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='groups', annotation=Op"
        "Ref(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init="
        "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
        "eld(name='interface_type', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields."
        "7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='ipv6_addresses', annotation=OpRef(name='init.fields.8.annota"
        "tion'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='mac_address', annota"
        "tion=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='network_interface_id', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name"
        "='init.fields.10.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='outpost_arn', annotation=OpRef(name='init.fie"
        "lds.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=F"
        "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='owner_"
        "id', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default"
        "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='private_dns_name', annotation=OpRef(name='init.fields.13.annotation'), default=O"
        "pRef(name='init.fields.13.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_dns_name', annotation=OpRef(n"
        "ame='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='public_ip_dns_name_options', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='in"
        "it.fields.15.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='private_ip_address', annotation=OpRef(name='init."
        "fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='pri"
        "vate_ip_addresses', annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.def"
        "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
        "None, check_type=None), InitPlan.Field(name='ipv4_prefixes', annotation=OpRef(name='init.fields.18.annotation'"
        "), default=OpRef(name='init.fields.18.default'), default_factory=None, init=True, override=False, field_type=F"
        "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_prefixes', annotati"
        "on=OpRef(name='init.fields.19.annotation'), default=OpRef(name='init.fields.19.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='requester_id', annotation=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.f"
        "ields.20.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
        "e, validate=None, check_type=None), InitPlan.Field(name='requester_managed', annotation=OpRef(name='init.field"
        "s.21.annotation'), default=OpRef(name='init.fields.21.default'), default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='source_d"
        "est_check', annotation=OpRef(name='init.fields.22.annotation'), default=OpRef(name='init.fields.22.default'), "
        "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
        "eck_type=None), InitPlan.Field(name='status', annotation=OpRef(name='init.fields.23.annotation'), default=OpRe"
        "f(name='init.fields.23.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnet_id', annotation=OpRef(name='init"
        ".fields.24.annotation'), default=OpRef(name='init.fields.24.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ta"
        "g_set', annotation=OpRef(name='init.fields.25.annotation'), default=OpRef(name='init.fields.25.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.26.annotation'), default=OpRef(na"
        "me='init.fields.26.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
        "coerce=None, validate=None, check_type=None), InitPlan.Field(name='deny_all_igw_traffic', annotation=OpRef(nam"
        "e='init.fields.27.annotation'), default=OpRef(name='init.fields.27.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='ipv6_native', annotation=OpRef(name='init.fields.28.annotation'), default=OpRef(name='init.fields.28.defa"
        "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
        "one, check_type=None), InitPlan.Field(name='ipv6_address', annotation=OpRef(name='init.fields.29.annotation'),"
        " default=OpRef(name='init.fields.29.default'), default_factory=None, init=True, override=False, field_type=Fie"
        "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='operator', annotation=OpRe"
        "f(name='init.fields.30.annotation'), default=OpRef(name='init.fields.30.default'), default_factory=None, init="
        "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
        "eld(name='associated_subnets', annotation=OpRef(name='init.fields.31.annotation'), default=OpRef(name='init.fi"
        "elds.31.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
        ", validate=None, check_type=None), InitPlan.Field(name='availability_zone_id', annotation=OpRef(name='init.fie"
        "lds.32.annotation'), default=OpRef(name='init.fields.32.default'), default_factory=None, init=True, override=F"
        "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_par"
        "ams=(), kw_only_params=('association', 'attachment', 'availability_zone', 'connection_tracking_configuration',"
        " 'description', 'groups', 'interface_type', 'ipv6_addresses', 'mac_address', 'network_interface_id', 'outpost_"
        "arn', 'owner_id', 'private_dns_name', 'public_dns_name', 'public_ip_dns_name_options', 'private_ip_address', '"
        "private_ip_addresses', 'ipv4_prefixes', 'ipv6_prefixes', 'requester_id', 'requester_managed', 'source_dest_che"
        "ck', 'status', 'subnet_id', 'tag_set', 'vpc_id', 'deny_all_igw_traffic', 'ipv6_native', 'ipv6_address', 'opera"
        "tor', 'associated_subnets', 'availability_zone_id'), frozen=True, slots=False, post_init_params=None, init_fns"
        "=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='association', kw_only=True, fn=None), ReprPlan.Fi"
        "eld(name='attachment', kw_only=True, fn=None), ReprPlan.Field(name='availability_zone', kw_only=True, fn=None)"
        ", ReprPlan.Field(name='connection_tracking_configuration', kw_only=True, fn=None), ReprPlan.Field(name='descri"
        "ption', kw_only=True, fn=None), ReprPlan.Field(name='groups', kw_only=True, fn=None), ReprPlan.Field(name='int"
        "erface_type', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_addresses', kw_only=True, fn=None), ReprPlan.F"
        "ield(name='mac_address', kw_only=True, fn=None), ReprPlan.Field(name='network_interface_id', kw_only=True, fn="
        "None), ReprPlan.Field(name='outpost_arn', kw_only=True, fn=None), ReprPlan.Field(name='owner_id', kw_only=True"
        ", fn=None), ReprPlan.Field(name='private_dns_name', kw_only=True, fn=None), ReprPlan.Field(name='public_dns_na"
        "me', kw_only=True, fn=None), ReprPlan.Field(name='public_ip_dns_name_options', kw_only=True, fn=None), ReprPla"
        "n.Field(name='private_ip_address', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_addresses', kw_only"
        "=True, fn=None), ReprPlan.Field(name='ipv4_prefixes', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_prefix"
        "es', kw_only=True, fn=None), ReprPlan.Field(name='requester_id', kw_only=True, fn=None), ReprPlan.Field(name='"
        "requester_managed', kw_only=True, fn=None), ReprPlan.Field(name='source_dest_check', kw_only=True, fn=None), R"
        "eprPlan.Field(name='status', kw_only=True, fn=None), ReprPlan.Field(name='subnet_id', kw_only=True, fn=None), "
        "ReprPlan.Field(name='tag_set', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), R"
        "eprPlan.Field(name='deny_all_igw_traffic', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_native', kw_only="
        "True, fn=None), ReprPlan.Field(name='ipv6_address', kw_only=True, fn=None), ReprPlan.Field(name='operator', kw"
        "_only=True, fn=None), ReprPlan.Field(name='associated_subnets', kw_only=True, fn=None), ReprPlan.Field(name='a"
        "vailability_zone_id', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='c56cd673ae581949b4aded8799612b0330bd060b',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__24__annotation',
        '__dataclass__init__fields__24__default',
        '__dataclass__init__fields__25__annotation',
        '__dataclass__init__fields__25__default',
        '__dataclass__init__fields__26__annotation',
        '__dataclass__init__fields__26__default',
        '__dataclass__init__fields__27__annotation',
        '__dataclass__init__fields__27__default',
        '__dataclass__init__fields__28__annotation',
        '__dataclass__init__fields__28__default',
        '__dataclass__init__fields__29__annotation',
        '__dataclass__init__fields__29__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__30__annotation',
        '__dataclass__init__fields__30__default',
        '__dataclass__init__fields__31__annotation',
        '__dataclass__init__fields__31__default',
        '__dataclass__init__fields__32__annotation',
        '__dataclass__init__fields__32__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NetworkInterface'),
    ),
)
def _process_dataclass__c56cd673ae581949b4aded8799612b0330bd060b():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__24__annotation,
        __dataclass__init__fields__24__default,
        __dataclass__init__fields__25__annotation,
        __dataclass__init__fields__25__default,
        __dataclass__init__fields__26__annotation,
        __dataclass__init__fields__26__default,
        __dataclass__init__fields__27__annotation,
        __dataclass__init__fields__27__default,
        __dataclass__init__fields__28__annotation,
        __dataclass__init__fields__28__default,
        __dataclass__init__fields__29__annotation,
        __dataclass__init__fields__29__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__30__annotation,
        __dataclass__init__fields__30__default,
        __dataclass__init__fields__31__annotation,
        __dataclass__init__fields__31__default,
        __dataclass__init__fields__32__annotation,
        __dataclass__init__fields__32__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                association=self.association,
                attachment=self.attachment,
                availability_zone=self.availability_zone,
                connection_tracking_configuration=self.connection_tracking_configuration,
                description=self.description,
                groups=self.groups,
                interface_type=self.interface_type,
                ipv6_addresses=self.ipv6_addresses,
                mac_address=self.mac_address,
                network_interface_id=self.network_interface_id,
                outpost_arn=self.outpost_arn,
                owner_id=self.owner_id,
                private_dns_name=self.private_dns_name,
                public_dns_name=self.public_dns_name,
                public_ip_dns_name_options=self.public_ip_dns_name_options,
                private_ip_address=self.private_ip_address,
                private_ip_addresses=self.private_ip_addresses,
                ipv4_prefixes=self.ipv4_prefixes,
                ipv6_prefixes=self.ipv6_prefixes,
                requester_id=self.requester_id,
                requester_managed=self.requester_managed,
                source_dest_check=self.source_dest_check,
                status=self.status,
                subnet_id=self.subnet_id,
                tag_set=self.tag_set,
                vpc_id=self.vpc_id,
                deny_all_igw_traffic=self.deny_all_igw_traffic,
                ipv6_native=self.ipv6_native,
                ipv6_address=self.ipv6_address,
                operator=self.operator,
                associated_subnets=self.associated_subnets,
                availability_zone_id=self.availability_zone_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.association == other.association and
                self.attachment == other.attachment and
                self.availability_zone == other.availability_zone and
                self.connection_tracking_configuration == other.connection_tracking_configuration and
                self.description == other.description and
                self.groups == other.groups and
                self.interface_type == other.interface_type and
                self.ipv6_addresses == other.ipv6_addresses and
                self.mac_address == other.mac_address and
                self.network_interface_id == other.network_interface_id and
                self.outpost_arn == other.outpost_arn and
                self.owner_id == other.owner_id and
                self.private_dns_name == other.private_dns_name and
                self.public_dns_name == other.public_dns_name and
                self.public_ip_dns_name_options == other.public_ip_dns_name_options and
                self.private_ip_address == other.private_ip_address and
                self.private_ip_addresses == other.private_ip_addresses and
                self.ipv4_prefixes == other.ipv4_prefixes and
                self.ipv6_prefixes == other.ipv6_prefixes and
                self.requester_id == other.requester_id and
                self.requester_managed == other.requester_managed and
                self.source_dest_check == other.source_dest_check and
                self.status == other.status and
                self.subnet_id == other.subnet_id and
                self.tag_set == other.tag_set and
                self.vpc_id == other.vpc_id and
                self.deny_all_igw_traffic == other.deny_all_igw_traffic and
                self.ipv6_native == other.ipv6_native and
                self.ipv6_address == other.ipv6_address and
                self.operator == other.operator and
                self.associated_subnets == other.associated_subnets and
                self.availability_zone_id == other.availability_zone_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'association',
            'attachment',
            'availability_zone',
            'connection_tracking_configuration',
            'description',
            'groups',
            'interface_type',
            'ipv6_addresses',
            'mac_address',
            'network_interface_id',
            'outpost_arn',
            'owner_id',
            'private_dns_name',
            'public_dns_name',
            'public_ip_dns_name_options',
            'private_ip_address',
            'private_ip_addresses',
            'ipv4_prefixes',
            'ipv6_prefixes',
            'requester_id',
            'requester_managed',
            'source_dest_check',
            'status',
            'subnet_id',
            'tag_set',
            'vpc_id',
            'deny_all_igw_traffic',
            'ipv6_native',
            'ipv6_address',
            'operator',
            'associated_subnets',
            'availability_zone_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'association',
            'attachment',
            'availability_zone',
            'connection_tracking_configuration',
            'description',
            'groups',
            'interface_type',
            'ipv6_addresses',
            'mac_address',
            'network_interface_id',
            'outpost_arn',
            'owner_id',
            'private_dns_name',
            'public_dns_name',
            'public_ip_dns_name_options',
            'private_ip_address',
            'private_ip_addresses',
            'ipv4_prefixes',
            'ipv6_prefixes',
            'requester_id',
            'requester_managed',
            'source_dest_check',
            'status',
            'subnet_id',
            'tag_set',
            'vpc_id',
            'deny_all_igw_traffic',
            'ipv6_native',
            'ipv6_address',
            'operator',
            'associated_subnets',
            'availability_zone_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.association,
                self.attachment,
                self.availability_zone,
                self.connection_tracking_configuration,
                self.description,
                self.groups,
                self.interface_type,
                self.ipv6_addresses,
                self.mac_address,
                self.network_interface_id,
                self.outpost_arn,
                self.owner_id,
                self.private_dns_name,
                self.public_dns_name,
                self.public_ip_dns_name_options,
                self.private_ip_address,
                self.private_ip_addresses,
                self.ipv4_prefixes,
                self.ipv6_prefixes,
                self.requester_id,
                self.requester_managed,
                self.source_dest_check,
                self.status,
                self.subnet_id,
                self.tag_set,
                self.vpc_id,
                self.deny_all_igw_traffic,
                self.ipv6_native,
                self.ipv6_address,
                self.operator,
                self.associated_subnets,
                self.availability_zone_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            association: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            attachment: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            availability_zone: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            connection_tracking_configuration: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            description: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            groups: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            interface_type: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            ipv6_addresses: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            mac_address: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            network_interface_id: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            outpost_arn: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            owner_id: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            private_dns_name: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            public_dns_name: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            public_ip_dns_name_options: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            private_ip_address: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            private_ip_addresses: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            ipv4_prefixes: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            ipv6_prefixes: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            requester_id: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            requester_managed: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            source_dest_check: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            status: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
            subnet_id: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
            tag_set: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
            vpc_id: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
            deny_all_igw_traffic: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
            ipv6_native: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
            ipv6_address: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
            operator: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
            associated_subnets: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
            availability_zone_id: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'association', association)
            __dataclass__object_setattr(self, 'attachment', attachment)
            __dataclass__object_setattr(self, 'availability_zone', availability_zone)
            __dataclass__object_setattr(self, 'connection_tracking_configuration', connection_tracking_configuration)
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'groups', groups)
            __dataclass__object_setattr(self, 'interface_type', interface_type)
            __dataclass__object_setattr(self, 'ipv6_addresses', ipv6_addresses)
            __dataclass__object_setattr(self, 'mac_address', mac_address)
            __dataclass__object_setattr(self, 'network_interface_id', network_interface_id)
            __dataclass__object_setattr(self, 'outpost_arn', outpost_arn)
            __dataclass__object_setattr(self, 'owner_id', owner_id)
            __dataclass__object_setattr(self, 'private_dns_name', private_dns_name)
            __dataclass__object_setattr(self, 'public_dns_name', public_dns_name)
            __dataclass__object_setattr(self, 'public_ip_dns_name_options', public_ip_dns_name_options)
            __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)
            __dataclass__object_setattr(self, 'private_ip_addresses', private_ip_addresses)
            __dataclass__object_setattr(self, 'ipv4_prefixes', ipv4_prefixes)
            __dataclass__object_setattr(self, 'ipv6_prefixes', ipv6_prefixes)
            __dataclass__object_setattr(self, 'requester_id', requester_id)
            __dataclass__object_setattr(self, 'requester_managed', requester_managed)
            __dataclass__object_setattr(self, 'source_dest_check', source_dest_check)
            __dataclass__object_setattr(self, 'status', status)
            __dataclass__object_setattr(self, 'subnet_id', subnet_id)
            __dataclass__object_setattr(self, 'tag_set', tag_set)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'deny_all_igw_traffic', deny_all_igw_traffic)
            __dataclass__object_setattr(self, 'ipv6_native', ipv6_native)
            __dataclass__object_setattr(self, 'ipv6_address', ipv6_address)
            __dataclass__object_setattr(self, 'operator', operator)
            __dataclass__object_setattr(self, 'associated_subnets', associated_subnets)
            __dataclass__object_setattr(self, 'availability_zone_id', availability_zone_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"association={self.association!r}")
            parts.append(f"attachment={self.attachment!r}")
            parts.append(f"availability_zone={self.availability_zone!r}")
            parts.append(f"connection_tracking_configuration={self.connection_tracking_configuration!r}")
            parts.append(f"description={self.description!r}")
            parts.append(f"groups={self.groups!r}")
            parts.append(f"interface_type={self.interface_type!r}")
            parts.append(f"ipv6_addresses={self.ipv6_addresses!r}")
            parts.append(f"mac_address={self.mac_address!r}")
            parts.append(f"network_interface_id={self.network_interface_id!r}")
            parts.append(f"outpost_arn={self.outpost_arn!r}")
            parts.append(f"owner_id={self.owner_id!r}")
            parts.append(f"private_dns_name={self.private_dns_name!r}")
            parts.append(f"public_dns_name={self.public_dns_name!r}")
            parts.append(f"public_ip_dns_name_options={self.public_ip_dns_name_options!r}")
            parts.append(f"private_ip_address={self.private_ip_address!r}")
            parts.append(f"private_ip_addresses={self.private_ip_addresses!r}")
            parts.append(f"ipv4_prefixes={self.ipv4_prefixes!r}")
            parts.append(f"ipv6_prefixes={self.ipv6_prefixes!r}")
            parts.append(f"requester_id={self.requester_id!r}")
            parts.append(f"requester_managed={self.requester_managed!r}")
            parts.append(f"source_dest_check={self.source_dest_check!r}")
            parts.append(f"status={self.status!r}")
            parts.append(f"subnet_id={self.subnet_id!r}")
            parts.append(f"tag_set={self.tag_set!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"deny_all_igw_traffic={self.deny_all_igw_traffic!r}")
            parts.append(f"ipv6_native={self.ipv6_native!r}")
            parts.append(f"ipv6_address={self.ipv6_address!r}")
            parts.append(f"operator={self.operator!r}")
            parts.append(f"associated_subnets={self.associated_subnets!r}")
            parts.append(f"availability_zone_id={self.availability_zone_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('allocation_id', 'association_id', 'ip_owner_id', 'public_dns_name', 'public_ip', "
        "'customer_owned_ip', 'carrier_ip')), EqPlan(fields=('allocation_id', 'association_id', 'ip_owner_id', 'public_"
        "dns_name', 'public_ip', 'customer_owned_ip', 'carrier_ip')), FrozenPlan(fields=('__shape__', 'allocation_id', "
        "'association_id', 'ip_owner_id', 'public_dns_name', 'public_ip', 'customer_owned_ip', 'carrier_ip'), allow_dyn"
        "amic_dunder_attrs=False), HashPlan(action='add', fields=('allocation_id', 'association_id', 'ip_owner_id', 'pu"
        "blic_dns_name', 'public_ip', 'customer_owned_ip', 'carrier_ip'), cache=False), InitPlan(fields=(InitPlan.Field"
        "(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init"
        "=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='allocation_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields"
        ".1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='association_id', annotation=OpRef(name='init.fields.2.annot"
        "ation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ip_owner_id', annot"
        "ation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='public_dns_name', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='ini"
        "t.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
        "one, validate=None, check_type=None), InitPlan.Field(name='public_ip', annotation=OpRef(name='init.fields.5.an"
        "notation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, fiel"
        "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='customer_owned_i"
        "p', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_fa"
        "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
        "one), InitPlan.Field(name='carrier_ip', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name="
        "'init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('allocation_id', "
        "'association_id', 'ip_owner_id', 'public_dns_name', 'public_ip', 'customer_owned_ip', 'carrier_ip'), frozen=Tr"
        "ue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='a"
        "llocation_id', kw_only=True, fn=None), ReprPlan.Field(name='association_id', kw_only=True, fn=None), ReprPlan."
        "Field(name='ip_owner_id', kw_only=True, fn=None), ReprPlan.Field(name='public_dns_name', kw_only=True, fn=None"
        "), ReprPlan.Field(name='public_ip', kw_only=True, fn=None), ReprPlan.Field(name='customer_owned_ip', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='carrier_ip', kw_only=True, fn=None)), id=False, terse=False, default_fn=No"
        "ne)))"
    ),
    plan_repr_sha1='cf29ec57560fe99a689b868df651118a8fab1f0b',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NetworkInterfaceAssociation'),
    ),
)
def _process_dataclass__cf29ec57560fe99a689b868df651118a8fab1f0b():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                allocation_id=self.allocation_id,
                association_id=self.association_id,
                ip_owner_id=self.ip_owner_id,
                public_dns_name=self.public_dns_name,
                public_ip=self.public_ip,
                customer_owned_ip=self.customer_owned_ip,
                carrier_ip=self.carrier_ip,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.allocation_id == other.allocation_id and
                self.association_id == other.association_id and
                self.ip_owner_id == other.ip_owner_id and
                self.public_dns_name == other.public_dns_name and
                self.public_ip == other.public_ip and
                self.customer_owned_ip == other.customer_owned_ip and
                self.carrier_ip == other.carrier_ip
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'allocation_id',
            'association_id',
            'ip_owner_id',
            'public_dns_name',
            'public_ip',
            'customer_owned_ip',
            'carrier_ip',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'allocation_id',
            'association_id',
            'ip_owner_id',
            'public_dns_name',
            'public_ip',
            'customer_owned_ip',
            'carrier_ip',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.allocation_id,
                self.association_id,
                self.ip_owner_id,
                self.public_dns_name,
                self.public_ip,
                self.customer_owned_ip,
                self.carrier_ip,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            allocation_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            association_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            ip_owner_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            public_dns_name: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            public_ip: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            customer_owned_ip: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            carrier_ip: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'allocation_id', allocation_id)
            __dataclass__object_setattr(self, 'association_id', association_id)
            __dataclass__object_setattr(self, 'ip_owner_id', ip_owner_id)
            __dataclass__object_setattr(self, 'public_dns_name', public_dns_name)
            __dataclass__object_setattr(self, 'public_ip', public_ip)
            __dataclass__object_setattr(self, 'customer_owned_ip', customer_owned_ip)
            __dataclass__object_setattr(self, 'carrier_ip', carrier_ip)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"allocation_id={self.allocation_id!r}")
            parts.append(f"association_id={self.association_id!r}")
            parts.append(f"ip_owner_id={self.ip_owner_id!r}")
            parts.append(f"public_dns_name={self.public_dns_name!r}")
            parts.append(f"public_ip={self.public_ip!r}")
            parts.append(f"customer_owned_ip={self.customer_owned_ip!r}")
            parts.append(f"carrier_ip={self.carrier_ip!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('attach_time', 'attachment_id', 'delete_on_termination', 'device_index', 'network_"
        "card_index', 'instance_id', 'instance_owner_id', 'status', 'ena_srd_specification', 'ena_queue_count')), EqPla"
        "n(fields=('attach_time', 'attachment_id', 'delete_on_termination', 'device_index', 'network_card_index', 'inst"
        "ance_id', 'instance_owner_id', 'status', 'ena_srd_specification', 'ena_queue_count')), FrozenPlan(fields=('__s"
        "hape__', 'attach_time', 'attachment_id', 'delete_on_termination', 'device_index', 'network_card_index', 'insta"
        "nce_id', 'instance_owner_id', 'status', 'ena_srd_specification', 'ena_queue_count'), allow_dynamic_dunder_attr"
        "s=False), HashPlan(action='add', fields=('attach_time', 'attachment_id', 'delete_on_termination', 'device_inde"
        "x', 'network_card_index', 'instance_id', 'instance_owner_id', 'status', 'ena_srd_specification', 'ena_queue_co"
        "unt'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.an"
        "notation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='attach_time', annotation=OpRef(name='init.fiel"
        "ds.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='attachmen"
        "t_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default"
        "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='delete_on_termination', annotation=OpRef(name='init.fields.3.annotation'), defau"
        "lt=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType."
        "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='device_index', annotation=OpRef(n"
        "ame='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='network_card_index', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None), InitPlan.Field(name='instance_id', annotation=OpRef(name='init.fields.6.annotation"
        "'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=F"
        "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_owner_id', anno"
        "tation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='status', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields"
        ".8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='ena_srd_specification', annotation=OpRef(name='init.fields."
        "9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ena_queue_co"
        "unt', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), defaul"
        "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
        "pe=None)), self_param='self', std_params=(), kw_only_params=('attach_time', 'attachment_id', 'delete_on_termin"
        "ation', 'device_index', 'network_card_index', 'instance_id', 'instance_owner_id', 'status', 'ena_srd_specifica"
        "tion', 'ena_queue_count'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Rep"
        "rPlan(fields=(ReprPlan.Field(name='attach_time', kw_only=True, fn=None), ReprPlan.Field(name='attachment_id', "
        "kw_only=True, fn=None), ReprPlan.Field(name='delete_on_termination', kw_only=True, fn=None), ReprPlan.Field(na"
        "me='device_index', kw_only=True, fn=None), ReprPlan.Field(name='network_card_index', kw_only=True, fn=None), R"
        "eprPlan.Field(name='instance_id', kw_only=True, fn=None), ReprPlan.Field(name='instance_owner_id', kw_only=Tru"
        "e, fn=None), ReprPlan.Field(name='status', kw_only=True, fn=None), ReprPlan.Field(name='ena_srd_specification'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='ena_queue_count', kw_only=True, fn=None)), id=False, terse=Fals"
        "e, default_fn=None)))"
    ),
    plan_repr_sha1='c062d3ee4ff14428774ed2e1093da14147ac2647',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NetworkInterfaceAttachment'),
    ),
)
def _process_dataclass__c062d3ee4ff14428774ed2e1093da14147ac2647():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                attach_time=self.attach_time,
                attachment_id=self.attachment_id,
                delete_on_termination=self.delete_on_termination,
                device_index=self.device_index,
                network_card_index=self.network_card_index,
                instance_id=self.instance_id,
                instance_owner_id=self.instance_owner_id,
                status=self.status,
                ena_srd_specification=self.ena_srd_specification,
                ena_queue_count=self.ena_queue_count,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.attach_time == other.attach_time and
                self.attachment_id == other.attachment_id and
                self.delete_on_termination == other.delete_on_termination and
                self.device_index == other.device_index and
                self.network_card_index == other.network_card_index and
                self.instance_id == other.instance_id and
                self.instance_owner_id == other.instance_owner_id and
                self.status == other.status and
                self.ena_srd_specification == other.ena_srd_specification and
                self.ena_queue_count == other.ena_queue_count
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'attach_time',
            'attachment_id',
            'delete_on_termination',
            'device_index',
            'network_card_index',
            'instance_id',
            'instance_owner_id',
            'status',
            'ena_srd_specification',
            'ena_queue_count',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'attach_time',
            'attachment_id',
            'delete_on_termination',
            'device_index',
            'network_card_index',
            'instance_id',
            'instance_owner_id',
            'status',
            'ena_srd_specification',
            'ena_queue_count',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.attach_time,
                self.attachment_id,
                self.delete_on_termination,
                self.device_index,
                self.network_card_index,
                self.instance_id,
                self.instance_owner_id,
                self.status,
                self.ena_srd_specification,
                self.ena_queue_count,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            attach_time: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            attachment_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            delete_on_termination: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            device_index: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            network_card_index: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            instance_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            instance_owner_id: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            status: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            ena_srd_specification: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            ena_queue_count: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'attach_time', attach_time)
            __dataclass__object_setattr(self, 'attachment_id', attachment_id)
            __dataclass__object_setattr(self, 'delete_on_termination', delete_on_termination)
            __dataclass__object_setattr(self, 'device_index', device_index)
            __dataclass__object_setattr(self, 'network_card_index', network_card_index)
            __dataclass__object_setattr(self, 'instance_id', instance_id)
            __dataclass__object_setattr(self, 'instance_owner_id', instance_owner_id)
            __dataclass__object_setattr(self, 'status', status)
            __dataclass__object_setattr(self, 'ena_srd_specification', ena_srd_specification)
            __dataclass__object_setattr(self, 'ena_queue_count', ena_queue_count)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"attach_time={self.attach_time!r}")
            parts.append(f"attachment_id={self.attachment_id!r}")
            parts.append(f"delete_on_termination={self.delete_on_termination!r}")
            parts.append(f"device_index={self.device_index!r}")
            parts.append(f"network_card_index={self.network_card_index!r}")
            parts.append(f"instance_id={self.instance_id!r}")
            parts.append(f"instance_owner_id={self.instance_owner_id!r}")
            parts.append(f"status={self.status!r}")
            parts.append(f"ena_srd_specification={self.ena_srd_specification!r}")
            parts.append(f"ena_queue_count={self.ena_queue_count!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('ipv6_address', 'public_ipv6_dns_name', 'is_primary_ipv6')), EqPlan(fields=('ipv6_"
        "address', 'public_ipv6_dns_name', 'is_primary_ipv6')), FrozenPlan(fields=('__shape__', 'ipv6_address', 'public"
        "_ipv6_dns_name', 'is_primary_ipv6'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ipv6_a"
        "ddress', 'public_ipv6_dns_name', 'is_primary_ipv6'), cache=False), InitPlan(fields=(InitPlan.Field(name='__sha"
        "pe__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "ipv6_address', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None), InitPlan.Field(name='public_ipv6_dns_name', annotation=OpRef(name='init.fields.2.annotation')"
        ", default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Fie"
        "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='is_primary_ipv6', annotati"
        "on=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_"
        "param='self', std_params=(), kw_only_params=('ipv6_address', 'public_ipv6_dns_name', 'is_primary_ipv6'), froze"
        "n=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
        "e='ipv6_address', kw_only=True, fn=None), ReprPlan.Field(name='public_ipv6_dns_name', kw_only=True, fn=None), "
        "ReprPlan.Field(name='is_primary_ipv6', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='24cdb7e6bf479781358d58f65e57cd2559550867',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NetworkInterfaceIpv6Address'),
    ),
)
def _process_dataclass__24cdb7e6bf479781358d58f65e57cd2559550867():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                ipv6_address=self.ipv6_address,
                public_ipv6_dns_name=self.public_ipv6_dns_name,
                is_primary_ipv6=self.is_primary_ipv6,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.ipv6_address == other.ipv6_address and
                self.public_ipv6_dns_name == other.public_ipv6_dns_name and
                self.is_primary_ipv6 == other.is_primary_ipv6
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'ipv6_address',
            'public_ipv6_dns_name',
            'is_primary_ipv6',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'ipv6_address',
            'public_ipv6_dns_name',
            'is_primary_ipv6',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.ipv6_address,
                self.public_ipv6_dns_name,
                self.is_primary_ipv6,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            ipv6_address: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            public_ipv6_dns_name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            is_primary_ipv6: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'ipv6_address', ipv6_address)
            __dataclass__object_setattr(self, 'public_ipv6_dns_name', public_ipv6_dns_name)
            __dataclass__object_setattr(self, 'is_primary_ipv6', is_primary_ipv6)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"ipv6_address={self.ipv6_address!r}")
            parts.append(f"public_ipv6_dns_name={self.public_ipv6_dns_name!r}")
            parts.append(f"is_primary_ipv6={self.is_primary_ipv6!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('count', 'version')), EqPlan(fields=('count', 'version')), FrozenPlan(fields=('__s"
        "hape__', 'count', 'version'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('count', 'vers"
        "ion'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.an"
        "notation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='count', annotation=OpRef(name='init.fields.1.a"
        "nnotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='version', annot"
        "ation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), se"
        "lf_param='self', std_params=(), kw_only_params=('count', 'version'), frozen=True, slots=False, post_init_param"
        "s=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='count', kw_only=True, fn=None), R"
        "eprPlan.Field(name='version', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='3fbe620c1e5b283d887815f698c446f82f447c36',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NeuronDeviceCoreInfo'),
    ),
)
def _process_dataclass__3fbe620c1e5b283d887815f698c446f82f447c36():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                count=self.count,
                version=self.version,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.count == other.count and
                self.version == other.version
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'count',
            'version',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'count',
            'version',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.count,
                self.version,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            count: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            version: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'count', count)
            __dataclass__object_setattr(self, 'version', version)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"count={self.count!r}")
            parts.append(f"version={self.version!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('count', 'name', 'core_info', 'memory_info')), EqPlan(fields=('count', 'name', 'co"
        "re_info', 'memory_info')), FrozenPlan(fields=('__shape__', 'count', 'name', 'core_info', 'memory_info'), allow"
        "_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('count', 'name', 'core_info', 'memory_info'), cac"
        "he=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation')"
        ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='count', annotation=OpRef(name='init.fields.1.annotation'"
        "), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(n"
        "ame='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True,"
        " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
        "ame='core_info', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='memory_info', annotation=OpRef(name='init.fields.4.annotation'), defau"
        "lt=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType."
        "INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('co"
        "unt', 'name', 'core_info', 'memory_info'), frozen=True, slots=False, post_init_params=None, init_fns=(), valid"
        "ate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='count', kw_only=True, fn=None), ReprPlan.Field(name='name',"
        " kw_only=True, fn=None), ReprPlan.Field(name='core_info', kw_only=True, fn=None), ReprPlan.Field(name='memory_"
        "info', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='4e1bc1b87764803cdd93079441753724a6ce4e6e',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NeuronDeviceInfo'),
    ),
)
def _process_dataclass__4e1bc1b87764803cdd93079441753724a6ce4e6e():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                count=self.count,
                name=self.name,
                core_info=self.core_info,
                memory_info=self.memory_info,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.count == other.count and
                self.name == other.name and
                self.core_info == other.core_info and
                self.memory_info == other.memory_info
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'count',
            'name',
            'core_info',
            'memory_info',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'count',
            'name',
            'core_info',
            'memory_info',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.count,
                self.name,
                self.core_info,
                self.memory_info,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            count: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            core_info: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            memory_info: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'count', count)
            __dataclass__object_setattr(self, 'name', name)
            __dataclass__object_setattr(self, 'core_info', core_info)
            __dataclass__object_setattr(self, 'memory_info', memory_info)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"count={self.count!r}")
            parts.append(f"name={self.name!r}")
            parts.append(f"core_info={self.core_info!r}")
            parts.append(f"memory_info={self.memory_info!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('neuron_devices', 'total_neuron_device_memory_in_mi_b')), EqPlan(fields=('neuron_d"
        "evices', 'total_neuron_device_memory_in_mi_b')), FrozenPlan(fields=('__shape__', 'neuron_devices', 'total_neur"
        "on_device_memory_in_mi_b'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('neuron_devices'"
        ", 'total_neuron_device_memory_in_mi_b'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annot"
        "ation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='neuron_devic"
        "es', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None), InitPlan.Field(name='total_neuron_device_memory_in_mi_b', annotation=OpRef(name='init.fields.2.annotati"
        "on'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type"
        "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_"
        "params=('neuron_devices', 'total_neuron_device_memory_in_mi_b'), frozen=True, slots=False, post_init_params=No"
        "ne, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='neuron_devices', kw_only=True, fn=Non"
        "e), ReprPlan.Field(name='total_neuron_device_memory_in_mi_b', kw_only=True, fn=None)), id=False, terse=False, "
        "default_fn=None)))"
    ),
    plan_repr_sha1='cb350e551ebaec6d052e77a79144de2121b49254',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NeuronInfo'),
    ),
)
def _process_dataclass__cb350e551ebaec6d052e77a79144de2121b49254():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                neuron_devices=self.neuron_devices,
                total_neuron_device_memory_in_mi_b=self.total_neuron_device_memory_in_mi_b,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.neuron_devices == other.neuron_devices and
                self.total_neuron_device_memory_in_mi_b == other.total_neuron_device_memory_in_mi_b
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'neuron_devices',
            'total_neuron_device_memory_in_mi_b',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'neuron_devices',
            'total_neuron_device_memory_in_mi_b',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.neuron_devices,
                self.total_neuron_device_memory_in_mi_b,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            neuron_devices: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            total_neuron_device_memory_in_mi_b: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'neuron_devices', neuron_devices)
            __dataclass__object_setattr(self, 'total_neuron_device_memory_in_mi_b', total_neuron_device_memory_in_mi_b)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"neuron_devices={self.neuron_devices!r}")
            parts.append(f"total_neuron_device_memory_in_mi_b={self.total_neuron_device_memory_in_mi_b!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('supported_versions',)), EqPlan(fields=('supported_versions',)), FrozenPlan(fields"
        "=('__shape__', 'supported_versions'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('suppo"
        "rted_versions',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init."
        "fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLA"
        "SS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='supported_versions', annotation=OpR"
        "ef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param="
        "'self', std_params=(), kw_only_params=('supported_versions',), frozen=True, slots=False, post_init_params=None"
        ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='supported_versions', kw_only=True, fn=N"
        "one),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='b21e63103b657587ad4e98ea3e1e6b9c55c51087',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'NitroTpmInfo'),
    ),
)
def _process_dataclass__b21e63103b657587ad4e98ea3e1e6b9c55c51087():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                supported_versions=self.supported_versions,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.supported_versions == other.supported_versions
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'supported_versions',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'supported_versions',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.supported_versions,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            supported_versions: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'supported_versions', supported_versions)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"supported_versions={self.supported_versions!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('principal',)), EqPlan(fields=('principal',)), FrozenPlan(fields=('__shape__', 'pr"
        "incipal'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('principal',), cache=False), Init"
        "Plan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None,"
        " default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='principal', annotation=OpRef(name='init.fields.1.annotation'), default="
        "OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('princ"
        "ipal',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Repr"
        "Plan.Field(name='principal', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='27b3607ff46bc04e13f6289e0a67ee2b47296301',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'OperatorRequest'),
    ),
)
def _process_dataclass__27b3607ff46bc04e13f6289e0a67ee2b47296301():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                principal=self.principal,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.principal == other.principal
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'principal',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'principal',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.principal,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            principal: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'principal', principal)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"principal={self.principal!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('managed', 'principal')), EqPlan(fields=('managed', 'principal')), FrozenPlan(fiel"
        "ds=('__shape__', 'managed', 'principal'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('m"
        "anaged', 'principal'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='"
        "init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='managed', annotation=OpRef(nam"
        "e='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='principal', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None)), self_param='self', std_params=(), kw_only_params=('managed', 'principal'), frozen=True, slot"
        "s=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='managed',"
        " kw_only=True, fn=None), ReprPlan.Field(name='principal', kw_only=True, fn=None)), id=False, terse=False, defa"
        "ult_fn=None)))"
    ),
    plan_repr_sha1='3db983948f839eb4e1e64db71fc93230245732f1',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'OperatorResponse'),
    ),
)
def _process_dataclass__3db983948f839eb4e1e64db71fc93230245732f1():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                managed=self.managed,
                principal=self.principal,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.managed == other.managed and
                self.principal == other.principal
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'managed',
            'principal',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'managed',
            'principal',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.managed,
                self.principal,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            managed: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            principal: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'managed', managed)
            __dataclass__object_setattr(self, 'principal', principal)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"managed={self.managed!r}")
            parts.append(f"principal={self.principal!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('availability_zone_id', 'affinity', 'group_name', 'partition_number', 'host_id', '"
        "tenancy', 'spread_domain', 'host_resource_group_arn', 'group_id', 'availability_zone')), EqPlan(fields=('avail"
        "ability_zone_id', 'affinity', 'group_name', 'partition_number', 'host_id', 'tenancy', 'spread_domain', 'host_r"
        "esource_group_arn', 'group_id', 'availability_zone')), FrozenPlan(fields=('__shape__', 'availability_zone_id',"
        " 'affinity', 'group_name', 'partition_number', 'host_id', 'tenancy', 'spread_domain', 'host_resource_group_arn"
        "', 'group_id', 'availability_zone'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('availa"
        "bility_zone_id', 'affinity', 'group_name', 'partition_number', 'host_id', 'tenancy', 'spread_domain', 'host_re"
        "source_group_arn', 'group_id', 'availability_zone'), cache=False), InitPlan(fields=(InitPlan.Field(name='__sha"
        "pe__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "availability_zone_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.de"
        "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
        "=None, check_type=None), InitPlan.Field(name='affinity', annotation=OpRef(name='init.fields.2.annotation'), de"
        "fault=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_name', annotation=OpRef("
        "name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='partition_number', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='host_id', annotation=OpRef(name='init.fields.5.annotation'), d"
        "efault=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tenancy', annotation=OpRef(na"
        "me='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='spread_domain', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='host_resource_group_arn', annotation=OpRef(name='init.fields.8.anno"
        "tation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_id', annotat"
        "ion=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None,"
        " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
        "lan.Field(name='availability_zone', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='in"
        "it.fields.10.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('availability_zone_"
        "id', 'affinity', 'group_name', 'partition_number', 'host_id', 'tenancy', 'spread_domain', 'host_resource_group"
        "_arn', 'group_id', 'availability_zone'), frozen=True, slots=False, post_init_params=None, init_fns=(), validat"
        "e_fns=()), ReprPlan(fields=(ReprPlan.Field(name='availability_zone_id', kw_only=True, fn=None), ReprPlan.Field"
        "(name='affinity', kw_only=True, fn=None), ReprPlan.Field(name='group_name', kw_only=True, fn=None), ReprPlan.F"
        "ield(name='partition_number', kw_only=True, fn=None), ReprPlan.Field(name='host_id', kw_only=True, fn=None), R"
        "eprPlan.Field(name='tenancy', kw_only=True, fn=None), ReprPlan.Field(name='spread_domain', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='host_resource_group_arn', kw_only=True, fn=None), ReprPlan.Field(name='group_id', kw"
        "_only=True, fn=None), ReprPlan.Field(name='availability_zone', kw_only=True, fn=None)), id=False, terse=False,"
        " default_fn=None)))"
    ),
    plan_repr_sha1='9056bbd7f356d0e4a2386c0252f0b94cc7bd0de0',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Placement'),
    ),
)
def _process_dataclass__9056bbd7f356d0e4a2386c0252f0b94cc7bd0de0():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                availability_zone_id=self.availability_zone_id,
                affinity=self.affinity,
                group_name=self.group_name,
                partition_number=self.partition_number,
                host_id=self.host_id,
                tenancy=self.tenancy,
                spread_domain=self.spread_domain,
                host_resource_group_arn=self.host_resource_group_arn,
                group_id=self.group_id,
                availability_zone=self.availability_zone,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.availability_zone_id == other.availability_zone_id and
                self.affinity == other.affinity and
                self.group_name == other.group_name and
                self.partition_number == other.partition_number and
                self.host_id == other.host_id and
                self.tenancy == other.tenancy and
                self.spread_domain == other.spread_domain and
                self.host_resource_group_arn == other.host_resource_group_arn and
                self.group_id == other.group_id and
                self.availability_zone == other.availability_zone
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'availability_zone_id',
            'affinity',
            'group_name',
            'partition_number',
            'host_id',
            'tenancy',
            'spread_domain',
            'host_resource_group_arn',
            'group_id',
            'availability_zone',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'availability_zone_id',
            'affinity',
            'group_name',
            'partition_number',
            'host_id',
            'tenancy',
            'spread_domain',
            'host_resource_group_arn',
            'group_id',
            'availability_zone',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.availability_zone_id,
                self.affinity,
                self.group_name,
                self.partition_number,
                self.host_id,
                self.tenancy,
                self.spread_domain,
                self.host_resource_group_arn,
                self.group_id,
                self.availability_zone,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            availability_zone_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            affinity: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            group_name: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            partition_number: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            host_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            tenancy: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            spread_domain: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            host_resource_group_arn: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            group_id: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            availability_zone: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'availability_zone_id', availability_zone_id)
            __dataclass__object_setattr(self, 'affinity', affinity)
            __dataclass__object_setattr(self, 'group_name', group_name)
            __dataclass__object_setattr(self, 'partition_number', partition_number)
            __dataclass__object_setattr(self, 'host_id', host_id)
            __dataclass__object_setattr(self, 'tenancy', tenancy)
            __dataclass__object_setattr(self, 'spread_domain', spread_domain)
            __dataclass__object_setattr(self, 'host_resource_group_arn', host_resource_group_arn)
            __dataclass__object_setattr(self, 'group_id', group_id)
            __dataclass__object_setattr(self, 'availability_zone', availability_zone)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"availability_zone_id={self.availability_zone_id!r}")
            parts.append(f"affinity={self.affinity!r}")
            parts.append(f"group_name={self.group_name!r}")
            parts.append(f"partition_number={self.partition_number!r}")
            parts.append(f"host_id={self.host_id!r}")
            parts.append(f"tenancy={self.tenancy!r}")
            parts.append(f"spread_domain={self.spread_domain!r}")
            parts.append(f"host_resource_group_arn={self.host_resource_group_arn!r}")
            parts.append(f"group_id={self.group_id!r}")
            parts.append(f"availability_zone={self.availability_zone!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('supported_strategies',)), EqPlan(fields=('supported_strategies',)), FrozenPlan(fi"
        "elds=('__shape__', 'supported_strategies'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=("
        "'supported_strategies',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(nam"
        "e='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Field"
        "Type.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='supported_strategies', anno"
        "tation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), s"
        "elf_param='self', std_params=(), kw_only_params=('supported_strategies',), frozen=True, slots=False, post_init"
        "_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='supported_strategies', kw_o"
        "nly=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='55379d54f30130a79aa6c48675259cc882cf4d61',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'PlacementGroupInfo'),
    ),
)
def _process_dataclass__55379d54f30130a79aa6c48675259cc882cf4d61():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                supported_strategies=self.supported_strategies,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.supported_strategies == other.supported_strategies
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'supported_strategies',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'supported_strategies',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.supported_strategies,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            supported_strategies: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'supported_strategies', supported_strategies)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"supported_strategies={self.supported_strategies!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('description', 'prefix_list_id')), EqPlan(fields=('description', 'prefix_list_id')"
        "), FrozenPlan(fields=('__shape__', 'description', 'prefix_list_id'), allow_dynamic_dunder_attrs=False), HashPl"
        "an(action='add', fields=('description', 'prefix_list_id'), cache=False), InitPlan(fields=(InitPlan.Field(name="
        "'__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True,"
        " override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='description', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='prefix_list_id', annotation=OpRef(name='init.fields.2.annotation'),"
        " default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_param"
        "s=('description', 'prefix_list_id'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fn"
        "s=()), ReprPlan(fields=(ReprPlan.Field(name='description', kw_only=True, fn=None), ReprPlan.Field(name='prefix"
        "_list_id', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='18d3544ece736395e2893d219c6c8cb4ef26e598',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'PrefixListId'),
    ),
)
def _process_dataclass__18d3544ece736395e2893d219c6c8cb4ef26e598():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                description=self.description,
                prefix_list_id=self.prefix_list_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.description == other.description and
                self.prefix_list_id == other.prefix_list_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'description',
            'prefix_list_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'description',
            'prefix_list_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.description,
                self.prefix_list_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            description: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            prefix_list_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'prefix_list_id', prefix_list_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"description={self.description!r}")
            parts.append(f"prefix_list_id={self.prefix_list_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('hostname_type', 'enable_resource_name_dns_a_record', 'enable_resource_name_dns_aa"
        "aa_record')), EqPlan(fields=('hostname_type', 'enable_resource_name_dns_a_record', 'enable_resource_name_dns_a"
        "aaa_record')), FrozenPlan(fields=('__shape__', 'hostname_type', 'enable_resource_name_dns_a_record', 'enable_r"
        "esource_name_dns_aaaa_record'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('hostname_ty"
        "pe', 'enable_resource_name_dns_a_record', 'enable_resource_name_dns_aaaa_record'), cache=False), InitPlan(fiel"
        "ds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_"
        "factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='hostname_type', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef"
        "(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
        ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='enable_resource_name_dns_a_record', annot"
        "ation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=Non"
        "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
        "tPlan.Field(name='enable_resource_name_dns_aaaa_record', annotation=OpRef(name='init.fields.3.annotation'), de"
        "fault=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=("
        "'hostname_type', 'enable_resource_name_dns_a_record', 'enable_resource_name_dns_aaaa_record'), frozen=True, sl"
        "ots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='hostnam"
        "e_type', kw_only=True, fn=None), ReprPlan.Field(name='enable_resource_name_dns_a_record', kw_only=True, fn=Non"
        "e), ReprPlan.Field(name='enable_resource_name_dns_aaaa_record', kw_only=True, fn=None)), id=False, terse=False"
        ", default_fn=None)))"
    ),
    plan_repr_sha1='7e027928b04e3415eab0806728312f23ccdfd8a2',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'PrivateDnsNameOptionsOnLaunch'),
        ('ominfra.clouds.aws.models.services.ec2', 'PrivateDnsNameOptionsRequest'),
        ('ominfra.clouds.aws.models.services.ec2', 'PrivateDnsNameOptionsResponse'),
    ),
)
def _process_dataclass__7e027928b04e3415eab0806728312f23ccdfd8a2():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                hostname_type=self.hostname_type,
                enable_resource_name_dns_a_record=self.enable_resource_name_dns_a_record,
                enable_resource_name_dns_aaaa_record=self.enable_resource_name_dns_aaaa_record,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.hostname_type == other.hostname_type and
                self.enable_resource_name_dns_a_record == other.enable_resource_name_dns_a_record and
                self.enable_resource_name_dns_aaaa_record == other.enable_resource_name_dns_aaaa_record
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'hostname_type',
            'enable_resource_name_dns_a_record',
            'enable_resource_name_dns_aaaa_record',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'hostname_type',
            'enable_resource_name_dns_a_record',
            'enable_resource_name_dns_aaaa_record',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.hostname_type,
                self.enable_resource_name_dns_a_record,
                self.enable_resource_name_dns_aaaa_record,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            hostname_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            enable_resource_name_dns_a_record: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            enable_resource_name_dns_aaaa_record: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'hostname_type', hostname_type)
            __dataclass__object_setattr(self, 'enable_resource_name_dns_a_record', enable_resource_name_dns_a_record)
            __dataclass__object_setattr(self, 'enable_resource_name_dns_aaaa_record', enable_resource_name_dns_aaaa_record)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"hostname_type={self.hostname_type!r}")
            parts.append(f"enable_resource_name_dns_a_record={self.enable_resource_name_dns_a_record!r}")
            parts.append(f"enable_resource_name_dns_aaaa_record={self.enable_resource_name_dns_aaaa_record!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('primary', 'private_ip_address')), EqPlan(fields=('primary', 'private_ip_address')"
        "), FrozenPlan(fields=('__shape__', 'primary', 'private_ip_address'), allow_dynamic_dunder_attrs=False), HashPl"
        "an(action='add', fields=('primary', 'private_ip_address'), cache=False), InitPlan(fields=(InitPlan.Field(name="
        "'__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True,"
        " override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='primary', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default')"
        ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='private_ip_address', annotation=OpRef(name='init.fields.2.annotation'),"
        " default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_param"
        "s=('primary', 'private_ip_address'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fn"
        "s=()), ReprPlan(fields=(ReprPlan.Field(name='primary', kw_only=True, fn=None), ReprPlan.Field(name='private_ip"
        "_address', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d00a853b7290f4501b8d6289a3edd5190154a1e1',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'PrivateIpAddressSpecification'),
    ),
)
def _process_dataclass__d00a853b7290f4501b8d6289a3edd5190154a1e1():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                primary=self.primary,
                private_ip_address=self.private_ip_address,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.primary == other.primary and
                self.private_ip_address == other.private_ip_address
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'primary',
            'private_ip_address',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'primary',
            'private_ip_address',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.primary,
                self.private_ip_address,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            primary: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            private_ip_address: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'primary', primary)
            __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"primary={self.primary!r}")
            parts.append(f"private_ip_address={self.private_ip_address!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('supported_architectures', 'sustained_clock_speed_in_ghz', 'supported_features', '"
        "manufacturer')), EqPlan(fields=('supported_architectures', 'sustained_clock_speed_in_ghz', 'supported_features"
        "', 'manufacturer')), FrozenPlan(fields=('__shape__', 'supported_architectures', 'sustained_clock_speed_in_ghz'"
        ", 'supported_features', 'manufacturer'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('su"
        "pported_architectures', 'sustained_clock_speed_in_ghz', 'supported_features', 'manufacturer'), cache=False), I"
        "nitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=No"
        "ne, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='supported_architectures', annotation=OpRef(name='init.fields.1.annot"
        "ation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='sustained_clock_spe"
        "ed_in_ghz', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
        "k_type=None), InitPlan.Field(name='supported_features', annotation=OpRef(name='init.fields.3.annotation'), def"
        "ault=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='manufacturer', annotation=OpRef"
        "(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='s"
        "elf', std_params=(), kw_only_params=('supported_architectures', 'sustained_clock_speed_in_ghz', 'supported_fea"
        "tures', 'manufacturer'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
        "lan(fields=(ReprPlan.Field(name='supported_architectures', kw_only=True, fn=None), ReprPlan.Field(name='sustai"
        "ned_clock_speed_in_ghz', kw_only=True, fn=None), ReprPlan.Field(name='supported_features', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='manufacturer', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='bdbd9e5b5f43b4f9e7c788b19f3b006c841abc0e',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'ProcessorInfo'),
    ),
)
def _process_dataclass__bdbd9e5b5f43b4f9e7c788b19f3b006c841abc0e():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                supported_architectures=self.supported_architectures,
                sustained_clock_speed_in_ghz=self.sustained_clock_speed_in_ghz,
                supported_features=self.supported_features,
                manufacturer=self.manufacturer,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.supported_architectures == other.supported_architectures and
                self.sustained_clock_speed_in_ghz == other.sustained_clock_speed_in_ghz and
                self.supported_features == other.supported_features and
                self.manufacturer == other.manufacturer
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'supported_architectures',
            'sustained_clock_speed_in_ghz',
            'supported_features',
            'manufacturer',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'supported_architectures',
            'sustained_clock_speed_in_ghz',
            'supported_features',
            'manufacturer',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.supported_architectures,
                self.sustained_clock_speed_in_ghz,
                self.supported_features,
                self.manufacturer,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            supported_architectures: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            sustained_clock_speed_in_ghz: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            supported_features: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            manufacturer: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'supported_architectures', supported_architectures)
            __dataclass__object_setattr(self, 'sustained_clock_speed_in_ghz', sustained_clock_speed_in_ghz)
            __dataclass__object_setattr(self, 'supported_features', supported_features)
            __dataclass__object_setattr(self, 'manufacturer', manufacturer)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"supported_architectures={self.supported_architectures!r}")
            parts.append(f"sustained_clock_speed_in_ghz={self.sustained_clock_speed_in_ghz!r}")
            parts.append(f"supported_features={self.supported_features!r}")
            parts.append(f"manufacturer={self.manufacturer!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('product_code_id', 'product_code_type')), EqPlan(fields=('product_code_id', 'produ"
        "ct_code_type')), FrozenPlan(fields=('__shape__', 'product_code_id', 'product_code_type'), allow_dynamic_dunder"
        "_attrs=False), HashPlan(action='add', fields=('product_code_id', 'product_code_type'), cache=False), InitPlan("
        "fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check"
        "_type=None), InitPlan.Field(name='product_code_id', annotation=OpRef(name='init.fields.1.annotation'), default"
        "=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
        "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='product_code_type', annotation=OpRe"
        "f(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='"
        "self', std_params=(), kw_only_params=('product_code_id', 'product_code_type'), frozen=True, slots=False, post_"
        "init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='product_code_id', kw_on"
        "ly=True, fn=None), ReprPlan.Field(name='product_code_type', kw_only=True, fn=None)), id=False, terse=False, de"
        "fault_fn=None)))"
    ),
    plan_repr_sha1='3e88e14547154097971278ad025811e2dd1154c4',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'ProductCode'),
    ),
)
def _process_dataclass__3e88e14547154097971278ad025811e2dd1154c4():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                product_code_id=self.product_code_id,
                product_code_type=self.product_code_type,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.product_code_id == other.product_code_id and
                self.product_code_type == other.product_code_type
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'product_code_id',
            'product_code_type',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'product_code_id',
            'product_code_type',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.product_code_id,
                self.product_code_type,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            product_code_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            product_code_type: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'product_code_id', product_code_id)
            __dataclass__object_setattr(self, 'product_code_type', product_code_type)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"product_code_id={self.product_code_id!r}")
            parts.append(f"product_code_type={self.product_code_type!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('gateway_id',)), EqPlan(fields=('gateway_id',)), FrozenPlan(fields=('__shape__', '"
        "gateway_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('gateway_id',), cache=False), "
        "InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=N"
        "one, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='gateway_id', annotation=OpRef(name='init.fields.1.annotation'), def"
        "ault=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('"
        "gateway_id',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields"
        "=(ReprPlan.Field(name='gateway_id', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='3dd2aca645dbc2b2649d807760268465d937e2f3',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'PropagatingVgw'),
    ),
)
def _process_dataclass__3dd2aca645dbc2b2649d807760268465d937e2f3():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                gateway_id=self.gateway_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.gateway_id == other.gateway_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'gateway_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'gateway_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.gateway_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            gateway_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'gateway_id', gateway_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"gateway_id={self.gateway_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('dns_hostname_type', 'public_ipv4_dns_name', 'public_ipv6_dns_name', 'public_dual_"
        "stack_dns_name')), EqPlan(fields=('dns_hostname_type', 'public_ipv4_dns_name', 'public_ipv6_dns_name', 'public"
        "_dual_stack_dns_name')), FrozenPlan(fields=('__shape__', 'dns_hostname_type', 'public_ipv4_dns_name', 'public_"
        "ipv6_dns_name', 'public_dual_stack_dns_name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', field"
        "s=('dns_hostname_type', 'public_ipv4_dns_name', 'public_ipv6_dns_name', 'public_dual_stack_dns_name'), cache=F"
        "alse), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), de"
        "fault=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='dns_hostname_type', annotation=OpRef(name='init.fields.1.ann"
        "otation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_ipv4_dns_n"
        "ame', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='public_ipv6_dns_name', annotation=OpRef(name='init.fields.3.annotation'), default"
        "=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
        "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='public_dual_stack_dns_name', annota"
        "tion=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), sel"
        "f_param='self', std_params=(), kw_only_params=('dns_hostname_type', 'public_ipv4_dns_name', 'public_ipv6_dns_n"
        "ame', 'public_dual_stack_dns_name'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fn"
        "s=()), ReprPlan(fields=(ReprPlan.Field(name='dns_hostname_type', kw_only=True, fn=None), ReprPlan.Field(name='"
        "public_ipv4_dns_name', kw_only=True, fn=None), ReprPlan.Field(name='public_ipv6_dns_name', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='public_dual_stack_dns_name', kw_only=True, fn=None)), id=False, terse=False, default"
        "_fn=None)))"
    ),
    plan_repr_sha1='ce7d79af67863ed76184828a5195f4fe33df604c',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'PublicIpDnsNameOptions'),
    ),
)
def _process_dataclass__ce7d79af67863ed76184828a5195f4fe33df604c():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                dns_hostname_type=self.dns_hostname_type,
                public_ipv4_dns_name=self.public_ipv4_dns_name,
                public_ipv6_dns_name=self.public_ipv6_dns_name,
                public_dual_stack_dns_name=self.public_dual_stack_dns_name,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.dns_hostname_type == other.dns_hostname_type and
                self.public_ipv4_dns_name == other.public_ipv4_dns_name and
                self.public_ipv6_dns_name == other.public_ipv6_dns_name and
                self.public_dual_stack_dns_name == other.public_dual_stack_dns_name
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'dns_hostname_type',
            'public_ipv4_dns_name',
            'public_ipv6_dns_name',
            'public_dual_stack_dns_name',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'dns_hostname_type',
            'public_ipv4_dns_name',
            'public_ipv6_dns_name',
            'public_dual_stack_dns_name',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.dns_hostname_type,
                self.public_ipv4_dns_name,
                self.public_ipv6_dns_name,
                self.public_dual_stack_dns_name,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            dns_hostname_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            public_ipv4_dns_name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            public_ipv6_dns_name: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            public_dual_stack_dns_name: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'dns_hostname_type', dns_hostname_type)
            __dataclass__object_setattr(self, 'public_ipv4_dns_name', public_ipv4_dns_name)
            __dataclass__object_setattr(self, 'public_ipv6_dns_name', public_ipv6_dns_name)
            __dataclass__object_setattr(self, 'public_dual_stack_dns_name', public_dual_stack_dns_name)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"dns_hostname_type={self.dns_hostname_type!r}")
            parts.append(f"public_ipv4_dns_name={self.public_ipv4_dns_name!r}")
            parts.append(f"public_ipv6_dns_name={self.public_ipv6_dns_name!r}")
            parts.append(f"public_dual_stack_dns_name={self.public_dual_stack_dns_name!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('instance_ids', 'dry_run')), EqPlan(fields=('instance_ids', 'dry_run')), FrozenPla"
        "n(fields=('__shape__', 'instance_ids', 'dry_run'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', f"
        "ields=('instance_ids', 'dry_run'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation="
        "OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_ids', ann"
        "otation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', a"
        "nnotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory"
        "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None))"
        ", self_param='self', std_params=(), kw_only_params=('instance_ids', 'dry_run'), frozen=True, slots=False, post"
        "_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='instance_ids', kw_only"
        "=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None)), id=False, terse=False, default_fn=Non"
        "e)))"
    ),
    plan_repr_sha1='c569820b05e8694651bb4d8885a11d68f50dc213',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'RebootInstancesRequest'),
    ),
)
def _process_dataclass__c569820b05e8694651bb4d8885a11d68f50dc213():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                instance_ids=self.instance_ids,
                dry_run=self.dry_run,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.instance_ids == other.instance_ids and
                self.dry_run == other.dry_run
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'dry_run',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'dry_run',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.instance_ids,
                self.dry_run,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            instance_ids: __dataclass__init__fields__1__annotation,
            dry_run: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'instance_ids', instance_ids)
            __dataclass__object_setattr(self, 'dry_run', dry_run)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"instance_ids={self.instance_ids!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('reservation_id', 'owner_id', 'requester_id', 'groups', 'instances')), EqPlan(fiel"
        "ds=('reservation_id', 'owner_id', 'requester_id', 'groups', 'instances')), FrozenPlan(fields=('__shape__', 're"
        "servation_id', 'owner_id', 'requester_id', 'groups', 'instances'), allow_dynamic_dunder_attrs=False), HashPlan"
        "(action='add', fields=('reservation_id', 'owner_id', 'requester_id', 'groups', 'instances'), cache=False), Ini"
        "tPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None"
        ", default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='reservation_id', annotation=OpRef(name='init.fields.1.annotation'), de"
        "fault=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='owner_id', annotation=OpRef(na"
        "me='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='requester_id', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='groups', annotation=OpRef(name='init.fields.4.annotation'), default="
        "OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instances', annotation=OpRef(name='i"
        "nit.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', st"
        "d_params=(), kw_only_params=('reservation_id', 'owner_id', 'requester_id', 'groups', 'instances'), frozen=True"
        ", slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='res"
        "ervation_id', kw_only=True, fn=None), ReprPlan.Field(name='owner_id', kw_only=True, fn=None), ReprPlan.Field(n"
        "ame='requester_id', kw_only=True, fn=None), ReprPlan.Field(name='groups', kw_only=True, fn=None), ReprPlan.Fie"
        "ld(name='instances', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='4dcdc31a11266b0f3715b509ae10ced769c8d571',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Reservation'),
    ),
)
def _process_dataclass__4dcdc31a11266b0f3715b509ae10ced769c8d571():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                reservation_id=self.reservation_id,
                owner_id=self.owner_id,
                requester_id=self.requester_id,
                groups=self.groups,
                instances=self.instances,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.reservation_id == other.reservation_id and
                self.owner_id == other.owner_id and
                self.requester_id == other.requester_id and
                self.groups == other.groups and
                self.instances == other.instances
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'reservation_id',
            'owner_id',
            'requester_id',
            'groups',
            'instances',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'reservation_id',
            'owner_id',
            'requester_id',
            'groups',
            'instances',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.reservation_id,
                self.owner_id,
                self.requester_id,
                self.groups,
                self.instances,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            reservation_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            owner_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            requester_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            groups: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            instances: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'reservation_id', reservation_id)
            __dataclass__object_setattr(self, 'owner_id', owner_id)
            __dataclass__object_setattr(self, 'requester_id', requester_id)
            __dataclass__object_setattr(self, 'groups', groups)
            __dataclass__object_setattr(self, 'instances', instances)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"reservation_id={self.reservation_id!r}")
            parts.append(f"owner_id={self.owner_id!r}")
            parts.append(f"requester_id={self.requester_id!r}")
            parts.append(f"groups={self.groups!r}")
            parts.append(f"instances={self.instances!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('destination_cidr_block', 'destination_ipv6_cidr_block', 'destination_prefix_list_"
        "id', 'egress_only_internet_gateway_id', 'gateway_id', 'instance_id', 'instance_owner_id', 'nat_gateway_id', 't"
        "ransit_gateway_id', 'local_gateway_id', 'carrier_gateway_id', 'network_interface_id', 'origin', 'state', 'vpc_"
        "peering_connection_id', 'core_network_arn', 'odb_network_arn', 'ip_address')), EqPlan(fields=('destination_cid"
        "r_block', 'destination_ipv6_cidr_block', 'destination_prefix_list_id', 'egress_only_internet_gateway_id', 'gat"
        "eway_id', 'instance_id', 'instance_owner_id', 'nat_gateway_id', 'transit_gateway_id', 'local_gateway_id', 'car"
        "rier_gateway_id', 'network_interface_id', 'origin', 'state', 'vpc_peering_connection_id', 'core_network_arn', "
        "'odb_network_arn', 'ip_address')), FrozenPlan(fields=('__shape__', 'destination_cidr_block', 'destination_ipv6"
        "_cidr_block', 'destination_prefix_list_id', 'egress_only_internet_gateway_id', 'gateway_id', 'instance_id', 'i"
        "nstance_owner_id', 'nat_gateway_id', 'transit_gateway_id', 'local_gateway_id', 'carrier_gateway_id', 'network_"
        "interface_id', 'origin', 'state', 'vpc_peering_connection_id', 'core_network_arn', 'odb_network_arn', 'ip_addr"
        "ess'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('destination_cidr_block', 'destinatio"
        "n_ipv6_cidr_block', 'destination_prefix_list_id', 'egress_only_internet_gateway_id', 'gateway_id', 'instance_i"
        "d', 'instance_owner_id', 'nat_gateway_id', 'transit_gateway_id', 'local_gateway_id', 'carrier_gateway_id', 'ne"
        "twork_interface_id', 'origin', 'state', 'vpc_peering_connection_id', 'core_network_arn', 'odb_network_arn', 'i"
        "p_address'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.field"
        "s.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VA"
        "R, coerce=None, validate=None, check_type=None), InitPlan.Field(name='destination_cidr_block', annotation=OpRe"
        "f(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='destination_ipv6_cidr_block', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='i"
        "nit.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='destination_prefix_list_id', annotation=OpRef(nam"
        "e='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, o"
        "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
        "e='egress_only_internet_gateway_id', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='in"
        "it.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='gateway_id', annotation=OpRef(name='init.fields.5."
        "annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, fi"
        "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_id', "
        "annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='instance_owner_id', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(na"
        "me='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
        "oerce=None, validate=None, check_type=None), InitPlan.Field(name='nat_gateway_id', annotation=OpRef(name='init"
        ".fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override"
        "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tran"
        "sit_gateway_id', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='local_gateway_id', annotation=OpRef(name='init.fields.10.annotation'),"
        " default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_type=Fie"
        "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='carrier_gateway_id', annot"
        "ation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='network_interface_id', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(n"
        "ame='init.fields.12.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
        " coerce=None, validate=None, check_type=None), InitPlan.Field(name='origin', annotation=OpRef(name='init.field"
        "s.13.annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state', "
        "annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='vpc_peering_connection_id', annotation=OpRef(name='init.fields.15.annotation'), defau"
        "lt=OpRef(name='init.fields.15.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='core_network_arn', annotation=Op"
        "Ref(name='init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='odb_network_arn', annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fie"
        "lds.17.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='ip_address', annotation=OpRef(name='init.fields.18.anno"
        "tation'), default=OpRef(name='init.fields.18.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_"
        "only_params=('destination_cidr_block', 'destination_ipv6_cidr_block', 'destination_prefix_list_id', 'egress_on"
        "ly_internet_gateway_id', 'gateway_id', 'instance_id', 'instance_owner_id', 'nat_gateway_id', 'transit_gateway_"
        "id', 'local_gateway_id', 'carrier_gateway_id', 'network_interface_id', 'origin', 'state', 'vpc_peering_connect"
        "ion_id', 'core_network_arn', 'odb_network_arn', 'ip_address'), frozen=True, slots=False, post_init_params=None"
        ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='destination_cidr_block', kw_only=True, "
        "fn=None), ReprPlan.Field(name='destination_ipv6_cidr_block', kw_only=True, fn=None), ReprPlan.Field(name='dest"
        "ination_prefix_list_id', kw_only=True, fn=None), ReprPlan.Field(name='egress_only_internet_gateway_id', kw_onl"
        "y=True, fn=None), ReprPlan.Field(name='gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='instance_id',"
        " kw_only=True, fn=None), ReprPlan.Field(name='instance_owner_id', kw_only=True, fn=None), ReprPlan.Field(name="
        "'nat_gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='transit_gateway_id', kw_only=True, fn=None), Re"
        "prPlan.Field(name='local_gateway_id', kw_only=True, fn=None), ReprPlan.Field(name='carrier_gateway_id', kw_onl"
        "y=True, fn=None), ReprPlan.Field(name='network_interface_id', kw_only=True, fn=None), ReprPlan.Field(name='ori"
        "gin', kw_only=True, fn=None), ReprPlan.Field(name='state', kw_only=True, fn=None), ReprPlan.Field(name='vpc_pe"
        "ering_connection_id', kw_only=True, fn=None), ReprPlan.Field(name='core_network_arn', kw_only=True, fn=None), "
        "ReprPlan.Field(name='odb_network_arn', kw_only=True, fn=None), ReprPlan.Field(name='ip_address', kw_only=True,"
        " fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d10b36836b385aa819993a55a03255210a1b5dd1',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Route'),
    ),
)
def _process_dataclass__d10b36836b385aa819993a55a03255210a1b5dd1():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                destination_cidr_block=self.destination_cidr_block,
                destination_ipv6_cidr_block=self.destination_ipv6_cidr_block,
                destination_prefix_list_id=self.destination_prefix_list_id,
                egress_only_internet_gateway_id=self.egress_only_internet_gateway_id,
                gateway_id=self.gateway_id,
                instance_id=self.instance_id,
                instance_owner_id=self.instance_owner_id,
                nat_gateway_id=self.nat_gateway_id,
                transit_gateway_id=self.transit_gateway_id,
                local_gateway_id=self.local_gateway_id,
                carrier_gateway_id=self.carrier_gateway_id,
                network_interface_id=self.network_interface_id,
                origin=self.origin,
                state=self.state,
                vpc_peering_connection_id=self.vpc_peering_connection_id,
                core_network_arn=self.core_network_arn,
                odb_network_arn=self.odb_network_arn,
                ip_address=self.ip_address,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.destination_cidr_block == other.destination_cidr_block and
                self.destination_ipv6_cidr_block == other.destination_ipv6_cidr_block and
                self.destination_prefix_list_id == other.destination_prefix_list_id and
                self.egress_only_internet_gateway_id == other.egress_only_internet_gateway_id and
                self.gateway_id == other.gateway_id and
                self.instance_id == other.instance_id and
                self.instance_owner_id == other.instance_owner_id and
                self.nat_gateway_id == other.nat_gateway_id and
                self.transit_gateway_id == other.transit_gateway_id and
                self.local_gateway_id == other.local_gateway_id and
                self.carrier_gateway_id == other.carrier_gateway_id and
                self.network_interface_id == other.network_interface_id and
                self.origin == other.origin and
                self.state == other.state and
                self.vpc_peering_connection_id == other.vpc_peering_connection_id and
                self.core_network_arn == other.core_network_arn and
                self.odb_network_arn == other.odb_network_arn and
                self.ip_address == other.ip_address
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'destination_cidr_block',
            'destination_ipv6_cidr_block',
            'destination_prefix_list_id',
            'egress_only_internet_gateway_id',
            'gateway_id',
            'instance_id',
            'instance_owner_id',
            'nat_gateway_id',
            'transit_gateway_id',
            'local_gateway_id',
            'carrier_gateway_id',
            'network_interface_id',
            'origin',
            'state',
            'vpc_peering_connection_id',
            'core_network_arn',
            'odb_network_arn',
            'ip_address',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'destination_cidr_block',
            'destination_ipv6_cidr_block',
            'destination_prefix_list_id',
            'egress_only_internet_gateway_id',
            'gateway_id',
            'instance_id',
            'instance_owner_id',
            'nat_gateway_id',
            'transit_gateway_id',
            'local_gateway_id',
            'carrier_gateway_id',
            'network_interface_id',
            'origin',
            'state',
            'vpc_peering_connection_id',
            'core_network_arn',
            'odb_network_arn',
            'ip_address',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.destination_cidr_block,
                self.destination_ipv6_cidr_block,
                self.destination_prefix_list_id,
                self.egress_only_internet_gateway_id,
                self.gateway_id,
                self.instance_id,
                self.instance_owner_id,
                self.nat_gateway_id,
                self.transit_gateway_id,
                self.local_gateway_id,
                self.carrier_gateway_id,
                self.network_interface_id,
                self.origin,
                self.state,
                self.vpc_peering_connection_id,
                self.core_network_arn,
                self.odb_network_arn,
                self.ip_address,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            destination_cidr_block: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            destination_ipv6_cidr_block: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            destination_prefix_list_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            egress_only_internet_gateway_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            gateway_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            instance_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            instance_owner_id: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            nat_gateway_id: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            transit_gateway_id: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            local_gateway_id: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            carrier_gateway_id: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            network_interface_id: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            origin: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            state: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            vpc_peering_connection_id: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            core_network_arn: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            odb_network_arn: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            ip_address: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'destination_cidr_block', destination_cidr_block)
            __dataclass__object_setattr(self, 'destination_ipv6_cidr_block', destination_ipv6_cidr_block)
            __dataclass__object_setattr(self, 'destination_prefix_list_id', destination_prefix_list_id)
            __dataclass__object_setattr(self, 'egress_only_internet_gateway_id', egress_only_internet_gateway_id)
            __dataclass__object_setattr(self, 'gateway_id', gateway_id)
            __dataclass__object_setattr(self, 'instance_id', instance_id)
            __dataclass__object_setattr(self, 'instance_owner_id', instance_owner_id)
            __dataclass__object_setattr(self, 'nat_gateway_id', nat_gateway_id)
            __dataclass__object_setattr(self, 'transit_gateway_id', transit_gateway_id)
            __dataclass__object_setattr(self, 'local_gateway_id', local_gateway_id)
            __dataclass__object_setattr(self, 'carrier_gateway_id', carrier_gateway_id)
            __dataclass__object_setattr(self, 'network_interface_id', network_interface_id)
            __dataclass__object_setattr(self, 'origin', origin)
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'vpc_peering_connection_id', vpc_peering_connection_id)
            __dataclass__object_setattr(self, 'core_network_arn', core_network_arn)
            __dataclass__object_setattr(self, 'odb_network_arn', odb_network_arn)
            __dataclass__object_setattr(self, 'ip_address', ip_address)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"destination_cidr_block={self.destination_cidr_block!r}")
            parts.append(f"destination_ipv6_cidr_block={self.destination_ipv6_cidr_block!r}")
            parts.append(f"destination_prefix_list_id={self.destination_prefix_list_id!r}")
            parts.append(f"egress_only_internet_gateway_id={self.egress_only_internet_gateway_id!r}")
            parts.append(f"gateway_id={self.gateway_id!r}")
            parts.append(f"instance_id={self.instance_id!r}")
            parts.append(f"instance_owner_id={self.instance_owner_id!r}")
            parts.append(f"nat_gateway_id={self.nat_gateway_id!r}")
            parts.append(f"transit_gateway_id={self.transit_gateway_id!r}")
            parts.append(f"local_gateway_id={self.local_gateway_id!r}")
            parts.append(f"carrier_gateway_id={self.carrier_gateway_id!r}")
            parts.append(f"network_interface_id={self.network_interface_id!r}")
            parts.append(f"origin={self.origin!r}")
            parts.append(f"state={self.state!r}")
            parts.append(f"vpc_peering_connection_id={self.vpc_peering_connection_id!r}")
            parts.append(f"core_network_arn={self.core_network_arn!r}")
            parts.append(f"odb_network_arn={self.odb_network_arn!r}")
            parts.append(f"ip_address={self.ip_address!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('associations', 'propagating_vgws', 'route_table_id', 'routes', 'tags', 'vpc_id', "
        "'owner_id')), EqPlan(fields=('associations', 'propagating_vgws', 'route_table_id', 'routes', 'tags', 'vpc_id',"
        " 'owner_id')), FrozenPlan(fields=('__shape__', 'associations', 'propagating_vgws', 'route_table_id', 'routes',"
        " 'tags', 'vpc_id', 'owner_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('association"
        "s', 'propagating_vgws', 'route_table_id', 'routes', 'tags', 'vpc_id', 'owner_id'), cache=False), InitPlan(fiel"
        "ds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_"
        "factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='associations', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef("
        "name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
        " coerce=None, validate=None, check_type=None), InitPlan.Field(name='propagating_vgws', annotation=OpRef(name='"
        "init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, over"
        "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "route_table_id', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'"
        "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='routes', annotation=OpRef(name='init.fields.4.annotation'), default=Op"
        "Ref(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
        "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='init.fie"
        "lds.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_id',"
        " annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_facto"
        "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
        "), InitPlan.Field(name='owner_id', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init"
        ".fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('associations', 'propa"
        "gating_vgws', 'route_table_id', 'routes', 'tags', 'vpc_id', 'owner_id'), frozen=True, slots=False, post_init_p"
        "arams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='associations', kw_only=True, "
        "fn=None), ReprPlan.Field(name='propagating_vgws', kw_only=True, fn=None), ReprPlan.Field(name='route_table_id'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='routes', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw"
        "_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPlan.Field(name='owner_id', kw"
        "_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='743790e42a33fe8d52a44a740e180dc180d5d330',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'RouteTable'),
    ),
)
def _process_dataclass__743790e42a33fe8d52a44a740e180dc180d5d330():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                associations=self.associations,
                propagating_vgws=self.propagating_vgws,
                route_table_id=self.route_table_id,
                routes=self.routes,
                tags=self.tags,
                vpc_id=self.vpc_id,
                owner_id=self.owner_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.associations == other.associations and
                self.propagating_vgws == other.propagating_vgws and
                self.route_table_id == other.route_table_id and
                self.routes == other.routes and
                self.tags == other.tags and
                self.vpc_id == other.vpc_id and
                self.owner_id == other.owner_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'associations',
            'propagating_vgws',
            'route_table_id',
            'routes',
            'tags',
            'vpc_id',
            'owner_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'associations',
            'propagating_vgws',
            'route_table_id',
            'routes',
            'tags',
            'vpc_id',
            'owner_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.associations,
                self.propagating_vgws,
                self.route_table_id,
                self.routes,
                self.tags,
                self.vpc_id,
                self.owner_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            associations: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            propagating_vgws: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            route_table_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            routes: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            tags: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            vpc_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            owner_id: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'associations', associations)
            __dataclass__object_setattr(self, 'propagating_vgws', propagating_vgws)
            __dataclass__object_setattr(self, 'route_table_id', route_table_id)
            __dataclass__object_setattr(self, 'routes', routes)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'owner_id', owner_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"associations={self.associations!r}")
            parts.append(f"propagating_vgws={self.propagating_vgws!r}")
            parts.append(f"route_table_id={self.route_table_id!r}")
            parts.append(f"routes={self.routes!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"owner_id={self.owner_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('main', 'route_table_association_id', 'route_table_id', 'subnet_id', 'gateway_id',"
        " 'public_ipv4_pool', 'association_state')), EqPlan(fields=('main', 'route_table_association_id', 'route_table_"
        "id', 'subnet_id', 'gateway_id', 'public_ipv4_pool', 'association_state')), FrozenPlan(fields=('__shape__', 'ma"
        "in', 'route_table_association_id', 'route_table_id', 'subnet_id', 'gateway_id', 'public_ipv4_pool', 'associati"
        "on_state'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('main', 'route_table_association"
        "_id', 'route_table_id', 'subnet_id', 'gateway_id', 'public_ipv4_pool', 'association_state'), cache=False), Ini"
        "tPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None"
        ", default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='main', annotation=OpRef(name='init.fields.1.annotation'), default=OpRe"
        "f(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
        "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='route_table_association_id', annotation="
        "OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='route_table_id', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.field"
        "s.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='subnet_id', annotation=OpRef(name='init.fields.4.annotatio"
        "n'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type="
        "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='gateway_id', annotation"
        "=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
        ".Field(name='public_ipv4_pool', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fi"
        "elds.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='association_state', annotation=OpRef(name='init.fields."
        "7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=()"
        ", kw_only_params=('main', 'route_table_association_id', 'route_table_id', 'subnet_id', 'gateway_id', 'public_i"
        "pv4_pool', 'association_state'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()"
        "), ReprPlan(fields=(ReprPlan.Field(name='main', kw_only=True, fn=None), ReprPlan.Field(name='route_table_assoc"
        "iation_id', kw_only=True, fn=None), ReprPlan.Field(name='route_table_id', kw_only=True, fn=None), ReprPlan.Fie"
        "ld(name='subnet_id', kw_only=True, fn=None), ReprPlan.Field(name='gateway_id', kw_only=True, fn=None), ReprPla"
        "n.Field(name='public_ipv4_pool', kw_only=True, fn=None), ReprPlan.Field(name='association_state', kw_only=True"
        ", fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='df63244c16b2a1951ab99d694225b97a336704c1',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'RouteTableAssociation'),
    ),
)
def _process_dataclass__df63244c16b2a1951ab99d694225b97a336704c1():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                main=self.main,
                route_table_association_id=self.route_table_association_id,
                route_table_id=self.route_table_id,
                subnet_id=self.subnet_id,
                gateway_id=self.gateway_id,
                public_ipv4_pool=self.public_ipv4_pool,
                association_state=self.association_state,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.main == other.main and
                self.route_table_association_id == other.route_table_association_id and
                self.route_table_id == other.route_table_id and
                self.subnet_id == other.subnet_id and
                self.gateway_id == other.gateway_id and
                self.public_ipv4_pool == other.public_ipv4_pool and
                self.association_state == other.association_state
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'main',
            'route_table_association_id',
            'route_table_id',
            'subnet_id',
            'gateway_id',
            'public_ipv4_pool',
            'association_state',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'main',
            'route_table_association_id',
            'route_table_id',
            'subnet_id',
            'gateway_id',
            'public_ipv4_pool',
            'association_state',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.main,
                self.route_table_association_id,
                self.route_table_id,
                self.subnet_id,
                self.gateway_id,
                self.public_ipv4_pool,
                self.association_state,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            main: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            route_table_association_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            route_table_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            subnet_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            gateway_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            public_ipv4_pool: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            association_state: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'main', main)
            __dataclass__object_setattr(self, 'route_table_association_id', route_table_association_id)
            __dataclass__object_setattr(self, 'route_table_id', route_table_id)
            __dataclass__object_setattr(self, 'subnet_id', subnet_id)
            __dataclass__object_setattr(self, 'gateway_id', gateway_id)
            __dataclass__object_setattr(self, 'public_ipv4_pool', public_ipv4_pool)
            __dataclass__object_setattr(self, 'association_state', association_state)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"main={self.main!r}")
            parts.append(f"route_table_association_id={self.route_table_association_id!r}")
            parts.append(f"route_table_id={self.route_table_id!r}")
            parts.append(f"subnet_id={self.subnet_id!r}")
            parts.append(f"gateway_id={self.gateway_id!r}")
            parts.append(f"public_ipv4_pool={self.public_ipv4_pool!r}")
            parts.append(f"association_state={self.association_state!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('state', 'status_message')), EqPlan(fields=('state', 'status_message')), FrozenPla"
        "n(fields=('__shape__', 'state', 'status_message'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', f"
        "ields=('state', 'status_message'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation="
        "OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_t"
        "ype=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state', annotation"
        "=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
        ".Field(name='status_message', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fiel"
        "ds.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('state', 'status_message'),"
        " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Fie"
        "ld(name='state', kw_only=True, fn=None), ReprPlan.Field(name='status_message', kw_only=True, fn=None)), id=Fal"
        "se, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='f5b11eca48f4c5e0caac03c39767918c6711dba4',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'RouteTableAssociationState'),
        ('ominfra.clouds.aws.models.services.ec2', 'SubnetCidrBlockState'),
        ('ominfra.clouds.aws.models.services.ec2', 'VpcCidrBlockState'),
    ),
)
def _process_dataclass__f5b11eca48f4c5e0caac03c39767918c6711dba4():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                state=self.state,
                status_message=self.status_message,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.state == other.state and
                self.status_message == other.status_message
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'state',
            'status_message',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'state',
            'status_message',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.state,
                self.status_message,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            state: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            status_message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'status_message', status_message)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"state={self.state!r}")
            parts.append(f"status_message={self.status_message!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('enabled',)), EqPlan(fields=('enabled',)), FrozenPlan(fields=('__shape__', 'enable"
        "d'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('enabled',), cache=False), InitPlan(fie"
        "lds=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default"
        "_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_ty"
        "pe=None), InitPlan.Field(name='enabled', annotation=OpRef(name='init.fields.1.annotation'), default=None, defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None)), self_param='self', std_params=(), kw_only_params=('enabled',), frozen=True, slots=False, post_ini"
        "t_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='enabled', kw_only=True, fn"
        "=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='bb4476bedb74d1ffda10b96b3aa1736540de06a7',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'RunInstancesMonitoringEnabled'),
    ),
)
def _process_dataclass__bb4476bedb74d1ffda10b96b3aa1736540de06a7():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                enabled=self.enabled,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.enabled == other.enabled
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'enabled',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'enabled',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.enabled,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            enabled: __dataclass__init__fields__1__annotation,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'enabled', enabled)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"enabled={self.enabled!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('block_device_mappings', 'image_id', 'instance_type', 'ipv6_address_count', 'ipv6_"
        "addresses', 'kernel_id', 'key_name', 'max_count', 'min_count', 'monitoring', 'placement', 'ramdisk_id', 'secur"
        "ity_group_ids', 'security_groups', 'subnet_id', 'user_data', 'elastic_gpu_specification', 'elastic_inference_a"
        "ccelerators', 'tag_specifications', 'launch_template', 'instance_market_options', 'credit_specification', 'cpu"
        "_options', 'capacity_reservation_specification', 'hibernation_options', 'license_specifications', 'metadata_op"
        "tions', 'enclave_options', 'private_dns_name_options', 'maintenance_options', 'disable_api_stop', 'enable_prim"
        "ary_ipv6', 'network_performance_options', 'operator', 'dry_run', 'disable_api_termination', 'instance_initiate"
        "d_shutdown_behavior', 'private_ip_address', 'client_token', 'additional_info', 'network_interfaces', 'iam_inst"
        "ance_profile', 'ebs_optimized')), EqPlan(fields=('block_device_mappings', 'image_id', 'instance_type', 'ipv6_a"
        "ddress_count', 'ipv6_addresses', 'kernel_id', 'key_name', 'max_count', 'min_count', 'monitoring', 'placement',"
        " 'ramdisk_id', 'security_group_ids', 'security_groups', 'subnet_id', 'user_data', 'elastic_gpu_specification',"
        " 'elastic_inference_accelerators', 'tag_specifications', 'launch_template', 'instance_market_options', 'credit"
        "_specification', 'cpu_options', 'capacity_reservation_specification', 'hibernation_options', 'license_specific"
        "ations', 'metadata_options', 'enclave_options', 'private_dns_name_options', 'maintenance_options', 'disable_ap"
        "i_stop', 'enable_primary_ipv6', 'network_performance_options', 'operator', 'dry_run', 'disable_api_termination"
        "', 'instance_initiated_shutdown_behavior', 'private_ip_address', 'client_token', 'additional_info', 'network_i"
        "nterfaces', 'iam_instance_profile', 'ebs_optimized')), FrozenPlan(fields=('__shape__', 'block_device_mappings'"
        ", 'image_id', 'instance_type', 'ipv6_address_count', 'ipv6_addresses', 'kernel_id', 'key_name', 'max_count', '"
        "min_count', 'monitoring', 'placement', 'ramdisk_id', 'security_group_ids', 'security_groups', 'subnet_id', 'us"
        "er_data', 'elastic_gpu_specification', 'elastic_inference_accelerators', 'tag_specifications', 'launch_templat"
        "e', 'instance_market_options', 'credit_specification', 'cpu_options', 'capacity_reservation_specification', 'h"
        "ibernation_options', 'license_specifications', 'metadata_options', 'enclave_options', 'private_dns_name_option"
        "s', 'maintenance_options', 'disable_api_stop', 'enable_primary_ipv6', 'network_performance_options', 'operator"
        "', 'dry_run', 'disable_api_termination', 'instance_initiated_shutdown_behavior', 'private_ip_address', 'client"
        "_token', 'additional_info', 'network_interfaces', 'iam_instance_profile', 'ebs_optimized'), allow_dynamic_dund"
        "er_attrs=False), HashPlan(action='add', fields=('block_device_mappings', 'image_id', 'instance_type', 'ipv6_ad"
        "dress_count', 'ipv6_addresses', 'kernel_id', 'key_name', 'max_count', 'min_count', 'monitoring', 'placement', "
        "'ramdisk_id', 'security_group_ids', 'security_groups', 'subnet_id', 'user_data', 'elastic_gpu_specification', "
        "'elastic_inference_accelerators', 'tag_specifications', 'launch_template', 'instance_market_options', 'credit_"
        "specification', 'cpu_options', 'capacity_reservation_specification', 'hibernation_options', 'license_specifica"
        "tions', 'metadata_options', 'enclave_options', 'private_dns_name_options', 'maintenance_options', 'disable_api"
        "_stop', 'enable_primary_ipv6', 'network_performance_options', 'operator', 'dry_run', 'disable_api_termination'"
        ", 'instance_initiated_shutdown_behavior', 'private_ip_address', 'client_token', 'additional_info', 'network_in"
        "terfaces', 'iam_instance_profile', 'ebs_optimized'), cache=False), InitPlan(fields=(InitPlan.Field(name='__sha"
        "pe__', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overr"
        "ide=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "block_device_mappings', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='image_id', annotation=OpRef(name='init.fields.2.annotation'), d"
        "efault=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_type', annotation=Op"
        "Ref(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init="
        "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
        "eld(name='ipv6_address_count', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fie"
        "lds.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='ipv6_addresses', annotation=OpRef(name='init.fields.5.an"
        "notation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, fiel"
        "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='kernel_id', anno"
        "tation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='key_name', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fiel"
        "ds.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
        "alidate=None, check_type=None), InitPlan.Field(name='max_count', annotation=OpRef(name='init.fields.8.annotati"
        "on'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
        "e, validate=None, check_type=None), InitPlan.Field(name='min_count', annotation=OpRef(name='init.fields.9.anno"
        "tation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
        "=None, validate=None, check_type=None), InitPlan.Field(name='monitoring', annotation=OpRef(name='init.fields.1"
        "0.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='placement',"
        " annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='ramdisk_id', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name="
        "'init.fields.12.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='security_group_ids', annotation=OpRef(name='in"
        "it.fields.13.annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, over"
        "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "security_groups', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='subnet_id', annotation=OpRef(name='init.fields.15.annotation'), def"
        "ault=OpRef(name='init.fields.15.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
        "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='user_data', annotation=OpRef(n"
        "ame='init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=Tru"
        "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
        "(name='elastic_gpu_specification', annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='ini"
        "t.fields.17.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='elastic_inference_accelerators', annotation=OpRef("
        "name='init.fields.18.annotation'), default=OpRef(name='init.fields.18.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='tag_specifications', annotation=OpRef(name='init.fields.19.annotation'), default=OpRef(name='init.fiel"
        "ds.19.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='launch_template', annotation=OpRef(name='init.fields.20."
        "annotation'), default=OpRef(name='init.fields.20.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_mark"
        "et_options', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='init.fields.21.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None), InitPlan.Field(name='credit_specification', annotation=OpRef(name='init.fields.22.annotation'"
        "), default=OpRef(name='init.fields.22.default'), default_factory=None, init=True, override=False, field_type=F"
        "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cpu_options', annotation"
        "=OpRef(name='init.fields.23.annotation'), default=OpRef(name='init.fields.23.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='capacity_reservation_specification', annotation=OpRef(name='init.fields.24.annotation'), defaul"
        "t=OpRef(name='init.fields.24.default'), default_factory=None, init=True, override=False, field_type=FieldType."
        "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='hibernation_options', annotation="
        "OpRef(name='init.fields.25.annotation'), default=OpRef(name='init.fields.25.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='license_specifications', annotation=OpRef(name='init.fields.26.annotation'), default=OpRef(name="
        "'init.fields.26.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None), InitPlan.Field(name='metadata_options', annotation=OpRef(name='init"
        ".fields.27.annotation'), default=OpRef(name='init.fields.27.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='en"
        "clave_options', annotation=OpRef(name='init.fields.28.annotation'), default=OpRef(name='init.fields.28.default"
        "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
        ", check_type=None), InitPlan.Field(name='private_dns_name_options', annotation=OpRef(name='init.fields.29.anno"
        "tation'), default=OpRef(name='init.fields.29.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='maintenance_optio"
        "ns', annotation=OpRef(name='init.fields.30.annotation'), default=OpRef(name='init.fields.30.default'), default"
        "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='disable_api_stop', annotation=OpRef(name='init.fields.31.annotation'), default=O"
        "pRef(name='init.fields.31.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
        "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='enable_primary_ipv6', annotation=OpR"
        "ef(name='init.fields.32.annotation'), default=OpRef(name='init.fields.32.default'), default_factory=None, init"
        "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
        "ield(name='network_performance_options', annotation=OpRef(name='init.fields.33.annotation'), default=OpRef(nam"
        "e='init.fields.33.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
        "oerce=None, validate=None, check_type=None), InitPlan.Field(name='operator', annotation=OpRef(name='init.field"
        "s.34.annotation'), default=OpRef(name='init.fields.34.default'), default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run'"
        ", annotation=OpRef(name='init.fields.35.annotation'), default=OpRef(name='init.fields.35.default'), default_fa"
        "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
        "one), InitPlan.Field(name='disable_api_termination', annotation=OpRef(name='init.fields.36.annotation'), defau"
        "lt=OpRef(name='init.fields.36.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_initiated_shutdown_beha"
        "vior', annotation=OpRef(name='init.fields.37.annotation'), default=OpRef(name='init.fields.37.default'), defau"
        "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
        "ype=None), InitPlan.Field(name='private_ip_address', annotation=OpRef(name='init.fields.38.annotation'), defau"
        "lt=OpRef(name='init.fields.38.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='client_token', annotation=OpRef("
        "name='init.fields.39.annotation'), default=OpRef(name='init.fields.39.default'), default_factory=None, init=Tr"
        "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
        "d(name='additional_info', annotation=OpRef(name='init.fields.40.annotation'), default=OpRef(name='init.fields."
        "40.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
        "idate=None, check_type=None), InitPlan.Field(name='network_interfaces', annotation=OpRef(name='init.fields.41."
        "annotation'), default=OpRef(name='init.fields.41.default'), default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='iam_instance_"
        "profile', annotation=OpRef(name='init.fields.42.annotation'), default=OpRef(name='init.fields.42.default'), de"
        "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
        "k_type=None), InitPlan.Field(name='ebs_optimized', annotation=OpRef(name='init.fields.43.annotation'), default"
        "=OpRef(name='init.fields.43.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
        "NSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('blo"
        "ck_device_mappings', 'image_id', 'instance_type', 'ipv6_address_count', 'ipv6_addresses', 'kernel_id', 'key_na"
        "me', 'max_count', 'min_count', 'monitoring', 'placement', 'ramdisk_id', 'security_group_ids', 'security_groups"
        "', 'subnet_id', 'user_data', 'elastic_gpu_specification', 'elastic_inference_accelerators', 'tag_specification"
        "s', 'launch_template', 'instance_market_options', 'credit_specification', 'cpu_options', 'capacity_reservation"
        "_specification', 'hibernation_options', 'license_specifications', 'metadata_options', 'enclave_options', 'priv"
        "ate_dns_name_options', 'maintenance_options', 'disable_api_stop', 'enable_primary_ipv6', 'network_performance_"
        "options', 'operator', 'dry_run', 'disable_api_termination', 'instance_initiated_shutdown_behavior', 'private_i"
        "p_address', 'client_token', 'additional_info', 'network_interfaces', 'iam_instance_profile', 'ebs_optimized'),"
        " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Fie"
        "ld(name='block_device_mappings', kw_only=True, fn=None), ReprPlan.Field(name='image_id', kw_only=True, fn=None"
        "), ReprPlan.Field(name='instance_type', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_address_count', kw_o"
        "nly=True, fn=None), ReprPlan.Field(name='ipv6_addresses', kw_only=True, fn=None), ReprPlan.Field(name='kernel_"
        "id', kw_only=True, fn=None), ReprPlan.Field(name='key_name', kw_only=True, fn=None), ReprPlan.Field(name='max_"
        "count', kw_only=True, fn=None), ReprPlan.Field(name='min_count', kw_only=True, fn=None), ReprPlan.Field(name='"
        "monitoring', kw_only=True, fn=None), ReprPlan.Field(name='placement', kw_only=True, fn=None), ReprPlan.Field(n"
        "ame='ramdisk_id', kw_only=True, fn=None), ReprPlan.Field(name='security_group_ids', kw_only=True, fn=None), Re"
        "prPlan.Field(name='security_groups', kw_only=True, fn=None), ReprPlan.Field(name='subnet_id', kw_only=True, fn"
        "=None), ReprPlan.Field(name='user_data', kw_only=True, fn=None), ReprPlan.Field(name='elastic_gpu_specificatio"
        "n', kw_only=True, fn=None), ReprPlan.Field(name='elastic_inference_accelerators', kw_only=True, fn=None), Repr"
        "Plan.Field(name='tag_specifications', kw_only=True, fn=None), ReprPlan.Field(name='launch_template', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='instance_market_options', kw_only=True, fn=None), ReprPlan.Field(name='cre"
        "dit_specification', kw_only=True, fn=None), ReprPlan.Field(name='cpu_options', kw_only=True, fn=None), ReprPla"
        "n.Field(name='capacity_reservation_specification', kw_only=True, fn=None), ReprPlan.Field(name='hibernation_op"
        "tions', kw_only=True, fn=None), ReprPlan.Field(name='license_specifications', kw_only=True, fn=None), ReprPlan"
        ".Field(name='metadata_options', kw_only=True, fn=None), ReprPlan.Field(name='enclave_options', kw_only=True, f"
        "n=None), ReprPlan.Field(name='private_dns_name_options', kw_only=True, fn=None), ReprPlan.Field(name='maintena"
        "nce_options', kw_only=True, fn=None), ReprPlan.Field(name='disable_api_stop', kw_only=True, fn=None), ReprPlan"
        ".Field(name='enable_primary_ipv6', kw_only=True, fn=None), ReprPlan.Field(name='network_performance_options', "
        "kw_only=True, fn=None), ReprPlan.Field(name='operator', kw_only=True, fn=None), ReprPlan.Field(name='dry_run',"
        " kw_only=True, fn=None), ReprPlan.Field(name='disable_api_termination', kw_only=True, fn=None), ReprPlan.Field"
        "(name='instance_initiated_shutdown_behavior', kw_only=True, fn=None), ReprPlan.Field(name='private_ip_address'"
        ", kw_only=True, fn=None), ReprPlan.Field(name='client_token', kw_only=True, fn=None), ReprPlan.Field(name='add"
        "itional_info', kw_only=True, fn=None), ReprPlan.Field(name='network_interfaces', kw_only=True, fn=None), ReprP"
        "lan.Field(name='iam_instance_profile', kw_only=True, fn=None), ReprPlan.Field(name='ebs_optimized', kw_only=Tr"
        "ue, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='38db1e6f17b46debfe1fe98a6634a87377979b95',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__24__annotation',
        '__dataclass__init__fields__24__default',
        '__dataclass__init__fields__25__annotation',
        '__dataclass__init__fields__25__default',
        '__dataclass__init__fields__26__annotation',
        '__dataclass__init__fields__26__default',
        '__dataclass__init__fields__27__annotation',
        '__dataclass__init__fields__27__default',
        '__dataclass__init__fields__28__annotation',
        '__dataclass__init__fields__28__default',
        '__dataclass__init__fields__29__annotation',
        '__dataclass__init__fields__29__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__30__annotation',
        '__dataclass__init__fields__30__default',
        '__dataclass__init__fields__31__annotation',
        '__dataclass__init__fields__31__default',
        '__dataclass__init__fields__32__annotation',
        '__dataclass__init__fields__32__default',
        '__dataclass__init__fields__33__annotation',
        '__dataclass__init__fields__33__default',
        '__dataclass__init__fields__34__annotation',
        '__dataclass__init__fields__34__default',
        '__dataclass__init__fields__35__annotation',
        '__dataclass__init__fields__35__default',
        '__dataclass__init__fields__36__annotation',
        '__dataclass__init__fields__36__default',
        '__dataclass__init__fields__37__annotation',
        '__dataclass__init__fields__37__default',
        '__dataclass__init__fields__38__annotation',
        '__dataclass__init__fields__38__default',
        '__dataclass__init__fields__39__annotation',
        '__dataclass__init__fields__39__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__40__annotation',
        '__dataclass__init__fields__40__default',
        '__dataclass__init__fields__41__annotation',
        '__dataclass__init__fields__41__default',
        '__dataclass__init__fields__42__annotation',
        '__dataclass__init__fields__42__default',
        '__dataclass__init__fields__43__annotation',
        '__dataclass__init__fields__43__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__9__annotation',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'RunInstancesRequest'),
    ),
)
def _process_dataclass__38db1e6f17b46debfe1fe98a6634a87377979b95():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__24__annotation,
        __dataclass__init__fields__24__default,
        __dataclass__init__fields__25__annotation,
        __dataclass__init__fields__25__default,
        __dataclass__init__fields__26__annotation,
        __dataclass__init__fields__26__default,
        __dataclass__init__fields__27__annotation,
        __dataclass__init__fields__27__default,
        __dataclass__init__fields__28__annotation,
        __dataclass__init__fields__28__default,
        __dataclass__init__fields__29__annotation,
        __dataclass__init__fields__29__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__30__annotation,
        __dataclass__init__fields__30__default,
        __dataclass__init__fields__31__annotation,
        __dataclass__init__fields__31__default,
        __dataclass__init__fields__32__annotation,
        __dataclass__init__fields__32__default,
        __dataclass__init__fields__33__annotation,
        __dataclass__init__fields__33__default,
        __dataclass__init__fields__34__annotation,
        __dataclass__init__fields__34__default,
        __dataclass__init__fields__35__annotation,
        __dataclass__init__fields__35__default,
        __dataclass__init__fields__36__annotation,
        __dataclass__init__fields__36__default,
        __dataclass__init__fields__37__annotation,
        __dataclass__init__fields__37__default,
        __dataclass__init__fields__38__annotation,
        __dataclass__init__fields__38__default,
        __dataclass__init__fields__39__annotation,
        __dataclass__init__fields__39__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__40__annotation,
        __dataclass__init__fields__40__default,
        __dataclass__init__fields__41__annotation,
        __dataclass__init__fields__41__default,
        __dataclass__init__fields__42__annotation,
        __dataclass__init__fields__42__default,
        __dataclass__init__fields__43__annotation,
        __dataclass__init__fields__43__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__9__annotation,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                block_device_mappings=self.block_device_mappings,
                image_id=self.image_id,
                instance_type=self.instance_type,
                ipv6_address_count=self.ipv6_address_count,
                ipv6_addresses=self.ipv6_addresses,
                kernel_id=self.kernel_id,
                key_name=self.key_name,
                max_count=self.max_count,
                min_count=self.min_count,
                monitoring=self.monitoring,
                placement=self.placement,
                ramdisk_id=self.ramdisk_id,
                security_group_ids=self.security_group_ids,
                security_groups=self.security_groups,
                subnet_id=self.subnet_id,
                user_data=self.user_data,
                elastic_gpu_specification=self.elastic_gpu_specification,
                elastic_inference_accelerators=self.elastic_inference_accelerators,
                tag_specifications=self.tag_specifications,
                launch_template=self.launch_template,
                instance_market_options=self.instance_market_options,
                credit_specification=self.credit_specification,
                cpu_options=self.cpu_options,
                capacity_reservation_specification=self.capacity_reservation_specification,
                hibernation_options=self.hibernation_options,
                license_specifications=self.license_specifications,
                metadata_options=self.metadata_options,
                enclave_options=self.enclave_options,
                private_dns_name_options=self.private_dns_name_options,
                maintenance_options=self.maintenance_options,
                disable_api_stop=self.disable_api_stop,
                enable_primary_ipv6=self.enable_primary_ipv6,
                network_performance_options=self.network_performance_options,
                operator=self.operator,
                dry_run=self.dry_run,
                disable_api_termination=self.disable_api_termination,
                instance_initiated_shutdown_behavior=self.instance_initiated_shutdown_behavior,
                private_ip_address=self.private_ip_address,
                client_token=self.client_token,
                additional_info=self.additional_info,
                network_interfaces=self.network_interfaces,
                iam_instance_profile=self.iam_instance_profile,
                ebs_optimized=self.ebs_optimized,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.block_device_mappings == other.block_device_mappings and
                self.image_id == other.image_id and
                self.instance_type == other.instance_type and
                self.ipv6_address_count == other.ipv6_address_count and
                self.ipv6_addresses == other.ipv6_addresses and
                self.kernel_id == other.kernel_id and
                self.key_name == other.key_name and
                self.max_count == other.max_count and
                self.min_count == other.min_count and
                self.monitoring == other.monitoring and
                self.placement == other.placement and
                self.ramdisk_id == other.ramdisk_id and
                self.security_group_ids == other.security_group_ids and
                self.security_groups == other.security_groups and
                self.subnet_id == other.subnet_id and
                self.user_data == other.user_data and
                self.elastic_gpu_specification == other.elastic_gpu_specification and
                self.elastic_inference_accelerators == other.elastic_inference_accelerators and
                self.tag_specifications == other.tag_specifications and
                self.launch_template == other.launch_template and
                self.instance_market_options == other.instance_market_options and
                self.credit_specification == other.credit_specification and
                self.cpu_options == other.cpu_options and
                self.capacity_reservation_specification == other.capacity_reservation_specification and
                self.hibernation_options == other.hibernation_options and
                self.license_specifications == other.license_specifications and
                self.metadata_options == other.metadata_options and
                self.enclave_options == other.enclave_options and
                self.private_dns_name_options == other.private_dns_name_options and
                self.maintenance_options == other.maintenance_options and
                self.disable_api_stop == other.disable_api_stop and
                self.enable_primary_ipv6 == other.enable_primary_ipv6 and
                self.network_performance_options == other.network_performance_options and
                self.operator == other.operator and
                self.dry_run == other.dry_run and
                self.disable_api_termination == other.disable_api_termination and
                self.instance_initiated_shutdown_behavior == other.instance_initiated_shutdown_behavior and
                self.private_ip_address == other.private_ip_address and
                self.client_token == other.client_token and
                self.additional_info == other.additional_info and
                self.network_interfaces == other.network_interfaces and
                self.iam_instance_profile == other.iam_instance_profile and
                self.ebs_optimized == other.ebs_optimized
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'block_device_mappings',
            'image_id',
            'instance_type',
            'ipv6_address_count',
            'ipv6_addresses',
            'kernel_id',
            'key_name',
            'max_count',
            'min_count',
            'monitoring',
            'placement',
            'ramdisk_id',
            'security_group_ids',
            'security_groups',
            'subnet_id',
            'user_data',
            'elastic_gpu_specification',
            'elastic_inference_accelerators',
            'tag_specifications',
            'launch_template',
            'instance_market_options',
            'credit_specification',
            'cpu_options',
            'capacity_reservation_specification',
            'hibernation_options',
            'license_specifications',
            'metadata_options',
            'enclave_options',
            'private_dns_name_options',
            'maintenance_options',
            'disable_api_stop',
            'enable_primary_ipv6',
            'network_performance_options',
            'operator',
            'dry_run',
            'disable_api_termination',
            'instance_initiated_shutdown_behavior',
            'private_ip_address',
            'client_token',
            'additional_info',
            'network_interfaces',
            'iam_instance_profile',
            'ebs_optimized',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'block_device_mappings',
            'image_id',
            'instance_type',
            'ipv6_address_count',
            'ipv6_addresses',
            'kernel_id',
            'key_name',
            'max_count',
            'min_count',
            'monitoring',
            'placement',
            'ramdisk_id',
            'security_group_ids',
            'security_groups',
            'subnet_id',
            'user_data',
            'elastic_gpu_specification',
            'elastic_inference_accelerators',
            'tag_specifications',
            'launch_template',
            'instance_market_options',
            'credit_specification',
            'cpu_options',
            'capacity_reservation_specification',
            'hibernation_options',
            'license_specifications',
            'metadata_options',
            'enclave_options',
            'private_dns_name_options',
            'maintenance_options',
            'disable_api_stop',
            'enable_primary_ipv6',
            'network_performance_options',
            'operator',
            'dry_run',
            'disable_api_termination',
            'instance_initiated_shutdown_behavior',
            'private_ip_address',
            'client_token',
            'additional_info',
            'network_interfaces',
            'iam_instance_profile',
            'ebs_optimized',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.block_device_mappings,
                self.image_id,
                self.instance_type,
                self.ipv6_address_count,
                self.ipv6_addresses,
                self.kernel_id,
                self.key_name,
                self.max_count,
                self.min_count,
                self.monitoring,
                self.placement,
                self.ramdisk_id,
                self.security_group_ids,
                self.security_groups,
                self.subnet_id,
                self.user_data,
                self.elastic_gpu_specification,
                self.elastic_inference_accelerators,
                self.tag_specifications,
                self.launch_template,
                self.instance_market_options,
                self.credit_specification,
                self.cpu_options,
                self.capacity_reservation_specification,
                self.hibernation_options,
                self.license_specifications,
                self.metadata_options,
                self.enclave_options,
                self.private_dns_name_options,
                self.maintenance_options,
                self.disable_api_stop,
                self.enable_primary_ipv6,
                self.network_performance_options,
                self.operator,
                self.dry_run,
                self.disable_api_termination,
                self.instance_initiated_shutdown_behavior,
                self.private_ip_address,
                self.client_token,
                self.additional_info,
                self.network_interfaces,
                self.iam_instance_profile,
                self.ebs_optimized,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            block_device_mappings: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            image_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            instance_type: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            ipv6_address_count: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            ipv6_addresses: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            kernel_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            key_name: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            max_count: __dataclass__init__fields__8__annotation,
            min_count: __dataclass__init__fields__9__annotation,
            monitoring: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            placement: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            ramdisk_id: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            security_group_ids: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            security_groups: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            subnet_id: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            user_data: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            elastic_gpu_specification: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            elastic_inference_accelerators: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            tag_specifications: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            launch_template: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            instance_market_options: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            credit_specification: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            cpu_options: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
            capacity_reservation_specification: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
            hibernation_options: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
            license_specifications: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
            metadata_options: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
            enclave_options: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
            private_dns_name_options: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
            maintenance_options: __dataclass__init__fields__30__annotation = __dataclass__init__fields__30__default,
            disable_api_stop: __dataclass__init__fields__31__annotation = __dataclass__init__fields__31__default,
            enable_primary_ipv6: __dataclass__init__fields__32__annotation = __dataclass__init__fields__32__default,
            network_performance_options: __dataclass__init__fields__33__annotation = __dataclass__init__fields__33__default,
            operator: __dataclass__init__fields__34__annotation = __dataclass__init__fields__34__default,
            dry_run: __dataclass__init__fields__35__annotation = __dataclass__init__fields__35__default,
            disable_api_termination: __dataclass__init__fields__36__annotation = __dataclass__init__fields__36__default,
            instance_initiated_shutdown_behavior: __dataclass__init__fields__37__annotation = __dataclass__init__fields__37__default,
            private_ip_address: __dataclass__init__fields__38__annotation = __dataclass__init__fields__38__default,
            client_token: __dataclass__init__fields__39__annotation = __dataclass__init__fields__39__default,
            additional_info: __dataclass__init__fields__40__annotation = __dataclass__init__fields__40__default,
            network_interfaces: __dataclass__init__fields__41__annotation = __dataclass__init__fields__41__default,
            iam_instance_profile: __dataclass__init__fields__42__annotation = __dataclass__init__fields__42__default,
            ebs_optimized: __dataclass__init__fields__43__annotation = __dataclass__init__fields__43__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'block_device_mappings', block_device_mappings)
            __dataclass__object_setattr(self, 'image_id', image_id)
            __dataclass__object_setattr(self, 'instance_type', instance_type)
            __dataclass__object_setattr(self, 'ipv6_address_count', ipv6_address_count)
            __dataclass__object_setattr(self, 'ipv6_addresses', ipv6_addresses)
            __dataclass__object_setattr(self, 'kernel_id', kernel_id)
            __dataclass__object_setattr(self, 'key_name', key_name)
            __dataclass__object_setattr(self, 'max_count', max_count)
            __dataclass__object_setattr(self, 'min_count', min_count)
            __dataclass__object_setattr(self, 'monitoring', monitoring)
            __dataclass__object_setattr(self, 'placement', placement)
            __dataclass__object_setattr(self, 'ramdisk_id', ramdisk_id)
            __dataclass__object_setattr(self, 'security_group_ids', security_group_ids)
            __dataclass__object_setattr(self, 'security_groups', security_groups)
            __dataclass__object_setattr(self, 'subnet_id', subnet_id)
            __dataclass__object_setattr(self, 'user_data', user_data)
            __dataclass__object_setattr(self, 'elastic_gpu_specification', elastic_gpu_specification)
            __dataclass__object_setattr(self, 'elastic_inference_accelerators', elastic_inference_accelerators)
            __dataclass__object_setattr(self, 'tag_specifications', tag_specifications)
            __dataclass__object_setattr(self, 'launch_template', launch_template)
            __dataclass__object_setattr(self, 'instance_market_options', instance_market_options)
            __dataclass__object_setattr(self, 'credit_specification', credit_specification)
            __dataclass__object_setattr(self, 'cpu_options', cpu_options)
            __dataclass__object_setattr(self, 'capacity_reservation_specification', capacity_reservation_specification)
            __dataclass__object_setattr(self, 'hibernation_options', hibernation_options)
            __dataclass__object_setattr(self, 'license_specifications', license_specifications)
            __dataclass__object_setattr(self, 'metadata_options', metadata_options)
            __dataclass__object_setattr(self, 'enclave_options', enclave_options)
            __dataclass__object_setattr(self, 'private_dns_name_options', private_dns_name_options)
            __dataclass__object_setattr(self, 'maintenance_options', maintenance_options)
            __dataclass__object_setattr(self, 'disable_api_stop', disable_api_stop)
            __dataclass__object_setattr(self, 'enable_primary_ipv6', enable_primary_ipv6)
            __dataclass__object_setattr(self, 'network_performance_options', network_performance_options)
            __dataclass__object_setattr(self, 'operator', operator)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'disable_api_termination', disable_api_termination)
            __dataclass__object_setattr(self, 'instance_initiated_shutdown_behavior', instance_initiated_shutdown_behavior)
            __dataclass__object_setattr(self, 'private_ip_address', private_ip_address)
            __dataclass__object_setattr(self, 'client_token', client_token)
            __dataclass__object_setattr(self, 'additional_info', additional_info)
            __dataclass__object_setattr(self, 'network_interfaces', network_interfaces)
            __dataclass__object_setattr(self, 'iam_instance_profile', iam_instance_profile)
            __dataclass__object_setattr(self, 'ebs_optimized', ebs_optimized)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"block_device_mappings={self.block_device_mappings!r}")
            parts.append(f"image_id={self.image_id!r}")
            parts.append(f"instance_type={self.instance_type!r}")
            parts.append(f"ipv6_address_count={self.ipv6_address_count!r}")
            parts.append(f"ipv6_addresses={self.ipv6_addresses!r}")
            parts.append(f"kernel_id={self.kernel_id!r}")
            parts.append(f"key_name={self.key_name!r}")
            parts.append(f"max_count={self.max_count!r}")
            parts.append(f"min_count={self.min_count!r}")
            parts.append(f"monitoring={self.monitoring!r}")
            parts.append(f"placement={self.placement!r}")
            parts.append(f"ramdisk_id={self.ramdisk_id!r}")
            parts.append(f"security_group_ids={self.security_group_ids!r}")
            parts.append(f"security_groups={self.security_groups!r}")
            parts.append(f"subnet_id={self.subnet_id!r}")
            parts.append(f"user_data={self.user_data!r}")
            parts.append(f"elastic_gpu_specification={self.elastic_gpu_specification!r}")
            parts.append(f"elastic_inference_accelerators={self.elastic_inference_accelerators!r}")
            parts.append(f"tag_specifications={self.tag_specifications!r}")
            parts.append(f"launch_template={self.launch_template!r}")
            parts.append(f"instance_market_options={self.instance_market_options!r}")
            parts.append(f"credit_specification={self.credit_specification!r}")
            parts.append(f"cpu_options={self.cpu_options!r}")
            parts.append(f"capacity_reservation_specification={self.capacity_reservation_specification!r}")
            parts.append(f"hibernation_options={self.hibernation_options!r}")
            parts.append(f"license_specifications={self.license_specifications!r}")
            parts.append(f"metadata_options={self.metadata_options!r}")
            parts.append(f"enclave_options={self.enclave_options!r}")
            parts.append(f"private_dns_name_options={self.private_dns_name_options!r}")
            parts.append(f"maintenance_options={self.maintenance_options!r}")
            parts.append(f"disable_api_stop={self.disable_api_stop!r}")
            parts.append(f"enable_primary_ipv6={self.enable_primary_ipv6!r}")
            parts.append(f"network_performance_options={self.network_performance_options!r}")
            parts.append(f"operator={self.operator!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"disable_api_termination={self.disable_api_termination!r}")
            parts.append(f"instance_initiated_shutdown_behavior={self.instance_initiated_shutdown_behavior!r}")
            parts.append(f"private_ip_address={self.private_ip_address!r}")
            parts.append(f"client_token={self.client_token!r}")
            parts.append(f"additional_info={self.additional_info!r}")
            parts.append(f"network_interfaces={self.network_interfaces!r}")
            parts.append(f"iam_instance_profile={self.iam_instance_profile!r}")
            parts.append(f"ebs_optimized={self.ebs_optimized!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('group_id', 'ip_permissions_egress', 'tags', 'vpc_id', 'security_group_arn', 'owne"
        "r_id', 'group_name', 'description', 'ip_permissions')), EqPlan(fields=('group_id', 'ip_permissions_egress', 't"
        "ags', 'vpc_id', 'security_group_arn', 'owner_id', 'group_name', 'description', 'ip_permissions')), FrozenPlan("
        "fields=('__shape__', 'group_id', 'ip_permissions_egress', 'tags', 'vpc_id', 'security_group_arn', 'owner_id', "
        "'group_name', 'description', 'ip_permissions'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fiel"
        "ds=('group_id', 'ip_permissions_egress', 'tags', 'vpc_id', 'security_group_arn', 'owner_id', 'group_name', 'de"
        "scription', 'ip_permissions'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRe"
        "f(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type="
        "FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_id', annotation="
        "OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='ip_permissions_egress', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='ini"
        "t.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
        "one, validate=None, check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='init.fields.3.annotat"
        "ion'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_id', annotation=O"
        "pRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init"
        "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
        "ield(name='security_group_arn', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fi"
        "elds.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='owner_id', annotation=OpRef(name='init.fields.6.annotat"
        "ion'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_name', annotati"
        "on=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, "
        "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
        "an.Field(name='description', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.field"
        "s.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='ip_permissions', annotation=OpRef(name='init.fields.9.anno"
        "tation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_"
        "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_o"
        "nly_params=('group_id', 'ip_permissions_egress', 'tags', 'vpc_id', 'security_group_arn', 'owner_id', 'group_na"
        "me', 'description', 'ip_permissions'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_"
        "fns=()), ReprPlan(fields=(ReprPlan.Field(name='group_id', kw_only=True, fn=None), ReprPlan.Field(name='ip_perm"
        "issions_egress', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=True, fn=None), ReprPlan.Field(na"
        "me='vpc_id', kw_only=True, fn=None), ReprPlan.Field(name='security_group_arn', kw_only=True, fn=None), ReprPla"
        "n.Field(name='owner_id', kw_only=True, fn=None), ReprPlan.Field(name='group_name', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='description', kw_only=True, fn=None), ReprPlan.Field(name='ip_permissions', kw_only=True, fn"
        "=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='6b96e533fe8f8ebd408827622def8123d5c1c9dc',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'SecurityGroup'),
    ),
)
def _process_dataclass__6b96e533fe8f8ebd408827622def8123d5c1c9dc():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                group_id=self.group_id,
                ip_permissions_egress=self.ip_permissions_egress,
                tags=self.tags,
                vpc_id=self.vpc_id,
                security_group_arn=self.security_group_arn,
                owner_id=self.owner_id,
                group_name=self.group_name,
                description=self.description,
                ip_permissions=self.ip_permissions,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.group_id == other.group_id and
                self.ip_permissions_egress == other.ip_permissions_egress and
                self.tags == other.tags and
                self.vpc_id == other.vpc_id and
                self.security_group_arn == other.security_group_arn and
                self.owner_id == other.owner_id and
                self.group_name == other.group_name and
                self.description == other.description and
                self.ip_permissions == other.ip_permissions
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'group_id',
            'ip_permissions_egress',
            'tags',
            'vpc_id',
            'security_group_arn',
            'owner_id',
            'group_name',
            'description',
            'ip_permissions',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'group_id',
            'ip_permissions_egress',
            'tags',
            'vpc_id',
            'security_group_arn',
            'owner_id',
            'group_name',
            'description',
            'ip_permissions',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.group_id,
                self.ip_permissions_egress,
                self.tags,
                self.vpc_id,
                self.security_group_arn,
                self.owner_id,
                self.group_name,
                self.description,
                self.ip_permissions,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            group_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            ip_permissions_egress: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            tags: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            vpc_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            security_group_arn: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            owner_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            group_name: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            description: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            ip_permissions: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'group_id', group_id)
            __dataclass__object_setattr(self, 'ip_permissions_egress', ip_permissions_egress)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'security_group_arn', security_group_arn)
            __dataclass__object_setattr(self, 'owner_id', owner_id)
            __dataclass__object_setattr(self, 'group_name', group_name)
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'ip_permissions', ip_permissions)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"group_id={self.group_id!r}")
            parts.append(f"ip_permissions_egress={self.ip_permissions_egress!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"security_group_arn={self.security_group_arn!r}")
            parts.append(f"owner_id={self.owner_id!r}")
            parts.append(f"group_name={self.group_name!r}")
            parts.append(f"description={self.description!r}")
            parts.append(f"ip_permissions={self.ip_permissions!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('max_price', 'spot_instance_type', 'block_duration_minutes', 'valid_until', 'insta"
        "nce_interruption_behavior')), EqPlan(fields=('max_price', 'spot_instance_type', 'block_duration_minutes', 'val"
        "id_until', 'instance_interruption_behavior')), FrozenPlan(fields=('__shape__', 'max_price', 'spot_instance_typ"
        "e', 'block_duration_minutes', 'valid_until', 'instance_interruption_behavior'), allow_dynamic_dunder_attrs=Fal"
        "se), HashPlan(action='add', fields=('max_price', 'spot_instance_type', 'block_duration_minutes', 'valid_until'"
        ", 'instance_interruption_behavior'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotatio"
        "n=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field"
        "_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_price', anno"
        "tation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='spot_instance_type', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name="
        "'init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
        "ce=None, validate=None, check_type=None), InitPlan.Field(name='block_duration_minutes', annotation=OpRef(name="
        "'init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
        "'valid_until', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'),"
        " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
        "heck_type=None), InitPlan.Field(name='instance_interruption_behavior', annotation=OpRef(name='init.fields.5.an"
        "notation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, fiel"
        "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw"
        "_only_params=('max_price', 'spot_instance_type', 'block_duration_minutes', 'valid_until', 'instance_interrupti"
        "on_behavior'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields"
        "=(ReprPlan.Field(name='max_price', kw_only=True, fn=None), ReprPlan.Field(name='spot_instance_type', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='block_duration_minutes', kw_only=True, fn=None), ReprPlan.Field(name='vali"
        "d_until', kw_only=True, fn=None), ReprPlan.Field(name='instance_interruption_behavior', kw_only=True, fn=None)"
        "), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='55e8d0b1f86c2e6ba251537033deded72da1e0b9',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'SpotMarketOptions'),
    ),
)
def _process_dataclass__55e8d0b1f86c2e6ba251537033deded72da1e0b9():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                max_price=self.max_price,
                spot_instance_type=self.spot_instance_type,
                block_duration_minutes=self.block_duration_minutes,
                valid_until=self.valid_until,
                instance_interruption_behavior=self.instance_interruption_behavior,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.max_price == other.max_price and
                self.spot_instance_type == other.spot_instance_type and
                self.block_duration_minutes == other.block_duration_minutes and
                self.valid_until == other.valid_until and
                self.instance_interruption_behavior == other.instance_interruption_behavior
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'max_price',
            'spot_instance_type',
            'block_duration_minutes',
            'valid_until',
            'instance_interruption_behavior',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'max_price',
            'spot_instance_type',
            'block_duration_minutes',
            'valid_until',
            'instance_interruption_behavior',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.max_price,
                self.spot_instance_type,
                self.block_duration_minutes,
                self.valid_until,
                self.instance_interruption_behavior,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            max_price: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            spot_instance_type: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            block_duration_minutes: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            valid_until: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            instance_interruption_behavior: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'max_price', max_price)
            __dataclass__object_setattr(self, 'spot_instance_type', spot_instance_type)
            __dataclass__object_setattr(self, 'block_duration_minutes', block_duration_minutes)
            __dataclass__object_setattr(self, 'valid_until', valid_until)
            __dataclass__object_setattr(self, 'instance_interruption_behavior', instance_interruption_behavior)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"max_price={self.max_price!r}")
            parts.append(f"spot_instance_type={self.spot_instance_type!r}")
            parts.append(f"block_duration_minutes={self.block_duration_minutes!r}")
            parts.append(f"valid_until={self.valid_until!r}")
            parts.append(f"instance_interruption_behavior={self.instance_interruption_behavior!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('instance_ids', 'additional_info', 'dry_run')), EqPlan(fields=('instance_ids', 'ad"
        "ditional_info', 'dry_run')), FrozenPlan(fields=('__shape__', 'instance_ids', 'additional_info', 'dry_run'), al"
        "low_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('instance_ids', 'additional_info', 'dry_run'),"
        " cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotati"
        "on'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='instance_ids', annotation=OpRef(name='init.fields.1."
        "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='additional_info', annotation=OpRef(name='init"
        ".fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override"
        "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_"
        "run', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None)), self_param='self', std_params=(), kw_only_params=('instance_ids', 'additional_info', 'dry_run'), froz"
        "en=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(na"
        "me='instance_ids', kw_only=True, fn=None), ReprPlan.Field(name='additional_info', kw_only=True, fn=None), Repr"
        "Plan.Field(name='dry_run', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='3c289e0fbc4af42ddd56e4a3c5ca5d6381a09a3e',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'StartInstancesRequest'),
    ),
)
def _process_dataclass__3c289e0fbc4af42ddd56e4a3c5ca5d6381a09a3e():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                instance_ids=self.instance_ids,
                additional_info=self.additional_info,
                dry_run=self.dry_run,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.instance_ids == other.instance_ids and
                self.additional_info == other.additional_info and
                self.dry_run == other.dry_run
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'additional_info',
            'dry_run',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'additional_info',
            'dry_run',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.instance_ids,
                self.additional_info,
                self.dry_run,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            instance_ids: __dataclass__init__fields__1__annotation,
            additional_info: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            dry_run: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'instance_ids', instance_ids)
            __dataclass__object_setattr(self, 'additional_info', additional_info)
            __dataclass__object_setattr(self, 'dry_run', dry_run)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"instance_ids={self.instance_ids!r}")
            parts.append(f"additional_info={self.additional_info!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('starting_instances',)), EqPlan(fields=('starting_instances',)), FrozenPlan(fields"
        "=('__shape__', 'starting_instances'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('start"
        "ing_instances',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init."
        "fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLA"
        "SS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='starting_instances', annotation=OpR"
        "ef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param="
        "'self', std_params=(), kw_only_params=('starting_instances',), frozen=True, slots=False, post_init_params=None"
        ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='starting_instances', kw_only=True, fn=N"
        "one),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='a4a751ef703aea92c31990370bde756df31b62dc',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'StartInstancesResult'),
    ),
)
def _process_dataclass__a4a751ef703aea92c31990370bde756df31b62dc():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                starting_instances=self.starting_instances,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.starting_instances == other.starting_instances
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'starting_instances',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'starting_instances',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.starting_instances,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            starting_instances: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'starting_instances', starting_instances)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"starting_instances={self.starting_instances!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('code', 'message')), EqPlan(fields=('code', 'message')), FrozenPlan(fields=('__sha"
        "pe__', 'code', 'message'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('code', 'message'"
        "), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annota"
        "tion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce="
        "None, validate=None, check_type=None), InitPlan.Field(name='code', annotation=OpRef(name='init.fields.1.annota"
        "tion'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='message', annotation"
        "=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_pa"
        "ram='self', std_params=(), kw_only_params=('code', 'message'), frozen=True, slots=False, post_init_params=None"
        ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='code', kw_only=True, fn=None), ReprPlan"
        ".Field(name='message', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='498779f0c9503dc1e5e39f1a2c431bda47dbae98',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'StateReason'),
    ),
)
def _process_dataclass__498779f0c9503dc1e5e39f1a2c431bda47dbae98():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                code=self.code,
                message=self.message,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.code == other.code and
                self.message == other.message
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'code',
            'message',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'code',
            'message',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.code,
                self.message,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            code: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'code', code)
            __dataclass__object_setattr(self, 'message', message)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"code={self.code!r}")
            parts.append(f"message={self.message!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('instance_ids', 'hibernate', 'skip_os_shutdown', 'dry_run', 'force')), EqPlan(fiel"
        "ds=('instance_ids', 'hibernate', 'skip_os_shutdown', 'dry_run', 'force')), FrozenPlan(fields=('__shape__', 'in"
        "stance_ids', 'hibernate', 'skip_os_shutdown', 'dry_run', 'force'), allow_dynamic_dunder_attrs=False), HashPlan"
        "(action='add', fields=('instance_ids', 'hibernate', 'skip_os_shutdown', 'dry_run', 'force'), cache=False), Ini"
        "tPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation'), default=None"
        ", default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None,"
        " check_type=None), InitPlan.Field(name='instance_ids', annotation=OpRef(name='init.fields.1.annotation'), defa"
        "ult=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='hibernate', annotation=OpRef(name='init.fields.2.annotation'), "
        "default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=Field"
        "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='skip_os_shutdown', annotatio"
        "n=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='dry_run', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='force', annotation=OpRef(name='init.fields.5.annotation'), defa"
        "ult=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('i"
        "nstance_ids', 'hibernate', 'skip_os_shutdown', 'dry_run', 'force'), frozen=True, slots=False, post_init_params"
        "=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='instance_ids', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='hibernate', kw_only=True, fn=None), ReprPlan.Field(name='skip_os_shutdown', kw_only="
        "True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None), ReprPlan.Field(name='force', kw_only=Tr"
        "ue, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='c3adac5db74dbc3a32afc8eb06cfdde4e0d7df27',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'StopInstancesRequest'),
    ),
)
def _process_dataclass__c3adac5db74dbc3a32afc8eb06cfdde4e0d7df27():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                instance_ids=self.instance_ids,
                hibernate=self.hibernate,
                skip_os_shutdown=self.skip_os_shutdown,
                dry_run=self.dry_run,
                force=self.force,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.instance_ids == other.instance_ids and
                self.hibernate == other.hibernate and
                self.skip_os_shutdown == other.skip_os_shutdown and
                self.dry_run == other.dry_run and
                self.force == other.force
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'hibernate',
            'skip_os_shutdown',
            'dry_run',
            'force',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'hibernate',
            'skip_os_shutdown',
            'dry_run',
            'force',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.instance_ids,
                self.hibernate,
                self.skip_os_shutdown,
                self.dry_run,
                self.force,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            instance_ids: __dataclass__init__fields__1__annotation,
            hibernate: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            skip_os_shutdown: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            dry_run: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            force: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'instance_ids', instance_ids)
            __dataclass__object_setattr(self, 'hibernate', hibernate)
            __dataclass__object_setattr(self, 'skip_os_shutdown', skip_os_shutdown)
            __dataclass__object_setattr(self, 'dry_run', dry_run)
            __dataclass__object_setattr(self, 'force', force)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"instance_ids={self.instance_ids!r}")
            parts.append(f"hibernate={self.hibernate!r}")
            parts.append(f"skip_os_shutdown={self.skip_os_shutdown!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            parts.append(f"force={self.force!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('stopping_instances',)), EqPlan(fields=('stopping_instances',)), FrozenPlan(fields"
        "=('__shape__', 'stopping_instances'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('stopp"
        "ing_instances',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init."
        "fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLA"
        "SS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='stopping_instances', annotation=OpR"
        "ef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param="
        "'self', std_params=(), kw_only_params=('stopping_instances',), frozen=True, slots=False, post_init_params=None"
        ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='stopping_instances', kw_only=True, fn=N"
        "one),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='e2d93455c9a1ab29f2896f8f9ffa88f634c68bc7',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'StopInstancesResult'),
    ),
)
def _process_dataclass__e2d93455c9a1ab29f2896f8f9ffa88f634c68bc7():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                stopping_instances=self.stopping_instances,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.stopping_instances == other.stopping_instances
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'stopping_instances',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'stopping_instances',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.stopping_instances,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            stopping_instances: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'stopping_instances', stopping_instances)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"stopping_instances={self.stopping_instances!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('availability_zone_id', 'enable_lni_at_device_index', 'map_customer_owned_ip_on_la"
        "unch', 'customer_owned_ipv4_pool', 'owner_id', 'assign_ipv6_address_on_creation', 'ipv6_cidr_block_association"
        "_set', 'tags', 'subnet_arn', 'outpost_arn', 'enable_dns64', 'ipv6_native', 'private_dns_name_options_on_launch"
        "', 'block_public_access_states', 'type', 'subnet_id', 'state', 'vpc_id', 'cidr_block', 'available_ip_address_c"
        "ount', 'availability_zone', 'default_for_az', 'map_public_ip_on_launch')), EqPlan(fields=('availability_zone_i"
        "d', 'enable_lni_at_device_index', 'map_customer_owned_ip_on_launch', 'customer_owned_ipv4_pool', 'owner_id', '"
        "assign_ipv6_address_on_creation', 'ipv6_cidr_block_association_set', 'tags', 'subnet_arn', 'outpost_arn', 'ena"
        "ble_dns64', 'ipv6_native', 'private_dns_name_options_on_launch', 'block_public_access_states', 'type', 'subnet"
        "_id', 'state', 'vpc_id', 'cidr_block', 'available_ip_address_count', 'availability_zone', 'default_for_az', 'm"
        "ap_public_ip_on_launch')), FrozenPlan(fields=('__shape__', 'availability_zone_id', 'enable_lni_at_device_index"
        "', 'map_customer_owned_ip_on_launch', 'customer_owned_ipv4_pool', 'owner_id', 'assign_ipv6_address_on_creation"
        "', 'ipv6_cidr_block_association_set', 'tags', 'subnet_arn', 'outpost_arn', 'enable_dns64', 'ipv6_native', 'pri"
        "vate_dns_name_options_on_launch', 'block_public_access_states', 'type', 'subnet_id', 'state', 'vpc_id', 'cidr_"
        "block', 'available_ip_address_count', 'availability_zone', 'default_for_az', 'map_public_ip_on_launch'), allow"
        "_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('availability_zone_id', 'enable_lni_at_device_ind"
        "ex', 'map_customer_owned_ip_on_launch', 'customer_owned_ipv4_pool', 'owner_id', 'assign_ipv6_address_on_creati"
        "on', 'ipv6_cidr_block_association_set', 'tags', 'subnet_arn', 'outpost_arn', 'enable_dns64', 'ipv6_native', 'p"
        "rivate_dns_name_options_on_launch', 'block_public_access_states', 'type', 'subnet_id', 'state', 'vpc_id', 'cid"
        "r_block', 'available_ip_address_count', 'availability_zone', 'default_for_az', 'map_public_ip_on_launch'), cac"
        "he=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotation')"
        ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=None, "
        "validate=None, check_type=None), InitPlan.Field(name='availability_zone_id', annotation=OpRef(name='init.field"
        "s.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False"
        ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='enable_lni"
        "_at_device_index', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='map_customer_owned_ip_on_launch', annotation=OpRef(name='init.fields"
        ".3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False,"
        " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='customer_ow"
        "ned_ipv4_pool', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default')"
        ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='owner_id', annotation=OpRef(name='init.fields.5.annotation'), default=O"
        "pRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='assign_ipv6_address_on_creation', ann"
        "otation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=N"
        "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
        "nitPlan.Field(name='ipv6_cidr_block_association_set', annotation=OpRef(name='init.fields.7.annotation'), defau"
        "lt=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType."
        "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='ini"
        "t.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='sub"
        "net_arn', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='outpost_arn', annotation=OpRef(name='init.fields.10.annotation'), default=OpR"
        "ef(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
        "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='enable_dns64', annotation=OpRef(name='"
        "init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True, ov"
        "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
        "='ipv6_native', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default"
        "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
        ", check_type=None), InitPlan.Field(name='private_dns_name_options_on_launch', annotation=OpRef(name='init.fiel"
        "ds.13.annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=Fa"
        "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='block_p"
        "ublic_access_states', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.d"
        "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
        "e=None, check_type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.15.annotation'), defa"
        "ult=OpRef(name='init.fields.15.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
        "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='subnet_id', annotation=OpRef(na"
        "me='init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='state', annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default')"
        ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fields.18.annotation'), default=Op"
        "Ref(name='init.fields.18.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cidr_block', annotation=OpRef(name='i"
        "nit.fields.19.annotation'), default=OpRef(name='init.fields.19.default'), default_factory=None, init=True, ove"
        "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
        "'available_ip_address_count', annotation=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.fie"
        "lds.20.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
        " validate=None, check_type=None), InitPlan.Field(name='availability_zone', annotation=OpRef(name='init.fields."
        "21.annotation'), default=OpRef(name='init.fields.21.default'), default_factory=None, init=True, override=False"
        ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='default_fo"
        "r_az', annotation=OpRef(name='init.fields.22.annotation'), default=OpRef(name='init.fields.22.default'), defau"
        "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
        "ype=None), InitPlan.Field(name='map_public_ip_on_launch', annotation=OpRef(name='init.fields.23.annotation'), "
        "default=OpRef(name='init.fields.23.default'), default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_param"
        "s=('availability_zone_id', 'enable_lni_at_device_index', 'map_customer_owned_ip_on_launch', 'customer_owned_ip"
        "v4_pool', 'owner_id', 'assign_ipv6_address_on_creation', 'ipv6_cidr_block_association_set', 'tags', 'subnet_ar"
        "n', 'outpost_arn', 'enable_dns64', 'ipv6_native', 'private_dns_name_options_on_launch', 'block_public_access_s"
        "tates', 'type', 'subnet_id', 'state', 'vpc_id', 'cidr_block', 'available_ip_address_count', 'availability_zone"
        "', 'default_for_az', 'map_public_ip_on_launch'), frozen=True, slots=False, post_init_params=None, init_fns=(),"
        " validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='availability_zone_id', kw_only=True, fn=None), ReprPl"
        "an.Field(name='enable_lni_at_device_index', kw_only=True, fn=None), ReprPlan.Field(name='map_customer_owned_ip"
        "_on_launch', kw_only=True, fn=None), ReprPlan.Field(name='customer_owned_ipv4_pool', kw_only=True, fn=None), R"
        "eprPlan.Field(name='owner_id', kw_only=True, fn=None), ReprPlan.Field(name='assign_ipv6_address_on_creation', "
        "kw_only=True, fn=None), ReprPlan.Field(name='ipv6_cidr_block_association_set', kw_only=True, fn=None), ReprPla"
        "n.Field(name='tags', kw_only=True, fn=None), ReprPlan.Field(name='subnet_arn', kw_only=True, fn=None), ReprPla"
        "n.Field(name='outpost_arn', kw_only=True, fn=None), ReprPlan.Field(name='enable_dns64', kw_only=True, fn=None)"
        ", ReprPlan.Field(name='ipv6_native', kw_only=True, fn=None), ReprPlan.Field(name='private_dns_name_options_on_"
        "launch', kw_only=True, fn=None), ReprPlan.Field(name='block_public_access_states', kw_only=True, fn=None), Rep"
        "rPlan.Field(name='type', kw_only=True, fn=None), ReprPlan.Field(name='subnet_id', kw_only=True, fn=None), Repr"
        "Plan.Field(name='state', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPla"
        "n.Field(name='cidr_block', kw_only=True, fn=None), ReprPlan.Field(name='available_ip_address_count', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='availability_zone', kw_only=True, fn=None), ReprPlan.Field(name='default_f"
        "or_az', kw_only=True, fn=None), ReprPlan.Field(name='map_public_ip_on_launch', kw_only=True, fn=None)), id=Fal"
        "se, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='75f7e362ffb3e14e0ae63b7138f52a6d7cd258c5',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__13__annotation',
        '__dataclass__init__fields__13__default',
        '__dataclass__init__fields__14__annotation',
        '__dataclass__init__fields__14__default',
        '__dataclass__init__fields__15__annotation',
        '__dataclass__init__fields__15__default',
        '__dataclass__init__fields__16__annotation',
        '__dataclass__init__fields__16__default',
        '__dataclass__init__fields__17__annotation',
        '__dataclass__init__fields__17__default',
        '__dataclass__init__fields__18__annotation',
        '__dataclass__init__fields__18__default',
        '__dataclass__init__fields__19__annotation',
        '__dataclass__init__fields__19__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__20__annotation',
        '__dataclass__init__fields__20__default',
        '__dataclass__init__fields__21__annotation',
        '__dataclass__init__fields__21__default',
        '__dataclass__init__fields__22__annotation',
        '__dataclass__init__fields__22__default',
        '__dataclass__init__fields__23__annotation',
        '__dataclass__init__fields__23__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Subnet'),
    ),
)
def _process_dataclass__75f7e362ffb3e14e0ae63b7138f52a6d7cd258c5():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__13__annotation,
        __dataclass__init__fields__13__default,
        __dataclass__init__fields__14__annotation,
        __dataclass__init__fields__14__default,
        __dataclass__init__fields__15__annotation,
        __dataclass__init__fields__15__default,
        __dataclass__init__fields__16__annotation,
        __dataclass__init__fields__16__default,
        __dataclass__init__fields__17__annotation,
        __dataclass__init__fields__17__default,
        __dataclass__init__fields__18__annotation,
        __dataclass__init__fields__18__default,
        __dataclass__init__fields__19__annotation,
        __dataclass__init__fields__19__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__20__annotation,
        __dataclass__init__fields__20__default,
        __dataclass__init__fields__21__annotation,
        __dataclass__init__fields__21__default,
        __dataclass__init__fields__22__annotation,
        __dataclass__init__fields__22__default,
        __dataclass__init__fields__23__annotation,
        __dataclass__init__fields__23__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                availability_zone_id=self.availability_zone_id,
                enable_lni_at_device_index=self.enable_lni_at_device_index,
                map_customer_owned_ip_on_launch=self.map_customer_owned_ip_on_launch,
                customer_owned_ipv4_pool=self.customer_owned_ipv4_pool,
                owner_id=self.owner_id,
                assign_ipv6_address_on_creation=self.assign_ipv6_address_on_creation,
                ipv6_cidr_block_association_set=self.ipv6_cidr_block_association_set,
                tags=self.tags,
                subnet_arn=self.subnet_arn,
                outpost_arn=self.outpost_arn,
                enable_dns64=self.enable_dns64,
                ipv6_native=self.ipv6_native,
                private_dns_name_options_on_launch=self.private_dns_name_options_on_launch,
                block_public_access_states=self.block_public_access_states,
                type=self.type,
                subnet_id=self.subnet_id,
                state=self.state,
                vpc_id=self.vpc_id,
                cidr_block=self.cidr_block,
                available_ip_address_count=self.available_ip_address_count,
                availability_zone=self.availability_zone,
                default_for_az=self.default_for_az,
                map_public_ip_on_launch=self.map_public_ip_on_launch,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.availability_zone_id == other.availability_zone_id and
                self.enable_lni_at_device_index == other.enable_lni_at_device_index and
                self.map_customer_owned_ip_on_launch == other.map_customer_owned_ip_on_launch and
                self.customer_owned_ipv4_pool == other.customer_owned_ipv4_pool and
                self.owner_id == other.owner_id and
                self.assign_ipv6_address_on_creation == other.assign_ipv6_address_on_creation and
                self.ipv6_cidr_block_association_set == other.ipv6_cidr_block_association_set and
                self.tags == other.tags and
                self.subnet_arn == other.subnet_arn and
                self.outpost_arn == other.outpost_arn and
                self.enable_dns64 == other.enable_dns64 and
                self.ipv6_native == other.ipv6_native and
                self.private_dns_name_options_on_launch == other.private_dns_name_options_on_launch and
                self.block_public_access_states == other.block_public_access_states and
                self.type == other.type and
                self.subnet_id == other.subnet_id and
                self.state == other.state and
                self.vpc_id == other.vpc_id and
                self.cidr_block == other.cidr_block and
                self.available_ip_address_count == other.available_ip_address_count and
                self.availability_zone == other.availability_zone and
                self.default_for_az == other.default_for_az and
                self.map_public_ip_on_launch == other.map_public_ip_on_launch
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'availability_zone_id',
            'enable_lni_at_device_index',
            'map_customer_owned_ip_on_launch',
            'customer_owned_ipv4_pool',
            'owner_id',
            'assign_ipv6_address_on_creation',
            'ipv6_cidr_block_association_set',
            'tags',
            'subnet_arn',
            'outpost_arn',
            'enable_dns64',
            'ipv6_native',
            'private_dns_name_options_on_launch',
            'block_public_access_states',
            'type',
            'subnet_id',
            'state',
            'vpc_id',
            'cidr_block',
            'available_ip_address_count',
            'availability_zone',
            'default_for_az',
            'map_public_ip_on_launch',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'availability_zone_id',
            'enable_lni_at_device_index',
            'map_customer_owned_ip_on_launch',
            'customer_owned_ipv4_pool',
            'owner_id',
            'assign_ipv6_address_on_creation',
            'ipv6_cidr_block_association_set',
            'tags',
            'subnet_arn',
            'outpost_arn',
            'enable_dns64',
            'ipv6_native',
            'private_dns_name_options_on_launch',
            'block_public_access_states',
            'type',
            'subnet_id',
            'state',
            'vpc_id',
            'cidr_block',
            'available_ip_address_count',
            'availability_zone',
            'default_for_az',
            'map_public_ip_on_launch',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.availability_zone_id,
                self.enable_lni_at_device_index,
                self.map_customer_owned_ip_on_launch,
                self.customer_owned_ipv4_pool,
                self.owner_id,
                self.assign_ipv6_address_on_creation,
                self.ipv6_cidr_block_association_set,
                self.tags,
                self.subnet_arn,
                self.outpost_arn,
                self.enable_dns64,
                self.ipv6_native,
                self.private_dns_name_options_on_launch,
                self.block_public_access_states,
                self.type,
                self.subnet_id,
                self.state,
                self.vpc_id,
                self.cidr_block,
                self.available_ip_address_count,
                self.availability_zone,
                self.default_for_az,
                self.map_public_ip_on_launch,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            availability_zone_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            enable_lni_at_device_index: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            map_customer_owned_ip_on_launch: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            customer_owned_ipv4_pool: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            owner_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            assign_ipv6_address_on_creation: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            ipv6_cidr_block_association_set: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            tags: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            subnet_arn: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            outpost_arn: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            enable_dns64: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            ipv6_native: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
            private_dns_name_options_on_launch: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
            block_public_access_states: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
            type: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
            subnet_id: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
            state: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
            vpc_id: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
            cidr_block: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
            available_ip_address_count: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
            availability_zone: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
            default_for_az: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
            map_public_ip_on_launch: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'availability_zone_id', availability_zone_id)
            __dataclass__object_setattr(self, 'enable_lni_at_device_index', enable_lni_at_device_index)
            __dataclass__object_setattr(self, 'map_customer_owned_ip_on_launch', map_customer_owned_ip_on_launch)
            __dataclass__object_setattr(self, 'customer_owned_ipv4_pool', customer_owned_ipv4_pool)
            __dataclass__object_setattr(self, 'owner_id', owner_id)
            __dataclass__object_setattr(self, 'assign_ipv6_address_on_creation', assign_ipv6_address_on_creation)
            __dataclass__object_setattr(self, 'ipv6_cidr_block_association_set', ipv6_cidr_block_association_set)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'subnet_arn', subnet_arn)
            __dataclass__object_setattr(self, 'outpost_arn', outpost_arn)
            __dataclass__object_setattr(self, 'enable_dns64', enable_dns64)
            __dataclass__object_setattr(self, 'ipv6_native', ipv6_native)
            __dataclass__object_setattr(self, 'private_dns_name_options_on_launch', private_dns_name_options_on_launch)
            __dataclass__object_setattr(self, 'block_public_access_states', block_public_access_states)
            __dataclass__object_setattr(self, 'type', type)
            __dataclass__object_setattr(self, 'subnet_id', subnet_id)
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'cidr_block', cidr_block)
            __dataclass__object_setattr(self, 'available_ip_address_count', available_ip_address_count)
            __dataclass__object_setattr(self, 'availability_zone', availability_zone)
            __dataclass__object_setattr(self, 'default_for_az', default_for_az)
            __dataclass__object_setattr(self, 'map_public_ip_on_launch', map_public_ip_on_launch)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"availability_zone_id={self.availability_zone_id!r}")
            parts.append(f"enable_lni_at_device_index={self.enable_lni_at_device_index!r}")
            parts.append(f"map_customer_owned_ip_on_launch={self.map_customer_owned_ip_on_launch!r}")
            parts.append(f"customer_owned_ipv4_pool={self.customer_owned_ipv4_pool!r}")
            parts.append(f"owner_id={self.owner_id!r}")
            parts.append(f"assign_ipv6_address_on_creation={self.assign_ipv6_address_on_creation!r}")
            parts.append(f"ipv6_cidr_block_association_set={self.ipv6_cidr_block_association_set!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"subnet_arn={self.subnet_arn!r}")
            parts.append(f"outpost_arn={self.outpost_arn!r}")
            parts.append(f"enable_dns64={self.enable_dns64!r}")
            parts.append(f"ipv6_native={self.ipv6_native!r}")
            parts.append(f"private_dns_name_options_on_launch={self.private_dns_name_options_on_launch!r}")
            parts.append(f"block_public_access_states={self.block_public_access_states!r}")
            parts.append(f"type={self.type!r}")
            parts.append(f"subnet_id={self.subnet_id!r}")
            parts.append(f"state={self.state!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"cidr_block={self.cidr_block!r}")
            parts.append(f"available_ip_address_count={self.available_ip_address_count!r}")
            parts.append(f"availability_zone={self.availability_zone!r}")
            parts.append(f"default_for_az={self.default_for_az!r}")
            parts.append(f"map_public_ip_on_launch={self.map_public_ip_on_launch!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('association_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'ipv6_address_attrib"
        "ute', 'ip_source')), EqPlan(fields=('association_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'ipv6_addres"
        "s_attribute', 'ip_source')), FrozenPlan(fields=('__shape__', 'association_id', 'ipv6_cidr_block', 'ipv6_cidr_b"
        "lock_state', 'ipv6_address_attribute', 'ip_source'), allow_dynamic_dunder_attrs=False), HashPlan(action='add',"
        " fields=('association_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'ipv6_address_attribute', 'ip_source'),"
        " cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0.annotati"
        "on'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, coerce=No"
        "ne, validate=None, check_type=None), InitPlan.Field(name='association_id', annotation=OpRef(name='init.fields."
        "1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_cidr_bl"
        "ock', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_"
        "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
        "=None), InitPlan.Field(name='ipv6_cidr_block_state', annotation=OpRef(name='init.fields.3.annotation'), defaul"
        "t=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
        "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_address_attribute', annotatio"
        "n=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, i"
        "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
        "n.Field(name='ip_source', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('association_id', 'ipv6_cidr_bl"
        "ock', 'ipv6_cidr_block_state', 'ipv6_address_attribute', 'ip_source'), frozen=True, slots=False, post_init_par"
        "ams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='association_id', kw_only=True, "
        "fn=None), ReprPlan.Field(name='ipv6_cidr_block', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_cidr_block_"
        "state', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_address_attribute', kw_only=True, fn=None), ReprPlan"
        ".Field(name='ip_source', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='58932d05fd6336438a2ce2e7422de8bf9a7c4aae',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'SubnetIpv6CidrBlockAssociation'),
    ),
)
def _process_dataclass__58932d05fd6336438a2ce2e7422de8bf9a7c4aae():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                association_id=self.association_id,
                ipv6_cidr_block=self.ipv6_cidr_block,
                ipv6_cidr_block_state=self.ipv6_cidr_block_state,
                ipv6_address_attribute=self.ipv6_address_attribute,
                ip_source=self.ip_source,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.association_id == other.association_id and
                self.ipv6_cidr_block == other.ipv6_cidr_block and
                self.ipv6_cidr_block_state == other.ipv6_cidr_block_state and
                self.ipv6_address_attribute == other.ipv6_address_attribute and
                self.ip_source == other.ip_source
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'association_id',
            'ipv6_cidr_block',
            'ipv6_cidr_block_state',
            'ipv6_address_attribute',
            'ip_source',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'association_id',
            'ipv6_cidr_block',
            'ipv6_cidr_block_state',
            'ipv6_address_attribute',
            'ip_source',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.association_id,
                self.ipv6_cidr_block,
                self.ipv6_cidr_block_state,
                self.ipv6_address_attribute,
                self.ip_source,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            association_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            ipv6_cidr_block: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            ipv6_cidr_block_state: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            ipv6_address_attribute: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            ip_source: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'association_id', association_id)
            __dataclass__object_setattr(self, 'ipv6_cidr_block', ipv6_cidr_block)
            __dataclass__object_setattr(self, 'ipv6_cidr_block_state', ipv6_cidr_block_state)
            __dataclass__object_setattr(self, 'ipv6_address_attribute', ipv6_address_attribute)
            __dataclass__object_setattr(self, 'ip_source', ip_source)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"association_id={self.association_id!r}")
            parts.append(f"ipv6_cidr_block={self.ipv6_cidr_block!r}")
            parts.append(f"ipv6_cidr_block_state={self.ipv6_cidr_block_state!r}")
            parts.append(f"ipv6_address_attribute={self.ipv6_address_attribute!r}")
            parts.append(f"ip_source={self.ip_source!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('resource_type', 'tags')), EqPlan(fields=('resource_type', 'tags')), FrozenPlan(fi"
        "elds=('__shape__', 'resource_type', 'tags'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields="
        "('resource_type', 'tags'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(na"
        "me='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fiel"
        "dType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='resource_type', annotation"
        "=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
        ".Field(name='tags', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None)), self_param='self', std_params=(), kw_only_params=('resource_type', 'tags'), frozen=True"
        ", slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='res"
        "ource_type', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=True, fn=None)), id=False, terse=Fals"
        "e, default_fn=None)))"
    ),
    plan_repr_sha1='72408a250113d7efc0131778f5e6fa438b55e772',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'TagSpecification'),
    ),
)
def _process_dataclass__72408a250113d7efc0131778f5e6fa438b55e772():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                resource_type=self.resource_type,
                tags=self.tags,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.resource_type == other.resource_type and
                self.tags == other.tags
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'resource_type',
            'tags',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'resource_type',
            'tags',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.resource_type,
                self.tags,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            resource_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            tags: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'resource_type', resource_type)
            __dataclass__object_setattr(self, 'tags', tags)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"resource_type={self.resource_type!r}")
            parts.append(f"tags={self.tags!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('instance_ids', 'force', 'skip_os_shutdown', 'dry_run')), EqPlan(fields=('instance"
        "_ids', 'force', 'skip_os_shutdown', 'dry_run')), FrozenPlan(fields=('__shape__', 'instance_ids', 'force', 'ski"
        "p_os_shutdown', 'dry_run'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('instance_ids', "
        "'force', 'skip_os_shutdown', 'dry_run'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annot"
        "ation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, f"
        "ield_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='instance_ids"
        "', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override="
        "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='force"
        "', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='skip_os_shutdown', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef("
        "name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
        " coerce=None, validate=None, check_type=None), InitPlan.Field(name='dry_run', annotation=OpRef(name='init.fiel"
        "ds.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=Fals"
        "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params"
        "=(), kw_only_params=('instance_ids', 'force', 'skip_os_shutdown', 'dry_run'), frozen=True, slots=False, post_i"
        "nit_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='instance_ids', kw_only=T"
        "rue, fn=None), ReprPlan.Field(name='force', kw_only=True, fn=None), ReprPlan.Field(name='skip_os_shutdown', kw"
        "_only=True, fn=None), ReprPlan.Field(name='dry_run', kw_only=True, fn=None)), id=False, terse=False, default_f"
        "n=None)))"
    ),
    plan_repr_sha1='91c5afb6e2c6cf1902cb47c9479b535857ed2830',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'TerminateInstancesRequest'),
    ),
)
def _process_dataclass__91c5afb6e2c6cf1902cb47c9479b535857ed2830():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                instance_ids=self.instance_ids,
                force=self.force,
                skip_os_shutdown=self.skip_os_shutdown,
                dry_run=self.dry_run,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.instance_ids == other.instance_ids and
                self.force == other.force and
                self.skip_os_shutdown == other.skip_os_shutdown and
                self.dry_run == other.dry_run
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'force',
            'skip_os_shutdown',
            'dry_run',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'instance_ids',
            'force',
            'skip_os_shutdown',
            'dry_run',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.instance_ids,
                self.force,
                self.skip_os_shutdown,
                self.dry_run,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            instance_ids: __dataclass__init__fields__1__annotation,
            force: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            skip_os_shutdown: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            dry_run: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'instance_ids', instance_ids)
            __dataclass__object_setattr(self, 'force', force)
            __dataclass__object_setattr(self, 'skip_os_shutdown', skip_os_shutdown)
            __dataclass__object_setattr(self, 'dry_run', dry_run)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"instance_ids={self.instance_ids!r}")
            parts.append(f"force={self.force!r}")
            parts.append(f"skip_os_shutdown={self.skip_os_shutdown!r}")
            parts.append(f"dry_run={self.dry_run!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('terminating_instances',)), EqPlan(fields=('terminating_instances',)), FrozenPlan("
        "fields=('__shape__', 'terminating_instances'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', field"
        "s=('terminating_instances',), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef"
        "(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=F"
        "ieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='terminating_instances',"
        " annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_facto"
        "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
        ")), self_param='self', std_params=(), kw_only_params=('terminating_instances',), frozen=True, slots=False, pos"
        "t_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='terminating_instances"
        "', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='cf5ef8fece55e5fdc025db18d19108aa811ff60c',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'TerminateInstancesResult'),
    ),
)
def _process_dataclass__cf5ef8fece55e5fdc025db18d19108aa811ff60c():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                terminating_instances=self.terminating_instances,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.terminating_instances == other.terminating_instances
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'terminating_instances',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'terminating_instances',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.terminating_instances,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            terminating_instances: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'terminating_instances', terminating_instances)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"terminating_instances={self.terminating_instances!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('description', 'user_id', 'group_name', 'group_id', 'vpc_id', 'vpc_peering_connect"
        "ion_id', 'peering_status')), EqPlan(fields=('description', 'user_id', 'group_name', 'group_id', 'vpc_id', 'vpc"
        "_peering_connection_id', 'peering_status')), FrozenPlan(fields=('__shape__', 'description', 'user_id', 'group_"
        "name', 'group_id', 'vpc_id', 'vpc_peering_connection_id', 'peering_status'), allow_dynamic_dunder_attrs=False)"
        ", HashPlan(action='add', fields=('description', 'user_id', 'group_name', 'group_id', 'vpc_id', 'vpc_peering_co"
        "nnection_id', 'peering_status'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=Op"
        "Ref(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='description', annota"
        "tion=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None"
        ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
        "Plan.Field(name='user_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields."
        "2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='group_name', annotation=OpRef(name='init.fields.3.annotation"
        "'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=F"
        "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='group_id', annotation=Op"
        "Ref(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init="
        "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
        "eld(name='vpc_id', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.defaul"
        "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
        "e, check_type=None), InitPlan.Field(name='vpc_peering_connection_id', annotation=OpRef(name='init.fields.6.ann"
        "otation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field"
        "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='peering_status', "
        "annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        "), self_param='self', std_params=(), kw_only_params=('description', 'user_id', 'group_name', 'group_id', 'vpc_"
        "id', 'vpc_peering_connection_id', 'peering_status'), frozen=True, slots=False, post_init_params=None, init_fns"
        "=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='description', kw_only=True, fn=None), ReprPlan.Fi"
        "eld(name='user_id', kw_only=True, fn=None), ReprPlan.Field(name='group_name', kw_only=True, fn=None), ReprPlan"
        ".Field(name='group_id', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPlan"
        ".Field(name='vpc_peering_connection_id', kw_only=True, fn=None), ReprPlan.Field(name='peering_status', kw_only"
        "=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='1345d9c80c309896fbf85a8241c28bcc211432e6',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'UserIdGroupPair'),
    ),
)
def _process_dataclass__1345d9c80c309896fbf85a8241c28bcc211432e6():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                description=self.description,
                user_id=self.user_id,
                group_name=self.group_name,
                group_id=self.group_id,
                vpc_id=self.vpc_id,
                vpc_peering_connection_id=self.vpc_peering_connection_id,
                peering_status=self.peering_status,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.description == other.description and
                self.user_id == other.user_id and
                self.group_name == other.group_name and
                self.group_id == other.group_id and
                self.vpc_id == other.vpc_id and
                self.vpc_peering_connection_id == other.vpc_peering_connection_id and
                self.peering_status == other.peering_status
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'description',
            'user_id',
            'group_name',
            'group_id',
            'vpc_id',
            'vpc_peering_connection_id',
            'peering_status',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'description',
            'user_id',
            'group_name',
            'group_id',
            'vpc_id',
            'vpc_peering_connection_id',
            'peering_status',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.description,
                self.user_id,
                self.group_name,
                self.group_id,
                self.vpc_id,
                self.vpc_peering_connection_id,
                self.peering_status,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            description: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            user_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            group_name: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            group_id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            vpc_id: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            vpc_peering_connection_id: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            peering_status: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'description', description)
            __dataclass__object_setattr(self, 'user_id', user_id)
            __dataclass__object_setattr(self, 'group_name', group_name)
            __dataclass__object_setattr(self, 'group_id', group_id)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'vpc_peering_connection_id', vpc_peering_connection_id)
            __dataclass__object_setattr(self, 'peering_status', peering_status)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"description={self.description!r}")
            parts.append(f"user_id={self.user_id!r}")
            parts.append(f"group_name={self.group_name!r}")
            parts.append(f"group_id={self.group_id!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"vpc_peering_connection_id={self.vpc_peering_connection_id!r}")
            parts.append(f"peering_status={self.peering_status!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('default_v_cpus', 'default_cores', 'default_threads_per_core', 'valid_cores', 'val"
        "id_threads_per_core')), EqPlan(fields=('default_v_cpus', 'default_cores', 'default_threads_per_core', 'valid_c"
        "ores', 'valid_threads_per_core')), FrozenPlan(fields=('__shape__', 'default_v_cpus', 'default_cores', 'default"
        "_threads_per_core', 'valid_cores', 'valid_threads_per_core'), allow_dynamic_dunder_attrs=False), HashPlan(acti"
        "on='add', fields=('default_v_cpus', 'default_cores', 'default_threads_per_core', 'valid_cores', 'valid_threads"
        "_per_core'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.field"
        "s.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VA"
        "R, coerce=None, validate=None, check_type=None), InitPlan.Field(name='default_v_cpus', annotation=OpRef(name='"
        "init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, over"
        "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
        "default_cores', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default')"
        ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
        "check_type=None), InitPlan.Field(name='default_threads_per_core', annotation=OpRef(name='init.fields.3.annotat"
        "ion'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='valid_cores', annotat"
        "ion=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None,"
        " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
        "lan.Field(name='valid_threads_per_core', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name"
        "='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
        "rce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('default_v_cpus'"
        ", 'default_cores', 'default_threads_per_core', 'valid_cores', 'valid_threads_per_core'), frozen=True, slots=Fa"
        "lse, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='default_v_cpu"
        "s', kw_only=True, fn=None), ReprPlan.Field(name='default_cores', kw_only=True, fn=None), ReprPlan.Field(name='"
        "default_threads_per_core', kw_only=True, fn=None), ReprPlan.Field(name='valid_cores', kw_only=True, fn=None), "
        "ReprPlan.Field(name='valid_threads_per_core', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)"
        "))"
    ),
    plan_repr_sha1='3b2bc736efeacacf1a96fc040e201359b4679dd7',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'VCpuInfo'),
    ),
)
def _process_dataclass__3b2bc736efeacacf1a96fc040e201359b4679dd7():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                default_v_cpus=self.default_v_cpus,
                default_cores=self.default_cores,
                default_threads_per_core=self.default_threads_per_core,
                valid_cores=self.valid_cores,
                valid_threads_per_core=self.valid_threads_per_core,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.default_v_cpus == other.default_v_cpus and
                self.default_cores == other.default_cores and
                self.default_threads_per_core == other.default_threads_per_core and
                self.valid_cores == other.valid_cores and
                self.valid_threads_per_core == other.valid_threads_per_core
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'default_v_cpus',
            'default_cores',
            'default_threads_per_core',
            'valid_cores',
            'valid_threads_per_core',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'default_v_cpus',
            'default_cores',
            'default_threads_per_core',
            'valid_cores',
            'valid_threads_per_core',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.default_v_cpus,
                self.default_cores,
                self.default_threads_per_core,
                self.valid_cores,
                self.valid_threads_per_core,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            default_v_cpus: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            default_cores: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            default_threads_per_core: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            valid_cores: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            valid_threads_per_core: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'default_v_cpus', default_v_cpus)
            __dataclass__object_setattr(self, 'default_cores', default_cores)
            __dataclass__object_setattr(self, 'default_threads_per_core', default_threads_per_core)
            __dataclass__object_setattr(self, 'valid_cores', valid_cores)
            __dataclass__object_setattr(self, 'valid_threads_per_core', valid_threads_per_core)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"default_v_cpus={self.default_v_cpus!r}")
            parts.append(f"default_cores={self.default_cores!r}")
            parts.append(f"default_threads_per_core={self.default_threads_per_core!r}")
            parts.append(f"valid_cores={self.valid_cores!r}")
            parts.append(f"valid_threads_per_core={self.valid_threads_per_core!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('owner_id', 'instance_tenancy', 'ipv6_cidr_block_association_set', 'cidr_block_ass"
        "ociation_set', 'is_default', 'encryption_control', 'tags', 'block_public_access_states', 'vpc_id', 'state', 'c"
        "idr_block', 'dhcp_options_id')), EqPlan(fields=('owner_id', 'instance_tenancy', 'ipv6_cidr_block_association_s"
        "et', 'cidr_block_association_set', 'is_default', 'encryption_control', 'tags', 'block_public_access_states', '"
        "vpc_id', 'state', 'cidr_block', 'dhcp_options_id')), FrozenPlan(fields=('__shape__', 'owner_id', 'instance_ten"
        "ancy', 'ipv6_cidr_block_association_set', 'cidr_block_association_set', 'is_default', 'encryption_control', 't"
        "ags', 'block_public_access_states', 'vpc_id', 'state', 'cidr_block', 'dhcp_options_id'), allow_dynamic_dunder_"
        "attrs=False), HashPlan(action='add', fields=('owner_id', 'instance_tenancy', 'ipv6_cidr_block_association_set'"
        ", 'cidr_block_association_set', 'is_default', 'encryption_control', 'tags', 'block_public_access_states', 'vpc"
        "_id', 'state', 'cidr_block', 'dhcp_options_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__"
        "', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override="
        "False, field_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='owne"
        "r_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default"
        "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
        "e=None), InitPlan.Field(name='instance_tenancy', annotation=OpRef(name='init.fields.2.annotation'), default=Op"
        "Ref(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
        "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_cidr_block_association_set', anno"
        "tation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=No"
        "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
        "itPlan.Field(name='cidr_block_association_set', annotation=OpRef(name='init.fields.4.annotation'), default=OpR"
        "ef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='is_default', annotation=OpRef(name='ini"
        "t.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, overrid"
        "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='enc"
        "ryption_control', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default"
        "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
        ", check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='init.fields.7.annotation'), default=OpR"
        "ef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
        "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='block_public_access_states', annotation"
        "=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, in"
        "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
        ".Field(name='vpc_id', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.def"
        "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
        "None, check_type=None), InitPlan.Field(name='state', annotation=OpRef(name='init.fields.10.annotation'), defau"
        "lt=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cidr_block', annotation=OpRef(na"
        "me='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=True"
        ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
        "name='dhcp_options_id', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12"
        ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
        "ate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('owner_id', 'instance_tenancy',"
        " 'ipv6_cidr_block_association_set', 'cidr_block_association_set', 'is_default', 'encryption_control', 'tags', "
        "'block_public_access_states', 'vpc_id', 'state', 'cidr_block', 'dhcp_options_id'), frozen=True, slots=False, p"
        "ost_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='owner_id', kw_only="
        "True, fn=None), ReprPlan.Field(name='instance_tenancy', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_cidr"
        "_block_association_set', kw_only=True, fn=None), ReprPlan.Field(name='cidr_block_association_set', kw_only=Tru"
        "e, fn=None), ReprPlan.Field(name='is_default', kw_only=True, fn=None), ReprPlan.Field(name='encryption_control"
        "', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=True, fn=None), ReprPlan.Field(name='block_publ"
        "ic_access_states', kw_only=True, fn=None), ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPlan.Fiel"
        "d(name='state', kw_only=True, fn=None), ReprPlan.Field(name='cidr_block', kw_only=True, fn=None), ReprPlan.Fie"
        "ld(name='dhcp_options_id', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='d719e59ed39034940f5557de3b6e95b675f461c6',
    op_ref_idents=(
        '__dataclass__init__fields__10__annotation',
        '__dataclass__init__fields__10__default',
        '__dataclass__init__fields__11__annotation',
        '__dataclass__init__fields__11__default',
        '__dataclass__init__fields__12__annotation',
        '__dataclass__init__fields__12__default',
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
        '__dataclass__init__fields__9__annotation',
        '__dataclass__init__fields__9__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'Vpc'),
    ),
)
def _process_dataclass__d719e59ed39034940f5557de3b6e95b675f461c6():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__10__annotation,
        __dataclass__init__fields__10__default,
        __dataclass__init__fields__11__annotation,
        __dataclass__init__fields__11__default,
        __dataclass__init__fields__12__annotation,
        __dataclass__init__fields__12__default,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__init__fields__9__annotation,
        __dataclass__init__fields__9__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                owner_id=self.owner_id,
                instance_tenancy=self.instance_tenancy,
                ipv6_cidr_block_association_set=self.ipv6_cidr_block_association_set,
                cidr_block_association_set=self.cidr_block_association_set,
                is_default=self.is_default,
                encryption_control=self.encryption_control,
                tags=self.tags,
                block_public_access_states=self.block_public_access_states,
                vpc_id=self.vpc_id,
                state=self.state,
                cidr_block=self.cidr_block,
                dhcp_options_id=self.dhcp_options_id,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.owner_id == other.owner_id and
                self.instance_tenancy == other.instance_tenancy and
                self.ipv6_cidr_block_association_set == other.ipv6_cidr_block_association_set and
                self.cidr_block_association_set == other.cidr_block_association_set and
                self.is_default == other.is_default and
                self.encryption_control == other.encryption_control and
                self.tags == other.tags and
                self.block_public_access_states == other.block_public_access_states and
                self.vpc_id == other.vpc_id and
                self.state == other.state and
                self.cidr_block == other.cidr_block and
                self.dhcp_options_id == other.dhcp_options_id
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'owner_id',
            'instance_tenancy',
            'ipv6_cidr_block_association_set',
            'cidr_block_association_set',
            'is_default',
            'encryption_control',
            'tags',
            'block_public_access_states',
            'vpc_id',
            'state',
            'cidr_block',
            'dhcp_options_id',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'owner_id',
            'instance_tenancy',
            'ipv6_cidr_block_association_set',
            'cidr_block_association_set',
            'is_default',
            'encryption_control',
            'tags',
            'block_public_access_states',
            'vpc_id',
            'state',
            'cidr_block',
            'dhcp_options_id',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.owner_id,
                self.instance_tenancy,
                self.ipv6_cidr_block_association_set,
                self.cidr_block_association_set,
                self.is_default,
                self.encryption_control,
                self.tags,
                self.block_public_access_states,
                self.vpc_id,
                self.state,
                self.cidr_block,
                self.dhcp_options_id,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            owner_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            instance_tenancy: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            ipv6_cidr_block_association_set: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            cidr_block_association_set: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            is_default: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            encryption_control: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            tags: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            block_public_access_states: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
            vpc_id: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
            state: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
            cidr_block: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
            dhcp_options_id: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'owner_id', owner_id)
            __dataclass__object_setattr(self, 'instance_tenancy', instance_tenancy)
            __dataclass__object_setattr(self, 'ipv6_cidr_block_association_set', ipv6_cidr_block_association_set)
            __dataclass__object_setattr(self, 'cidr_block_association_set', cidr_block_association_set)
            __dataclass__object_setattr(self, 'is_default', is_default)
            __dataclass__object_setattr(self, 'encryption_control', encryption_control)
            __dataclass__object_setattr(self, 'tags', tags)
            __dataclass__object_setattr(self, 'block_public_access_states', block_public_access_states)
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'cidr_block', cidr_block)
            __dataclass__object_setattr(self, 'dhcp_options_id', dhcp_options_id)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"owner_id={self.owner_id!r}")
            parts.append(f"instance_tenancy={self.instance_tenancy!r}")
            parts.append(f"ipv6_cidr_block_association_set={self.ipv6_cidr_block_association_set!r}")
            parts.append(f"cidr_block_association_set={self.cidr_block_association_set!r}")
            parts.append(f"is_default={self.is_default!r}")
            parts.append(f"encryption_control={self.encryption_control!r}")
            parts.append(f"tags={self.tags!r}")
            parts.append(f"block_public_access_states={self.block_public_access_states!r}")
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"state={self.state!r}")
            parts.append(f"cidr_block={self.cidr_block!r}")
            parts.append(f"dhcp_options_id={self.dhcp_options_id!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('association_id', 'cidr_block', 'cidr_block_state')), EqPlan(fields=('association_"
        "id', 'cidr_block', 'cidr_block_state')), FrozenPlan(fields=('__shape__', 'association_id', 'cidr_block', 'cidr"
        "_block_state'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('association_id', 'cidr_bloc"
        "k', 'cidr_block_state'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name"
        "='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldT"
        "ype.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='association_id', annotation="
        "OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, ini"
        "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
        "Field(name='cidr_block', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None), InitPlan.Field(name='cidr_block_state', annotation=OpRef(name='init.fields.3.annota"
        "tion'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_ty"
        "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_onl"
        "y_params=('association_id', 'cidr_block', 'cidr_block_state'), frozen=True, slots=False, post_init_params=None"
        ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='association_id', kw_only=True, fn=None)"
        ", ReprPlan.Field(name='cidr_block', kw_only=True, fn=None), ReprPlan.Field(name='cidr_block_state', kw_only=Tr"
        "ue, fn=None)), id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='040de49b0cfab72b376b5f24d0bbcccbb8d8612b',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'VpcCidrBlockAssociation'),
    ),
)
def _process_dataclass__040de49b0cfab72b376b5f24d0bbcccbb8d8612b():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                association_id=self.association_id,
                cidr_block=self.cidr_block,
                cidr_block_state=self.cidr_block_state,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.association_id == other.association_id and
                self.cidr_block == other.cidr_block and
                self.cidr_block_state == other.cidr_block_state
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'association_id',
            'cidr_block',
            'cidr_block_state',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'association_id',
            'cidr_block',
            'cidr_block_state',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.association_id,
                self.cidr_block,
                self.cidr_block_state,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            association_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            cidr_block: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            cidr_block_state: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'association_id', association_id)
            __dataclass__object_setattr(self, 'cidr_block', cidr_block)
            __dataclass__object_setattr(self, 'cidr_block_state', cidr_block_state)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"association_id={self.association_id!r}")
            parts.append(f"cidr_block={self.cidr_block!r}")
            parts.append(f"cidr_block_state={self.cidr_block_state!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('vpc_id', 'vpc_encryption_control_id', 'mode', 'state', 'state_message', 'resource"
        "_exclusions', 'tags')), EqPlan(fields=('vpc_id', 'vpc_encryption_control_id', 'mode', 'state', 'state_message'"
        ", 'resource_exclusions', 'tags')), FrozenPlan(fields=('__shape__', 'vpc_id', 'vpc_encryption_control_id', 'mod"
        "e', 'state', 'state_message', 'resource_exclusions', 'tags'), allow_dynamic_dunder_attrs=False), HashPlan(acti"
        "on='add', fields=('vpc_id', 'vpc_encryption_control_id', 'mode', 'state', 'state_message', 'resource_exclusion"
        "s', 'tags'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.field"
        "s.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VA"
        "R, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_id', annotation=OpRef(name='init.fie"
        "lds.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=Fal"
        "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_encr"
        "yption_control_id', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defau"
        "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
        "ne, check_type=None), InitPlan.Field(name='mode', annotation=OpRef(name='init.fields.3.annotation'), default=O"
        "pRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
        "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state', annotation=OpRef(name='init.f"
        "ields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=F"
        "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state_"
        "message', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), defa"
        "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
        "type=None), InitPlan.Field(name='resource_exclusions', annotation=OpRef(name='init.fields.6.annotation'), defa"
        "ult=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType"
        ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tags', annotation=OpRef(name='in"
        "it.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std"
        "_params=(), kw_only_params=('vpc_id', 'vpc_encryption_control_id', 'mode', 'state', 'state_message', 'resource"
        "_exclusions', 'tags'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPla"
        "n(fields=(ReprPlan.Field(name='vpc_id', kw_only=True, fn=None), ReprPlan.Field(name='vpc_encryption_control_id"
        "', kw_only=True, fn=None), ReprPlan.Field(name='mode', kw_only=True, fn=None), ReprPlan.Field(name='state', kw"
        "_only=True, fn=None), ReprPlan.Field(name='state_message', kw_only=True, fn=None), ReprPlan.Field(name='resour"
        "ce_exclusions', kw_only=True, fn=None), ReprPlan.Field(name='tags', kw_only=True, fn=None)), id=False, terse=F"
        "alse, default_fn=None)))"
    ),
    plan_repr_sha1='320aefe088785f2aa267fdc198bbe8c5f4dbcf2c',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'VpcEncryptionControl'),
    ),
)
def _process_dataclass__320aefe088785f2aa267fdc198bbe8c5f4dbcf2c():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                vpc_id=self.vpc_id,
                vpc_encryption_control_id=self.vpc_encryption_control_id,
                mode=self.mode,
                state=self.state,
                state_message=self.state_message,
                resource_exclusions=self.resource_exclusions,
                tags=self.tags,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.vpc_id == other.vpc_id and
                self.vpc_encryption_control_id == other.vpc_encryption_control_id and
                self.mode == other.mode and
                self.state == other.state and
                self.state_message == other.state_message and
                self.resource_exclusions == other.resource_exclusions and
                self.tags == other.tags
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'vpc_id',
            'vpc_encryption_control_id',
            'mode',
            'state',
            'state_message',
            'resource_exclusions',
            'tags',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'vpc_id',
            'vpc_encryption_control_id',
            'mode',
            'state',
            'state_message',
            'resource_exclusions',
            'tags',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.vpc_id,
                self.vpc_encryption_control_id,
                self.mode,
                self.state,
                self.state_message,
                self.resource_exclusions,
                self.tags,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            vpc_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            vpc_encryption_control_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            mode: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            state: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            state_message: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            resource_exclusions: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            tags: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'vpc_id', vpc_id)
            __dataclass__object_setattr(self, 'vpc_encryption_control_id', vpc_encryption_control_id)
            __dataclass__object_setattr(self, 'mode', mode)
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'state_message', state_message)
            __dataclass__object_setattr(self, 'resource_exclusions', resource_exclusions)
            __dataclass__object_setattr(self, 'tags', tags)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"vpc_id={self.vpc_id!r}")
            parts.append(f"vpc_encryption_control_id={self.vpc_encryption_control_id!r}")
            parts.append(f"mode={self.mode!r}")
            parts.append(f"state={self.state!r}")
            parts.append(f"state_message={self.state_message!r}")
            parts.append(f"resource_exclusions={self.resource_exclusions!r}")
            parts.append(f"tags={self.tags!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('state', 'state_message')), EqPlan(fields=('state', 'state_message')), FrozenPlan("
        "fields=('__shape__', 'state', 'state_message'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fiel"
        "ds=('state', 'state_message'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRe"
        "f(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type="
        "FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='state', annotation=OpR"
        "ef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=T"
        "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
        "ld(name='state_message', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2."
        "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
        "te=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('state', 'state_message'), froze"
        "n=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
        "e='state', kw_only=True, fn=None), ReprPlan.Field(name='state_message', kw_only=True, fn=None)), id=False, ter"
        "se=False, default_fn=None)))"
    ),
    plan_repr_sha1='8e0c14bba9e8983bf6d4f25359bf99c8ca9c423a',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'VpcEncryptionControlExclusion'),
    ),
)
def _process_dataclass__8e0c14bba9e8983bf6d4f25359bf99c8ca9c423a():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                state=self.state,
                state_message=self.state_message,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.state == other.state and
                self.state_message == other.state_message
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'state',
            'state_message',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'state',
            'state_message',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.state,
                self.state_message,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            state: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            state_message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'state', state)
            __dataclass__object_setattr(self, 'state_message', state_message)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"state={self.state!r}")
            parts.append(f"state_message={self.state_message!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('internet_gateway', 'egress_only_internet_gateway', 'nat_gateway', 'virtual_privat"
        "e_gateway', 'vpc_peering', 'lambda_', 'vpc_lattice', 'elastic_file_system')), EqPlan(fields=('internet_gateway"
        "', 'egress_only_internet_gateway', 'nat_gateway', 'virtual_private_gateway', 'vpc_peering', 'lambda_', 'vpc_la"
        "ttice', 'elastic_file_system')), FrozenPlan(fields=('__shape__', 'internet_gateway', 'egress_only_internet_gat"
        "eway', 'nat_gateway', 'virtual_private_gateway', 'vpc_peering', 'lambda_', 'vpc_lattice', 'elastic_file_system"
        "'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('internet_gateway', 'egress_only_interne"
        "t_gateway', 'nat_gateway', 'virtual_private_gateway', 'vpc_peering', 'lambda_', 'vpc_lattice', 'elastic_file_s"
        "ystem'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotation=OpRef(name='init.fields.0."
        "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.CLASS_VAR, c"
        "oerce=None, validate=None, check_type=None), InitPlan.Field(name='internet_gateway', annotation=OpRef(name='in"
        "it.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overri"
        "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='eg"
        "ress_only_internet_gateway', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.field"
        "s.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
        "lidate=None, check_type=None), InitPlan.Field(name='nat_gateway', annotation=OpRef(name='init.fields.3.annotat"
        "ion'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_typ"
        "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='virtual_private_gatew"
        "ay', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_f"
        "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
        "None), InitPlan.Field(name='vpc_peering', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(nam"
        "e='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
        "erce=None, validate=None, check_type=None), InitPlan.Field(name='lambda_', annotation=OpRef(name='init.fields."
        "6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, "
        "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vpc_lattice'"
        ", annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_fact"
        "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
        "e), InitPlan.Field(name='elastic_file_system', annotation=OpRef(name='init.fields.8.annotation'), default=OpRe"
        "f(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
        "E, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('internet_"
        "gateway', 'egress_only_internet_gateway', 'nat_gateway', 'virtual_private_gateway', 'vpc_peering', 'lambda_', "
        "'vpc_lattice', 'elastic_file_system'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_"
        "fns=()), ReprPlan(fields=(ReprPlan.Field(name='internet_gateway', kw_only=True, fn=None), ReprPlan.Field(name="
        "'egress_only_internet_gateway', kw_only=True, fn=None), ReprPlan.Field(name='nat_gateway', kw_only=True, fn=No"
        "ne), ReprPlan.Field(name='virtual_private_gateway', kw_only=True, fn=None), ReprPlan.Field(name='vpc_peering',"
        " kw_only=True, fn=None), ReprPlan.Field(name='lambda_', kw_only=True, fn=None), ReprPlan.Field(name='vpc_latti"
        "ce', kw_only=True, fn=None), ReprPlan.Field(name='elastic_file_system', kw_only=True, fn=None)), id=False, ter"
        "se=False, default_fn=None)))"
    ),
    plan_repr_sha1='8e5a61cba55eff4b4b1cbaafcda7e5d75c135da6',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
        '__dataclass__init__fields__8__annotation',
        '__dataclass__init__fields__8__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'VpcEncryptionControlExclusions'),
    ),
)
def _process_dataclass__8e5a61cba55eff4b4b1cbaafcda7e5d75c135da6():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__init__fields__8__annotation,
        __dataclass__init__fields__8__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                internet_gateway=self.internet_gateway,
                egress_only_internet_gateway=self.egress_only_internet_gateway,
                nat_gateway=self.nat_gateway,
                virtual_private_gateway=self.virtual_private_gateway,
                vpc_peering=self.vpc_peering,
                lambda_=self.lambda_,
                vpc_lattice=self.vpc_lattice,
                elastic_file_system=self.elastic_file_system,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.internet_gateway == other.internet_gateway and
                self.egress_only_internet_gateway == other.egress_only_internet_gateway and
                self.nat_gateway == other.nat_gateway and
                self.virtual_private_gateway == other.virtual_private_gateway and
                self.vpc_peering == other.vpc_peering and
                self.lambda_ == other.lambda_ and
                self.vpc_lattice == other.vpc_lattice and
                self.elastic_file_system == other.elastic_file_system
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'internet_gateway',
            'egress_only_internet_gateway',
            'nat_gateway',
            'virtual_private_gateway',
            'vpc_peering',
            'lambda_',
            'vpc_lattice',
            'elastic_file_system',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'internet_gateway',
            'egress_only_internet_gateway',
            'nat_gateway',
            'virtual_private_gateway',
            'vpc_peering',
            'lambda_',
            'vpc_lattice',
            'elastic_file_system',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.internet_gateway,
                self.egress_only_internet_gateway,
                self.nat_gateway,
                self.virtual_private_gateway,
                self.vpc_peering,
                self.lambda_,
                self.vpc_lattice,
                self.elastic_file_system,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            internet_gateway: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            egress_only_internet_gateway: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            nat_gateway: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            virtual_private_gateway: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            vpc_peering: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            lambda_: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            vpc_lattice: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
            elastic_file_system: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'internet_gateway', internet_gateway)
            __dataclass__object_setattr(self, 'egress_only_internet_gateway', egress_only_internet_gateway)
            __dataclass__object_setattr(self, 'nat_gateway', nat_gateway)
            __dataclass__object_setattr(self, 'virtual_private_gateway', virtual_private_gateway)
            __dataclass__object_setattr(self, 'vpc_peering', vpc_peering)
            __dataclass__object_setattr(self, 'lambda_', lambda_)
            __dataclass__object_setattr(self, 'vpc_lattice', vpc_lattice)
            __dataclass__object_setattr(self, 'elastic_file_system', elastic_file_system)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"internet_gateway={self.internet_gateway!r}")
            parts.append(f"egress_only_internet_gateway={self.egress_only_internet_gateway!r}")
            parts.append(f"nat_gateway={self.nat_gateway!r}")
            parts.append(f"virtual_private_gateway={self.virtual_private_gateway!r}")
            parts.append(f"vpc_peering={self.vpc_peering!r}")
            parts.append(f"lambda_={self.lambda_!r}")
            parts.append(f"vpc_lattice={self.vpc_lattice!r}")
            parts.append(f"elastic_file_system={self.elastic_file_system!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass


@_register(
    plan_repr=(
        "Plans(tup=(CopyPlan(fields=('association_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'network_border_grou"
        "p', 'ipv6_pool', 'ipv6_address_attribute', 'ip_source')), EqPlan(fields=('association_id', 'ipv6_cidr_block', "
        "'ipv6_cidr_block_state', 'network_border_group', 'ipv6_pool', 'ipv6_address_attribute', 'ip_source')), FrozenP"
        "lan(fields=('__shape__', 'association_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'network_border_group',"
        " 'ipv6_pool', 'ipv6_address_attribute', 'ip_source'), allow_dynamic_dunder_attrs=False), HashPlan(action='add'"
        ", fields=('association_id', 'ipv6_cidr_block', 'ipv6_cidr_block_state', 'network_border_group', 'ipv6_pool', '"
        "ipv6_address_attribute', 'ip_source'), cache=False), InitPlan(fields=(InitPlan.Field(name='__shape__', annotat"
        "ion=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fie"
        "ld_type=FieldType.CLASS_VAR, coerce=None, validate=None, check_type=None), InitPlan.Field(name='association_id"
        "', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_fac"
        "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
        "ne), InitPlan.Field(name='ipv6_cidr_block', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(n"
        "ame='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
        "coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_cidr_block_state', annotation=OpRef(na"
        "me='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, "
        "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
        "me='network_border_group', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields."
        "4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
        "date=None, check_type=None), InitPlan.Field(name='ipv6_pool', annotation=OpRef(name='init.fields.5.annotation'"
        "), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=Fi"
        "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ipv6_address_attribute', "
        "annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factor"
        "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
        ", InitPlan.Field(name='ip_source', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init"
        ".fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
        "ne, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('association_id', 'ipv"
        "6_cidr_block', 'ipv6_cidr_block_state', 'network_border_group', 'ipv6_pool', 'ipv6_address_attribute', 'ip_sou"
        "rce'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPl"
        "an.Field(name='association_id', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_cidr_block', kw_only=True, f"
        "n=None), ReprPlan.Field(name='ipv6_cidr_block_state', kw_only=True, fn=None), ReprPlan.Field(name='network_bor"
        "der_group', kw_only=True, fn=None), ReprPlan.Field(name='ipv6_pool', kw_only=True, fn=None), ReprPlan.Field(na"
        "me='ipv6_address_attribute', kw_only=True, fn=None), ReprPlan.Field(name='ip_source', kw_only=True, fn=None)),"
        " id=False, terse=False, default_fn=None)))"
    ),
    plan_repr_sha1='e23ed4d9f733a3418bb8ffcecaf739c352fd48ac',
    op_ref_idents=(
        '__dataclass__init__fields__1__annotation',
        '__dataclass__init__fields__1__default',
        '__dataclass__init__fields__2__annotation',
        '__dataclass__init__fields__2__default',
        '__dataclass__init__fields__3__annotation',
        '__dataclass__init__fields__3__default',
        '__dataclass__init__fields__4__annotation',
        '__dataclass__init__fields__4__default',
        '__dataclass__init__fields__5__annotation',
        '__dataclass__init__fields__5__default',
        '__dataclass__init__fields__6__annotation',
        '__dataclass__init__fields__6__default',
        '__dataclass__init__fields__7__annotation',
        '__dataclass__init__fields__7__default',
    ),
    cls_names=(
        ('ominfra.clouds.aws.models.services.ec2', 'VpcIpv6CidrBlockAssociation'),
    ),
)
def _process_dataclass__e23ed4d9f733a3418bb8ffcecaf739c352fd48ac():
    def _process_dataclass(
        *,
        __dataclass__cls,
        __dataclass__init__fields__1__annotation,
        __dataclass__init__fields__1__default,
        __dataclass__init__fields__2__annotation,
        __dataclass__init__fields__2__default,
        __dataclass__init__fields__3__annotation,
        __dataclass__init__fields__3__default,
        __dataclass__init__fields__4__annotation,
        __dataclass__init__fields__4__default,
        __dataclass__init__fields__5__annotation,
        __dataclass__init__fields__5__default,
        __dataclass__init__fields__6__annotation,
        __dataclass__init__fields__6__default,
        __dataclass__init__fields__7__annotation,
        __dataclass__init__fields__7__default,
        __dataclass__FieldFnValidationError,  # noqa
        __dataclass__FieldTypeValidationError,  # noqa
        __dataclass__FnValidationError,  # noqa
        __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
        __dataclass__FunctionType=types.FunctionType,  # noqa
        __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
        __dataclass__MISSING=dataclasses.MISSING,  # noqa
        __dataclass__None=None,  # noqa
        __dataclass__TypeError=TypeError,  # noqa
        __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
        __dataclass__isinstance=isinstance,  # noqa
        __dataclass__object_setattr=object.__setattr__,  # noqa
        __dataclass__property=property,  # noqa
    ):
        def __copy__(self):
            if self.__class__ is not __dataclass__cls:
                raise TypeError(self)
            return __dataclass__cls(  # noqa
                association_id=self.association_id,
                ipv6_cidr_block=self.ipv6_cidr_block,
                ipv6_cidr_block_state=self.ipv6_cidr_block_state,
                network_border_group=self.network_border_group,
                ipv6_pool=self.ipv6_pool,
                ipv6_address_attribute=self.ipv6_address_attribute,
                ip_source=self.ip_source,
            )

        __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
        if '__copy__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__copy__', __copy__)

        def __eq__(self, other):
            if self is other:
                return True
            if self.__class__ is not other.__class__:
                return NotImplemented
            return (
                self.association_id == other.association_id and
                self.ipv6_cidr_block == other.ipv6_cidr_block and
                self.ipv6_cidr_block_state == other.ipv6_cidr_block_state and
                self.network_border_group == other.network_border_group and
                self.ipv6_pool == other.ipv6_pool and
                self.ipv6_address_attribute == other.ipv6_address_attribute and
                self.ip_source == other.ip_source
            )

        __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
        if '__eq__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__eq__', __eq__)

        __dataclass___setattr_frozen_fields = {
            '__shape__',
            'association_id',
            'ipv6_cidr_block',
            'ipv6_cidr_block_state',
            'network_border_group',
            'ipv6_pool',
            'ipv6_address_attribute',
            'ip_source',
        }

        def __setattr__(self, name, value):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___setattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
            super(__dataclass__cls, self).__setattr__(name, value)

        __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
        if '__setattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__setattr__', __setattr__)

        __dataclass___delattr_frozen_fields = {
            '__shape__',
            'association_id',
            'ipv6_cidr_block',
            'ipv6_cidr_block_state',
            'network_border_group',
            'ipv6_pool',
            'ipv6_address_attribute',
            'ip_source',
        }

        def __delattr__(self, name):
            if (
                type(self) is __dataclass__cls
                 or name in __dataclass___delattr_frozen_fields
            ):
                raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
            super(__dataclass__cls, self).__delattr__(name)

        __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
        if '__delattr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__delattr__', __delattr__)

        def __hash__(self):
            return hash((
                self.association_id,
                self.ipv6_cidr_block,
                self.ipv6_cidr_block_state,
                self.network_border_group,
                self.ipv6_pool,
                self.ipv6_address_attribute,
                self.ip_source,
            ))

        __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
        setattr(__dataclass__cls, '__hash__', __hash__)

        def __init__(
            self,
            *,
            association_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
            ipv6_cidr_block: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
            ipv6_cidr_block_state: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
            network_border_group: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
            ipv6_pool: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
            ipv6_address_attribute: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
            ip_source: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        ) -> __dataclass__None:
            __dataclass__object_setattr(self, 'association_id', association_id)
            __dataclass__object_setattr(self, 'ipv6_cidr_block', ipv6_cidr_block)
            __dataclass__object_setattr(self, 'ipv6_cidr_block_state', ipv6_cidr_block_state)
            __dataclass__object_setattr(self, 'network_border_group', network_border_group)
            __dataclass__object_setattr(self, 'ipv6_pool', ipv6_pool)
            __dataclass__object_setattr(self, 'ipv6_address_attribute', ipv6_address_attribute)
            __dataclass__object_setattr(self, 'ip_source', ip_source)

        __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
        if '__init__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__init__', __init__)

        @__dataclass___recursive_repr()
        def __repr__(self):
            parts = []
            parts.append(f"association_id={self.association_id!r}")
            parts.append(f"ipv6_cidr_block={self.ipv6_cidr_block!r}")
            parts.append(f"ipv6_cidr_block_state={self.ipv6_cidr_block_state!r}")
            parts.append(f"network_border_group={self.network_border_group!r}")
            parts.append(f"ipv6_pool={self.ipv6_pool!r}")
            parts.append(f"ipv6_address_attribute={self.ipv6_address_attribute!r}")
            parts.append(f"ip_source={self.ip_source!r}")
            return (
                f"{self.__class__.__qualname__}("
                f"{', '.join(parts)}"
                f")"
            )

        __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
        if '__repr__' in __dataclass__cls.__dict__:
            raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
        setattr(__dataclass__cls, '__repr__', __repr__)

    return _process_dataclass
