import typing as ta


Nodes: ta.TypeAlias = list['Node']


##
# Node classes.
#
# A parser returns a parse tree of Node objects. Usually one would then walk the node tree with a visitor object to do
# whatever. A NodeVisitor class, found below, implements basic reflective visitor.


class Node:
    """Node objects are used to build parse trees."""

    __slots__ = ('name', 'children', '_value')

    def __init__(self, name: str, *children: 'Node') -> None:
        super().__init__()

        self.name = name
        self.children = list(children)
        self._value = ''.join([child.value for child in children])

    @property
    def value(self) -> str:
        """Returns the node value as generated by a parser."""

        return self._value

    def __str__(self) -> str:
        return f'Node({self.name!r}{f", [{", ".join(map(str, self.children))}]" if self.children else ""})'

    def __eq__(self, other: object):
        return (
                type(other) is type(self) and
                self.name == other.name and  # type: ignore[attr-defined]
                self.children == other.children  # type: ignore[attr-defined]
        )


class LiteralNode:
    """LiteralNode objects are used to build parse trees."""

    __slots__ = ('name', 'value', 'offset', 'length')

    def __init__(self, value: str, offset: int, length: int) -> None:
        super().__init__()

        self.name = 'literal'
        self.value = value
        self.offset = offset
        self.length = length

    @property
    def children(self) -> list[Node]:
        """Returns an empty list of children, since LiteralNodes are terminal."""

        return []

    def __str__(self):
        return f'Node({self.name!r}, {self.value!r}, {self.offset!r})'

    def __eq__(self, other: object):
        return (
                type(other) is type(self) and
                self.value == other.value and  # type: ignore[attr-defined]
                self.offset == other.offset and  # type: ignore[attr-defined]
                self.length == other.length  # type: ignore[attr-defined]
        )


class NodeVisitor:
    """An external visitor class."""

    def __init__(self) -> None:
        super().__init__()

        self._node_method_cache = {}
        method_prefix = 'visit_'
        name_start = len(method_prefix)
        self._node_method_cache = {
            attr[name_start:]: getattr(self, attr)
            for attr in dir(self)
            if attr.startswith(method_prefix)
        }

    def __call__(self, node: Node):
        return self.visit(node)

    def visit(self, node: Node) -> ta.Any:
        """Visit node. This method invokes the appropriate method for the node type."""

        return self._node_method_cache.get(
            node.name.replace('-', '_').casefold(),
            lambda _: None,
        )(node)
