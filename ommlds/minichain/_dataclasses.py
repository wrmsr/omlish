# @omlish-generated
# type: ignore
# ruff: noqa
# flake8: noqa
import dataclasses
import reprlib
import types


##


REGISTRY = {}


def _register(plan_repr):
    def inner(fn):
        REGISTRY[fn.__name__] = (plan_repr, fn)
        return fn
    return inner


##



@_register(
    "Plans(tup=(CopyPlan(fields=()), ReprPlan(fields=(), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fdataclasses_2fmetaclass_2fbases_2fData(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), FrozenPlan(fields=(), allow_dynamic_dunder_attrs=False), InitPlan(fields=(), self_"
    "param='self', std_params=(), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), vali"
    "date_fns=()), ReprPlan(fields=(), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fdataclasses_2fmetaclass_2fbases_2fFrozen(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=(), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=(), cache=False), InitPlan(fields=(), self_param='self', std_params=(), kw_only_params=(),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fdataclasses_2fmetaclass_2fbases_2fCase(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__omlish_2fdataclasses_2fmetaclass_2fbases_2fBox(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__omlish_2ftypedvalues_2fvalues_2fScalarTypedValue(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__omlish_2ftypedvalues_2fvalues_2fUniqueScalarTypedValue(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('cls', 'new', 'old')), EqPlan(fields=('cls', 'new', 'old')), HashPlan(action='set_none"
    "', fields=None, cache=None), InitPlan(fields=(InitPlan.Field(name='cls', annotation=OpRef(name='init.fields.0.anno"
    "tation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
    "e, validate=None, check_type=None), InitPlan.Field(name='new', annotation=OpRef(name='init.fields.1.annotation'), "
    "default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None), InitPlan.Field(name='old', annotation=OpRef(name='init.fields.2.annotation'), default=No"
    "ne, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None)), self_param='self', std_params=('cls', 'new', 'old'), kw_only_params=(), frozen=False, slots=False"
    ", post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='cls', kw_only=False,"
    " fn=None), ReprPlan.Field(name='new', kw_only=False, fn=None), ReprPlan.Field(name='old', kw_only=False, fn=None))"
    ", id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2ftypedvalues_2fcollection_2fDuplicateUniqueTypedValueError(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            cls=self.cls,
            new=self.new,
            old=self.old,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.cls == other.cls and
            self.new == other.new and
            self.old == other.old
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    setattr(__dataclass__cls, '__hash__', None)

    def __init__(
        self,
        cls: __dataclass__init__fields__0__annotation,
        new: __dataclass__init__fields__1__annotation,
        old: __dataclass__init__fields__2__annotation,
    ) -> __dataclass__None:
        self.cls = cls
        self.new = new
        self.old = old

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"cls={self.cls!r}")
        parts.append(f"new={self.new!r}")
        parts.append(f"old={self.old!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v_ty', 'l', 'x')), EqPlan(fields=('v_ty', 'l', 'x')), FrozenPlan(fields=('v_ty', 'l',"
    " 'x'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('v_ty', 'l', 'x'), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='v_ty', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
    "InitPlan.Field(name='l', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='x', annotation=OpRef(name='init.fields.2.annotation'), default=None, default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_"
    "params=('v_ty', 'l', 'x'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), valida"
    "te_fns=()), ReprPlan(fields=(ReprPlan.Field(name='v_ty', kw_only=False, fn=None), ReprPlan.Field(name='l', kw_only"
    "=False, fn=None), ReprPlan.Field(name='x', kw_only=False, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fmarshal_2fcomposite_2funions_2fliterals_2fLiteralUnionMarshaler(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v_ty=self.v_ty,
            l=self.l,
            x=self.x,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v_ty == other.v_ty and
            self.l == other.l and
            self.x == other.x
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v_ty',
        'l',
        'x',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v_ty',
        'l',
        'x',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v_ty,
            self.l,
            self.x,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v_ty: __dataclass__init__fields__0__annotation,
        l: __dataclass__init__fields__1__annotation,
        x: __dataclass__init__fields__2__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v_ty', v_ty)
        __dataclass__object_setattr(self, 'l', l)
        __dataclass__object_setattr(self, 'x', x)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"v_ty={self.v_ty!r}")
        parts.append(f"l={self.l!r}")
        parts.append(f"x={self.x!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v_ty', 'l', 'x')), EqPlan(fields=('v_ty', 'l', 'x')), FrozenPlan(fields=('v_ty', 'l',"
    " 'x'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('v_ty', 'l', 'x'), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='v_ty', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
    "InitPlan.Field(name='l', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='x', annotation=OpRef(name='init.fields.2.annotation'), default=None, default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_"
    "params=('v_ty', 'l', 'x'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), valida"
    "te_fns=()), ReprPlan(fields=(ReprPlan.Field(name='v_ty', kw_only=False, fn=None), ReprPlan.Field(name='l', kw_only"
    "=False, fn=None), ReprPlan.Field(name='x', kw_only=False, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fmarshal_2fcomposite_2funions_2fliterals_2fLiteralUnionUnmarshaler(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v_ty=self.v_ty,
            l=self.l,
            x=self.x,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v_ty == other.v_ty and
            self.l == other.l and
            self.x == other.x
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v_ty',
        'l',
        'x',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v_ty',
        'l',
        'x',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v_ty,
            self.l,
            self.x,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v_ty: __dataclass__init__fields__0__annotation,
        l: __dataclass__init__fields__1__annotation,
        x: __dataclass__init__fields__2__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v_ty', v_ty)
        __dataclass__object_setattr(self, 'l', l)
        __dataclass__object_setattr(self, 'x', x)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"v_ty={self.v_ty!r}")
        parts.append(f"l={self.l!r}")
        parts.append(f"x={self.x!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('tys', 'x')), EqPlan(fields=('tys', 'x')), FrozenPlan(fields=('tys', 'x'), allow_dynam"
    "ic_dunder_attrs=False), HashPlan(action='add', fields=('tys', 'x'), cache=False), InitPlan(fields=(InitPlan.Field("
    "name='tys', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='x', "
    "annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_"
    "param='self', std_params=('tys', 'x'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fn"
    "s=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='tys', kw_only=False, fn=None), ReprPlan.Field(name='"
    "x', kw_only=False, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fmarshal_2fcomposite_2funions_2fprimitives_2fPrimitiveUnionMarshaler(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            tys=self.tys,
            x=self.x,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.tys == other.tys and
            self.x == other.x
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'tys',
        'x',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'tys',
        'x',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.tys,
            self.x,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        tys: __dataclass__init__fields__0__annotation,
        x: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'tys', tys)
        __dataclass__object_setattr(self, 'x', x)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"tys={self.tys!r}")
        parts.append(f"x={self.x!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('tys',)), EqPlan(fields=('tys',)), FrozenPlan(fields=('tys',), allow_dynamic_dunder_at"
    "trs=False), HashPlan(action='add', fields=('tys',), cache=False), InitPlan(fields=(InitPlan.Field(name='tys', anno"
    "tation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_par"
    "am='self', std_params=('tys',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), v"
    "alidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='tys', kw_only=False, fn=None),), id=False, terse=False, def"
    "ault_fn=None)))"
)
def _process_dataclass__omlish_2fmarshal_2fcomposite_2funions_2fprimitives_2fPrimitiveUnionMarshalerFactory(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            tys=self.tys,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.tys == other.tys
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'tys',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'tys',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.tys,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        tys: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'tys', tys)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"tys={self.tys!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('tys', 'x')), EqPlan(fields=('tys', 'x')), FrozenPlan(fields=('tys', 'x'), allow_dynam"
    "ic_dunder_attrs=False), HashPlan(action='add', fields=('tys', 'x'), cache=False), InitPlan(fields=(InitPlan.Field("
    "name='tys', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='x', "
    "annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_"
    "param='self', std_params=('tys', 'x'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fn"
    "s=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='tys', kw_only=False, fn=None), ReprPlan.Field(name='"
    "x', kw_only=False, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fmarshal_2fcomposite_2funions_2fprimitives_2fPrimitiveUnionUnmarshaler(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            tys=self.tys,
            x=self.x,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.tys == other.tys and
            self.x == other.x
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'tys',
        'x',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'tys',
        'x',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.tys,
            self.x,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        tys: __dataclass__init__fields__0__annotation,
        x: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'tys', tys)
        __dataclass__object_setattr(self, 'x', x)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"tys={self.tys!r}")
        parts.append(f"x={self.x!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('tys',)), EqPlan(fields=('tys',)), FrozenPlan(fields=('tys',), allow_dynamic_dunder_at"
    "trs=False), HashPlan(action='add', fields=('tys',), cache=False), InitPlan(fields=(InitPlan.Field(name='tys', anno"
    "tation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_par"
    "am='self', std_params=('tys',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), v"
    "alidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='tys', kw_only=False, fn=None),), id=False, terse=False, def"
    "ault_fn=None)))"
)
def _process_dataclass__omlish_2fmarshal_2fcomposite_2funions_2fprimitives_2fPrimitiveUnionUnmarshalerFactory(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            tys=self.tys,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.tys == other.tys
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'tys',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'tys',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.tys,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        tys: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'tys', tys)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"tys={self.tys!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('omit_if', 'default', 'embed', 'generic_replace', 'no_marshal', 'no_unmarshal')), EqPl"
    "an(fields=('omit_if', 'default', 'embed', 'generic_replace', 'no_marshal', 'no_unmarshal')), FrozenPlan(fields=('o"
    "mit_if', 'default', 'embed', 'generic_replace', 'no_marshal', 'no_unmarshal'), allow_dynamic_dunder_attrs=False), "
    "HashPlan(action='add', fields=('omit_if', 'default', 'embed', 'generic_replace', 'no_marshal', 'no_unmarshal'), ca"
    "che=False), InitPlan(fields=(InitPlan.Field(name='omit_if', annotation=OpRef(name='init.fields.0.annotation'), def"
    "ault=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='default', annotation=OpRef(name='init.f"
    "ields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=OpRef(name='init.fields.1.check_type')), I"
    "nitPlan.Field(name='embed', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.d"
    "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
    "ne, check_type=None), InitPlan.Field(name='generic_replace', annotation=OpRef(name='init.fields.3.annotation'), de"
    "fault=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
    "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='no_marshal', annotation=OpRef(name='in"
    "it.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='no_unmarsh"
    "al', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_facto"
    "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), "
    "self_param='self', std_params=(), kw_only_params=('omit_if', 'default', 'embed', 'generic_replace', 'no_marshal', "
    "'no_unmarshal'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=("
    "ReprPlan.Field(name='omit_if', kw_only=True, fn=None), ReprPlan.Field(name='default', kw_only=True, fn=None), Repr"
    "Plan.Field(name='embed', kw_only=True, fn=None), ReprPlan.Field(name='generic_replace', kw_only=True, fn=None), Re"
    "prPlan.Field(name='no_marshal', kw_only=True, fn=None), ReprPlan.Field(name='no_unmarshal', kw_only=True, fn=None)"
    "), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fmarshal_2fobjects_2fmetadata_2fFieldOptions(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__check_type,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            omit_if=self.omit_if,
            default=self.default,
            embed=self.embed,
            generic_replace=self.generic_replace,
            no_marshal=self.no_marshal,
            no_unmarshal=self.no_unmarshal,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.omit_if == other.omit_if and
            self.default == other.default and
            self.embed == other.embed and
            self.generic_replace == other.generic_replace and
            self.no_marshal == other.no_marshal and
            self.no_unmarshal == other.no_unmarshal
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'omit_if',
        'default',
        'embed',
        'generic_replace',
        'no_marshal',
        'no_unmarshal',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'omit_if',
        'default',
        'embed',
        'generic_replace',
        'no_marshal',
        'no_unmarshal',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.omit_if,
            self.default,
            self.embed,
            self.generic_replace,
            self.no_marshal,
            self.no_unmarshal,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        omit_if: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        default: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        embed: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        generic_replace: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        no_marshal: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        no_unmarshal: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        if not __dataclass__isinstance(default, __dataclass__init__fields__1__check_type): 
            raise __dataclass__FieldTypeValidationError(
                obj=self,
                type=__dataclass__init__fields__1__check_type,
                field='default',
                value=default,
            )
        __dataclass__object_setattr(self, 'omit_if', omit_if)
        __dataclass__object_setattr(self, 'default', default)
        __dataclass__object_setattr(self, 'embed', embed)
        __dataclass__object_setattr(self, 'generic_replace', generic_replace)
        __dataclass__object_setattr(self, 'no_marshal', no_marshal)
        __dataclass__object_setattr(self, 'no_unmarshal', no_unmarshal)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"omit_if={self.omit_if!r}")
        parts.append(f"default={self.default!r}")
        parts.append(f"embed={self.embed!r}")
        parts.append(f"generic_replace={self.generic_replace!r}")
        parts.append(f"no_marshal={self.no_marshal!r}")
        parts.append(f"no_unmarshal={self.no_unmarshal!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'alts', 'options', 'marshaler', 'marshaler_factory', 'unmarshaler', 'unmarshal"
    "er_factory')), EqPlan(fields=('name', 'alts', 'options', 'marshaler', 'marshaler_factory', 'unmarshaler', 'unmarsh"
    "aler_factory')), FrozenPlan(fields=('name', 'alts', 'options', 'marshaler', 'marshaler_factory', 'unmarshaler', 'u"
    "nmarshaler_factory'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'alts', 'options',"
    " 'marshaler', 'marshaler_factory', 'unmarshaler', 'unmarshaler_factory'), cache=False), InitPlan(fields=(InitPlan."
    "Field(name='name', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'),"
    " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
    "_type=None), InitPlan.Field(name='alts', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='in"
    "it.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
    ", validate=None, check_type=None), InitPlan.Field(name='options', annotation=OpRef(name='init.fields.2.annotation'"
    "), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='marshaler', annotation=OpRef(name"
    "='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, overri"
    "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=OpRef(name='init.fields.3.check_ty"
    "pe')), InitPlan.Field(name='marshaler_factory', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(n"
    "ame='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='unmarshaler', annotation=OpRef(name='init.fields.5."
    "annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=OpRef(name='init.fields.5.check_type')), InitPlan."
    "Field(name='unmarshaler_factory', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fiel"
    "ds.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('name', 'alts', 'options', 'marshal"
    "er', 'marshaler_factory', 'unmarshaler', 'unmarshaler_factory'), frozen=True, slots=False, post_init_params=None, "
    "init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field"
    "(name='alts', kw_only=True, fn=None), ReprPlan.Field(name='options', kw_only=True, fn=None), ReprPlan.Field(name='"
    "marshaler', kw_only=True, fn=None), ReprPlan.Field(name='marshaler_factory', kw_only=True, fn=None), ReprPlan.Fiel"
    "d(name='unmarshaler', kw_only=True, fn=None), ReprPlan.Field(name='unmarshaler_factory', kw_only=True, fn=None)), "
    "id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fmarshal_2fobjects_2fmetadata_2fFieldMetadata(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__check_type,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__check_type,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            alts=self.alts,
            options=self.options,
            marshaler=self.marshaler,
            marshaler_factory=self.marshaler_factory,
            unmarshaler=self.unmarshaler,
            unmarshaler_factory=self.unmarshaler_factory,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.alts == other.alts and
            self.options == other.options and
            self.marshaler == other.marshaler and
            self.marshaler_factory == other.marshaler_factory and
            self.unmarshaler == other.unmarshaler and
            self.unmarshaler_factory == other.unmarshaler_factory
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'name',
        'alts',
        'options',
        'marshaler',
        'marshaler_factory',
        'unmarshaler',
        'unmarshaler_factory',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
        'alts',
        'options',
        'marshaler',
        'marshaler_factory',
        'unmarshaler',
        'unmarshaler_factory',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.alts,
            self.options,
            self.marshaler,
            self.marshaler_factory,
            self.unmarshaler,
            self.unmarshaler_factory,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        name: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        alts: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        options: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        marshaler: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        marshaler_factory: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        unmarshaler: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        unmarshaler_factory: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
    ) -> __dataclass__None:
        if not __dataclass__isinstance(marshaler, __dataclass__init__fields__3__check_type): 
            raise __dataclass__FieldTypeValidationError(
                obj=self,
                type=__dataclass__init__fields__3__check_type,
                field='marshaler',
                value=marshaler,
            )
        if not __dataclass__isinstance(unmarshaler, __dataclass__init__fields__5__check_type): 
            raise __dataclass__FieldTypeValidationError(
                obj=self,
                type=__dataclass__init__fields__5__check_type,
                field='unmarshaler',
                value=unmarshaler,
            )
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'alts', alts)
        __dataclass__object_setattr(self, 'options', options)
        __dataclass__object_setattr(self, 'marshaler', marshaler)
        __dataclass__object_setattr(self, 'marshaler_factory', marshaler_factory)
        __dataclass__object_setattr(self, 'unmarshaler', unmarshaler)
        __dataclass__object_setattr(self, 'unmarshaler_factory', unmarshaler_factory)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"alts={self.alts!r}")
        parts.append(f"options={self.options!r}")
        parts.append(f"marshaler={self.marshaler!r}")
        parts.append(f"marshaler_factory={self.marshaler_factory!r}")
        parts.append(f"unmarshaler={self.unmarshaler!r}")
        parts.append(f"unmarshaler_factory={self.unmarshaler_factory!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('field_naming', 'unknown_field', 'source_field', 'field_defaults', 'ignore_unknown')),"
    " EqPlan(fields=('field_naming', 'unknown_field', 'source_field', 'field_defaults', 'ignore_unknown')), FrozenPlan("
    "fields=('field_naming', 'unknown_field', 'source_field', 'field_defaults', 'ignore_unknown'), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('field_naming', 'unknown_field', 'source_field', 'field_defaults', '"
    "ignore_unknown'), cache=False), InitPlan(fields=(InitPlan.Field(name='field_naming', annotation=OpRef(name='init.f"
    "ields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='unknown_field'"
    ", annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='source_field', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields"
    ".2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None), InitPlan.Field(name='field_defaults', annotation=OpRef(name='init.fields.3.annotation'),"
    " default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ignore_unknown', annotation=OpRef(n"
    "ame='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_"
    "params=(), kw_only_params=('field_naming', 'unknown_field', 'source_field', 'field_defaults', 'ignore_unknown'), f"
    "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
    "e='field_naming', kw_only=True, fn=None), ReprPlan.Field(name='unknown_field', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='source_field', kw_only=True, fn=None), ReprPlan.Field(name='field_defaults', kw_only=True, fn=None), Rep"
    "rPlan.Field(name='ignore_unknown', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fmarshal_2fobjects_2fmetadata_2fObjectMetadata(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            field_naming=self.field_naming,
            unknown_field=self.unknown_field,
            source_field=self.source_field,
            field_defaults=self.field_defaults,
            ignore_unknown=self.ignore_unknown,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.field_naming == other.field_naming and
            self.unknown_field == other.unknown_field and
            self.source_field == other.source_field and
            self.field_defaults == other.field_defaults and
            self.ignore_unknown == other.ignore_unknown
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'field_naming',
        'unknown_field',
        'source_field',
        'field_defaults',
        'ignore_unknown',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'field_naming',
        'unknown_field',
        'source_field',
        'field_defaults',
        'ignore_unknown',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.field_naming,
            self.unknown_field,
            self.source_field,
            self.field_defaults,
            self.ignore_unknown,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        field_naming: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        unknown_field: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        source_field: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        field_defaults: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        ignore_unknown: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'field_naming', field_naming)
        __dataclass__object_setattr(self, 'unknown_field', unknown_field)
        __dataclass__object_setattr(self, 'source_field', source_field)
        __dataclass__object_setattr(self, 'field_defaults', field_defaults)
        __dataclass__object_setattr(self, 'ignore_unknown', ignore_unknown)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"field_naming={self.field_naming!r}")
        parts.append(f"unknown_field={self.unknown_field!r}")
        parts.append(f"source_field={self.source_field!r}")
        parts.append(f"field_defaults={self.field_defaults!r}")
        parts.append(f"ignore_unknown={self.ignore_unknown!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('unknown', 'source')), EqPlan(fields=('unknown', 'source')), FrozenPlan(fields=('unkno"
    "wn', 'source'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('unknown', 'source'), cache=Fals"
    "e), InitPlan(fields=(InitPlan.Field(name='unknown', annotation=OpRef(name='init.fields.0.annotation'), default=OpR"
    "ef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None), InitPlan.Field(name='source', annotation=OpRef(name='init.fields.1.a"
    "nnotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_p"
    "arams=('unknown', 'source'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
    "lan(fields=(ReprPlan.Field(name='unknown', kw_only=True, fn=None), ReprPlan.Field(name='source', kw_only=True, fn="
    "None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fmarshal_2fobjects_2fmetadata_2fObjectSpecials(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            unknown=self.unknown,
            source=self.source,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.unknown == other.unknown and
            self.source == other.source
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'unknown',
        'source',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'unknown',
        'source',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.unknown,
            self.source,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        unknown: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        source: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'unknown', unknown)
        __dataclass__object_setattr(self, 'source', source)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"unknown={self.unknown!r}")
        parts.append(f"source={self.source!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'type', 'marshal_name', 'unmarshal_names', 'metadata', 'options')), EqPlan(fie"
    "lds=('name', 'type', 'marshal_name', 'unmarshal_names', 'metadata', 'options')), FrozenPlan(fields=('name', 'type'"
    ", 'marshal_name', 'unmarshal_names', 'metadata', 'options'), allow_dynamic_dunder_attrs=False), HashPlan(action='a"
    "dd', fields=('name', 'type', 'marshal_name', 'unmarshal_names', 'metadata', 'options'), cache=False), InitPlan(fie"
    "lds=(InitPlan.Field(name='name', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='type', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='marshal_name', annotation=OpRef(name='init.fields.2.annotation'), default=None, default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='unmarshal_names', annotation=OpRef(name='init.fields.3.annotation'), default=None, default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='metadata', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default')"
    ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='options', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name"
    "='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('name', 'type', 'marshal"
    "_name', 'unmarshal_names', 'metadata', 'options'), frozen=True, slots=False, post_init_params=None, init_fns=(), v"
    "alidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='type', "
    "kw_only=True, fn=None), ReprPlan.Field(name='marshal_name', kw_only=True, fn=None), ReprPlan.Field(name='unmarshal"
    "_names', kw_only=True, fn=None), ReprPlan.Field(name='metadata', kw_only=True, fn=None), ReprPlan.Field(name='opti"
    "ons', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fmarshal_2fobjects_2fmetadata_2fFieldInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            type=self.type,
            marshal_name=self.marshal_name,
            unmarshal_names=self.unmarshal_names,
            metadata=self.metadata,
            options=self.options,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.type == other.type and
            self.marshal_name == other.marshal_name and
            self.unmarshal_names == other.unmarshal_names and
            self.metadata == other.metadata and
            self.options == other.options
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'name',
        'type',
        'marshal_name',
        'unmarshal_names',
        'metadata',
        'options',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
        'type',
        'marshal_name',
        'unmarshal_names',
        'metadata',
        'options',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.type,
            self.marshal_name,
            self.unmarshal_names,
            self.metadata,
            self.options,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        name: __dataclass__init__fields__0__annotation,
        type: __dataclass__init__fields__1__annotation,
        marshal_name: __dataclass__init__fields__2__annotation,
        unmarshal_names: __dataclass__init__fields__3__annotation,
        metadata: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        options: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'type', type)
        __dataclass__object_setattr(self, 'marshal_name', marshal_name)
        __dataclass__object_setattr(self, 'unmarshal_names', unmarshal_names)
        __dataclass__object_setattr(self, 'metadata', metadata)
        __dataclass__object_setattr(self, 'options', options)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"type={self.type!r}")
        parts.append(f"marshal_name={self.marshal_name!r}")
        parts.append(f"unmarshal_names={self.unmarshal_names!r}")
        parts.append(f"metadata={self.metadata!r}")
        parts.append(f"options={self.options!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('lst',)), EqPlan(fields=('lst',)), FrozenPlan(fields=('lst',), allow_dynamic_dunder_at"
    "trs=False), HashPlan(action='add', fields=('lst',), cache=False), InitPlan(fields=(InitPlan.Field(name='lst', anno"
    "tation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('lst',),"
    " kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(OpRef(name='init.init_fns.0'), OpRe"
    "f(name='init.init_fns.1'), OpRef(name='init.init_fns.2')), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name="
    "'lst', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fmarshal_2fobjects_2fmetadata_2fFieldInfos(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__init_fns__0,
    __dataclass__init__init_fns__1,
    __dataclass__init__init_fns__2,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            lst=self.lst,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.lst == other.lst
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'lst',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'lst',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.lst,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        lst: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'lst', lst)
        __dataclass__init__init_fns__0(self)
        __dataclass__init__init_fns__1(self)
        __dataclass__init__init_fns__2(self)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"lst={self.lst!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('fields', 'specials', 'attr_getter')), EqPlan(fields=('fields', 'specials', 'attr_gett"
    "er')), FrozenPlan(fields=('fields', 'specials', 'attr_getter'), allow_dynamic_dunder_attrs=False), HashPlan(action"
    "='add', fields=('fields', 'specials', 'attr_getter'), cache=False), InitPlan(fields=(InitPlan.Field(name='fields',"
    " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='specials', anno"
    "tation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
    "ield(name='attr_getter', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None)), self_param='self', std_params=('fields',), kw_only_params=('specials', 'attr_getter'), frozen="
    "True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='fie"
    "lds', kw_only=False, fn=None), ReprPlan.Field(name='specials', kw_only=True, fn=None), ReprPlan.Field(name='attr_g"
    "etter', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fmarshal_2fobjects_2fmarshal_2fObjectMarshaler(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            fields=self.fields,
            specials=self.specials,
            attr_getter=self.attr_getter,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.fields == other.fields and
            self.specials == other.specials and
            self.attr_getter == other.attr_getter
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'fields',
        'specials',
        'attr_getter',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'fields',
        'specials',
        'attr_getter',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.fields,
            self.specials,
            self.attr_getter,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        fields: __dataclass__init__fields__0__annotation,
        *,
        specials: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        attr_getter: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'fields', fields)
        __dataclass__object_setattr(self, 'specials', specials)
        __dataclass__object_setattr(self, 'attr_getter', attr_getter)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"fields={self.fields!r}")
        parts.append(f"specials={self.specials!r}")
        parts.append(f"attr_getter={self.attr_getter!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('dct', 'specials')), EqPlan(fields=('dct', 'specials')), FrozenPlan(fields=('dct', 'sp"
    "ecials'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('dct', 'specials'), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='dct', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='specials', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fie"
    "lds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None)), self_param='self', std_params=('dct',), kw_only_params=('specials',), frozen=True, s"
    "lots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='dct', kw_o"
    "nly=False, fn=None), ReprPlan.Field(name='specials', kw_only=True, fn=None)), id=False, terse=False, default_fn=No"
    "ne)))"
)
def _process_dataclass__omlish_2fmarshal_2fobjects_2fmarshal_2fSimpleObjectMarshalerFactory(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            dct=self.dct,
            specials=self.specials,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.dct == other.dct and
            self.specials == other.specials
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'dct',
        'specials',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'dct',
        'specials',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.dct,
            self.specials,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        dct: __dataclass__init__fields__0__annotation,
        *,
        specials: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'dct', dct)
        __dataclass__object_setattr(self, 'specials', specials)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"dct={self.dct!r}")
        parts.append(f"specials={self.specials!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('factory', 'fields_by_unmarshal_name', 'specials', 'defaults', 'embeds', 'embeds_by_un"
    "marshal_name', 'ignore_unknown')), EqPlan(fields=('factory', 'fields_by_unmarshal_name', 'specials', 'defaults', '"
    "embeds', 'embeds_by_unmarshal_name', 'ignore_unknown')), FrozenPlan(fields=('factory', 'fields_by_unmarshal_name',"
    " 'specials', 'defaults', 'embeds', 'embeds_by_unmarshal_name', 'ignore_unknown'), allow_dynamic_dunder_attrs=False"
    "), HashPlan(action='add', fields=('factory', 'fields_by_unmarshal_name', 'specials', 'defaults', 'embeds', 'embeds"
    "_by_unmarshal_name', 'ignore_unknown'), cache=False), InitPlan(fields=(InitPlan.Field(name='factory', annotation=O"
    "pRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=F"
    "ieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='fields_by_unmarshal_name', a"
    "nnotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, f"
    "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='specials', annota"
    "tion=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='defaults', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default')"
    ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='embeds', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name="
    "'init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
    "one, validate=None, check_type=None), InitPlan.Field(name='embeds_by_unmarshal_name', annotation=OpRef(name='init."
    "fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=Fals"
    "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='ignore_unknow"
    "n', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factor"
    "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), s"
    "elf_param='self', std_params=('factory', 'fields_by_unmarshal_name'), kw_only_params=('specials', 'defaults', 'emb"
    "eds', 'embeds_by_unmarshal_name', 'ignore_unknown'), frozen=True, slots=False, post_init_params=None, init_fns=(),"
    " validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='factory', kw_only=False, fn=None), ReprPlan.Field(name='f"
    "ields_by_unmarshal_name', kw_only=False, fn=None), ReprPlan.Field(name='specials', kw_only=True, fn=None), ReprPla"
    "n.Field(name='defaults', kw_only=True, fn=None), ReprPlan.Field(name='embeds', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='embeds_by_unmarshal_name', kw_only=True, fn=None), ReprPlan.Field(name='ignore_unknown', kw_only=True, f"
    "n=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fmarshal_2fobjects_2funmarshal_2fObjectUnmarshaler(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            factory=self.factory,
            fields_by_unmarshal_name=self.fields_by_unmarshal_name,
            specials=self.specials,
            defaults=self.defaults,
            embeds=self.embeds,
            embeds_by_unmarshal_name=self.embeds_by_unmarshal_name,
            ignore_unknown=self.ignore_unknown,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.factory == other.factory and
            self.fields_by_unmarshal_name == other.fields_by_unmarshal_name and
            self.specials == other.specials and
            self.defaults == other.defaults and
            self.embeds == other.embeds and
            self.embeds_by_unmarshal_name == other.embeds_by_unmarshal_name and
            self.ignore_unknown == other.ignore_unknown
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'factory',
        'fields_by_unmarshal_name',
        'specials',
        'defaults',
        'embeds',
        'embeds_by_unmarshal_name',
        'ignore_unknown',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'factory',
        'fields_by_unmarshal_name',
        'specials',
        'defaults',
        'embeds',
        'embeds_by_unmarshal_name',
        'ignore_unknown',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.factory,
            self.fields_by_unmarshal_name,
            self.specials,
            self.defaults,
            self.embeds,
            self.embeds_by_unmarshal_name,
            self.ignore_unknown,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        factory: __dataclass__init__fields__0__annotation,
        fields_by_unmarshal_name: __dataclass__init__fields__1__annotation,
        *,
        specials: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        defaults: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        embeds: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        embeds_by_unmarshal_name: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        ignore_unknown: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'factory', factory)
        __dataclass__object_setattr(self, 'fields_by_unmarshal_name', fields_by_unmarshal_name)
        __dataclass__object_setattr(self, 'specials', specials)
        __dataclass__object_setattr(self, 'defaults', defaults)
        __dataclass__object_setattr(self, 'embeds', embeds)
        __dataclass__object_setattr(self, 'embeds_by_unmarshal_name', embeds_by_unmarshal_name)
        __dataclass__object_setattr(self, 'ignore_unknown', ignore_unknown)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"factory={self.factory!r}")
        parts.append(f"fields_by_unmarshal_name={self.fields_by_unmarshal_name!r}")
        parts.append(f"specials={self.specials!r}")
        parts.append(f"defaults={self.defaults!r}")
        parts.append(f"embeds={self.embeds!r}")
        parts.append(f"embeds_by_unmarshal_name={self.embeds_by_unmarshal_name!r}")
        parts.append(f"ignore_unknown={self.ignore_unknown!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('dct', 'specials')), EqPlan(fields=('dct', 'specials')), FrozenPlan(fields=('dct', 'sp"
    "ecials'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('dct', 'specials'), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='dct', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='specials', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fie"
    "lds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None)), self_param='self', std_params=('dct',), kw_only_params=('specials',), frozen=True, s"
    "lots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='dct', kw_o"
    "nly=False, fn=None), ReprPlan.Field(name='specials', kw_only=True, fn=None)), id=False, terse=False, default_fn=No"
    "ne)))"
)
def _process_dataclass__omlish_2fmarshal_2fobjects_2funmarshal_2fSimpleObjectUnmarshalerFactory(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            dct=self.dct,
            specials=self.specials,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.dct == other.dct and
            self.specials == other.specials
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'dct',
        'specials',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'dct',
        'specials',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.dct,
            self.specials,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        dct: __dataclass__init__fields__0__annotation,
        *,
        specials: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'dct', dct)
        __dataclass__object_setattr(self, 'specials', specials)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"dct={self.dct!r}")
        parts.append(f"specials={self.specials!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('m',)), EqPlan(fields=('m',)), FrozenPlan(fields=('m',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('m',), cache=False), InitPlan(fields=(InitPlan.Field(name='m', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=OpRef(name='init.fields.0.default_factory'), in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=OpRef(name='init.fields.0.coerce'), validate=None, "
    "check_type=None),), self_param='self', std_params=('m',), kw_only_params=(), frozen=True, slots=False, post_init_p"
    "arams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='m', kw_only=False, fn=None),), id"
    "=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fmarshal_2ffactories_2ftypemap_2fTypeMapMarshalerFactory(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__coerce,
    __dataclass__init__fields__0__default_factory,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            m=self.m,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.m == other.m
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'm',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'm',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.m,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        m: __dataclass__init__fields__0__annotation = __dataclass__HAS_DEFAULT_FACTORY,
    ) -> __dataclass__None:
        if m is __dataclass__HAS_DEFAULT_FACTORY:
            m = __dataclass__init__fields__0__default_factory()
        m = __dataclass__init__fields__0__coerce(m)
        __dataclass__object_setattr(self, 'm', m)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"m={self.m!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('u',)), EqPlan(fields=('u',)), FrozenPlan(fields=('u',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('u',), cache=False), InitPlan(fields=(InitPlan.Field(name='u', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=OpRef(name='init.fields.0.default_factory'), in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=OpRef(name='init.fields.0.coerce'), validate=None, "
    "check_type=None),), self_param='self', std_params=('u',), kw_only_params=(), frozen=True, slots=False, post_init_p"
    "arams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='u', kw_only=False, fn=None),), id"
    "=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fmarshal_2ffactories_2ftypemap_2fTypeMapUnmarshalerFactory(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__coerce,
    __dataclass__init__fields__0__default_factory,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            u=self.u,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.u == other.u
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'u',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'u',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.u,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        u: __dataclass__init__fields__0__annotation = __dataclass__HAS_DEFAULT_FACTORY,
    ) -> __dataclass__None:
        if u is __dataclass__HAS_DEFAULT_FACTORY:
            u = __dataclass__init__fields__0__default_factory()
        u = __dataclass__init__fields__0__coerce(u)
        __dataclass__object_setattr(self, 'u', u)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"u={self.u!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ty',)), EqPlan(fields=('ty',)), FrozenPlan(fields=('ty',), allow_dynamic_dunder_attrs"
    "=False), HashPlan(action='add', fields=('ty',), cache=False), InitPlan(fields=(InitPlan.Field(name='ty', annotatio"
    "n=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('ty',), kw_on"
    "ly_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Rep"
    "rPlan.Field(name='ty', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fmarshal_2fsingular_2fprimitives_2fPrimitiveMarshalerUnmarshaler(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ty=self.ty,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ty == other.ty
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'ty',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'ty',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ty,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        ty: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ty', ty)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ty={self.ty!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'root')), EqPlan(fields=('name', 'root')), FrozenPlan(fields=('name', 'root'),"
    " allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'root'), cache=False), InitPlan(fields="
    "(InitPlan.Field(name='name', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
    ".Field(name='root', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self"
    "', std_params=('name', 'root'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), v"
    "alidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_only=False, fn=None), ReprPlan.Field(name='root',"
    " kw_only=False, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fjson_2fJsonSchema(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            root=self.root,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.root == other.root
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'name',
        'root',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
        'root',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.root,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        name: __dataclass__init__fields__0__annotation,
        root: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'root', root)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"root={self.root!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('tvs_rty',)), EqPlan(fields=('tvs_rty',)), HashPlan(action='set_none', fields=None, ca"
    "che=None), InitPlan(fields=(InitPlan.Field(name='tvs_rty', annotation=OpRef(name='init.fields.0.annotation'), defa"
    "ult=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
    "ne, check_type=None),), self_param='self', std_params=('tvs_rty',), kw_only_params=(), frozen=False, slots=False, "
    "post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='tvs_rty', kw_only=Fals"
    "e, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2f_00marshal_2f_00TypedValuesFieldMarshalerFactory(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            tvs_rty=self.tvs_rty,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.tvs_rty == other.tvs_rty
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    setattr(__dataclass__cls, '__hash__', None)

    def __init__(
        self,
        tvs_rty: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        self.tvs_rty = tvs_rty

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"tvs_rty={self.tvs_rty!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('tvs_rty',)), EqPlan(fields=('tvs_rty',)), HashPlan(action='set_none', fields=None, ca"
    "che=None), InitPlan(fields=(InitPlan.Field(name='tvs_rty', annotation=OpRef(name='init.fields.0.annotation'), defa"
    "ult=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
    "ne, check_type=None),), self_param='self', std_params=('tvs_rty',), kw_only_params=(), frozen=False, slots=False, "
    "post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='tvs_rty', kw_only=Fals"
    "e, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2f_00marshal_2f_00TypedValuesFieldUnmarshalerFactory(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            tvs_rty=self.tvs_rty,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.tvs_rty == other.tvs_rty
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    setattr(__dataclass__cls, '__hash__', None)

    def __init__(
        self,
        tvs_rty: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        self.tvs_rty = tvs_rty

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"tvs_rty={self.tvs_rty!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fllms_2ftypes_2fTopK(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fllms_2ftypes_2fTemperature(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fllms_2ftypes_2fMaxTokens(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fllms_2ftypes_2fMaxCompletionTokens(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fllms_2ftypes_2fFinishReasonOutput(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('input', 'output', 'total')), EqPlan(fields=('input', 'output', 'total')), FrozenPlan("
    "fields=('input', 'output', 'total'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('input', 'o"
    "utput', 'total'), cache=False), InitPlan(fields=(InitPlan.Field(name='input', annotation=OpRef(name='init.fields.0"
    ".annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='output', annotation=OpRef(name='init.fields.1.annota"
    "tion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None), InitPlan.Field(name='total', annotation=OpRef(name='init.fields.2.annotation'), "
    "default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None)), self_param='self', std_params=('input', 'output', 'total'), kw_only_params=(), frozen=T"
    "rue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='inpu"
    "t', kw_only=False, fn=None), ReprPlan.Field(name='output', kw_only=False, fn=None), ReprPlan.Field(name='total', k"
    "w_only=False, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fllms_2ftypes_2fTokenUsage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            input=self.input,
            output=self.output,
            total=self.total,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.input == other.input and
            self.output == other.output and
            self.total == other.total
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'input',
        'output',
        'total',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'input',
        'output',
        'total',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.input,
            self.output,
            self.total,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        input: __dataclass__init__fields__0__annotation,
        output: __dataclass__init__fields__1__annotation,
        total: __dataclass__init__fields__2__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'input', input)
        __dataclass__object_setattr(self, 'output', output)
        __dataclass__object_setattr(self, 'total', total)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"input={self.input!r}")
        parts.append(f"output={self.output!r}")
        parts.append(f"total={self.total!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fllms_2ftypes_2fTokenUsageOutput(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('module', 'attr')), EqPlan(fields=('module', 'attr')), FrozenPlan(fields=('module', 'a"
    "ttr'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('module', 'attr'), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='module', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='attr', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_p"
    "aram='self', std_params=('module', 'attr'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, in"
    "it_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='module', kw_only=False, fn=None), ReprPlan.Fiel"
    "d(name='attr', kw_only=False, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fregistries_2fmanifests_2fRegistryTypeManifest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            module=self.module,
            attr=self.attr,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.module == other.module and
            self.attr == other.attr
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'module',
        'attr',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'module',
        'attr',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.module,
            self.attr,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        module: __dataclass__init__fields__0__annotation,
        attr: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'module', module)
        __dataclass__object_setattr(self, 'attr', attr)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"module={self.module!r}")
        parts.append(f"attr={self.attr!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('module', 'attr', 'name', 'aliases', 'type')), EqPlan(fields=('module', 'attr', 'name'"
    ", 'aliases', 'type')), FrozenPlan(fields=('module', 'attr', 'name', 'aliases', 'type'), allow_dynamic_dunder_attrs"
    "=False), HashPlan(action='add', fields=('module', 'attr', 'name', 'aliases', 'type'), cache=False), InitPlan(field"
    "s=(InitPlan.Field(name='module', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='attr', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='name', annotation=OpRef(name='init.fields.2.annotation'), default=None, default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='a"
    "liases', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.4.annotation'), default=None, default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_"
    "param='self', std_params=('module', 'attr', 'name', 'aliases'), kw_only_params=('type',), frozen=True, slots=False"
    ", post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='module', kw_only=Fal"
    "se, fn=None), ReprPlan.Field(name='attr', kw_only=False, fn=None), ReprPlan.Field(name='name', kw_only=False, fn=N"
    "one), ReprPlan.Field(name='aliases', kw_only=False, fn=None), ReprPlan.Field(name='type', kw_only=True, fn=None)),"
    " id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fregistries_2fmanifests_2fRegistryManifest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            module=self.module,
            attr=self.attr,
            name=self.name,
            aliases=self.aliases,
            type=self.type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.module == other.module and
            self.attr == other.attr and
            self.name == other.name and
            self.aliases == other.aliases and
            self.type == other.type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'module',
        'attr',
        'name',
        'aliases',
        'type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'module',
        'attr',
        'name',
        'aliases',
        'type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.module,
            self.attr,
            self.name,
            self.aliases,
            self.type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        module: __dataclass__init__fields__0__annotation,
        attr: __dataclass__init__fields__1__annotation,
        name: __dataclass__init__fields__2__annotation,
        aliases: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        *,
        type: __dataclass__init__fields__4__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'module', module)
        __dataclass__object_setattr(self, 'attr', attr)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'aliases', aliases)
        __dataclass__object_setattr(self, 'type', type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"module={self.module!r}")
        parts.append(f"attr={self.attr!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"aliases={self.aliases!r}")
        parts.append(f"type={self.type!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'registry_type_manifests', 'unresolved_type_manifests')), EqPlan(fields=('name"
    "', 'registry_type_manifests', 'unresolved_type_manifests')), HashPlan(action='set_none', fields=None, cache=None),"
    " InitPlan(fields=(InitPlan.Field(name='name', annotation=OpRef(name='init.fields.0.annotation'), default=None, def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='registry_type_manifests', annotation=OpRef(name='init.fields.1.annotation'), default"
    "=None, default_factory=OpRef(name='init.fields.1.default_factory'), init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='unresolved_type_manifests', annotat"
    "ion=OpRef(name='init.fields.2.annotation'), default=None, default_factory=OpRef(name='init.fields.2.default_factor"
    "y'), init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self"
    "_param='self', std_params=('name', 'registry_type_manifests', 'unresolved_type_manifests'), kw_only_params=(), fro"
    "zen=False, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name"
    "='name', kw_only=False, fn=None), ReprPlan.Field(name='registry_type_manifests', kw_only=False, fn=None), ReprPlan"
    ".Field(name='unresolved_type_manifests', kw_only=False, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fregistries_2fregistry_2fRegistry_2f_00Module(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default_factory,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default_factory,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            registry_type_manifests=self.registry_type_manifests,
            unresolved_type_manifests=self.unresolved_type_manifests,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.registry_type_manifests == other.registry_type_manifests and
            self.unresolved_type_manifests == other.unresolved_type_manifests
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    setattr(__dataclass__cls, '__hash__', None)

    def __init__(
        self,
        name: __dataclass__init__fields__0__annotation,
        registry_type_manifests: __dataclass__init__fields__1__annotation = __dataclass__HAS_DEFAULT_FACTORY,
        unresolved_type_manifests: __dataclass__init__fields__2__annotation = __dataclass__HAS_DEFAULT_FACTORY,
    ) -> __dataclass__None:
        if registry_type_manifests is __dataclass__HAS_DEFAULT_FACTORY:
            registry_type_manifests = __dataclass__init__fields__1__default_factory()
        if unresolved_type_manifests is __dataclass__HAS_DEFAULT_FACTORY:
            unresolved_type_manifests = __dataclass__init__fields__2__default_factory()
        self.name = name
        self.registry_type_manifests = registry_type_manifests
        self.unresolved_type_manifests = unresolved_type_manifests

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"registry_type_manifests={self.registry_type_manifests!r}")
        parts.append(f"unresolved_type_manifests={self.unresolved_type_manifests!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('cls', 'module')), EqPlan(fields=('cls', 'module')), FrozenPlan(fields=('cls', 'module"
    "'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('cls', 'module'), cache=False), InitPlan(fie"
    "lds=(InitPlan.Field(name='cls', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=N"
    "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
    "lan.Field(name='module', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None)), self_param='self', std_params=('cls',), kw_only_params=('module',), frozen=True, slots=False, "
    "post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='cls', kw_only=False, f"
    "n=None), ReprPlan.Field(name='module', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fregistries_2fregistry_2fRegistry_2f_00RegisteredType(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            cls=self.cls,
            module=self.module,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.cls == other.cls and
            self.module == other.module
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'cls',
        'module',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'cls',
        'module',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.cls,
            self.module,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        cls: __dataclass__init__fields__0__annotation,
        *,
        module: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'cls', cls)
        __dataclass__object_setattr(self, 'module', module)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"cls={self.cls!r}")
        parts.append(f"module={self.module!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('orig_class', 'rty', 'tv_types', 'tv_types_set')), EqPlan(fields=('orig_class', 'rty',"
    " 'tv_types', 'tv_types_set')), FrozenPlan(fields=('orig_class', 'rty', 'tv_types', 'tv_types_set'), allow_dynamic_"
    "dunder_attrs=False), HashPlan(action='add', fields=('orig_class', 'rty', 'tv_types', 'tv_types_set'), cache=False)"
    ", InitPlan(fields=(InitPlan.Field(name='orig_class', annotation=OpRef(name='init.fields.0.annotation'), default=No"
    "ne, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None), InitPlan.Field(name='rty', annotation=OpRef(name='init.fields.1.annotation'), default=None, defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='tv_types', annotation=OpRef(name='init.fields.2.annotation'), default=None, default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='tv_types_set', annotation=OpRef(name='init.fields.3.annotation'), default=None, default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)),"
    " self_param='self', std_params=(), kw_only_params=('orig_class', 'rty', 'tv_types', 'tv_types_set'), frozen=True, "
    "slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='orig_clas"
    "s', kw_only=True, fn=None), ReprPlan.Field(name='rty', kw_only=True, fn=None), ReprPlan.Field(name='tv_types', kw_"
    "only=True, fn=None), ReprPlan.Field(name='tv_types_set', kw_only=True, fn=None)), id=False, terse=False, default_f"
    "n=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fservices_2f_00typedvalues_2f_00TypedValuesInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__3__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            orig_class=self.orig_class,
            rty=self.rty,
            tv_types=self.tv_types,
            tv_types_set=self.tv_types_set,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.orig_class == other.orig_class and
            self.rty == other.rty and
            self.tv_types == other.tv_types and
            self.tv_types_set == other.tv_types_set
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'orig_class',
        'rty',
        'tv_types',
        'tv_types_set',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'orig_class',
        'rty',
        'tv_types',
        'tv_types_set',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.orig_class,
            self.rty,
            self.tv_types,
            self.tv_types_set,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        orig_class: __dataclass__init__fields__0__annotation,
        rty: __dataclass__init__fields__1__annotation,
        tv_types: __dataclass__init__fields__2__annotation,
        tv_types_set: __dataclass__init__fields__3__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'orig_class', orig_class)
        __dataclass__object_setattr(self, 'rty', rty)
        __dataclass__object_setattr(self, 'tv_types', tv_types)
        __dataclass__object_setattr(self, 'tv_types_set', tv_types_set)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"orig_class={self.orig_class!r}")
        parts.append(f"rty={self.rty!r}")
        parts.append(f"tv_types={self.tv_types!r}")
        parts.append(f"tv_types_set={self.tv_types_set!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('tv',)), EqPlan(fields=('tv',)), HashPlan(action='set_none', fields=None, cache=None),"
    " InitPlan(fields=(InitPlan.Field(name='tv', annotation=OpRef(name='init.fields.0.annotation'), default=None, defau"
    "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
    "None),), self_param='self', std_params=('tv',), kw_only_params=(), frozen=False, slots=False, post_init_params=Non"
    "e, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='tv', kw_only=False, fn=None),), id=False, "
    "terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fservices_2f_00typedvalues_2f_00TypedValuesTypeError(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            tv=self.tv,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.tv == other.tv
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    setattr(__dataclass__cls, '__hash__', None)

    def __init__(
        self,
        tv: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        self.tv = tv

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"tv={self.tv!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v', '_options')), EqPlan(fields=('v', '_options')), FrozenPlan(fields=('v', '_options"
    "'), allow_dynamic_dunder_attrs=True), HashPlan(action='add', fields=('v', '_options'), cache=False), InitPlan(fiel"
    "ds=(InitPlan.Field(name='v', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
    ".Field(name='_options', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defau"
    "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=OpRef(name='init.fiel"
    "ds.1.coerce'), validate=None, check_type=None)), self_param='self', std_params=('v', '_options'), kw_only_params=("
    "), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field"
    "(name='v', kw_only=False, fn=None), ReprPlan.Field(name='_options', kw_only=False, fn=OpRef(name='repr.fns.1.fn'))"
    "), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fservices_2frequests_2fRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__coerce,
    __dataclass__init__fields__1__default,
    __dataclass__repr__fns__1__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
            _options=self._options,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v and
            self._options == other._options
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
        '_options',
    }

    def __setattr__(self, name, value):
        if (
            (
                type(self) is __dataclass__cls
                and not (len(name) > 4 and name[:2] == name[-2:] == "__")
            )
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
        '_options',
    }

    def __delattr__(self, name):
        if (
            (
                type(self) is __dataclass__cls
                and not (len(name) > 4 and name[:2] == name[-2:] == "__")
            )
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
            self._options,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
        _options: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        _options = __dataclass__init__fields__1__coerce(_options)
        __dataclass__object_setattr(self, 'v', v)
        __dataclass__object_setattr(self, '_options', _options)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        if (s := __dataclass__repr__fns__1__fn(self._options)) is not None:
            parts.append(f"{s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v', '_outputs')), EqPlan(fields=('v', '_outputs')), FrozenPlan(fields=('v', '_outputs"
    "'), allow_dynamic_dunder_attrs=True), HashPlan(action='add', fields=('v', '_outputs'), cache=False), InitPlan(fiel"
    "ds=(InitPlan.Field(name='v', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
    ".Field(name='_outputs', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defau"
    "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=OpRef(name='init.fiel"
    "ds.1.coerce'), validate=None, check_type=None)), self_param='self', std_params=('v', '_outputs'), kw_only_params=("
    "), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field"
    "(name='v', kw_only=False, fn=None), ReprPlan.Field(name='_outputs', kw_only=False, fn=OpRef(name='repr.fns.1.fn'))"
    "), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fservices_2fresponses_2fResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__coerce,
    __dataclass__init__fields__1__default,
    __dataclass__repr__fns__1__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
            _outputs=self._outputs,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v and
            self._outputs == other._outputs
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
        '_outputs',
    }

    def __setattr__(self, name, value):
        if (
            (
                type(self) is __dataclass__cls
                and not (len(name) > 4 and name[:2] == name[-2:] == "__")
            )
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
        '_outputs',
    }

    def __delattr__(self, name):
        if (
            (
                type(self) is __dataclass__cls
                and not (len(name) > 4 and name[:2] == name[-2:] == "__")
            )
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
            self._outputs,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
        _outputs: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        _outputs = __dataclass__init__fields__1__coerce(_outputs)
        __dataclass__object_setattr(self, 'v', v)
        __dataclass__object_setattr(self, '_outputs', _outputs)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        if (s := __dataclass__repr__fns__1__fn(self._outputs)) is not None:
            parts.append(f"{s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('service',)), EqPlan(fields=('service',)), FrozenPlan(fields=('service',), allow_dynam"
    "ic_dunder_attrs=True), HashPlan(action='add', fields=('service',), cache=False), InitPlan(fields=(InitPlan.Field(n"
    "ame='service', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', s"
    "td_params=('service',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_"
    "fns=()), ReprPlan(fields=(ReprPlan.Field(name='service', kw_only=False, fn=None),), id=False, terse=True, default_"
    "fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fservices_2ffacades_2fServiceFacade(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            service=self.service,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.service == other.service
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'service',
    }

    def __setattr__(self, name, value):
        if (
            (
                type(self) is __dataclass__cls
                and not (len(name) > 4 and name[:2] == name[-2:] == "__")
            )
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'service',
    }

    def __delattr__(self, name):
        if (
            (
                type(self) is __dataclass__cls
                and not (len(name) > 4 and name[:2] == name[-2:] == "__")
            )
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.service,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        service: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'service', service)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.service!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fmetadata_2fUuid(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fmetadata_2fCreatedAt(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fresources_2fUseResources(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('title', 'url', 'description', 'snippets')), EqPlan(fields=('title', 'url', 'descripti"
    "on', 'snippets')), FrozenPlan(fields=('title', 'url', 'description', 'snippets'), allow_dynamic_dunder_attrs=False"
    "), HashPlan(action='add', fields=('title', 'url', 'description', 'snippets'), cache=False), InitPlan(fields=(InitP"
    "lan.Field(name='title', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='url', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, ov"
    "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='de"
    "scription', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='snippets', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init."
    "fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('title', 'url', 'description', "
    "'snippets'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Repr"
    "Plan.Field(name='title', kw_only=True, fn=None), ReprPlan.Field(name='url', kw_only=True, fn=None), ReprPlan.Field"
    "(name='description', kw_only=True, fn=None), ReprPlan.Field(name='snippets', kw_only=True, fn=None)), id=False, te"
    "rse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fsearch_2fSearchHit(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            title=self.title,
            url=self.url,
            description=self.description,
            snippets=self.snippets,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.title == other.title and
            self.url == other.url and
            self.description == other.description and
            self.snippets == other.snippets
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'title',
        'url',
        'description',
        'snippets',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'title',
        'url',
        'description',
        'snippets',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.title,
            self.url,
            self.description,
            self.snippets,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        title: __dataclass__init__fields__0__annotation,
        url: __dataclass__init__fields__1__annotation,
        description: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        snippets: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'title', title)
        __dataclass__object_setattr(self, 'url', url)
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'snippets', snippets)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"title={self.title!r}")
        parts.append(f"url={self.url!r}")
        parts.append(f"description={self.description!r}")
        parts.append(f"snippets={self.snippets!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('l', 'total_results')), EqPlan(fields=('l', 'total_results')), FrozenPlan(fields=('l',"
    " 'total_results'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('l', 'total_results'), cache="
    "False), InitPlan(fields=(InitPlan.Field(name='l', annotation=OpRef(name='init.fields.0.annotation'), default=None,"
    " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
    "_type=None), InitPlan.Field(name='total_results', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef"
    "(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('l', 'total_results"
    "'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Fiel"
    "d(name='l', kw_only=True, fn=None), ReprPlan.Field(name='total_results', kw_only=True, fn=None)), id=False, terse="
    "False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fsearch_2fSearchHits(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            l=self.l,
            total_results=self.total_results,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.l == other.l and
            self.total_results == other.total_results
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'l',
        'total_results',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'l',
        'total_results',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.l,
            self.total_results,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        l: __dataclass__init__fields__0__annotation,
        total_results: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'l', l)
        __dataclass__object_setattr(self, 'total_results', total_results)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"l={self.l!r}")
        parts.append(f"total_results={self.total_results!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('key',)), EqPlan(fields=('key',)), FrozenPlan(fields=('key',), allow_dynamic_dunder_at"
    "trs=False), HashPlan(action='add', fields=('key',), cache=False), InitPlan(fields=(InitPlan.Field(name='key', anno"
    "tation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('key',),"
    " kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(field"
    "s=(ReprPlan.Field(name='key', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__omlish_2fsecrets_2fsecrets_2fSecretRef(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            key=self.key,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.key == other.key
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'key',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'key',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.key,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        key: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'key', key)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.key!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('fn',)), EqPlan(fields=('fn',)), FrozenPlan(fields=('fn',), allow_dynamic_dunder_attrs"
    "=False), HashPlan(action='add', fields=('fn',), cache=False), InitPlan(fields=(InitPlan.Field(name='fn', annotatio"
    "n=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('fn',), kw_on"
    "ly_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Rep"
    "rPlan.Field(name='fn', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fsecrets_2fsecrets_2fFnSecrets(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            fn=self.fn,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.fn == other.fn
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'fn',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'fn',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.fn,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        fn: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'fn', fn)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"fn={self.fn!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('fn', 'child')), EqPlan(fields=('fn', 'child')), FrozenPlan(fields=('fn', 'child'), al"
    "low_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('fn', 'child'), cache=False), InitPlan(fields=(Ini"
    "tPlan.Field(name='fn', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='child', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', st"
    "d_params=('fn', 'child'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validat"
    "e_fns=()), ReprPlan(fields=(ReprPlan.Field(name='fn', kw_only=False, fn=None), ReprPlan.Field(name='child', kw_onl"
    "y=False, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fsecrets_2fsecrets_2fTransformedSecrets(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            fn=self.fn,
            child=self.child,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.fn == other.fn and
            self.child == other.child
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'fn',
        'child',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'fn',
        'child',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.fn,
            self.child,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        fn: __dataclass__init__fields__0__annotation,
        child: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'fn', fn)
        __dataclass__object_setattr(self, 'child', child)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"fn={self.fn!r}")
        parts.append(f"child={self.child!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fstandard_2fDevice(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fstandard_2fApiUrl(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=OpRef(name='repr.fns.0.fn')),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fstandard_2fSecretConfig(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__repr__fns__0__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__fns__0__fn(self.v)) is not None:
            parts.append(f"v={s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=OpRef(name='repr.fns.0.fn')),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fstandard_2fApiKey(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__repr__fns__0__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__fns__0__fn(self.v)) is not None:
            parts.append(f"{s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(OpRef(name='init.init_fns.0'),), validate_fns=("
    ")), ReprPlan(fields=(ReprPlan.Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fstandard_2fDefaultOptions(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__init_fns__0,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)
        __dataclass__init__init_fns__0(self)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('service_cls', 'name', 'factory_fn')), FrozenPlan(fields=('service_cls', 'name', 'fact"
    "ory_fn'), allow_dynamic_dunder_attrs=False), InitPlan(fields=(InitPlan.Field(name='service_cls', annotation=OpRef("
    "name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='ini"
    "t.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
    "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='factory_fn', annotation=OpRef(name='init.f"
    "ields.2.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
    ", coerce=None, validate=None, check_type=None)), self_param='self', std_params=('service_cls', 'name', 'factory_fn"
    "'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fi"
    "elds=(ReprPlan.Field(name='service_cls', kw_only=False, fn=None), ReprPlan.Field(name='name', kw_only=False, fn=No"
    "ne), ReprPlan.Field(name='factory_fn', kw_only=False, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fbackends_2fcatalogs_2fsimple_2fSimpleBackendCatalogEntry(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            service_cls=self.service_cls,
            name=self.name,
            factory_fn=self.factory_fn,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    __dataclass___setattr_frozen_fields = {
        'service_cls',
        'name',
        'factory_fn',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'service_cls',
        'name',
        'factory_fn',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __init__(
        self,
        service_cls: __dataclass__init__fields__0__annotation,
        name: __dataclass__init__fields__1__annotation,
        factory_fn: __dataclass__init__fields__2__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'service_cls', service_cls)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'factory_fn', factory_fn)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"service_cls={self.service_cls!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"factory_fn={self.factory_fn!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fmodels_2fconfigs_2fModelName(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fmodels_2fconfigs_2fModelPath(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('namespace', 'repo', 'tag', 'path')), EqPlan(fields=('namespace', 'repo', 'tag', 'path"
    "')), FrozenPlan(fields=('namespace', 'repo', 'tag', 'path'), allow_dynamic_dunder_attrs=False), HashPlan(action='a"
    "dd', fields=('namespace', 'repo', 'tag', 'path'), cache=False), InitPlan(fields=(InitPlan.Field(name='namespace', "
    "annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='repo', annotatio"
    "n=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tag', annotation=OpRef(na"
    "me='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='path"
    "', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory"
    "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), se"
    "lf_param='self', std_params=('namespace', 'repo'), kw_only_params=('tag', 'path'), frozen=True, slots=False, post_"
    "init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='namespace', kw_only=False, "
    "fn=None), ReprPlan.Field(name='repo', kw_only=False, fn=None), ReprPlan.Field(name='tag', kw_only=True, fn=OpRef(n"
    "ame='repr.fns.2.fn')), ReprPlan.Field(name='path', kw_only=True, fn=OpRef(name='repr.fns.3.fn'))), id=False, terse"
    "=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fmodels_2fconfigs_2fModelRepo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__repr__fns__2__fn,
    __dataclass__repr__fns__3__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            namespace=self.namespace,
            repo=self.repo,
            tag=self.tag,
            path=self.path,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.namespace == other.namespace and
            self.repo == other.repo and
            self.tag == other.tag and
            self.path == other.path
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'namespace',
        'repo',
        'tag',
        'path',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'namespace',
        'repo',
        'tag',
        'path',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.namespace,
            self.repo,
            self.tag,
            self.path,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        namespace: __dataclass__init__fields__0__annotation,
        repo: __dataclass__init__fields__1__annotation,
        *,
        tag: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        path: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'namespace', namespace)
        __dataclass__object_setattr(self, 'repo', repo)
        __dataclass__object_setattr(self, 'tag', tag)
        __dataclass__object_setattr(self, 'path', path)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"namespace={self.namespace!r}")
        parts.append(f"repo={self.repo!r}")
        if (s := __dataclass__repr__fns__2__fn(self.tag)) is not None:
            parts.append(f"tag={s}")
        if (s := __dataclass__repr__fns__3__fn(self.path)) is not None:
            parts.append(f"path={s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=(), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=(), cache=False), InitPlan(fields=(), self_param='self', std_params=(), kw_only_params=(),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fbackends_2fstrings_2fparsing_2fParsedBackendString_2fModel(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name',)), EqPlan(fields=('name',)), FrozenPlan(fields=('name',), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('name',), cache=False), InitPlan(fields=(InitPlan.Field(name='name',"
    " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('na"
    "me',), kw_only_params=(), frozen=True, slots=False, post_init_params=(), init_fns=(), validate_fns=()), ReprPlan(f"
    "ields=(ReprPlan.Field(name='name', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fbackends_2fstrings_2fparsing_2fParsedBackendString_2fNameModel(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        name: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        self.__post_init__()

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('path',)), EqPlan(fields=('path',)), FrozenPlan(fields=('path',), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('path',), cache=False), InitPlan(fields=(InitPlan.Field(name='path',"
    " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('pa"
    "th',), kw_only_params=(), frozen=True, slots=False, post_init_params=(), init_fns=(), validate_fns=()), ReprPlan(f"
    "ields=(ReprPlan.Field(name='path', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fbackends_2fstrings_2fparsing_2fParsedBackendString_2fPathModel(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            path=self.path,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.path == other.path
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'path',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'path',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.path,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        path: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'path', path)
        self.__post_init__()

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"path={self.path!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('namespace', 'repo', 'tag', 'path')), EqPlan(fields=('namespace', 'repo', 'tag', 'path"
    "')), FrozenPlan(fields=('namespace', 'repo', 'tag', 'path'), allow_dynamic_dunder_attrs=False), HashPlan(action='a"
    "dd', fields=('namespace', 'repo', 'tag', 'path'), cache=False), InitPlan(fields=(InitPlan.Field(name='namespace', "
    "annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='repo', annotatio"
    "n=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tag', annotation=OpRef(na"
    "me='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='path"
    "', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory"
    "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), se"
    "lf_param='self', std_params=('namespace', 'repo'), kw_only_params=('tag', 'path'), frozen=True, slots=False, post_"
    "init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='namespace', kw_only=False, "
    "fn=None), ReprPlan.Field(name='repo', kw_only=False, fn=None), ReprPlan.Field(name='tag', kw_only=True, fn=None), "
    "ReprPlan.Field(name='path', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fbackends_2fstrings_2fparsing_2fParsedBackendString_2fRepoModel(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            namespace=self.namespace,
            repo=self.repo,
            tag=self.tag,
            path=self.path,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.namespace == other.namespace and
            self.repo == other.repo and
            self.tag == other.tag and
            self.path == other.path
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'namespace',
        'repo',
        'tag',
        'path',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'namespace',
        'repo',
        'tag',
        'path',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.namespace,
            self.repo,
            self.tag,
            self.path,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        namespace: __dataclass__init__fields__0__annotation,
        repo: __dataclass__init__fields__1__annotation,
        *,
        tag: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        path: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'namespace', namespace)
        __dataclass__object_setattr(self, 'repo', repo)
        __dataclass__object_setattr(self, 'tag', tag)
        __dataclass__object_setattr(self, 'path', path)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"namespace={self.namespace!r}")
        parts.append(f"repo={self.repo!r}")
        parts.append(f"tag={self.tag!r}")
        parts.append(f"path={self.path!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('backend', 'model')), EqPlan(fields=('backend', 'model')), FrozenPlan(fields=('backend"
    "', 'model'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('backend', 'model'), cache=False), "
    "InitPlan(fields=(InitPlan.Field(name='backend', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(n"
    "ame='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='model', annotation=OpRef(name='init.fields.1.annota"
    "tion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('backend', 'model'), frozen=T"
    "rue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='back"
    "end', kw_only=True, fn=OpRef(name='repr.fns.0.fn')), ReprPlan.Field(name='model', kw_only=True, fn=None)), id=Fals"
    "e, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fbackends_2fstrings_2fparsing_2fParsedBackendString(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__repr__fns__0__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            backend=self.backend,
            model=self.model,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.backend == other.backend and
            self.model == other.model
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'backend',
        'model',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'backend',
        'model',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.backend,
            self.model,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        backend: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        model: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'backend', backend)
        __dataclass__object_setattr(self, 'model', model)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__fns__0__fn(self.backend)) is not None:
            parts.append(f"backend={s}")
        parts.append(f"model={self.model!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('default', 'aliases')), EqPlan(fields=('default', 'aliases')), FrozenPlan(fields=('def"
    "ault', 'aliases'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('default', 'aliases'), cache="
    "False), InitPlan(fields=(InitPlan.Field(name='default', annotation=OpRef(name='init.fields.0.annotation'), default"
    "=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='aliases', annotation=OpRef(name='init.field"
    "s.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_o"
    "nly_params=('default', 'aliases'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
    " ReprPlan(fields=(ReprPlan.Field(name='default', kw_only=True, fn=None), ReprPlan.Field(name='aliases', kw_only=Tr"
    "ue, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fmodels_2fnames_2fModelNameCollection(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            default=self.default,
            aliases=self.aliases,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.default == other.default and
            self.aliases == other.aliases
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'default',
        'aliases',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'default',
        'aliases',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.default,
            self.aliases,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        default: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        aliases: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'default', default)
        __dataclass__object_setattr(self, 'aliases', aliases)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"default={self.default!r}")
        parts.append(f"aliases={self.aliases!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('_metadata',)), EqPlan(fields=('_metadata',)), FrozenPlan(fields=('_metadata',), allow"
    "_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('_metadata',), cache=False), InitPlan(fields=(InitPla"
    "n.Field(name='_metadata', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=OpRef(name='init.fi"
    "elds.0.coerce'), validate=None, check_type=None),), self_param='self', std_params=(), kw_only_params=('_metadata',"
    "), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field"
    "(name='_metadata', kw_only=True, fn=OpRef(name='repr.fns.0.fn')),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fcontent_2fsimple_2fSimpleExtendedContent(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__coerce,
    __dataclass__init__fields__0__default,
    __dataclass__repr__fns__0__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            _metadata=self._metadata,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self._metadata == other._metadata
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '_metadata',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '_metadata',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self._metadata,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        _metadata: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        _metadata = __dataclass__init__fields__0__coerce(_metadata)
        __dataclass__object_setattr(self, '_metadata', _metadata)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__fns__0__fn(self._metadata)) is not None:
            parts.append(f"_metadata={s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('_metadata',)), EqPlan(fields=('_metadata',)), FrozenPlan(fields=('_metadata',), allow"
    "_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('_metadata',), cache=False), InitPlan(fields=(InitPla"
    "n.Field(name='_metadata', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=OpRef(name='init.fi"
    "elds.0.coerce'), validate=None, check_type=None),), self_param='self', std_params=(), kw_only_params=('_metadata',"
    "), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field"
    "(name='_metadata', kw_only=True, fn=OpRef(name='repr.fns.0.fn')),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fcontent_2fsimple_2fSimpleSingleExtendedContent(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__coerce,
    __dataclass__init__fields__0__default,
    __dataclass__repr__fns__0__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            _metadata=self._metadata,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self._metadata == other._metadata
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '_metadata',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '_metadata',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self._metadata,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        _metadata: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        _metadata = __dataclass__init__fields__0__coerce(_metadata)
        __dataclass__object_setattr(self, '_metadata', _metadata)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__fns__0__fn(self._metadata)) is not None:
            parts.append(f"_metadata={s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('_metadata', 'i')), EqPlan(fields=('_metadata', 'i')), FrozenPlan(fields=('_metadata',"
    " 'i'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('_metadata', 'i'), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='_metadata', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='i"
    "nit.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=OpR"
    "ef(name='init.fields.0.coerce'), validate=None, check_type=None), InitPlan.Field(name='i', annotation=OpRef(name='"
    "init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('i',), kw_only_params=('_met"
    "adata',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPla"
    "n.Field(name='_metadata', kw_only=True, fn=OpRef(name='repr.fns.0.fn')), ReprPlan.Field(name='i', kw_only=False, f"
    "n=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fcontent_2fimages_2fImageContent(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__coerce,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__repr__fns__0__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            _metadata=self._metadata,
            i=self.i,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self._metadata == other._metadata and
            self.i == other.i
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '_metadata',
        'i',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '_metadata',
        'i',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self._metadata,
            self.i,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        i: __dataclass__init__fields__1__annotation,
        *,
        _metadata: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        _metadata = __dataclass__init__fields__0__coerce(_metadata)
        __dataclass__object_setattr(self, '_metadata', _metadata)
        __dataclass__object_setattr(self, 'i', i)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__fns__0__fn(self._metadata)) is not None:
            parts.append(f"_metadata={s}")
        parts.append(f"i={self.i!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name',)), FrozenPlan(fields=('name',), allow_dynamic_dunder_attrs=False), InitPlan(fi"
    "elds=(InitPlan.Field(name='name', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fiel"
    "ds.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None),), self_param='self', std_params=(), kw_only_params=('name',), frozen=True, slots=False"
    ", post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_only=True,"
    " fn=OpRef(name='repr.fns.0.fn')),), id=True, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fcontent_2fplaceholders_2fContentPlaceholder(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__repr__fns__0__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    __dataclass___setattr_frozen_fields = {
        'name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __init__(
        self,
        *,
        name: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__fns__0__fn(self.name)) is not None:
            parts.append(f"name={s}")
        return (
            f"{self.__class__.__qualname__}@{hex(id(self))[2:]}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('_metadata', 'l')), EqPlan(fields=('_metadata', 'l')), FrozenPlan(fields=('_metadata',"
    " 'l'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('_metadata', 'l'), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='_metadata', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='i"
    "nit.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=OpR"
    "ef(name='init.fields.0.coerce'), validate=None, check_type=None), InitPlan.Field(name='l', annotation=OpRef(name='"
    "init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('l',), kw_only_params=('_met"
    "adata',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPla"
    "n.Field(name='_metadata', kw_only=True, fn=OpRef(name='repr.fns.0.fn')), ReprPlan.Field(name='l', kw_only=False, f"
    "n=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fcontent_2fsequence_2fSequenceContent(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__coerce,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__repr__fns__0__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            _metadata=self._metadata,
            l=self.l,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self._metadata == other._metadata and
            self.l == other.l
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '_metadata',
        'l',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '_metadata',
        'l',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self._metadata,
            self.l,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        l: __dataclass__init__fields__1__annotation,
        *,
        _metadata: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        _metadata = __dataclass__init__fields__0__coerce(_metadata)
        __dataclass__object_setattr(self, '_metadata', _metadata)
        __dataclass__object_setattr(self, 'l', l)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__fns__0__fn(self._metadata)) is not None:
            parts.append(f"_metadata={s}")
        parts.append(f"l={self.l!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('_metadata', 'l')), EqPlan(fields=('_metadata', 'l')), FrozenPlan(fields=('_metadata',"
    " 'l'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('_metadata', 'l'), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='_metadata', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='i"
    "nit.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=OpR"
    "ef(name='init.fields.0.coerce'), validate=None, check_type=None), InitPlan.Field(name='l', annotation=OpRef(name='"
    "init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('l',), kw_only_params=('_met"
    "adata',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPla"
    "n.Field(name='_metadata', kw_only=True, fn=OpRef(name='repr.fns.0.fn')), ReprPlan.Field(name='l', kw_only=False, f"
    "n=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fcontent_2fsequence_2fInlineContent(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__coerce,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__repr__fns__0__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            _metadata=self._metadata,
            l=self.l,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self._metadata == other._metadata and
            self.l == other.l
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '_metadata',
        'l',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '_metadata',
        'l',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self._metadata,
            self.l,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        l: __dataclass__init__fields__1__annotation,
        *,
        _metadata: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        _metadata = __dataclass__init__fields__0__coerce(_metadata)
        __dataclass__object_setattr(self, '_metadata', _metadata)
        __dataclass__object_setattr(self, 'l', l)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__fns__0__fn(self._metadata)) is not None:
            parts.append(f"_metadata={s}")
        parts.append(f"l={self.l!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('_metadata', 'l')), EqPlan(fields=('_metadata', 'l')), FrozenPlan(fields=('_metadata',"
    " 'l'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('_metadata', 'l'), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='_metadata', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='i"
    "nit.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=OpR"
    "ef(name='init.fields.0.coerce'), validate=None, check_type=None), InitPlan.Field(name='l', annotation=OpRef(name='"
    "init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('l',), kw_only_params=('_met"
    "adata',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPla"
    "n.Field(name='_metadata', kw_only=True, fn=OpRef(name='repr.fns.0.fn')), ReprPlan.Field(name='l', kw_only=False, f"
    "n=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fcontent_2fsequence_2fBlockContent(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__coerce,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__repr__fns__0__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            _metadata=self._metadata,
            l=self.l,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self._metadata == other._metadata and
            self.l == other.l
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '_metadata',
        'l',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '_metadata',
        'l',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self._metadata,
            self.l,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        l: __dataclass__init__fields__1__annotation,
        *,
        _metadata: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        _metadata = __dataclass__init__fields__0__coerce(_metadata)
        __dataclass__object_setattr(self, '_metadata', _metadata)
        __dataclass__object_setattr(self, 'l', l)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__fns__0__fn(self._metadata)) is not None:
            parts.append(f"_metadata={s}")
        parts.append(f"l={self.l!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('_metadata', 's')), EqPlan(fields=('_metadata', 's')), FrozenPlan(fields=('_metadata',"
    " 's'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('_metadata', 's'), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='_metadata', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='i"
    "nit.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=OpR"
    "ef(name='init.fields.0.coerce'), validate=None, check_type=None), InitPlan.Field(name='s', annotation=OpRef(name='"
    "init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('s',), kw_only_params=('_met"
    "adata',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPla"
    "n.Field(name='_metadata', kw_only=True, fn=OpRef(name='repr.fns.0.fn')), ReprPlan.Field(name='s', kw_only=False, f"
    "n=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fcontent_2ftext_2fTextContent(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__coerce,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__repr__fns__0__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            _metadata=self._metadata,
            s=self.s,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self._metadata == other._metadata and
            self.s == other.s
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '_metadata',
        's',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '_metadata',
        's',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self._metadata,
            self.s,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        s: __dataclass__init__fields__1__annotation,
        *,
        _metadata: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        _metadata = __dataclass__init__fields__0__coerce(_metadata)
        __dataclass__object_setattr(self, '_metadata', _metadata)
        __dataclass__object_setattr(self, 's', s)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__fns__0__fn(self._metadata)) is not None:
            parts.append(f"_metadata={s}")
        parts.append(f"s={self.s!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=(), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=(), cache=False), InitPlan(fields=(), self_param='self', std_params=(), kw_only_params=(),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ftypes_2fToolDtype(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('type',)), EqPlan(fields=('type',)), FrozenPlan(fields=('type',), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('type',), cache=False), InitPlan(fields=(InitPlan.Field(name='type',"
    " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('ty"
    "pe',), kw_only_params=(), frozen=True, slots=False, post_init_params=(), init_fns=(), validate_fns=()), ReprPlan(f"
    "ields=(ReprPlan.Field(name='type', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ftypes_2fPrimitiveToolDtype(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            type=self.type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.type == other.type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        type: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'type', type)
        self.__post_init__()

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.type!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('args',)), EqPlan(fields=('args',)), FrozenPlan(fields=('args',), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('args',), cache=False), InitPlan(fields=(InitPlan.Field(name='args',"
    " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('ar"
    "gs',), kw_only_params=(), frozen=True, slots=False, post_init_params=(), init_fns=(), validate_fns=()), ReprPlan(f"
    "ields=(ReprPlan.Field(name='args', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ftypes_2fUnionToolDtype(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            args=self.args,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.args == other.args
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'args',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'args',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.args,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        args: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'args', args)
        self.__post_init__()

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.args!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('type',)), EqPlan(fields=('type',)), FrozenPlan(fields=('type',), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('type',), cache=False), InitPlan(fields=(InitPlan.Field(name='type',"
    " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('ty"
    "pe',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan"
    "(fields=(ReprPlan.Field(name='type', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ftypes_2fNullableToolDtype(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            type=self.type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.type == other.type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        type: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'type', type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.type!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('element',)), EqPlan(fields=('element',)), FrozenPlan(fields=('element',), allow_dynam"
    "ic_dunder_attrs=False), HashPlan(action='add', fields=('element',), cache=False), InitPlan(fields=(InitPlan.Field("
    "name='element', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', "
    "std_params=('element',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate"
    "_fns=()), ReprPlan(fields=(ReprPlan.Field(name='element', kw_only=False, fn=None),), id=False, terse=True, default"
    "_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ftypes_2fSequenceToolDtype(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            element=self.element,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.element == other.element
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'element',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'element',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.element,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        element: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'element', element)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.element!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('key', 'value')), EqPlan(fields=('key', 'value')), FrozenPlan(fields=('key', 'value'),"
    " allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('key', 'value'), cache=False), InitPlan(fields="
    "(InitPlan.Field(name='key', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None,"
    " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
    "Field(name='value', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self"
    "', std_params=('key', 'value'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), v"
    "alidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='key', kw_only=False, fn=None), ReprPlan.Field(name='value',"
    " kw_only=False, fn=None)), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ftypes_2fMappingToolDtype(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            key=self.key,
            value=self.value,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.key == other.key and
            self.value == other.value
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'key',
        'value',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'key',
        'value',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.key,
            self.value,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        key: __dataclass__init__fields__0__annotation,
        value: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'key', key)
        __dataclass__object_setattr(self, 'value', value)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.key!r}")
        parts.append(f"{self.value!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('elements',)), EqPlan(fields=('elements',)), FrozenPlan(fields=('elements',), allow_dy"
    "namic_dunder_attrs=False), HashPlan(action='add', fields=('elements',), cache=False), InitPlan(fields=(InitPlan.Fi"
    "eld(name='elements', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=T"
    "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='se"
    "lf', std_params=('elements',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), va"
    "lidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='elements', kw_only=False, fn=None),), id=False, terse=True, "
    "default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ftypes_2fTupleToolDtype(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            elements=self.elements,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.elements == other.elements
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'elements',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'elements',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.elements,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        elements: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'elements', elements)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.elements!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('type', 'values')), EqPlan(fields=('type', 'values')), FrozenPlan(fields=('type', 'val"
    "ues'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('type', 'values'), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='type', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
    "InitPlan.Field(name='values', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_p"
    "aram='self', std_params=('type', 'values'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, in"
    "it_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='type', kw_only=False, fn=None), ReprPlan.Field("
    "name='values', kw_only=False, fn=None)), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ftypes_2fEnumToolDtype(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            type=self.type,
            values=self.values,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.type == other.type and
            self.values == other.values
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'type',
        'values',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'type',
        'values',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.type,
            self.values,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        type: __dataclass__init__fields__0__annotation,
        values: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'type', type)
        __dataclass__object_setattr(self, 'values', values)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.type!r}")
        parts.append(f"{self.values!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('fields',)), EqPlan(fields=('fields',)), FrozenPlan(fields=('fields',), allow_dynamic_"
    "dunder_attrs=False), HashPlan(action='add', fields=('fields',), cache=False), InitPlan(fields=(InitPlan.Field(name"
    "='fields', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_p"
    "arams=('fields',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=("
    ")), ReprPlan(fields=(ReprPlan.Field(name='fields', kw_only=False, fn=None),), id=False, terse=True, default_fn=Non"
    "e)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ftypes_2fObjectToolDtype(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            fields=self.fields,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.fields == other.fields
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'fields',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'fields',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.fields,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        fields: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'fields', fields)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.fields!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'desc', 'type', 'required')), EqPlan(fields=('name', 'desc', 'type', 'required"
    "')), FrozenPlan(fields=('name', 'desc', 'type', 'required'), allow_dynamic_dunder_attrs=False), HashPlan(action='a"
    "dd', fields=('name', 'desc', 'type', 'required'), cache=False), InitPlan(fields=(InitPlan.Field(name='name', annot"
    "ation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, i"
    "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
    "eld(name='desc', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init"
    ".fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='required', annotation=OpRef(name='init.fields.3.annotation')"
    ", default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
    "pe.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('name',), kw_only_param"
    "s=('desc', 'type', 'required'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Re"
    "prPlan(fields=(ReprPlan.Field(name='name', kw_only=False, fn=None), ReprPlan.Field(name='desc', kw_only=True, fn=N"
    "one), ReprPlan.Field(name='type', kw_only=True, fn=None), ReprPlan.Field(name='required', kw_only=True, fn=None)),"
    " id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ftypes_2fToolParam(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            desc=self.desc,
            type=self.type,
            required=self.required,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.desc == other.desc and
            self.type == other.type and
            self.required == other.required
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'name',
        'desc',
        'type',
        'required',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
        'desc',
        'type',
        'required',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.desc,
            self.type,
            self.required,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        name: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        *,
        desc: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        type: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        required: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'desc', desc)
        __dataclass__object_setattr(self, 'type', type)
        __dataclass__object_setattr(self, 'required', required)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"desc={self.desc!r}")
        parts.append(f"type={self.type!r}")
        parts.append(f"required={self.required!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'desc', 'params', 'allow_additional_params', 'returns_desc', 'returns_type')),"
    " EqPlan(fields=('name', 'desc', 'params', 'allow_additional_params', 'returns_desc', 'returns_type')), FrozenPlan("
    "fields=('name', 'desc', 'params', 'allow_additional_params', 'returns_desc', 'returns_type'), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('name', 'desc', 'params', 'allow_additional_params', 'returns_desc',"
    " 'returns_type'), cache=False), InitPlan(fields=(InitPlan.Field(name='name', annotation=OpRef(name='init.fields.0."
    "annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='desc', annotation=OpRe"
    "f(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "params', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='allow_additional_params', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef"
    "(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None), InitPlan.Field(name='returns_desc', annotation=OpRef(name='init.fields"
    ".4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='returns_type', anno"
    "tation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_para"
    "m='self', std_params=('name',), kw_only_params=('desc', 'params', 'allow_additional_params', 'returns_desc', 'retu"
    "rns_type'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprP"
    "lan.Field(name='name', kw_only=False, fn=None), ReprPlan.Field(name='desc', kw_only=True, fn=None), ReprPlan.Field"
    "(name='params', kw_only=True, fn=None), ReprPlan.Field(name='allow_additional_params', kw_only=True, fn=None), Rep"
    "rPlan.Field(name='returns_desc', kw_only=True, fn=None), ReprPlan.Field(name='returns_type', kw_only=True, fn=None"
    ")), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ftypes_2fToolSpec(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            desc=self.desc,
            params=self.params,
            allow_additional_params=self.allow_additional_params,
            returns_desc=self.returns_desc,
            returns_type=self.returns_type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.desc == other.desc and
            self.params == other.params and
            self.allow_additional_params == other.allow_additional_params and
            self.returns_desc == other.returns_desc and
            self.returns_type == other.returns_type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'name',
        'desc',
        'params',
        'allow_additional_params',
        'returns_desc',
        'returns_type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
        'desc',
        'params',
        'allow_additional_params',
        'returns_desc',
        'returns_type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.desc,
            self.params,
            self.allow_additional_params,
            self.returns_desc,
            self.returns_type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        name: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        *,
        desc: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        params: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        allow_additional_params: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        returns_desc: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        returns_type: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'desc', desc)
        __dataclass__object_setattr(self, 'params', params)
        __dataclass__object_setattr(self, 'allow_additional_params', allow_additional_params)
        __dataclass__object_setattr(self, 'returns_desc', returns_desc)
        __dataclass__object_setattr(self, 'returns_type', returns_type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"desc={self.desc!r}")
        parts.append(f"params={self.params!r}")
        parts.append(f"allow_additional_params={self.allow_additional_params!r}")
        parts.append(f"returns_desc={self.returns_desc!r}")
        parts.append(f"returns_type={self.returns_type!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('id', 'name', 'args', 'raw_args')), EqPlan(fields=('id', 'name', 'args', 'raw_args')),"
    " FrozenPlan(fields=('id', 'name', 'args', 'raw_args'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', f"
    "ields=('id', 'name', 'args', 'raw_args'), cache=False), InitPlan(fields=(InitPlan.Field(name='id', annotation=OpRe"
    "f(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "name', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override="
    "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='args', an"
    "notation=OpRef(name='init.fields.2.annotation'), default=None, default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='raw_args', annotat"
    "ion=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='"
    "self', std_params=(), kw_only_params=('id', 'name', 'args', 'raw_args'), frozen=True, slots=False, post_init_param"
    "s=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='id', kw_only=True, fn=None), ReprPlan"
    ".Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='args', kw_only=True, fn=None), ReprPlan.Field(nam"
    "e='raw_args', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ftypes_2fToolUse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            id=self.id,
            name=self.name,
            args=self.args,
            raw_args=self.raw_args,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.id == other.id and
            self.name == other.name and
            self.args == other.args and
            self.raw_args == other.raw_args
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'id',
        'name',
        'args',
        'raw_args',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'id',
        'name',
        'args',
        'raw_args',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.id,
            self.name,
            self.args,
            self.raw_args,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        id: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        name: __dataclass__init__fields__1__annotation,
        args: __dataclass__init__fields__2__annotation,
        raw_args: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'args', args)
        __dataclass__object_setattr(self, 'raw_args', raw_args)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"id={self.id!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"args={self.args!r}")
        parts.append(f"raw_args={self.raw_args!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('id', 'name', 'c')), EqPlan(fields=('id', 'name', 'c')), FrozenPlan(fields=('id', 'nam"
    "e', 'c'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('id', 'name', 'c'), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='id', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init"
    ".fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation'), de"
    "fault=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None), InitPlan.Field(name='c', annotation=OpRef(name='init.fields.2.annotation'), default=None, "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None)), self_param='self', std_params=(), kw_only_params=('id', 'name', 'c'), frozen=True, slots=False, post_"
    "init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='id', kw_only=True, fn=None)"
    ", ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='c', kw_only=True, fn=None)), id=False, "
    "terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ftypes_2fToolUseResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            id=self.id,
            name=self.name,
            c=self.c,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.id == other.id and
            self.name == other.name and
            self.c == other.c
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'id',
        'name',
        'c',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'id',
        'name',
        'c',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.id,
            self.name,
            self.c,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        id: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        name: __dataclass__init__fields__1__annotation,
        c: __dataclass__init__fields__2__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'c', c)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"id={self.id!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"c={self.c!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('_metadata',)), EqPlan(fields=('_metadata',)), FrozenPlan(fields=('_metadata',), allow"
    "_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('_metadata',), cache=False), InitPlan(fields=(InitPla"
    "n.Field(name='_metadata', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=OpRef(name='init.fi"
    "elds.0.coerce'), validate=None, check_type=None),), self_param='self', std_params=(), kw_only_params=('_metadata',"
    "), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, t"
    "erse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fmessages_2fMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__coerce,
    __dataclass__init__fields__0__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            _metadata=self._metadata,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self._metadata == other._metadata
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '_metadata',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '_metadata',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self._metadata,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        _metadata: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        _metadata = __dataclass__init__fields__0__coerce(_metadata)
        __dataclass__object_setattr(self, '_metadata', _metadata)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('_metadata',)), EqPlan(fields=('_metadata',)), FrozenPlan(fields=('_metadata',), allow"
    "_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('_metadata',), cache=False), InitPlan(fields=(InitPla"
    "n.Field(name='_metadata', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=OpRef(name='init.fi"
    "elds.0.coerce'), validate=None, check_type=None),), self_param='self', std_params=(), kw_only_params=('_metadata',"
    "), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, t"
    "erse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fmessages_2fAnyUserMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__coerce,
    __dataclass__init__fields__0__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            _metadata=self._metadata,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self._metadata == other._metadata
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '_metadata',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '_metadata',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self._metadata,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        _metadata: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        _metadata = __dataclass__init__fields__0__coerce(_metadata)
        __dataclass__object_setattr(self, '_metadata', _metadata)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('_metadata',)), EqPlan(fields=('_metadata',)), FrozenPlan(fields=('_metadata',), allow"
    "_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('_metadata',), cache=False), InitPlan(fields=(InitPla"
    "n.Field(name='_metadata', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=OpRef(name='init.fi"
    "elds.0.coerce'), validate=None, check_type=None),), self_param='self', std_params=(), kw_only_params=('_metadata',"
    "), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, t"
    "erse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fmessages_2fAnyAiMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__coerce,
    __dataclass__init__fields__0__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            _metadata=self._metadata,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self._metadata == other._metadata
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '_metadata',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '_metadata',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self._metadata,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        _metadata: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        _metadata = __dataclass__init__fields__0__coerce(_metadata)
        __dataclass__object_setattr(self, '_metadata', _metadata)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('_metadata', 'c')), EqPlan(fields=('_metadata', 'c')), FrozenPlan(fields=('_metadata',"
    " 'c'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('_metadata', 'c'), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='_metadata', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='i"
    "nit.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=OpR"
    "ef(name='init.fields.0.coerce'), validate=None, check_type=None), InitPlan.Field(name='c', annotation=OpRef(name='"
    "init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('c',), kw_only_params=('_met"
    "adata',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPla"
    "n.Field(name='c', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fmessages_2fSystemMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__coerce,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            _metadata=self._metadata,
            c=self.c,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self._metadata == other._metadata and
            self.c == other.c
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '_metadata',
        'c',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '_metadata',
        'c',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self._metadata,
            self.c,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        c: __dataclass__init__fields__1__annotation,
        *,
        _metadata: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        _metadata = __dataclass__init__fields__0__coerce(_metadata)
        __dataclass__object_setattr(self, '_metadata', _metadata)
        __dataclass__object_setattr(self, 'c', c)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"c={self.c!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('_metadata', 'c', 'name')), EqPlan(fields=('_metadata', 'c', 'name')), FrozenPlan(fiel"
    "ds=('_metadata', 'c', 'name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('_metadata', 'c',"
    " 'name'), cache=False), InitPlan(fields=(InitPlan.Field(name='_metadata', annotation=OpRef(name='init.fields.0.ann"
    "otation'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=OpRef(name='init.fields.0.coerce'), validate=None, check_type=None), InitPlan.Field(n"
    "ame='c', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', "
    "annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_"
    "param='self', std_params=('c', 'name'), kw_only_params=('_metadata',), frozen=True, slots=False, post_init_params="
    "None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='c', kw_only=False, fn=None), ReprPlan.F"
    "ield(name='name', kw_only=False, fn=OpRef(name='repr.fns.2.fn'))), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fmessages_2fUserMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__coerce,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__repr__fns__2__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            _metadata=self._metadata,
            c=self.c,
            name=self.name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self._metadata == other._metadata and
            self.c == other.c and
            self.name == other.name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '_metadata',
        'c',
        'name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '_metadata',
        'c',
        'name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self._metadata,
            self.c,
            self.name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        c: __dataclass__init__fields__1__annotation,
        name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        *,
        _metadata: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        _metadata = __dataclass__init__fields__0__coerce(_metadata)
        __dataclass__object_setattr(self, '_metadata', _metadata)
        __dataclass__object_setattr(self, 'c', c)
        __dataclass__object_setattr(self, 'name', name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"c={self.c!r}")
        if (s := __dataclass__repr__fns__2__fn(self.name)) is not None:
            parts.append(f"name={s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('_metadata', 'c')), EqPlan(fields=('_metadata', 'c')), FrozenPlan(fields=('_metadata',"
    " 'c'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('_metadata', 'c'), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='_metadata', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='i"
    "nit.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=OpR"
    "ef(name='init.fields.0.coerce'), validate=None, check_type=None), InitPlan.Field(name='c', annotation=OpRef(name='"
    "init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_param"
    "s=('c',), kw_only_params=('_metadata',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fn"
    "s=()), ReprPlan(fields=(ReprPlan.Field(name='c', kw_only=False, fn=OpRef(name='repr.fns.1.fn')),), id=False, terse"
    "=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fmessages_2fAiMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__coerce,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__repr__fns__1__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            _metadata=self._metadata,
            c=self.c,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self._metadata == other._metadata and
            self.c == other.c
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '_metadata',
        'c',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '_metadata',
        'c',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self._metadata,
            self.c,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        c: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        *,
        _metadata: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        _metadata = __dataclass__init__fields__0__coerce(_metadata)
        __dataclass__object_setattr(self, '_metadata', _metadata)
        __dataclass__object_setattr(self, 'c', c)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__fns__1__fn(self.c)) is not None:
            parts.append(f"c={s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('_metadata', 'tu')), EqPlan(fields=('_metadata', 'tu')), FrozenPlan(fields=('_metadata"
    "', 'tu'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('_metadata', 'tu'), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='_metadata', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(nam"
    "e='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=OpRef(name='init.fields.0.coerce'), validate=None, check_type=None), InitPlan.Field(name='tu', annotation=OpRef(n"
    "ame='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldTy"
    "pe.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('tu',), kw_only_params="
    "('_metadata',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(R"
    "eprPlan.Field(name='tu', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fmessages_2fToolUseMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__coerce,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            _metadata=self._metadata,
            tu=self.tu,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self._metadata == other._metadata and
            self.tu == other.tu
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '_metadata',
        'tu',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '_metadata',
        'tu',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self._metadata,
            self.tu,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        tu: __dataclass__init__fields__1__annotation,
        *,
        _metadata: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        _metadata = __dataclass__init__fields__0__coerce(_metadata)
        __dataclass__object_setattr(self, '_metadata', _metadata)
        __dataclass__object_setattr(self, 'tu', tu)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"tu={self.tu!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('_metadata', 'tur')), EqPlan(fields=('_metadata', 'tur')), FrozenPlan(fields=('_metada"
    "ta', 'tur'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('_metadata', 'tur'), cache=False), "
    "InitPlan(fields=(InitPlan.Field(name='_metadata', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef"
    "(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=OpRef(name='init.fields.0.coerce'), validate=None, check_type=None), InitPlan.Field(name='tur', annotation=Op"
    "Ref(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('tur',), kw_only_p"
    "arams=('_metadata',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fie"
    "lds=(ReprPlan.Field(name='tur', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fmessages_2fToolUseResultMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__coerce,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            _metadata=self._metadata,
            tur=self.tur,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self._metadata == other._metadata and
            self.tur == other.tur
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '_metadata',
        'tur',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '_metadata',
        'tur',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self._metadata,
            self.tur,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        tur: __dataclass__init__fields__1__annotation,
        *,
        _metadata: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        _metadata = __dataclass__init__fields__0__coerce(_metadata)
        __dataclass__object_setattr(self, '_metadata', _metadata)
        __dataclass__object_setattr(self, 'tur', tur)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"tur={self.tur!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ms',)), EqPlan(fields=('ms',)), FrozenPlan(fields=('ms',), allow_dynamic_dunder_attrs"
    "=False), HashPlan(action='add', fields=('ms',), cache=False), InitPlan(fields=(InitPlan.Field(name='ms', annotatio"
    "n=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('ms',), kw_on"
    "ly_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Rep"
    "rPlan.Field(name='ms', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fchoices_2ftypes_2fAiChoice(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ms=self.ms,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ms == other.ms
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'ms',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'ms',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ms,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        ms: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ms', ms)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ms={self.ms!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('cls', 'ctor', 'is_np')), EqPlan(fields=('cls', 'ctor', 'is_np')), FrozenPlan(fields=("
    "'cls', 'ctor', 'is_np'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('cls', 'ctor', 'is_np')"
    ", cache=False), InitPlan(fields=(InitPlan.Field(name='cls', annotation=OpRef(name='init.fields.0.annotation'), def"
    "ault=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='ctor', annotation=OpRef(name='init.fields.1.annotation'), default=None"
    ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='is_np', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='"
    "init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
    "ne, validate=None, check_type=None)), self_param='self', std_params=('cls', 'ctor'), kw_only_params=('is_np',), fr"
    "ozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name"
    "='cls', kw_only=False, fn=None), ReprPlan.Field(name='ctor', kw_only=False, fn=None), ReprPlan.Field(name='is_np',"
    " kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fvectors_2ftypes_2f_00StorageImpl(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            cls=self.cls,
            ctor=self.ctor,
            is_np=self.is_np,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.cls == other.cls and
            self.ctor == other.ctor and
            self.is_np == other.is_np
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'cls',
        'ctor',
        'is_np',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'cls',
        'ctor',
        'is_np',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.cls,
            self.ctor,
            self.is_np,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        cls: __dataclass__init__fields__0__annotation,
        ctor: __dataclass__init__fields__1__annotation,
        *,
        is_np: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'cls', cls)
        __dataclass__object_setattr(self, 'ctor', ctor)
        __dataclass__object_setattr(self, 'is_np', is_np)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"cls={self.cls!r}")
        parts.append(f"ctor={self.ctor!r}")
        parts.append(f"is_np={self.is_np!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v', 'vec')), EqPlan(fields=('v', 'vec')), FrozenPlan(fields=('v', 'vec'), allow_dynam"
    "ic_dunder_attrs=False), HashPlan(action='add', fields=('v', 'vec'), cache=False), InitPlan(fields=(InitPlan.Field("
    "name='v', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overri"
    "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='vec', "
    "annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('v', "
    "'vec'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPla"
    "n(fields=(ReprPlan.Field(name='v', kw_only=False, fn=None), ReprPlan.Field(name='vec', kw_only=False, fn=None)), i"
    "d=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fvectors_2findex_2fVectorIndexed(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
            vec=self.vec,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v and
            self.vec == other.vec
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
        'vec',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
        'vec',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
            self.vec,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
        vec: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)
        __dataclass__object_setattr(self, 'vec', vec)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"v={self.v!r}")
        parts.append(f"vec={self.vec!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('vec', 'k')), EqPlan(fields=('vec', 'k')), FrozenPlan(fields=('vec', 'k'), allow_dynam"
    "ic_dunder_attrs=False), HashPlan(action='add', fields=('vec', 'k'), cache=False), InitPlan(fields=(InitPlan.Field("
    "name='vec', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='k', "
    "annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_"
    "param='self', std_params=('vec',), kw_only_params=('k',), frozen=True, slots=False, post_init_params=None, init_fn"
    "s=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='vec', kw_only=False, fn=None), ReprPlan.Field(name='"
    "k', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fvectors_2fsearch_2fVectorSearch(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            vec=self.vec,
            k=self.k,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.vec == other.vec and
            self.k == other.k
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'vec',
        'k',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'vec',
        'k',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.vec,
            self.k,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        vec: __dataclass__init__fields__0__annotation,
        *,
        k: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'vec', vec)
        __dataclass__object_setattr(self, 'k', k)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"vec={self.vec!r}")
        parts.append(f"k={self.k!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v', 'score')), EqPlan(fields=('v', 'score')), FrozenPlan(fields=('v', 'score'), allow"
    "_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('v', 'score'), cache=False), InitPlan(fields=(InitPla"
    "n.Field(name='v', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True"
    ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='score', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, overri"
    "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_par"
    "ams=('v', 'score'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns="
    "()), ReprPlan(fields=(ReprPlan.Field(name='v', kw_only=False, fn=None), ReprPlan.Field(name='score', kw_only=False"
    ", fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fvectors_2fsearch_2fVectorHit(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
            score=self.score,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v and
            self.score == other.score
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
        'score',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
        'score',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
            self.score,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
        score: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)
        __dataclass__object_setattr(self, 'score', score)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"v={self.v!r}")
        parts.append(f"score={self.score!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('l',)), EqPlan(fields=('l',)), FrozenPlan(fields=('l',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('l',), cache=False), InitPlan(fields=(InitPlan.Field(name='l', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('l',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='l', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fvectors_2fsearch_2fVectorHits(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            l=self.l,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.l == other.l
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'l',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'l',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.l,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        l: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'l', l)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"l={self.l!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('similarity',)), EqPlan(fields=('similarity',)), FrozenPlan(fields=('similarity',), al"
    "low_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('similarity',), cache=False), InitPlan(fields=(Ini"
    "tPlan.Field(name='similarity', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self"
    "_param='self', std_params=('similarity',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, ini"
    "t_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='similarity', kw_only=False, fn=None),), id=False"
    ", terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fvectors_2fsearch_2fVectorSearchSimilarity(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            similarity=self.similarity,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.similarity == other.similarity
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'similarity',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'similarity',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.similarity,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        similarity: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'similarity', similarity)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"similarity={self.similarity!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('query', 'auto_parameters', 'topic', 'search_depth', 'chunks_per_source', 'max_results"
    "', 'time_range', 'start_date', 'end_date', 'include_answer', 'include_raw_content', 'include_images', 'include_ima"
    "ge_descriptions', 'include_favicon', 'include_domains', 'exclude_domains', 'country')), EqPlan(fields=('query', 'a"
    "uto_parameters', 'topic', 'search_depth', 'chunks_per_source', 'max_results', 'time_range', 'start_date', 'end_dat"
    "e', 'include_answer', 'include_raw_content', 'include_images', 'include_image_descriptions', 'include_favicon', 'i"
    "nclude_domains', 'exclude_domains', 'country')), FrozenPlan(fields=('query', 'auto_parameters', 'topic', 'search_d"
    "epth', 'chunks_per_source', 'max_results', 'time_range', 'start_date', 'end_date', 'include_answer', 'include_raw_"
    "content', 'include_images', 'include_image_descriptions', 'include_favicon', 'include_domains', 'exclude_domains',"
    " 'country'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('query', 'auto_parameters', 'topic'"
    ", 'search_depth', 'chunks_per_source', 'max_results', 'time_range', 'start_date', 'end_date', 'include_answer', 'i"
    "nclude_raw_content', 'include_images', 'include_image_descriptions', 'include_favicon', 'include_domains', 'exclud"
    "e_domains', 'country'), cache=False), InitPlan(fields=(InitPlan.Field(name='query', annotation=OpRef(name='init.fi"
    "elds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='auto_parameters', annotation=OpRef(name='init."
    "fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=Fals"
    "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='topic', annot"
    "ation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, i"
    "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
    "eld(name='search_depth', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='chunks_per_source', annotation=OpRef(name='init.fields.4.annotation'), def"
    "ault=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_results', annotation=OpRef(name='in"
    "it.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='time_range"
    "', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory"
    "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
    "tPlan.Field(name='start_date', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields."
    "7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='end_date', annotation=OpRef(name='init.fields.8.annotation'), defaul"
    "t=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
    "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='include_answer', annotation=OpRef(name='in"
    "it.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='include_ra"
    "w_content', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='include_images', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(na"
    "me='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='include_image_descriptions', annotation=OpRef(name="
    "'init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='inclu"
    "de_favicon', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13.default'), def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='include_domains', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef("
    "name='init.fields.14.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None), InitPlan.Field(name='exclude_domains', annotation=OpRef(name='init.fie"
    "lds.15.annotation'), default=OpRef(name='init.fields.15.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='country', anno"
    "tation=OpRef(name='init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_pa"
    "ram='self', std_params=(), kw_only_params=('query', 'auto_parameters', 'topic', 'search_depth', 'chunks_per_source"
    "', 'max_results', 'time_range', 'start_date', 'end_date', 'include_answer', 'include_raw_content', 'include_images"
    "', 'include_image_descriptions', 'include_favicon', 'include_domains', 'exclude_domains', 'country'), frozen=True,"
    " slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='query', "
    "kw_only=True, fn=None), ReprPlan.Field(name='auto_parameters', kw_only=True, fn=None), ReprPlan.Field(name='topic'"
    ", kw_only=True, fn=None), ReprPlan.Field(name='search_depth', kw_only=True, fn=None), ReprPlan.Field(name='chunks_"
    "per_source', kw_only=True, fn=None), ReprPlan.Field(name='max_results', kw_only=True, fn=None), ReprPlan.Field(nam"
    "e='time_range', kw_only=True, fn=None), ReprPlan.Field(name='start_date', kw_only=True, fn=None), ReprPlan.Field(n"
    "ame='end_date', kw_only=True, fn=None), ReprPlan.Field(name='include_answer', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='include_raw_content', kw_only=True, fn=None), ReprPlan.Field(name='include_images', kw_only=True, fn=None"
    "), ReprPlan.Field(name='include_image_descriptions', kw_only=True, fn=None), ReprPlan.Field(name='include_favicon'"
    ", kw_only=True, fn=None), ReprPlan.Field(name='include_domains', kw_only=True, fn=None), ReprPlan.Field(name='excl"
    "ude_domains', kw_only=True, fn=None), ReprPlan.Field(name='country', kw_only=True, fn=None)), id=False, terse=Fals"
    "e, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2ftavily_2fprotocol_2fSearchRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            query=self.query,
            auto_parameters=self.auto_parameters,
            topic=self.topic,
            search_depth=self.search_depth,
            chunks_per_source=self.chunks_per_source,
            max_results=self.max_results,
            time_range=self.time_range,
            start_date=self.start_date,
            end_date=self.end_date,
            include_answer=self.include_answer,
            include_raw_content=self.include_raw_content,
            include_images=self.include_images,
            include_image_descriptions=self.include_image_descriptions,
            include_favicon=self.include_favicon,
            include_domains=self.include_domains,
            exclude_domains=self.exclude_domains,
            country=self.country,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.query == other.query and
            self.auto_parameters == other.auto_parameters and
            self.topic == other.topic and
            self.search_depth == other.search_depth and
            self.chunks_per_source == other.chunks_per_source and
            self.max_results == other.max_results and
            self.time_range == other.time_range and
            self.start_date == other.start_date and
            self.end_date == other.end_date and
            self.include_answer == other.include_answer and
            self.include_raw_content == other.include_raw_content and
            self.include_images == other.include_images and
            self.include_image_descriptions == other.include_image_descriptions and
            self.include_favicon == other.include_favicon and
            self.include_domains == other.include_domains and
            self.exclude_domains == other.exclude_domains and
            self.country == other.country
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'query',
        'auto_parameters',
        'topic',
        'search_depth',
        'chunks_per_source',
        'max_results',
        'time_range',
        'start_date',
        'end_date',
        'include_answer',
        'include_raw_content',
        'include_images',
        'include_image_descriptions',
        'include_favicon',
        'include_domains',
        'exclude_domains',
        'country',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'query',
        'auto_parameters',
        'topic',
        'search_depth',
        'chunks_per_source',
        'max_results',
        'time_range',
        'start_date',
        'end_date',
        'include_answer',
        'include_raw_content',
        'include_images',
        'include_image_descriptions',
        'include_favicon',
        'include_domains',
        'exclude_domains',
        'country',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.query,
            self.auto_parameters,
            self.topic,
            self.search_depth,
            self.chunks_per_source,
            self.max_results,
            self.time_range,
            self.start_date,
            self.end_date,
            self.include_answer,
            self.include_raw_content,
            self.include_images,
            self.include_image_descriptions,
            self.include_favicon,
            self.include_domains,
            self.exclude_domains,
            self.country,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        query: __dataclass__init__fields__0__annotation,
        auto_parameters: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        topic: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        search_depth: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        chunks_per_source: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        max_results: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        time_range: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        start_date: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        end_date: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        include_answer: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        include_raw_content: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        include_images: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        include_image_descriptions: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        include_favicon: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        include_domains: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        exclude_domains: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        country: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'query', query)
        __dataclass__object_setattr(self, 'auto_parameters', auto_parameters)
        __dataclass__object_setattr(self, 'topic', topic)
        __dataclass__object_setattr(self, 'search_depth', search_depth)
        __dataclass__object_setattr(self, 'chunks_per_source', chunks_per_source)
        __dataclass__object_setattr(self, 'max_results', max_results)
        __dataclass__object_setattr(self, 'time_range', time_range)
        __dataclass__object_setattr(self, 'start_date', start_date)
        __dataclass__object_setattr(self, 'end_date', end_date)
        __dataclass__object_setattr(self, 'include_answer', include_answer)
        __dataclass__object_setattr(self, 'include_raw_content', include_raw_content)
        __dataclass__object_setattr(self, 'include_images', include_images)
        __dataclass__object_setattr(self, 'include_image_descriptions', include_image_descriptions)
        __dataclass__object_setattr(self, 'include_favicon', include_favicon)
        __dataclass__object_setattr(self, 'include_domains', include_domains)
        __dataclass__object_setattr(self, 'exclude_domains', exclude_domains)
        __dataclass__object_setattr(self, 'country', country)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"query={self.query!r}")
        parts.append(f"auto_parameters={self.auto_parameters!r}")
        parts.append(f"topic={self.topic!r}")
        parts.append(f"search_depth={self.search_depth!r}")
        parts.append(f"chunks_per_source={self.chunks_per_source!r}")
        parts.append(f"max_results={self.max_results!r}")
        parts.append(f"time_range={self.time_range!r}")
        parts.append(f"start_date={self.start_date!r}")
        parts.append(f"end_date={self.end_date!r}")
        parts.append(f"include_answer={self.include_answer!r}")
        parts.append(f"include_raw_content={self.include_raw_content!r}")
        parts.append(f"include_images={self.include_images!r}")
        parts.append(f"include_image_descriptions={self.include_image_descriptions!r}")
        parts.append(f"include_favicon={self.include_favicon!r}")
        parts.append(f"include_domains={self.include_domains!r}")
        parts.append(f"exclude_domains={self.exclude_domains!r}")
        parts.append(f"country={self.country!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('url', 'description')), EqPlan(fields=('url', 'description')), FrozenPlan(fields=('url"
    "', 'description'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('url', 'description'), cache="
    "False), InitPlan(fields=(InitPlan.Field(name='url', annotation=OpRef(name='init.fields.0.annotation'), default=OpR"
    "ef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None), InitPlan.Field(name='description', annotation=OpRef(name='init.field"
    "s.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_o"
    "nly_params=('url', 'description'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
    " ReprPlan(fields=(ReprPlan.Field(name='url', kw_only=True, fn=None), ReprPlan.Field(name='description', kw_only=Tr"
    "ue, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2ftavily_2fprotocol_2fSearchResponse_2fImage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            url=self.url,
            description=self.description,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.url == other.url and
            self.description == other.description
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'url',
        'description',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'url',
        'description',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.url,
            self.description,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        url: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        description: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'url', url)
        __dataclass__object_setattr(self, 'description', description)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"url={self.url!r}")
        parts.append(f"description={self.description!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('title', 'url', 'content', 'score', 'raw_content', 'favicon')), EqPlan(fields=('title'"
    ", 'url', 'content', 'score', 'raw_content', 'favicon')), FrozenPlan(fields=('title', 'url', 'content', 'score', 'r"
    "aw_content', 'favicon'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('title', 'url', 'conten"
    "t', 'score', 'raw_content', 'favicon'), cache=False), InitPlan(fields=(InitPlan.Field(name='title', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True,"
    " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
    "'url', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='content', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields"
    ".2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None), InitPlan.Field(name='score', annotation=OpRef(name='init.fields.3.annotation'), default="
    "OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
    "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='raw_content', annotation=OpRef(name='init.fi"
    "elds.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='favicon', annot"
    "ation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, i"
    "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param"
    "='self', std_params=(), kw_only_params=('title', 'url', 'content', 'score', 'raw_content', 'favicon'), frozen=True"
    ", slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='title',"
    " kw_only=True, fn=None), ReprPlan.Field(name='url', kw_only=True, fn=None), ReprPlan.Field(name='content', kw_only"
    "=True, fn=None), ReprPlan.Field(name='score', kw_only=True, fn=None), ReprPlan.Field(name='raw_content', kw_only=T"
    "rue, fn=None), ReprPlan.Field(name='favicon', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2ftavily_2fprotocol_2fSearchResponse_2fResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            title=self.title,
            url=self.url,
            content=self.content,
            score=self.score,
            raw_content=self.raw_content,
            favicon=self.favicon,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.title == other.title and
            self.url == other.url and
            self.content == other.content and
            self.score == other.score and
            self.raw_content == other.raw_content and
            self.favicon == other.favicon
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'title',
        'url',
        'content',
        'score',
        'raw_content',
        'favicon',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'title',
        'url',
        'content',
        'score',
        'raw_content',
        'favicon',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.title,
            self.url,
            self.content,
            self.score,
            self.raw_content,
            self.favicon,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        title: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        url: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        content: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        score: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        raw_content: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        favicon: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'title', title)
        __dataclass__object_setattr(self, 'url', url)
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'score', score)
        __dataclass__object_setattr(self, 'raw_content', raw_content)
        __dataclass__object_setattr(self, 'favicon', favicon)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"title={self.title!r}")
        parts.append(f"url={self.url!r}")
        parts.append(f"content={self.content!r}")
        parts.append(f"score={self.score!r}")
        parts.append(f"raw_content={self.raw_content!r}")
        parts.append(f"favicon={self.favicon!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('query', 'answer', 'images', 'results', 'follow_up_questions', 'auto_parameters', 'res"
    "ponse_time', 'request_id')), EqPlan(fields=('query', 'answer', 'images', 'results', 'follow_up_questions', 'auto_p"
    "arameters', 'response_time', 'request_id')), FrozenPlan(fields=('query', 'answer', 'images', 'results', 'follow_up"
    "_questions', 'auto_parameters', 'response_time', 'request_id'), allow_dynamic_dunder_attrs=False), HashPlan(action"
    "='add', fields=('query', 'answer', 'images', 'results', 'follow_up_questions', 'auto_parameters', 'response_time',"
    " 'request_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='query', annotation=OpRef(name='init.fields.0.a"
    "nnotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='answer', annotation=OpRef(name='init.fields.1.annotati"
    "on'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None), InitPlan.Field(name='images', annotation=OpRef(name='init.fields.2.annotation'), d"
    "efault=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType."
    "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='results', annotation=OpRef(name='init"
    ".fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='follow_up_qu"
    "estions', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e), InitPlan.Field(name='auto_parameters', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='"
    "init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
    "ne, validate=None, check_type=None), InitPlan.Field(name='response_time', annotation=OpRef(name='init.fields.6.ann"
    "otation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='request_id', annotation=O"
    "pRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=Tru"
    "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self'"
    ", std_params=(), kw_only_params=('query', 'answer', 'images', 'results', 'follow_up_questions', 'auto_parameters',"
    " 'response_time', 'request_id'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), R"
    "eprPlan(fields=(ReprPlan.Field(name='query', kw_only=True, fn=None), ReprPlan.Field(name='answer', kw_only=True, f"
    "n=None), ReprPlan.Field(name='images', kw_only=True, fn=None), ReprPlan.Field(name='results', kw_only=True, fn=Non"
    "e), ReprPlan.Field(name='follow_up_questions', kw_only=True, fn=None), ReprPlan.Field(name='auto_parameters', kw_o"
    "nly=True, fn=None), ReprPlan.Field(name='response_time', kw_only=True, fn=None), ReprPlan.Field(name='request_id',"
    " kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2ftavily_2fprotocol_2fSearchResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            query=self.query,
            answer=self.answer,
            images=self.images,
            results=self.results,
            follow_up_questions=self.follow_up_questions,
            auto_parameters=self.auto_parameters,
            response_time=self.response_time,
            request_id=self.request_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.query == other.query and
            self.answer == other.answer and
            self.images == other.images and
            self.results == other.results and
            self.follow_up_questions == other.follow_up_questions and
            self.auto_parameters == other.auto_parameters and
            self.response_time == other.response_time and
            self.request_id == other.request_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'query',
        'answer',
        'images',
        'results',
        'follow_up_questions',
        'auto_parameters',
        'response_time',
        'request_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'query',
        'answer',
        'images',
        'results',
        'follow_up_questions',
        'auto_parameters',
        'response_time',
        'request_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.query,
            self.answer,
            self.images,
            self.results,
            self.follow_up_questions,
            self.auto_parameters,
            self.response_time,
            self.request_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        query: __dataclass__init__fields__0__annotation,
        answer: __dataclass__init__fields__1__annotation,
        images: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        results: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        follow_up_questions: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        auto_parameters: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        response_time: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        request_id: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'query', query)
        __dataclass__object_setattr(self, 'answer', answer)
        __dataclass__object_setattr(self, 'images', images)
        __dataclass__object_setattr(self, 'results', results)
        __dataclass__object_setattr(self, 'follow_up_questions', follow_up_questions)
        __dataclass__object_setattr(self, 'auto_parameters', auto_parameters)
        __dataclass__object_setattr(self, 'response_time', response_time)
        __dataclass__object_setattr(self, 'request_id', request_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"query={self.query!r}")
        parts.append(f"answer={self.answer!r}")
        parts.append(f"images={self.images!r}")
        parts.append(f"results={self.results!r}")
        parts.append(f"follow_up_questions={self.follow_up_questions!r}")
        parts.append(f"auto_parameters={self.auto_parameters!r}")
        parts.append(f"response_time={self.response_time!r}")
        parts.append(f"request_id={self.request_id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('urls', 'include_images', 'include_favicon', 'extract_depth', 'format', 'timeout')), E"
    "qPlan(fields=('urls', 'include_images', 'include_favicon', 'extract_depth', 'format', 'timeout')), FrozenPlan(fiel"
    "ds=('urls', 'include_images', 'include_favicon', 'extract_depth', 'format', 'timeout'), allow_dynamic_dunder_attrs"
    "=False), HashPlan(action='add', fields=('urls', 'include_images', 'include_favicon', 'extract_depth', 'format', 't"
    "imeout'), cache=False), InitPlan(fields=(InitPlan.Field(name='urls', annotation=OpRef(name='init.fields.0.annotati"
    "on'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None), InitPlan.Field(name='include_images', annotation=OpRef(name='init.fields.1.annotat"
    "ion'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='include_favicon', annotation="
    "OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='extract_depth', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default')"
    ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='format', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name="
    "'init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
    "one, validate=None, check_type=None), InitPlan.Field(name='timeout', annotation=OpRef(name='init.fields.5.annotati"
    "on'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=("
    "'urls', 'include_images', 'include_favicon', 'extract_depth', 'format', 'timeout'), frozen=True, slots=False, post"
    "_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='urls', kw_only=True, fn=No"
    "ne), ReprPlan.Field(name='include_images', kw_only=True, fn=None), ReprPlan.Field(name='include_favicon', kw_only="
    "True, fn=None), ReprPlan.Field(name='extract_depth', kw_only=True, fn=None), ReprPlan.Field(name='format', kw_only"
    "=True, fn=None), ReprPlan.Field(name='timeout', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2ftavily_2fprotocol_2fExtractRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            urls=self.urls,
            include_images=self.include_images,
            include_favicon=self.include_favicon,
            extract_depth=self.extract_depth,
            format=self.format,
            timeout=self.timeout,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.urls == other.urls and
            self.include_images == other.include_images and
            self.include_favicon == other.include_favicon and
            self.extract_depth == other.extract_depth and
            self.format == other.format and
            self.timeout == other.timeout
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'urls',
        'include_images',
        'include_favicon',
        'extract_depth',
        'format',
        'timeout',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'urls',
        'include_images',
        'include_favicon',
        'extract_depth',
        'format',
        'timeout',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.urls,
            self.include_images,
            self.include_favicon,
            self.extract_depth,
            self.format,
            self.timeout,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        urls: __dataclass__init__fields__0__annotation,
        include_images: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        include_favicon: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        extract_depth: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        format: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        timeout: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'urls', urls)
        __dataclass__object_setattr(self, 'include_images', include_images)
        __dataclass__object_setattr(self, 'include_favicon', include_favicon)
        __dataclass__object_setattr(self, 'extract_depth', extract_depth)
        __dataclass__object_setattr(self, 'format', format)
        __dataclass__object_setattr(self, 'timeout', timeout)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"urls={self.urls!r}")
        parts.append(f"include_images={self.include_images!r}")
        parts.append(f"include_favicon={self.include_favicon!r}")
        parts.append(f"extract_depth={self.extract_depth!r}")
        parts.append(f"format={self.format!r}")
        parts.append(f"timeout={self.timeout!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('url', 'raw_content', 'images', 'favicon')), EqPlan(fields=('url', 'raw_content', 'ima"
    "ges', 'favicon')), FrozenPlan(fields=('url', 'raw_content', 'images', 'favicon'), allow_dynamic_dunder_attrs=False"
    "), HashPlan(action='add', fields=('url', 'raw_content', 'images', 'favicon'), cache=False), InitPlan(fields=(InitP"
    "lan.Field(name='url', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='raw_content', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='images', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), defau"
    "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='favicon', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init."
    "fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('url', 'raw_content', 'images',"
    " 'favicon'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Repr"
    "Plan.Field(name='url', kw_only=True, fn=None), ReprPlan.Field(name='raw_content', kw_only=True, fn=None), ReprPlan"
    ".Field(name='images', kw_only=True, fn=None), ReprPlan.Field(name='favicon', kw_only=True, fn=None)), id=False, te"
    "rse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2ftavily_2fprotocol_2fExtractResponse_2fResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            url=self.url,
            raw_content=self.raw_content,
            images=self.images,
            favicon=self.favicon,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.url == other.url and
            self.raw_content == other.raw_content and
            self.images == other.images and
            self.favicon == other.favicon
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'url',
        'raw_content',
        'images',
        'favicon',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'url',
        'raw_content',
        'images',
        'favicon',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.url,
            self.raw_content,
            self.images,
            self.favicon,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        url: __dataclass__init__fields__0__annotation,
        raw_content: __dataclass__init__fields__1__annotation,
        images: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        favicon: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'url', url)
        __dataclass__object_setattr(self, 'raw_content', raw_content)
        __dataclass__object_setattr(self, 'images', images)
        __dataclass__object_setattr(self, 'favicon', favicon)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"url={self.url!r}")
        parts.append(f"raw_content={self.raw_content!r}")
        parts.append(f"images={self.images!r}")
        parts.append(f"favicon={self.favicon!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('url', 'error')), EqPlan(fields=('url', 'error')), FrozenPlan(fields=('url', 'error'),"
    " allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('url', 'error'), cache=False), InitPlan(fields="
    "(InitPlan.Field(name='url', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None,"
    " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
    "Field(name='error', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self"
    "', std_params=(), kw_only_params=('url', 'error'), frozen=True, slots=False, post_init_params=None, init_fns=(), v"
    "alidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='url', kw_only=True, fn=None), ReprPlan.Field(name='error', "
    "kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2ftavily_2fprotocol_2fExtractResponse_2fFailedResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            url=self.url,
            error=self.error,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.url == other.url and
            self.error == other.error
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'url',
        'error',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'url',
        'error',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.url,
            self.error,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        url: __dataclass__init__fields__0__annotation,
        error: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'url', url)
        __dataclass__object_setattr(self, 'error', error)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"url={self.url!r}")
        parts.append(f"error={self.error!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('results', 'failed_results', 'response_time', 'request_id')), EqPlan(fields=('results'"
    ", 'failed_results', 'response_time', 'request_id')), FrozenPlan(fields=('results', 'failed_results', 'response_tim"
    "e', 'request_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('results', 'failed_results', "
    "'response_time', 'request_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='results', annotation=OpRef(nam"
    "e='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType"
    ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='failed_results', annotation=OpRef(na"
    "me='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='resp"
    "onse_time', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='request_id', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='ini"
    "t.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('results', 'failed_results', "
    "'response_time', 'request_id'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Re"
    "prPlan(fields=(ReprPlan.Field(name='results', kw_only=True, fn=None), ReprPlan.Field(name='failed_results', kw_onl"
    "y=True, fn=None), ReprPlan.Field(name='response_time', kw_only=True, fn=None), ReprPlan.Field(name='request_id', k"
    "w_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2ftavily_2fprotocol_2fExtractResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            results=self.results,
            failed_results=self.failed_results,
            response_time=self.response_time,
            request_id=self.request_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.results == other.results and
            self.failed_results == other.failed_results and
            self.response_time == other.response_time and
            self.request_id == other.request_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'results',
        'failed_results',
        'response_time',
        'request_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'results',
        'failed_results',
        'response_time',
        'request_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.results,
            self.failed_results,
            self.response_time,
            self.request_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        results: __dataclass__init__fields__0__annotation,
        failed_results: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        response_time: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        request_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'results', results)
        __dataclass__object_setattr(self, 'failed_results', failed_results)
        __dataclass__object_setattr(self, 'response_time', response_time)
        __dataclass__object_setattr(self, 'request_id', request_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"results={self.results!r}")
        parts.append(f"failed_results={self.failed_results!r}")
        parts.append(f"response_time={self.response_time!r}")
        parts.append(f"request_id={self.request_id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=(), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=(), cache=False), InitPlan(fields=(), self_param='self', std_params=(), kw_only_params=(),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fanthropic_2fprotocol_2ftypes_2fContent_2fEphemeralCacheControl(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('text', 'cache_control')), EqPlan(fields=('text', 'cache_control')), FrozenPlan(fields"
    "=('text', 'cache_control'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('text', 'cache_contr"
    "ol'), cache=False), InitPlan(fields=(InitPlan.Field(name='text', annotation=OpRef(name='init.fields.0.annotation')"
    ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='cache_control', annotation=OpRef(name='init.fields.1.annotation')"
    ", default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
    "pe.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('text',), kw_only_param"
    "s=('cache_control',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fie"
    "lds=(ReprPlan.Field(name='text', kw_only=False, fn=None), ReprPlan.Field(name='cache_control', kw_only=True, fn=Op"
    "Ref(name='repr.fns.1.fn'))), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fanthropic_2fprotocol_2ftypes_2fText(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__repr__fns__1__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            text=self.text,
            cache_control=self.cache_control,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.text == other.text and
            self.cache_control == other.cache_control
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'text',
        'cache_control',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'text',
        'cache_control',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.text,
            self.cache_control,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        text: __dataclass__init__fields__0__annotation,
        *,
        cache_control: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'text', text)
        __dataclass__object_setattr(self, 'cache_control', cache_control)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"text={self.text!r}")
        if (s := __dataclass__repr__fns__1__fn(self.cache_control)) is not None:
            parts.append(f"cache_control={s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('id', 'name', 'input', 'cache_control')), EqPlan(fields=('id', 'name', 'input', 'cache"
    "_control')), FrozenPlan(fields=('id', 'name', 'input', 'cache_control'), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=('id', 'name', 'input', 'cache_control'), cache=False), InitPlan(fields=(InitPlan.Field(na"
    "me='id', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', "
    "annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='input', annotati"
    "on=OpRef(name='init.fields.2.annotation'), default=None, default_factory=None, init=True, override=False, field_ty"
    "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cache_control', annotati"
    "on=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='s"
    "elf', std_params=('id', 'name', 'input'), kw_only_params=('cache_control',), frozen=True, slots=False, post_init_p"
    "arams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='id', kw_only=False, fn=None), Rep"
    "rPlan.Field(name='name', kw_only=False, fn=None), ReprPlan.Field(name='input', kw_only=False, fn=None), ReprPlan.F"
    "ield(name='cache_control', kw_only=True, fn=OpRef(name='repr.fns.3.fn'))), id=False, terse=False, default_fn=None)"
    "))"
)
def _process_dataclass__ommlds_2fbackends_2fanthropic_2fprotocol_2ftypes_2fToolUse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__repr__fns__3__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            id=self.id,
            name=self.name,
            input=self.input,
            cache_control=self.cache_control,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.id == other.id and
            self.name == other.name and
            self.input == other.input and
            self.cache_control == other.cache_control
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'id',
        'name',
        'input',
        'cache_control',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'id',
        'name',
        'input',
        'cache_control',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.id,
            self.name,
            self.input,
            self.cache_control,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        id: __dataclass__init__fields__0__annotation,
        name: __dataclass__init__fields__1__annotation,
        input: __dataclass__init__fields__2__annotation,
        *,
        cache_control: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'input', input)
        __dataclass__object_setattr(self, 'cache_control', cache_control)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"id={self.id!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"input={self.input!r}")
        if (s := __dataclass__repr__fns__3__fn(self.cache_control)) is not None:
            parts.append(f"cache_control={s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('tool_use_id', 'content')), EqPlan(fields=('tool_use_id', 'content')), FrozenPlan(fiel"
    "ds=('tool_use_id', 'content'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('tool_use_id', 'c"
    "ontent'), cache=False), InitPlan(fields=(InitPlan.Field(name='tool_use_id', annotation=OpRef(name='init.fields.0.a"
    "nnotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='content', annotation=OpRef(name='init.fields.1.annotat"
    "ion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None)), self_param='self', std_params=('tool_use_id', 'content'), kw_only_params=(), fro"
    "zen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name="
    "'tool_use_id', kw_only=False, fn=None), ReprPlan.Field(name='content', kw_only=False, fn=None)), id=False, terse=F"
    "alse, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fanthropic_2fprotocol_2ftypes_2fToolResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            tool_use_id=self.tool_use_id,
            content=self.content,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.tool_use_id == other.tool_use_id and
            self.content == other.content
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'tool_use_id',
        'content',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'tool_use_id',
        'content',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.tool_use_id,
            self.content,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        tool_use_id: __dataclass__init__fields__0__annotation,
        content: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'tool_use_id', tool_use_id)
        __dataclass__object_setattr(self, 'content', content)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"tool_use_id={self.tool_use_id!r}")
        parts.append(f"content={self.content!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ephemeral_5m_input_tokens', 'ephemeral_1h_input_tokens')), EqPlan(fields=('ephemeral_"
    "5m_input_tokens', 'ephemeral_1h_input_tokens')), FrozenPlan(fields=('ephemeral_5m_input_tokens', 'ephemeral_1h_inp"
    "ut_tokens'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('ephemeral_5m_input_tokens', 'ephem"
    "eral_1h_input_tokens'), cache=False), InitPlan(fields=(InitPlan.Field(name='ephemeral_5m_input_tokens', annotation"
    "=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=T"
    "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
    "ame='ephemeral_1h_input_tokens', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.field"
    "s.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('ephemeral_5m_input_tokens', 'epheme"
    "ral_1h_input_tokens'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fi"
    "elds=(ReprPlan.Field(name='ephemeral_5m_input_tokens', kw_only=True, fn=None), ReprPlan.Field(name='ephemeral_1h_i"
    "nput_tokens', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fanthropic_2fprotocol_2ftypes_2fCacheCreation(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ephemeral_5m_input_tokens=self.ephemeral_5m_input_tokens,
            ephemeral_1h_input_tokens=self.ephemeral_1h_input_tokens,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ephemeral_5m_input_tokens == other.ephemeral_5m_input_tokens and
            self.ephemeral_1h_input_tokens == other.ephemeral_1h_input_tokens
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'ephemeral_5m_input_tokens',
        'ephemeral_1h_input_tokens',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'ephemeral_5m_input_tokens',
        'ephemeral_1h_input_tokens',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ephemeral_5m_input_tokens,
            self.ephemeral_1h_input_tokens,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        ephemeral_5m_input_tokens: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        ephemeral_1h_input_tokens: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ephemeral_5m_input_tokens', ephemeral_5m_input_tokens)
        __dataclass__object_setattr(self, 'ephemeral_1h_input_tokens', ephemeral_1h_input_tokens)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ephemeral_5m_input_tokens={self.ephemeral_5m_input_tokens!r}")
        parts.append(f"ephemeral_1h_input_tokens={self.ephemeral_1h_input_tokens!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('input_tokens', 'output_tokens', 'cache_creation_input_tokens', 'cache_read_input_toke"
    "ns', 'cache_creation', 'service_tier')), EqPlan(fields=('input_tokens', 'output_tokens', 'cache_creation_input_tok"
    "ens', 'cache_read_input_tokens', 'cache_creation', 'service_tier')), FrozenPlan(fields=('input_tokens', 'output_to"
    "kens', 'cache_creation_input_tokens', 'cache_read_input_tokens', 'cache_creation', 'service_tier'), allow_dynamic_"
    "dunder_attrs=False), HashPlan(action='add', fields=('input_tokens', 'output_tokens', 'cache_creation_input_tokens'"
    ", 'cache_read_input_tokens', 'cache_creation', 'service_tier'), cache=False), InitPlan(fields=(InitPlan.Field(name"
    "='input_tokens', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None), InitPlan.Field(name='output_tokens', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(n"
    "ame='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='cache_creation_input_tokens', annotation=OpRef(name"
    "='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, overri"
    "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cache_"
    "read_input_tokens', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default')"
    ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='cache_creation', annotation=OpRef(name='init.fields.4.annotation'), default=OpR"
    "ef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None), InitPlan.Field(name='service_tier', annotation=OpRef(name='init.fiel"
    "ds.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, f"
    "ield_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_"
    "only_params=('input_tokens', 'output_tokens', 'cache_creation_input_tokens', 'cache_read_input_tokens', 'cache_cre"
    "ation', 'service_tier'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan("
    "fields=(ReprPlan.Field(name='input_tokens', kw_only=True, fn=None), ReprPlan.Field(name='output_tokens', kw_only=T"
    "rue, fn=None), ReprPlan.Field(name='cache_creation_input_tokens', kw_only=True, fn=None), ReprPlan.Field(name='cac"
    "he_read_input_tokens', kw_only=True, fn=None), ReprPlan.Field(name='cache_creation', kw_only=True, fn=None), ReprP"
    "lan.Field(name='service_tier', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fanthropic_2fprotocol_2ftypes_2fUsage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            input_tokens=self.input_tokens,
            output_tokens=self.output_tokens,
            cache_creation_input_tokens=self.cache_creation_input_tokens,
            cache_read_input_tokens=self.cache_read_input_tokens,
            cache_creation=self.cache_creation,
            service_tier=self.service_tier,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.input_tokens == other.input_tokens and
            self.output_tokens == other.output_tokens and
            self.cache_creation_input_tokens == other.cache_creation_input_tokens and
            self.cache_read_input_tokens == other.cache_read_input_tokens and
            self.cache_creation == other.cache_creation and
            self.service_tier == other.service_tier
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'input_tokens',
        'output_tokens',
        'cache_creation_input_tokens',
        'cache_read_input_tokens',
        'cache_creation',
        'service_tier',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'input_tokens',
        'output_tokens',
        'cache_creation_input_tokens',
        'cache_read_input_tokens',
        'cache_creation',
        'service_tier',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.input_tokens,
            self.output_tokens,
            self.cache_creation_input_tokens,
            self.cache_read_input_tokens,
            self.cache_creation,
            self.service_tier,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        input_tokens: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        output_tokens: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        cache_creation_input_tokens: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        cache_read_input_tokens: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        cache_creation: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        service_tier: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'input_tokens', input_tokens)
        __dataclass__object_setattr(self, 'output_tokens', output_tokens)
        __dataclass__object_setattr(self, 'cache_creation_input_tokens', cache_creation_input_tokens)
        __dataclass__object_setattr(self, 'cache_read_input_tokens', cache_read_input_tokens)
        __dataclass__object_setattr(self, 'cache_creation', cache_creation)
        __dataclass__object_setattr(self, 'service_tier', service_tier)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"input_tokens={self.input_tokens!r}")
        parts.append(f"output_tokens={self.output_tokens!r}")
        parts.append(f"cache_creation_input_tokens={self.cache_creation_input_tokens!r}")
        parts.append(f"cache_read_input_tokens={self.cache_read_input_tokens!r}")
        parts.append(f"cache_creation={self.cache_creation!r}")
        parts.append(f"service_tier={self.service_tier!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('id', 'role', 'model', 'content', 'stop_reason', 'stop_sequence', 'usage')), EqPlan(fi"
    "elds=('id', 'role', 'model', 'content', 'stop_reason', 'stop_sequence', 'usage')), FrozenPlan(fields=('id', 'role'"
    ", 'model', 'content', 'stop_reason', 'stop_sequence', 'usage'), allow_dynamic_dunder_attrs=False), HashPlan(action"
    "='add', fields=('id', 'role', 'model', 'content', 'stop_reason', 'stop_sequence', 'usage'), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='id', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fie"
    "lds.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None), InitPlan.Field(name='role', annotation=OpRef(name='init.fields.1.annotation'), defaul"
    "t=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
    ", check_type=None), InitPlan.Field(name='model', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef("
    "name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
    "rce=None, validate=None, check_type=None), InitPlan.Field(name='content', annotation=OpRef(name='init.fields.3.ann"
    "otation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='stop_reason', annotation="
    "OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='stop_sequence', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default')"
    ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='usage', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='"
    "init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
    "ne, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('id', 'role', 'model', 'co"
    "ntent', 'stop_reason', 'stop_sequence', 'usage'), frozen=True, slots=False, post_init_params=None, init_fns=(), va"
    "lidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='id', kw_only=True, fn=None), ReprPlan.Field(name='role', kw_"
    "only=True, fn=None), ReprPlan.Field(name='model', kw_only=True, fn=None), ReprPlan.Field(name='content', kw_only=T"
    "rue, fn=None), ReprPlan.Field(name='stop_reason', kw_only=True, fn=None), ReprPlan.Field(name='stop_sequence', kw_"
    "only=True, fn=None), ReprPlan.Field(name='usage', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)"
    "))"
)
def _process_dataclass__ommlds_2fbackends_2fanthropic_2fprotocol_2ftypes_2fMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            id=self.id,
            role=self.role,
            model=self.model,
            content=self.content,
            stop_reason=self.stop_reason,
            stop_sequence=self.stop_sequence,
            usage=self.usage,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.id == other.id and
            self.role == other.role and
            self.model == other.model and
            self.content == other.content and
            self.stop_reason == other.stop_reason and
            self.stop_sequence == other.stop_sequence and
            self.usage == other.usage
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'id',
        'role',
        'model',
        'content',
        'stop_reason',
        'stop_sequence',
        'usage',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'id',
        'role',
        'model',
        'content',
        'stop_reason',
        'stop_sequence',
        'usage',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.id,
            self.role,
            self.model,
            self.content,
            self.stop_reason,
            self.stop_sequence,
            self.usage,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        id: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        role: __dataclass__init__fields__1__annotation,
        model: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        content: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        stop_reason: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        stop_sequence: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        usage: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'role', role)
        __dataclass__object_setattr(self, 'model', model)
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'stop_reason', stop_reason)
        __dataclass__object_setattr(self, 'stop_sequence', stop_sequence)
        __dataclass__object_setattr(self, 'usage', usage)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"id={self.id!r}")
        parts.append(f"role={self.role!r}")
        parts.append(f"model={self.model!r}")
        parts.append(f"content={self.content!r}")
        parts.append(f"stop_reason={self.stop_reason!r}")
        parts.append(f"stop_sequence={self.stop_sequence!r}")
        parts.append(f"usage={self.usage!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'description', 'input_schema')), EqPlan(fields=('name', 'description', 'input_"
    "schema')), FrozenPlan(fields=('name', 'description', 'input_schema'), allow_dynamic_dunder_attrs=False), HashPlan("
    "action='add', fields=('name', 'description', 'input_schema'), cache=False), InitPlan(fields=(InitPlan.Field(name='"
    "name', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override="
    "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='descripti"
    "on', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=Fa"
    "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='input_schem"
    "a', annotation=OpRef(name='init.fields.2.annotation'), default=None, default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('"
    "name', 'description', 'input_schema'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fn"
    "s=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_only=False, fn=None), ReprPlan.Field(name="
    "'description', kw_only=False, fn=None), ReprPlan.Field(name='input_schema', kw_only=False, fn=None)), id=False, te"
    "rse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fanthropic_2fprotocol_2ftypes_2fToolSpec(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            description=self.description,
            input_schema=self.input_schema,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.description == other.description and
            self.input_schema == other.input_schema
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'name',
        'description',
        'input_schema',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
        'description',
        'input_schema',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.description,
            self.input_schema,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        name: __dataclass__init__fields__0__annotation,
        description: __dataclass__init__fields__1__annotation,
        input_schema: __dataclass__init__fields__2__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'input_schema', input_schema)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"description={self.description!r}")
        parts.append(f"input_schema={self.input_schema!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('model', 'messages', 'system', 'tools', 'temperature', 'max_tokens', 'stream', 'betas'"
    ", 'metadata')), EqPlan(fields=('model', 'messages', 'system', 'tools', 'temperature', 'max_tokens', 'stream', 'bet"
    "as', 'metadata')), FrozenPlan(fields=('model', 'messages', 'system', 'tools', 'temperature', 'max_tokens', 'stream"
    "', 'betas', 'metadata'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('model', 'messages', 's"
    "ystem', 'tools', 'temperature', 'max_tokens', 'stream', 'betas', 'metadata'), cache=False), InitPlan(fields=(InitP"
    "lan.Field(name='model', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='messages', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=Tru"
    "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
    "e='system', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='tools', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fie"
    "lds.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None), InitPlan.Field(name='temperature', annotation=OpRef(name='init.fields.4.annotation'),"
    " default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_tokens', annotation=OpRef(name="
    "'init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='stream'"
    ", annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='betas', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='metadata', annotation=OpRef(name='init.fields.8.annotation'), default=OpRe"
    "f(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None)), self_param='self', std_params=('model', 'messages'), kw_only_params="
    "('system', 'tools', 'temperature', 'max_tokens', 'stream', 'betas', 'metadata'), frozen=True, slots=False, post_in"
    "it_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='model', kw_only=False, fn=Non"
    "e), ReprPlan.Field(name='messages', kw_only=False, fn=None), ReprPlan.Field(name='system', kw_only=True, fn=None),"
    " ReprPlan.Field(name='tools', kw_only=True, fn=None), ReprPlan.Field(name='temperature', kw_only=True, fn=None), R"
    "eprPlan.Field(name='max_tokens', kw_only=True, fn=None), ReprPlan.Field(name='stream', kw_only=True, fn=None), Rep"
    "rPlan.Field(name='betas', kw_only=True, fn=None), ReprPlan.Field(name='metadata', kw_only=True, fn=None)), id=Fals"
    "e, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fanthropic_2fprotocol_2ftypes_2fMessagesRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            model=self.model,
            messages=self.messages,
            system=self.system,
            tools=self.tools,
            temperature=self.temperature,
            max_tokens=self.max_tokens,
            stream=self.stream,
            betas=self.betas,
            metadata=self.metadata,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.model == other.model and
            self.messages == other.messages and
            self.system == other.system and
            self.tools == other.tools and
            self.temperature == other.temperature and
            self.max_tokens == other.max_tokens and
            self.stream == other.stream and
            self.betas == other.betas and
            self.metadata == other.metadata
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'model',
        'messages',
        'system',
        'tools',
        'temperature',
        'max_tokens',
        'stream',
        'betas',
        'metadata',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'model',
        'messages',
        'system',
        'tools',
        'temperature',
        'max_tokens',
        'stream',
        'betas',
        'metadata',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.model,
            self.messages,
            self.system,
            self.tools,
            self.temperature,
            self.max_tokens,
            self.stream,
            self.betas,
            self.metadata,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        model: __dataclass__init__fields__0__annotation,
        messages: __dataclass__init__fields__1__annotation,
        *,
        system: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        tools: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        temperature: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        max_tokens: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        stream: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        betas: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        metadata: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'model', model)
        __dataclass__object_setattr(self, 'messages', messages)
        __dataclass__object_setattr(self, 'system', system)
        __dataclass__object_setattr(self, 'tools', tools)
        __dataclass__object_setattr(self, 'temperature', temperature)
        __dataclass__object_setattr(self, 'max_tokens', max_tokens)
        __dataclass__object_setattr(self, 'stream', stream)
        __dataclass__object_setattr(self, 'betas', betas)
        __dataclass__object_setattr(self, 'metadata', metadata)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"model={self.model!r}")
        parts.append(f"messages={self.messages!r}")
        parts.append(f"system={self.system!r}")
        parts.append(f"tools={self.tools!r}")
        parts.append(f"temperature={self.temperature!r}")
        parts.append(f"max_tokens={self.max_tokens!r}")
        parts.append(f"stream={self.stream!r}")
        parts.append(f"betas={self.betas!r}")
        parts.append(f"metadata={self.metadata!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('spec',)), EqPlan(fields=('spec',)), FrozenPlan(fields=('spec',), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('spec',), cache=False), InitPlan(fields=(InitPlan.Field(name='spec',"
    " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('sp"
    "ec',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan"
    "(fields=(ReprPlan.Field(name='spec', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftools_2ftypes_2fTool(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            spec=self.spec,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.spec == other.spec
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'spec',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'spec',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.spec,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        spec: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'spec', spec)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"spec={self.spec!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('data',)), EqPlan(fields=('data',)), FrozenPlan(fields=('data',), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('data',), cache=False), InitPlan(fields=(InitPlan.Field(name='data',"
    " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('da"
    "ta',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan"
    "(fields=(ReprPlan.Field(name='data', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fhttp_2fsse_2fSseComment(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            data=self.data,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.data == other.data
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'data',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'data',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.data,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        data: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'data', data)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"data={self.data!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('type', 'data', 'last_id')), EqPlan(fields=('type', 'data', 'last_id')), FrozenPlan(fi"
    "elds=('type', 'data', 'last_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('type', 'data'"
    ", 'last_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='type', annotation=OpRef(name='init.fields.0.anno"
    "tation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
    "e, validate=None, check_type=None), InitPlan.Field(name='data', annotation=OpRef(name='init.fields.1.annotation'),"
    " default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='last_id', annotation=OpRef(name='init.fields.2.annotation'), defau"
    "lt=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
    "ANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('type', 'data', 'last_id'), kw"
    "_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=("
    "ReprPlan.Field(name='type', kw_only=False, fn=None), ReprPlan.Field(name='data', kw_only=False, fn=None), ReprPlan"
    ".Field(name='last_id', kw_only=False, fn=OpRef(name='repr.fns.2.fn'))), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fhttp_2fsse_2fSseEvent(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__repr__fns__2__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            type=self.type,
            data=self.data,
            last_id=self.last_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.type == other.type and
            self.data == other.data and
            self.last_id == other.last_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'type',
        'data',
        'last_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'type',
        'data',
        'last_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.type,
            self.data,
            self.last_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        type: __dataclass__init__fields__0__annotation,
        data: __dataclass__init__fields__1__annotation,
        last_id: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'type', type)
        __dataclass__object_setattr(self, 'data', data)
        __dataclass__object_setattr(self, 'last_id', last_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"type={self.type!r}")
        parts.append(f"data={self.data!r}")
        if (s := __dataclass__repr__fns__2__fn(self.last_id)) is not None:
            parts.append(f"last_id={s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=(), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=(), cache=False), InitPlan(fields=(), self_param='self', std_params=(), kw_only_params=(),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fstream_2ftypes_2fAiDelta(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('c',)), EqPlan(fields=('c',)), FrozenPlan(fields=('c',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('c',), cache=False), InitPlan(fields=(InitPlan.Field(name='c', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('c',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='c', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fstream_2ftypes_2fContentAiDelta(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            c=self.c,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.c == other.c
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'c',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'c',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.c,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        c: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'c', c)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"c={self.c!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('id', 'name')), EqPlan(fields=('id', 'name')), FrozenPlan(fields=('id', 'name'), allow"
    "_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('id', 'name'), cache=False), InitPlan(fields=(InitPla"
    "n.Field(name='id', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'),"
    " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
    "_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='in"
    "it.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
    ", validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('id', 'name'), frozen=True, "
    "slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='id', kw_o"
    "nly=True, fn=None), ReprPlan.Field(name='name', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fstream_2ftypes_2fAnyToolUseAiDelta(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            id=self.id,
            name=self.name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.id == other.id and
            self.name == other.name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'id',
        'name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'id',
        'name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.id,
            self.name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        id: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'name', name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"id={self.id!r}")
        parts.append(f"name={self.name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('id', 'name', 'args')), EqPlan(fields=('id', 'name', 'args')), FrozenPlan(fields=('id'"
    ", 'name', 'args'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('id', 'name', 'args'), cache="
    "False), InitPlan(fields=(InitPlan.Field(name='id', annotation=OpRef(name='init.fields.0.annotation'), default=OpRe"
    "f(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.anno"
    "tation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type"
    "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='args', annotation=OpRef(na"
    "me='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_p"
    "arams=(), kw_only_params=('id', 'name', 'args'), frozen=True, slots=False, post_init_params=None, init_fns=(), val"
    "idate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='id', kw_only=True, fn=None), ReprPlan.Field(name='name', kw_o"
    "nly=True, fn=None), ReprPlan.Field(name='args', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fstream_2ftypes_2fToolUseAiDelta(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            id=self.id,
            name=self.name,
            args=self.args,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.id == other.id and
            self.name == other.name and
            self.args == other.args
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'id',
        'name',
        'args',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'id',
        'name',
        'args',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.id,
            self.name,
            self.args,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        id: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        args: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'args', args)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"id={self.id!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"args={self.args!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('id', 'name', 'raw_args')), EqPlan(fields=('id', 'name', 'raw_args')), FrozenPlan(fiel"
    "ds=('id', 'name', 'raw_args'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('id', 'name', 'ra"
    "w_args'), cache=False), InitPlan(fields=(InitPlan.Field(name='id', annotation=OpRef(name='init.fields.0.annotation"
    "'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='in"
    "it.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='raw_args',"
    " annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=N"
    "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self"
    "_param='self', std_params=(), kw_only_params=('id', 'name', 'raw_args'), frozen=True, slots=False, post_init_param"
    "s=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='id', kw_only=True, fn=None), ReprPlan"
    ".Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='raw_args', kw_only=True, fn=None)), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fstream_2ftypes_2fPartialToolUseAiDelta(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            id=self.id,
            name=self.name,
            raw_args=self.raw_args,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.id == other.id and
            self.name == other.name and
            self.raw_args == other.raw_args
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'id',
        'name',
        'raw_args',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'id',
        'name',
        'raw_args',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.id,
            self.name,
            self.raw_args,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        id: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        raw_args: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'raw_args', raw_args)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"id={self.id!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"raw_args={self.raw_args!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('deltas',)), EqPlan(fields=('deltas',)), FrozenPlan(fields=('deltas',), allow_dynamic_"
    "dunder_attrs=False), HashPlan(action='add', fields=('deltas',), cache=False), InitPlan(fields=(InitPlan.Field(name"
    "='deltas', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_p"
    "arams=('deltas',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=("
    ")), ReprPlan(fields=(ReprPlan.Field(name='deltas', kw_only=False, fn=None),), id=False, terse=False, default_fn=No"
    "ne)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fchoices_2fstream_2ftypes_2fAiChoiceDeltas(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            deltas=self.deltas,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.deltas == other.deltas
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'deltas',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'deltas',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.deltas,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        deltas: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'deltas', deltas)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"deltas={self.deltas!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('choices',)), EqPlan(fields=('choices',)), FrozenPlan(fields=('choices',), allow_dynam"
    "ic_dunder_attrs=False), HashPlan(action='add', fields=('choices',), cache=False), InitPlan(fields=(InitPlan.Field("
    "name='choices', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', "
    "std_params=('choices',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate"
    "_fns=()), ReprPlan(fields=(ReprPlan.Field(name='choices', kw_only=False, fn=None),), id=False, terse=False, defaul"
    "t_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fchoices_2fstream_2ftypes_2fAiChoicesDeltas(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            choices=self.choices,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.choices == other.choices
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'choices',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'choices',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.choices,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        choices: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'choices', choices)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"choices={self.choices!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ty',)), EqPlan(fields=('ty',)), FrozenPlan(fields=('ty',), allow_dynamic_dunder_attrs"
    "=False), HashPlan(action='add', fields=('ty',), cache=False), InitPlan(fields=(InitPlan.Field(name='ty', annotatio"
    "n=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('ty',), kw_on"
    "ly_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Rep"
    "rPlan.Field(name='ty', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__omlish_2fmarshal_2fsingular_2fbase64_2fBase64MarshalerUnmarshaler(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ty=self.ty,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ty == other.ty
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'ty',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'ty',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ty,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        ty: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ty', ty)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ty={self.ty!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('mine_type', 'data')), EqPlan(fields=('mine_type', 'data')), FrozenPlan(fields=('mine_"
    "type', 'data'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('mine_type', 'data'), cache=Fals"
    "e), InitPlan(fields=(InitPlan.Field(name='mine_type', annotation=OpRef(name='init.fields.0.annotation'), default=N"
    "one, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='data', annotation=OpRef(name='init.fields.1.annotation'), default=None, defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None)), self_param='self', std_params=(), kw_only_params=('mine_type', 'data'), frozen=True, slots=False, post_in"
    "it_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='mine_type', kw_only=True, fn="
    "None), ReprPlan.Field(name='data', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fBlob(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            mine_type=self.mine_type,
            data=self.data,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.mine_type == other.mine_type and
            self.data == other.data
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'mine_type',
        'data',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'mine_type',
        'data',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.mine_type,
            self.data,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        mine_type: __dataclass__init__fields__0__annotation,
        data: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'mine_type', mine_type)
        __dataclass__object_setattr(self, 'data', data)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"mine_type={self.mine_type!r}")
        parts.append(f"data={self.data!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('id', 'name', 'args')), EqPlan(fields=('id', 'name', 'args')), FrozenPlan(fields=('id'"
    ", 'name', 'args'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('id', 'name', 'args'), cache="
    "False), InitPlan(fields=(InitPlan.Field(name='id', annotation=OpRef(name='init.fields.0.annotation'), default=OpRe"
    "f(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.anno"
    "tation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
    "e, validate=None, check_type=None), InitPlan.Field(name='args', annotation=OpRef(name='init.fields.2.annotation'),"
    " default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('id',"
    " 'name', 'args'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields="
    "(ReprPlan.Field(name='id', kw_only=True, fn=None), ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='args', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fFunctionCall(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            id=self.id,
            name=self.name,
            args=self.args,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.id == other.id and
            self.name == other.name and
            self.args == other.args
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'id',
        'name',
        'args',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'id',
        'name',
        'args',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.id,
            self.name,
            self.args,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        id: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        name: __dataclass__init__fields__1__annotation,
        args: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'args', args)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"id={self.id!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"args={self.args!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('id', 'name', 'response', 'will_continue', 'scheduling')), EqPlan(fields=('id', 'name'"
    ", 'response', 'will_continue', 'scheduling')), FrozenPlan(fields=('id', 'name', 'response', 'will_continue', 'sche"
    "duling'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('id', 'name', 'response', 'will_contin"
    "ue', 'scheduling'), cache=False), InitPlan(fields=(InitPlan.Field(name='id', annotation=OpRef(name='init.fields.0."
    "annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRe"
    "f(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='response', annotation=OpRef(nam"
    "e='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='will_"
    "continue', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default"
    "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
    "ne), InitPlan.Field(name='scheduling', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init"
    ".fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('id', 'name', 'response', 'wil"
    "l_continue', 'scheduling'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPl"
    "an(fields=(ReprPlan.Field(name='id', kw_only=True, fn=None), ReprPlan.Field(name='name', kw_only=True, fn=None), R"
    "eprPlan.Field(name='response', kw_only=True, fn=None), ReprPlan.Field(name='will_continue', kw_only=True, fn=None)"
    ", ReprPlan.Field(name='scheduling', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fFunctionResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            id=self.id,
            name=self.name,
            response=self.response,
            will_continue=self.will_continue,
            scheduling=self.scheduling,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.id == other.id and
            self.name == other.name and
            self.response == other.response and
            self.will_continue == other.will_continue and
            self.scheduling == other.scheduling
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'id',
        'name',
        'response',
        'will_continue',
        'scheduling',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'id',
        'name',
        'response',
        'will_continue',
        'scheduling',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.id,
            self.name,
            self.response,
            self.will_continue,
            self.scheduling,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        id: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        name: __dataclass__init__fields__1__annotation,
        response: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        will_continue: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        scheduling: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'response', response)
        __dataclass__object_setattr(self, 'will_continue', will_continue)
        __dataclass__object_setattr(self, 'scheduling', scheduling)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"id={self.id!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"response={self.response!r}")
        parts.append(f"will_continue={self.will_continue!r}")
        parts.append(f"scheduling={self.scheduling!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('mime_type', 'file_uri')), EqPlan(fields=('mime_type', 'file_uri')), FrozenPlan(fields"
    "=('mime_type', 'file_uri'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('mime_type', 'file_u"
    "ri'), cache=False), InitPlan(fields=(InitPlan.Field(name='mime_type', annotation=OpRef(name='init.fields.0.annotat"
    "ion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='file_uri', annotation=OpRef(name='init.fields.1.annotation')"
    ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('mime_type', 'file_uri'), frozen=Tr"
    "ue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='mime_"
    "type', kw_only=True, fn=None), ReprPlan.Field(name='file_uri', kw_only=True, fn=None)), id=False, terse=False, def"
    "ault_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fFileData(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            mime_type=self.mime_type,
            file_uri=self.file_uri,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.mime_type == other.mime_type and
            self.file_uri == other.file_uri
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'mime_type',
        'file_uri',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'mime_type',
        'file_uri',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.mime_type,
            self.file_uri,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        mime_type: __dataclass__init__fields__0__annotation,
        file_uri: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'mime_type', mime_type)
        __dataclass__object_setattr(self, 'file_uri', file_uri)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"mime_type={self.mime_type!r}")
        parts.append(f"file_uri={self.file_uri!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('language', 'code')), EqPlan(fields=('language', 'code')), FrozenPlan(fields=('languag"
    "e', 'code'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('language', 'code'), cache=False), "
    "InitPlan(fields=(InitPlan.Field(name='language', annotation=OpRef(name='init.fields.0.annotation'), default=None, "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None), InitPlan.Field(name='code', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    ")), self_param='self', std_params=(), kw_only_params=('language', 'code'), frozen=True, slots=False, post_init_par"
    "ams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='language', kw_only=True, fn=None), "
    "ReprPlan.Field(name='code', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fExecutableCode(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            language=self.language,
            code=self.code,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.language == other.language and
            self.code == other.code
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'language',
        'code',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'language',
        'code',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.language,
            self.code,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        language: __dataclass__init__fields__0__annotation,
        code: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'language', language)
        __dataclass__object_setattr(self, 'code', code)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"language={self.language!r}")
        parts.append(f"code={self.code!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('outcome', 'output')), EqPlan(fields=('outcome', 'output')), FrozenPlan(fields=('outco"
    "me', 'output'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('outcome', 'output'), cache=Fals"
    "e), InitPlan(fields=(InitPlan.Field(name='outcome', annotation=OpRef(name='init.fields.0.annotation'), default=Non"
    "e, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
    "ck_type=None), InitPlan.Field(name='output', annotation=OpRef(name='init.fields.1.annotation'), default=None, defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None)), self_param='self', std_params=(), kw_only_params=('outcome', 'output'), frozen=True, slots=False, post_in"
    "it_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='outcome', kw_only=True, fn=No"
    "ne), ReprPlan.Field(name='output', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fCodeExecutionResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            outcome=self.outcome,
            output=self.output,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.outcome == other.outcome and
            self.output == other.output
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'outcome',
        'output',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'outcome',
        'output',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.outcome,
            self.output,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        outcome: __dataclass__init__fields__0__annotation,
        output: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'outcome', outcome)
        __dataclass__object_setattr(self, 'output', output)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"outcome={self.outcome!r}")
        parts.append(f"output={self.output!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('start_offset', 'end_offset', 'fps')), EqPlan(fields=('start_offset', 'end_offset', 'f"
    "ps')), FrozenPlan(fields=('start_offset', 'end_offset', 'fps'), allow_dynamic_dunder_attrs=False), HashPlan(action"
    "='add', fields=('start_offset', 'end_offset', 'fps'), cache=False), InitPlan(fields=(InitPlan.Field(name='start_of"
    "fset', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override="
    "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='end_offse"
    "t', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='fps', annota"
    "tion=OpRef(name='init.fields.2.annotation'), default=None, default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_"
    "params=('start_offset', 'end_offset', 'fps'), frozen=True, slots=False, post_init_params=None, init_fns=(), valida"
    "te_fns=()), ReprPlan(fields=(ReprPlan.Field(name='start_offset', kw_only=True, fn=None), ReprPlan.Field(name='end_"
    "offset', kw_only=True, fn=None), ReprPlan.Field(name='fps', kw_only=True, fn=None)), id=False, terse=False, defaul"
    "t_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fVideoMetadata(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            start_offset=self.start_offset,
            end_offset=self.end_offset,
            fps=self.fps,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.start_offset == other.start_offset and
            self.end_offset == other.end_offset and
            self.fps == other.fps
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'start_offset',
        'end_offset',
        'fps',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'start_offset',
        'end_offset',
        'fps',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.start_offset,
            self.end_offset,
            self.fps,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        start_offset: __dataclass__init__fields__0__annotation,
        end_offset: __dataclass__init__fields__1__annotation,
        fps: __dataclass__init__fields__2__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'start_offset', start_offset)
        __dataclass__object_setattr(self, 'end_offset', end_offset)
        __dataclass__object_setattr(self, 'fps', fps)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"start_offset={self.start_offset!r}")
        parts.append(f"end_offset={self.end_offset!r}")
        parts.append(f"fps={self.fps!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('text', 'inline_data', 'function_call', 'function_response', 'file_data', 'executable_"
    "code', 'code_execution_result', 'thought', 'thought_signature', 'video_metadata')), EqPlan(fields=('text', 'inline"
    "_data', 'function_call', 'function_response', 'file_data', 'executable_code', 'code_execution_result', 'thought', "
    "'thought_signature', 'video_metadata')), FrozenPlan(fields=('text', 'inline_data', 'function_call', 'function_resp"
    "onse', 'file_data', 'executable_code', 'code_execution_result', 'thought', 'thought_signature', 'video_metadata'),"
    " allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('text', 'inline_data', 'function_call', 'functi"
    "on_response', 'file_data', 'executable_code', 'code_execution_result', 'thought', 'thought_signature', 'video_meta"
    "data'), cache=False), InitPlan(fields=(InitPlan.Field(name='text', annotation=OpRef(name='init.fields.0.annotation"
    "'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='inline_data', annotation=OpRef(n"
    "ame='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='fun"
    "ction_call', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), defau"
    "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='function_response', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(n"
    "ame='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='file_data', annotation=OpRef(name='init.fields.4.an"
    "notation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_ty"
    "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='executable_code', annota"
    "tion=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='code_execution_result', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.field"
    "s.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='thought', annotation=OpRef(name='init.fields.7.annotation'), defau"
    "lt=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
    "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='thought_signature', annotation=OpRef(name"
    "='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, overri"
    "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='video_"
    "metadata', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default"
    "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
    "ne)), self_param='self', std_params=(), kw_only_params=('text', 'inline_data', 'function_call', 'function_response"
    "', 'file_data', 'executable_code', 'code_execution_result', 'thought', 'thought_signature', 'video_metadata'), fro"
    "zen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name="
    "'text', kw_only=True, fn=None), ReprPlan.Field(name='inline_data', kw_only=True, fn=None), ReprPlan.Field(name='fu"
    "nction_call', kw_only=True, fn=None), ReprPlan.Field(name='function_response', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='file_data', kw_only=True, fn=None), ReprPlan.Field(name='executable_code', kw_only=True, fn=None), ReprP"
    "lan.Field(name='code_execution_result', kw_only=True, fn=None), ReprPlan.Field(name='thought', kw_only=True, fn=No"
    "ne), ReprPlan.Field(name='thought_signature', kw_only=True, fn=None), ReprPlan.Field(name='video_metadata', kw_onl"
    "y=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fPart(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            text=self.text,
            inline_data=self.inline_data,
            function_call=self.function_call,
            function_response=self.function_response,
            file_data=self.file_data,
            executable_code=self.executable_code,
            code_execution_result=self.code_execution_result,
            thought=self.thought,
            thought_signature=self.thought_signature,
            video_metadata=self.video_metadata,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.text == other.text and
            self.inline_data == other.inline_data and
            self.function_call == other.function_call and
            self.function_response == other.function_response and
            self.file_data == other.file_data and
            self.executable_code == other.executable_code and
            self.code_execution_result == other.code_execution_result and
            self.thought == other.thought and
            self.thought_signature == other.thought_signature and
            self.video_metadata == other.video_metadata
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'text',
        'inline_data',
        'function_call',
        'function_response',
        'file_data',
        'executable_code',
        'code_execution_result',
        'thought',
        'thought_signature',
        'video_metadata',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'text',
        'inline_data',
        'function_call',
        'function_response',
        'file_data',
        'executable_code',
        'code_execution_result',
        'thought',
        'thought_signature',
        'video_metadata',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.text,
            self.inline_data,
            self.function_call,
            self.function_response,
            self.file_data,
            self.executable_code,
            self.code_execution_result,
            self.thought,
            self.thought_signature,
            self.video_metadata,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        text: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        inline_data: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        function_call: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        function_response: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        file_data: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        executable_code: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        code_execution_result: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        thought: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        thought_signature: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        video_metadata: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'text', text)
        __dataclass__object_setattr(self, 'inline_data', inline_data)
        __dataclass__object_setattr(self, 'function_call', function_call)
        __dataclass__object_setattr(self, 'function_response', function_response)
        __dataclass__object_setattr(self, 'file_data', file_data)
        __dataclass__object_setattr(self, 'executable_code', executable_code)
        __dataclass__object_setattr(self, 'code_execution_result', code_execution_result)
        __dataclass__object_setattr(self, 'thought', thought)
        __dataclass__object_setattr(self, 'thought_signature', thought_signature)
        __dataclass__object_setattr(self, 'video_metadata', video_metadata)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"text={self.text!r}")
        parts.append(f"inline_data={self.inline_data!r}")
        parts.append(f"function_call={self.function_call!r}")
        parts.append(f"function_response={self.function_response!r}")
        parts.append(f"file_data={self.file_data!r}")
        parts.append(f"executable_code={self.executable_code!r}")
        parts.append(f"code_execution_result={self.code_execution_result!r}")
        parts.append(f"thought={self.thought!r}")
        parts.append(f"thought_signature={self.thought_signature!r}")
        parts.append(f"video_metadata={self.video_metadata!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('parts', 'role')), EqPlan(fields=('parts', 'role')), FrozenPlan(fields=('parts', 'role"
    "'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('parts', 'role'), cache=False), InitPlan(fie"
    "lds=(InitPlan.Field(name='parts', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fiel"
    "ds.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='role', annotation=OpRef(name='init.fields.1.annotation'), default"
    "=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('parts', 'rol"
    "e'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Fie"
    "ld(name='parts', kw_only=True, fn=None), ReprPlan.Field(name='role', kw_only=True, fn=None)), id=False, terse=Fals"
    "e, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fContent(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            parts=self.parts,
            role=self.role,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.parts == other.parts and
            self.role == other.role
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'parts',
        'role',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'parts',
        'role',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.parts,
            self.role,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        parts: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        role: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'parts', parts)
        __dataclass__object_setattr(self, 'role', role)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"parts={self.parts!r}")
        parts.append(f"role={self.role!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=(), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=(), cache=False), InitPlan(fields=(), self_param='self', std_params=(), kw_only_params=(),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fValue(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('null_value',)), EqPlan(fields=('null_value',)), FrozenPlan(fields=('null_value',), al"
    "low_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('null_value',), cache=False), InitPlan(fields=(Ini"
    "tPlan.Field(name='null_value', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields."
    "0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None),), self_param='self', std_params=('null_value',), kw_only_params=(), frozen=True, slots=Fa"
    "lse, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='null_value', kw_o"
    "nly=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fNullValue(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            null_value=self.null_value,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.null_value == other.null_value
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'null_value',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'null_value',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.null_value,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        null_value: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'null_value', null_value)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"null_value={self.null_value!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('number_value',)), EqPlan(fields=('number_value',)), FrozenPlan(fields=('number_value'"
    ",), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('number_value',), cache=False), InitPlan(fie"
    "lds=(InitPlan.Field(name='number_value', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e),), self_param='self', std_params=('number_value',), kw_only_params=(), frozen=True, slots=False, post_init_para"
    "ms=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='number_value', kw_only=False, fn=Non"
    "e),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fNumberValue(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            number_value=self.number_value,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.number_value == other.number_value
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'number_value',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'number_value',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.number_value,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        number_value: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'number_value', number_value)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"number_value={self.number_value!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('string_value',)), EqPlan(fields=('string_value',)), FrozenPlan(fields=('string_value'"
    ",), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('string_value',), cache=False), InitPlan(fie"
    "lds=(InitPlan.Field(name='string_value', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e),), self_param='self', std_params=('string_value',), kw_only_params=(), frozen=True, slots=False, post_init_para"
    "ms=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='string_value', kw_only=False, fn=Non"
    "e),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fStringValue(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            string_value=self.string_value,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.string_value == other.string_value
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'string_value',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'string_value',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.string_value,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        string_value: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'string_value', string_value)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"string_value={self.string_value!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('bool_value',)), EqPlan(fields=('bool_value',)), FrozenPlan(fields=('bool_value',), al"
    "low_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('bool_value',), cache=False), InitPlan(fields=(Ini"
    "tPlan.Field(name='bool_value', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self"
    "_param='self', std_params=('bool_value',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, ini"
    "t_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='bool_value', kw_only=False, fn=None),), id=False"
    ", terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fBoolValue(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            bool_value=self.bool_value,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.bool_value == other.bool_value
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'bool_value',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'bool_value',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.bool_value,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        bool_value: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'bool_value', bool_value)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"bool_value={self.bool_value!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('struct_value',)), EqPlan(fields=('struct_value',)), FrozenPlan(fields=('struct_value'"
    ",), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('struct_value',), cache=False), InitPlan(fie"
    "lds=(InitPlan.Field(name='struct_value', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_"
    "factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=Non"
    "e),), self_param='self', std_params=('struct_value',), kw_only_params=(), frozen=True, slots=False, post_init_para"
    "ms=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='struct_value', kw_only=False, fn=Non"
    "e),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fStructValue(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            struct_value=self.struct_value,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.struct_value == other.struct_value
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'struct_value',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'struct_value',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.struct_value,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        struct_value: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'struct_value', struct_value)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"struct_value={self.struct_value!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('list_value',)), EqPlan(fields=('list_value',)), FrozenPlan(fields=('list_value',), al"
    "low_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('list_value',), cache=False), InitPlan(fields=(Ini"
    "tPlan.Field(name='list_value', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self"
    "_param='self', std_params=('list_value',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, ini"
    "t_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='list_value', kw_only=False, fn=None),), id=False"
    ", terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fListValue(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            list_value=self.list_value,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.list_value == other.list_value
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'list_value',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'list_value',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.list_value,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        list_value: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'list_value', list_value)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"list_value={self.list_value!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('type', 'format', 'title', 'description', 'nullable', 'enum', 'max_items', 'min_items'"
    ", 'properties', 'required', 'min_properties', 'max_properties', 'min_length', 'max_length', 'pattern', 'example', "
    "'any_of', 'property_ordering', 'default', 'items', 'minimum', 'maximum')), EqPlan(fields=('type', 'format', 'title"
    "', 'description', 'nullable', 'enum', 'max_items', 'min_items', 'properties', 'required', 'min_properties', 'max_p"
    "roperties', 'min_length', 'max_length', 'pattern', 'example', 'any_of', 'property_ordering', 'default', 'items', '"
    "minimum', 'maximum')), FrozenPlan(fields=('type', 'format', 'title', 'description', 'nullable', 'enum', 'max_items"
    "', 'min_items', 'properties', 'required', 'min_properties', 'max_properties', 'min_length', 'max_length', 'pattern"
    "', 'example', 'any_of', 'property_ordering', 'default', 'items', 'minimum', 'maximum'), allow_dynamic_dunder_attrs"
    "=False), HashPlan(action='add', fields=('type', 'format', 'title', 'description', 'nullable', 'enum', 'max_items',"
    " 'min_items', 'properties', 'required', 'min_properties', 'max_properties', 'min_length', 'max_length', 'pattern',"
    " 'example', 'any_of', 'property_ordering', 'default', 'items', 'minimum', 'maximum'), cache=False), InitPlan(field"
    "s=(InitPlan.Field(name='type', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields."
    "0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='format', annotation=OpRef(name='init.fields.1.annotation'), default="
    "OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
    "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='title', annotation=OpRef(name='init.fields.2"
    ".annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field"
    "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='description', annotat"
    "ion=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='nullable', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'),"
    " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
    "_type=None), InitPlan.Field(name='enum', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='in"
    "it.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
    ", validate=None, check_type=None), InitPlan.Field(name='max_items', annotation=OpRef(name='init.fields.6.annotatio"
    "n'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='min_items', annotation=OpRef(na"
    "me='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='prop"
    "erties', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='required', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fie"
    "lds.9.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None), InitPlan.Field(name='min_properties', annotation=OpRef(name='init.fields.10.annotatio"
    "n'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_properties', annotation=Op"
    "Ref(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='min_length', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'),"
    " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
    "_type=None), InitPlan.Field(name='max_length', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(n"
    "ame='init.fields.13.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
    "rce=None, validate=None, check_type=None), InitPlan.Field(name='pattern', annotation=OpRef(name='init.fields.14.an"
    "notation'), default=OpRef(name='init.fields.14.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='example', annotation=Op"
    "Ref(name='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='any_of', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='property_ordering', annotation=OpRef(name='init.fields.17.annotation'), default=OpRe"
    "f(name='init.fields.17.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None), InitPlan.Field(name='default', annotation=OpRef(name='init.fields.18"
    ".annotation'), default=OpRef(name='init.fields.18.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='items', annotation=O"
    "pRef(name='init.fields.19.annotation'), default=OpRef(name='init.fields.19.default'), default_factory=None, init=T"
    "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
    "ame='minimum', annotation=OpRef(name='init.fields.20.annotation'), default=OpRef(name='init.fields.20.default'), d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None), InitPlan.Field(name='maximum', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='"
    "init.fields.21.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
    "one, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('type', 'format', 'title'"
    ", 'description', 'nullable', 'enum', 'max_items', 'min_items', 'properties', 'required', 'min_properties', 'max_pr"
    "operties', 'min_length', 'max_length', 'pattern', 'example', 'any_of', 'property_ordering', 'default', 'items', 'm"
    "inimum', 'maximum'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fiel"
    "ds=(ReprPlan.Field(name='type', kw_only=True, fn=None), ReprPlan.Field(name='format', kw_only=True, fn=None), Repr"
    "Plan.Field(name='title', kw_only=True, fn=None), ReprPlan.Field(name='description', kw_only=True, fn=None), ReprPl"
    "an.Field(name='nullable', kw_only=True, fn=None), ReprPlan.Field(name='enum', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='max_items', kw_only=True, fn=None), ReprPlan.Field(name='min_items', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='properties', kw_only=True, fn=None), ReprPlan.Field(name='required', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='min_properties', kw_only=True, fn=None), ReprPlan.Field(name='max_properties', kw_only=True, fn=None), Re"
    "prPlan.Field(name='min_length', kw_only=True, fn=None), ReprPlan.Field(name='max_length', kw_only=True, fn=None), "
    "ReprPlan.Field(name='pattern', kw_only=True, fn=None), ReprPlan.Field(name='example', kw_only=True, fn=None), Repr"
    "Plan.Field(name='any_of', kw_only=True, fn=None), ReprPlan.Field(name='property_ordering', kw_only=True, fn=None),"
    " ReprPlan.Field(name='default', kw_only=True, fn=None), ReprPlan.Field(name='items', kw_only=True, fn=None), ReprP"
    "lan.Field(name='minimum', kw_only=True, fn=None), ReprPlan.Field(name='maximum', kw_only=True, fn=None)), id=False"
    ", terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fSchema(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__21__annotation,
    __dataclass__init__fields__21__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            type=self.type,
            format=self.format,
            title=self.title,
            description=self.description,
            nullable=self.nullable,
            enum=self.enum,
            max_items=self.max_items,
            min_items=self.min_items,
            properties=self.properties,
            required=self.required,
            min_properties=self.min_properties,
            max_properties=self.max_properties,
            min_length=self.min_length,
            max_length=self.max_length,
            pattern=self.pattern,
            example=self.example,
            any_of=self.any_of,
            property_ordering=self.property_ordering,
            default=self.default,
            items=self.items,
            minimum=self.minimum,
            maximum=self.maximum,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.type == other.type and
            self.format == other.format and
            self.title == other.title and
            self.description == other.description and
            self.nullable == other.nullable and
            self.enum == other.enum and
            self.max_items == other.max_items and
            self.min_items == other.min_items and
            self.properties == other.properties and
            self.required == other.required and
            self.min_properties == other.min_properties and
            self.max_properties == other.max_properties and
            self.min_length == other.min_length and
            self.max_length == other.max_length and
            self.pattern == other.pattern and
            self.example == other.example and
            self.any_of == other.any_of and
            self.property_ordering == other.property_ordering and
            self.default == other.default and
            self.items == other.items and
            self.minimum == other.minimum and
            self.maximum == other.maximum
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'type',
        'format',
        'title',
        'description',
        'nullable',
        'enum',
        'max_items',
        'min_items',
        'properties',
        'required',
        'min_properties',
        'max_properties',
        'min_length',
        'max_length',
        'pattern',
        'example',
        'any_of',
        'property_ordering',
        'default',
        'items',
        'minimum',
        'maximum',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'type',
        'format',
        'title',
        'description',
        'nullable',
        'enum',
        'max_items',
        'min_items',
        'properties',
        'required',
        'min_properties',
        'max_properties',
        'min_length',
        'max_length',
        'pattern',
        'example',
        'any_of',
        'property_ordering',
        'default',
        'items',
        'minimum',
        'maximum',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.type,
            self.format,
            self.title,
            self.description,
            self.nullable,
            self.enum,
            self.max_items,
            self.min_items,
            self.properties,
            self.required,
            self.min_properties,
            self.max_properties,
            self.min_length,
            self.max_length,
            self.pattern,
            self.example,
            self.any_of,
            self.property_ordering,
            self.default,
            self.items,
            self.minimum,
            self.maximum,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        type: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        format: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        title: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        description: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        nullable: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        enum: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        max_items: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        min_items: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        properties: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        required: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        min_properties: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        max_properties: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        min_length: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        max_length: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        pattern: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        example: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        any_of: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        property_ordering: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        default: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        items: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        minimum: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        maximum: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'type', type)
        __dataclass__object_setattr(self, 'format', format)
        __dataclass__object_setattr(self, 'title', title)
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'nullable', nullable)
        __dataclass__object_setattr(self, 'enum', enum)
        __dataclass__object_setattr(self, 'max_items', max_items)
        __dataclass__object_setattr(self, 'min_items', min_items)
        __dataclass__object_setattr(self, 'properties', properties)
        __dataclass__object_setattr(self, 'required', required)
        __dataclass__object_setattr(self, 'min_properties', min_properties)
        __dataclass__object_setattr(self, 'max_properties', max_properties)
        __dataclass__object_setattr(self, 'min_length', min_length)
        __dataclass__object_setattr(self, 'max_length', max_length)
        __dataclass__object_setattr(self, 'pattern', pattern)
        __dataclass__object_setattr(self, 'example', example)
        __dataclass__object_setattr(self, 'any_of', any_of)
        __dataclass__object_setattr(self, 'property_ordering', property_ordering)
        __dataclass__object_setattr(self, 'default', default)
        __dataclass__object_setattr(self, 'items', items)
        __dataclass__object_setattr(self, 'minimum', minimum)
        __dataclass__object_setattr(self, 'maximum', maximum)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"type={self.type!r}")
        parts.append(f"format={self.format!r}")
        parts.append(f"title={self.title!r}")
        parts.append(f"description={self.description!r}")
        parts.append(f"nullable={self.nullable!r}")
        parts.append(f"enum={self.enum!r}")
        parts.append(f"max_items={self.max_items!r}")
        parts.append(f"min_items={self.min_items!r}")
        parts.append(f"properties={self.properties!r}")
        parts.append(f"required={self.required!r}")
        parts.append(f"min_properties={self.min_properties!r}")
        parts.append(f"max_properties={self.max_properties!r}")
        parts.append(f"min_length={self.min_length!r}")
        parts.append(f"max_length={self.max_length!r}")
        parts.append(f"pattern={self.pattern!r}")
        parts.append(f"example={self.example!r}")
        parts.append(f"any_of={self.any_of!r}")
        parts.append(f"property_ordering={self.property_ordering!r}")
        parts.append(f"default={self.default!r}")
        parts.append(f"items={self.items!r}")
        parts.append(f"minimum={self.minimum!r}")
        parts.append(f"maximum={self.maximum!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'description', 'behavior', 'parameters', 'parameters_json_schema', 'response',"
    " 'response_json_schema')), EqPlan(fields=('name', 'description', 'behavior', 'parameters', 'parameters_json_schema"
    "', 'response', 'response_json_schema')), FrozenPlan(fields=('name', 'description', 'behavior', 'parameters', 'para"
    "meters_json_schema', 'response', 'response_json_schema'), allow_dynamic_dunder_attrs=False), HashPlan(action='add'"
    ", fields=('name', 'description', 'behavior', 'parameters', 'parameters_json_schema', 'response', 'response_json_sc"
    "hema'), cache=False), InitPlan(fields=(InitPlan.Field(name='name', annotation=OpRef(name='init.fields.0.annotation"
    "'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='description', annotation=OpRef(name='init.fields.1.annotation')"
    ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='behavior', annotation=OpRef(name='init.fields.2.annotation'), def"
    "ault=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='parameters', annotation=OpRef(name='ini"
    "t.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=Fa"
    "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='parameters_"
    "json_schema', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='response', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='ini"
    "t.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None), InitPlan.Field(name='response_json_schema', annotation=OpRef(name='init.fields.6"
    ".annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field"
    "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only"
    "_params=('name', 'description', 'behavior', 'parameters', 'parameters_json_schema', 'response', 'response_json_sch"
    "ema'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.F"
    "ield(name='name', kw_only=True, fn=None), ReprPlan.Field(name='description', kw_only=True, fn=None), ReprPlan.Fiel"
    "d(name='behavior', kw_only=True, fn=None), ReprPlan.Field(name='parameters', kw_only=True, fn=None), ReprPlan.Fiel"
    "d(name='parameters_json_schema', kw_only=True, fn=None), ReprPlan.Field(name='response', kw_only=True, fn=None), R"
    "eprPlan.Field(name='response_json_schema', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fFunctionDeclaration(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            description=self.description,
            behavior=self.behavior,
            parameters=self.parameters,
            parameters_json_schema=self.parameters_json_schema,
            response=self.response,
            response_json_schema=self.response_json_schema,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.description == other.description and
            self.behavior == other.behavior and
            self.parameters == other.parameters and
            self.parameters_json_schema == other.parameters_json_schema and
            self.response == other.response and
            self.response_json_schema == other.response_json_schema
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'name',
        'description',
        'behavior',
        'parameters',
        'parameters_json_schema',
        'response',
        'response_json_schema',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
        'description',
        'behavior',
        'parameters',
        'parameters_json_schema',
        'response',
        'response_json_schema',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.description,
            self.behavior,
            self.parameters,
            self.parameters_json_schema,
            self.response,
            self.response_json_schema,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        name: __dataclass__init__fields__0__annotation,
        description: __dataclass__init__fields__1__annotation,
        behavior: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        parameters: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        parameters_json_schema: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        response: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        response_json_schema: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'behavior', behavior)
        __dataclass__object_setattr(self, 'parameters', parameters)
        __dataclass__object_setattr(self, 'parameters_json_schema', parameters_json_schema)
        __dataclass__object_setattr(self, 'response', response)
        __dataclass__object_setattr(self, 'response_json_schema', response_json_schema)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"description={self.description!r}")
        parts.append(f"behavior={self.behavior!r}")
        parts.append(f"parameters={self.parameters!r}")
        parts.append(f"parameters_json_schema={self.parameters_json_schema!r}")
        parts.append(f"response={self.response!r}")
        parts.append(f"response_json_schema={self.response_json_schema!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('mode', 'dynamic_threshold')), EqPlan(fields=('mode', 'dynamic_threshold')), FrozenPla"
    "n(fields=('mode', 'dynamic_threshold'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('mode', "
    "'dynamic_threshold'), cache=False), InitPlan(fields=(InitPlan.Field(name='mode', annotation=OpRef(name='init.field"
    "s.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='dynamic_threshold'"
    ", annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), sel"
    "f_param='self', std_params=(), kw_only_params=('mode', 'dynamic_threshold'), frozen=True, slots=False, post_init_p"
    "arams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='mode', kw_only=True, fn=None), Re"
    "prPlan.Field(name='dynamic_threshold', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fDynamicRetrievalConfig(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            mode=self.mode,
            dynamic_threshold=self.dynamic_threshold,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.mode == other.mode and
            self.dynamic_threshold == other.dynamic_threshold
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'mode',
        'dynamic_threshold',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'mode',
        'dynamic_threshold',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.mode,
            self.dynamic_threshold,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        mode: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        dynamic_threshold: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'mode', mode)
        __dataclass__object_setattr(self, 'dynamic_threshold', dynamic_threshold)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"mode={self.mode!r}")
        parts.append(f"dynamic_threshold={self.dynamic_threshold!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('dynamic_retrieval_config',)), EqPlan(fields=('dynamic_retrieval_config',)), FrozenPla"
    "n(fields=('dynamic_retrieval_config',), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('dynamic"
    "_retrieval_config',), cache=False), InitPlan(fields=(InitPlan.Field(name='dynamic_retrieval_config', annotation=Op"
    "Ref(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_params"
    "=('dynamic_retrieval_config',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Re"
    "prPlan(fields=(ReprPlan.Field(name='dynamic_retrieval_config', kw_only=True, fn=None),), id=False, terse=False, de"
    "fault_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fGoogleSearchRetrieval(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            dynamic_retrieval_config=self.dynamic_retrieval_config,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.dynamic_retrieval_config == other.dynamic_retrieval_config
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'dynamic_retrieval_config',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'dynamic_retrieval_config',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.dynamic_retrieval_config,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        dynamic_retrieval_config: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'dynamic_retrieval_config', dynamic_retrieval_config)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"dynamic_retrieval_config={self.dynamic_retrieval_config!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=(), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=(), cache=False), InitPlan(fields=(), self_param='self', std_params=(), kw_only_params=(),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fCodeExecution(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('start_time', 'end_time')), EqPlan(fields=('start_time', 'end_time')), FrozenPlan(fiel"
    "ds=('start_time', 'end_time'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('start_time', 'en"
    "d_time'), cache=False), InitPlan(fields=(InitPlan.Field(name='start_time', annotation=OpRef(name='init.fields.0.an"
    "notation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
    "one, validate=None, check_type=None), InitPlan.Field(name='end_time', annotation=OpRef(name='init.fields.1.annotat"
    "ion'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('start_time', 'end_time'), fro"
    "zen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name="
    "'start_time', kw_only=True, fn=None), ReprPlan.Field(name='end_time', kw_only=True, fn=None)), id=False, terse=Fal"
    "se, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fInterval(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            start_time=self.start_time,
            end_time=self.end_time,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.start_time == other.start_time and
            self.end_time == other.end_time
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'start_time',
        'end_time',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'start_time',
        'end_time',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.start_time,
            self.end_time,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        start_time: __dataclass__init__fields__0__annotation,
        end_time: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'start_time', start_time)
        __dataclass__object_setattr(self, 'end_time', end_time)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"start_time={self.start_time!r}")
        parts.append(f"end_time={self.end_time!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('time_range_filter',)), EqPlan(fields=('time_range_filter',)), FrozenPlan(fields=('tim"
    "e_range_filter',), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('time_range_filter',), cache="
    "False), InitPlan(fields=(InitPlan.Field(name='time_range_filter', annotation=OpRef(name='init.fields.0.annotation'"
    "), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_params=('t"
    "ime_range_filter',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fiel"
    "ds=(ReprPlan.Field(name='time_range_filter', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fGoogleSearch(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            time_range_filter=self.time_range_filter,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.time_range_filter == other.time_range_filter
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'time_range_filter',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'time_range_filter',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.time_range_filter,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        time_range_filter: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'time_range_filter', time_range_filter)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"time_range_filter={self.time_range_filter!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=(), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=(), cache=False), InitPlan(fields=(), self_param='self', std_params=(), kw_only_params=(),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fUrlContext(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('function_declarations', 'google_search_retrieval', 'code_execution', 'google_search',"
    " 'url_context')), EqPlan(fields=('function_declarations', 'google_search_retrieval', 'code_execution', 'google_sea"
    "rch', 'url_context')), FrozenPlan(fields=('function_declarations', 'google_search_retrieval', 'code_execution', 'g"
    "oogle_search', 'url_context'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('function_declara"
    "tions', 'google_search_retrieval', 'code_execution', 'google_search', 'url_context'), cache=False), InitPlan(field"
    "s=(InitPlan.Field(name='function_declarations', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(n"
    "ame='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='google_search_retrieval', annotation=OpRef(name='in"
    "it.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='code_execu"
    "tion', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='google_search', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init."
    "fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None), InitPlan.Field(name='url_context', annotation=OpRef(name='init.fields.4.annotation"
    "'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('f"
    "unction_declarations', 'google_search_retrieval', 'code_execution', 'google_search', 'url_context'), frozen=True, "
    "slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='function_"
    "declarations', kw_only=True, fn=None), ReprPlan.Field(name='google_search_retrieval', kw_only=True, fn=None), Repr"
    "Plan.Field(name='code_execution', kw_only=True, fn=None), ReprPlan.Field(name='google_search', kw_only=True, fn=No"
    "ne), ReprPlan.Field(name='url_context', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fTool(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            function_declarations=self.function_declarations,
            google_search_retrieval=self.google_search_retrieval,
            code_execution=self.code_execution,
            google_search=self.google_search,
            url_context=self.url_context,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.function_declarations == other.function_declarations and
            self.google_search_retrieval == other.google_search_retrieval and
            self.code_execution == other.code_execution and
            self.google_search == other.google_search and
            self.url_context == other.url_context
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'function_declarations',
        'google_search_retrieval',
        'code_execution',
        'google_search',
        'url_context',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'function_declarations',
        'google_search_retrieval',
        'code_execution',
        'google_search',
        'url_context',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.function_declarations,
            self.google_search_retrieval,
            self.code_execution,
            self.google_search,
            self.url_context,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        function_declarations: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        google_search_retrieval: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        code_execution: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        google_search: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        url_context: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'function_declarations', function_declarations)
        __dataclass__object_setattr(self, 'google_search_retrieval', google_search_retrieval)
        __dataclass__object_setattr(self, 'code_execution', code_execution)
        __dataclass__object_setattr(self, 'google_search', google_search)
        __dataclass__object_setattr(self, 'url_context', url_context)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"function_declarations={self.function_declarations!r}")
        parts.append(f"google_search_retrieval={self.google_search_retrieval!r}")
        parts.append(f"code_execution={self.code_execution!r}")
        parts.append(f"google_search={self.google_search!r}")
        parts.append(f"url_context={self.url_context!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('mode', 'allowed_function_names')), EqPlan(fields=('mode', 'allowed_function_names')),"
    " FrozenPlan(fields=('mode', 'allowed_function_names'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', f"
    "ields=('mode', 'allowed_function_names'), cache=False), InitPlan(fields=(InitPlan.Field(name='mode', annotation=Op"
    "Ref(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True"
    ", override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name"
    "='allowed_function_names', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None)), self_param='self', std_params=(), kw_only_params=('mode', 'allowed_function_names'), frozen="
    "True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='mod"
    "e', kw_only=True, fn=None), ReprPlan.Field(name='allowed_function_names', kw_only=True, fn=None)), id=False, terse"
    "=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fFunctionCallingConfig(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            mode=self.mode,
            allowed_function_names=self.allowed_function_names,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.mode == other.mode and
            self.allowed_function_names == other.allowed_function_names
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'mode',
        'allowed_function_names',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'mode',
        'allowed_function_names',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.mode,
            self.allowed_function_names,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        mode: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        allowed_function_names: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'mode', mode)
        __dataclass__object_setattr(self, 'allowed_function_names', allowed_function_names)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"mode={self.mode!r}")
        parts.append(f"allowed_function_names={self.allowed_function_names!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('function_calling_config',)), EqPlan(fields=('function_calling_config',)), FrozenPlan("
    "fields=('function_calling_config',), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('function_c"
    "alling_config',), cache=False), InitPlan(fields=(InitPlan.Field(name='function_calling_config', annotation=OpRef(n"
    "ame='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std"
    "_params=(), kw_only_params=('function_calling_config',), frozen=True, slots=False, post_init_params=None, init_fns"
    "=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='function_calling_config', kw_only=True, fn=None),), i"
    "d=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fToolConfig(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            function_calling_config=self.function_calling_config,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.function_calling_config == other.function_calling_config
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'function_calling_config',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'function_calling_config',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.function_calling_config,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        function_calling_config: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'function_calling_config', function_calling_config)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"function_calling_config={self.function_calling_config!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('category', 'threshold')), EqPlan(fields=('category', 'threshold')), FrozenPlan(fields"
    "=('category', 'threshold'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('category', 'thresho"
    "ld'), cache=False), InitPlan(fields=(InitPlan.Field(name='category', annotation=OpRef(name='init.fields.0.annotati"
    "on'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None), InitPlan.Field(name='threshold', annotation=OpRef(name='init.fields.1.annotation')"
    ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('category', 'threshold'), frozen=Tr"
    "ue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='categ"
    "ory', kw_only=True, fn=None), ReprPlan.Field(name='threshold', kw_only=True, fn=None)), id=False, terse=False, def"
    "ault_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fSafetySetting(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            category=self.category,
            threshold=self.threshold,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.category == other.category and
            self.threshold == other.threshold
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'category',
        'threshold',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'category',
        'threshold',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.category,
            self.threshold,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        category: __dataclass__init__fields__0__annotation,
        threshold: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'category', category)
        __dataclass__object_setattr(self, 'threshold', threshold)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"category={self.category!r}")
        parts.append(f"threshold={self.threshold!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('include_thoughts', 'thinking_budget')), EqPlan(fields=('include_thoughts', 'thinking_"
    "budget')), FrozenPlan(fields=('include_thoughts', 'thinking_budget'), allow_dynamic_dunder_attrs=False), HashPlan("
    "action='add', fields=('include_thoughts', 'thinking_budget'), cache=False), InitPlan(fields=(InitPlan.Field(name='"
    "include_thoughts', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'),"
    " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
    "_type=None), InitPlan.Field(name='thinking_budget', annotation=OpRef(name='init.fields.1.annotation'), default=OpR"
    "ef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('include_thoughts"
    "', 'thinking_budget'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fi"
    "elds=(ReprPlan.Field(name='include_thoughts', kw_only=True, fn=None), ReprPlan.Field(name='thinking_budget', kw_on"
    "ly=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fThinkingConfig(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            include_thoughts=self.include_thoughts,
            thinking_budget=self.thinking_budget,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.include_thoughts == other.include_thoughts and
            self.thinking_budget == other.thinking_budget
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'include_thoughts',
        'thinking_budget',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'include_thoughts',
        'thinking_budget',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.include_thoughts,
            self.thinking_budget,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        include_thoughts: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        thinking_budget: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'include_thoughts', include_thoughts)
        __dataclass__object_setattr(self, 'thinking_budget', thinking_budget)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"include_thoughts={self.include_thoughts!r}")
        parts.append(f"thinking_budget={self.thinking_budget!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('stop_sequences', 'response_mime_type', 'response_schema', 'response_json_schema', 're"
    "sponse_modalities', 'candidate_count', 'max_output_tokens', 'temperature', 'top_p', 'top_k', 'seed', 'presence_pen"
    "alty', 'frequency_penalty', 'response_logprobs', 'logprobs', 'enable_enhanced_civic_answers', 'thinking_config', '"
    "media_resolution')), EqPlan(fields=('stop_sequences', 'response_mime_type', 'response_schema', 'response_json_sche"
    "ma', 'response_modalities', 'candidate_count', 'max_output_tokens', 'temperature', 'top_p', 'top_k', 'seed', 'pres"
    "ence_penalty', 'frequency_penalty', 'response_logprobs', 'logprobs', 'enable_enhanced_civic_answers', 'thinking_co"
    "nfig', 'media_resolution')), FrozenPlan(fields=('stop_sequences', 'response_mime_type', 'response_schema', 'respon"
    "se_json_schema', 'response_modalities', 'candidate_count', 'max_output_tokens', 'temperature', 'top_p', 'top_k', '"
    "seed', 'presence_penalty', 'frequency_penalty', 'response_logprobs', 'logprobs', 'enable_enhanced_civic_answers', "
    "'thinking_config', 'media_resolution'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('stop_se"
    "quences', 'response_mime_type', 'response_schema', 'response_json_schema', 'response_modalities', 'candidate_count"
    "', 'max_output_tokens', 'temperature', 'top_p', 'top_k', 'seed', 'presence_penalty', 'frequency_penalty', 'respons"
    "e_logprobs', 'logprobs', 'enable_enhanced_civic_answers', 'thinking_config', 'media_resolution'), cache=False), In"
    "itPlan(fields=(InitPlan.Field(name='stop_sequences', annotation=OpRef(name='init.fields.0.annotation'), default=Op"
    "Ref(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='response_mime_type', annotation=OpRef(name='in"
    "it.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='response_s"
    "chema', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='response_json_schema', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(nam"
    "e='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='response_modalities', annotation=OpRef(name='init.fie"
    "lds.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='candidate_count'"
    ", annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='max_output_tokens', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.f"
    "ields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='temperature', annotation=OpRef(name='init.fields.7.annotation'"
    "), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='top_p', annotation=OpRef(name='in"
    "it.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='top_k', an"
    "notation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
    ".Field(name='seed', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default"
    "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None), InitPlan.Field(name='presence_penalty', annotation=OpRef(name='init.fields.11.annotation'), defaul"
    "t=OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
    "ANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='frequency_penalty', annotation=OpRef(name"
    "='init.fields.12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='resp"
    "onse_logprobs', annotation=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13.default'), "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None), InitPlan.Field(name='logprobs', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name"
    "='init.fields.14.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='enable_enhanced_civic_answers', annotation=OpRef(name"
    "='init.fields.15.annotation'), default=OpRef(name='init.fields.15.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='thin"
    "king_config', annotation=OpRef(name='init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), de"
    "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='media_resolution', annotation=OpRef(name='init.fields.17.annotation'), default=OpRe"
    "f(name='init.fields.17.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('stop_sequences',"
    " 'response_mime_type', 'response_schema', 'response_json_schema', 'response_modalities', 'candidate_count', 'max_o"
    "utput_tokens', 'temperature', 'top_p', 'top_k', 'seed', 'presence_penalty', 'frequency_penalty', 'response_logprob"
    "s', 'logprobs', 'enable_enhanced_civic_answers', 'thinking_config', 'media_resolution'), frozen=True, slots=False,"
    " post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='stop_sequences', kw_o"
    "nly=True, fn=None), ReprPlan.Field(name='response_mime_type', kw_only=True, fn=None), ReprPlan.Field(name='respons"
    "e_schema', kw_only=True, fn=None), ReprPlan.Field(name='response_json_schema', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='response_modalities', kw_only=True, fn=None), ReprPlan.Field(name='candidate_count', kw_only=True, fn=No"
    "ne), ReprPlan.Field(name='max_output_tokens', kw_only=True, fn=None), ReprPlan.Field(name='temperature', kw_only=T"
    "rue, fn=None), ReprPlan.Field(name='top_p', kw_only=True, fn=None), ReprPlan.Field(name='top_k', kw_only=True, fn="
    "None), ReprPlan.Field(name='seed', kw_only=True, fn=None), ReprPlan.Field(name='presence_penalty', kw_only=True, f"
    "n=None), ReprPlan.Field(name='frequency_penalty', kw_only=True, fn=None), ReprPlan.Field(name='response_logprobs',"
    " kw_only=True, fn=None), ReprPlan.Field(name='logprobs', kw_only=True, fn=None), ReprPlan.Field(name='enable_enhan"
    "ced_civic_answers', kw_only=True, fn=None), ReprPlan.Field(name='thinking_config', kw_only=True, fn=None), ReprPla"
    "n.Field(name='media_resolution', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fGenerationConfig(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            stop_sequences=self.stop_sequences,
            response_mime_type=self.response_mime_type,
            response_schema=self.response_schema,
            response_json_schema=self.response_json_schema,
            response_modalities=self.response_modalities,
            candidate_count=self.candidate_count,
            max_output_tokens=self.max_output_tokens,
            temperature=self.temperature,
            top_p=self.top_p,
            top_k=self.top_k,
            seed=self.seed,
            presence_penalty=self.presence_penalty,
            frequency_penalty=self.frequency_penalty,
            response_logprobs=self.response_logprobs,
            logprobs=self.logprobs,
            enable_enhanced_civic_answers=self.enable_enhanced_civic_answers,
            thinking_config=self.thinking_config,
            media_resolution=self.media_resolution,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.stop_sequences == other.stop_sequences and
            self.response_mime_type == other.response_mime_type and
            self.response_schema == other.response_schema and
            self.response_json_schema == other.response_json_schema and
            self.response_modalities == other.response_modalities and
            self.candidate_count == other.candidate_count and
            self.max_output_tokens == other.max_output_tokens and
            self.temperature == other.temperature and
            self.top_p == other.top_p and
            self.top_k == other.top_k and
            self.seed == other.seed and
            self.presence_penalty == other.presence_penalty and
            self.frequency_penalty == other.frequency_penalty and
            self.response_logprobs == other.response_logprobs and
            self.logprobs == other.logprobs and
            self.enable_enhanced_civic_answers == other.enable_enhanced_civic_answers and
            self.thinking_config == other.thinking_config and
            self.media_resolution == other.media_resolution
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'stop_sequences',
        'response_mime_type',
        'response_schema',
        'response_json_schema',
        'response_modalities',
        'candidate_count',
        'max_output_tokens',
        'temperature',
        'top_p',
        'top_k',
        'seed',
        'presence_penalty',
        'frequency_penalty',
        'response_logprobs',
        'logprobs',
        'enable_enhanced_civic_answers',
        'thinking_config',
        'media_resolution',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'stop_sequences',
        'response_mime_type',
        'response_schema',
        'response_json_schema',
        'response_modalities',
        'candidate_count',
        'max_output_tokens',
        'temperature',
        'top_p',
        'top_k',
        'seed',
        'presence_penalty',
        'frequency_penalty',
        'response_logprobs',
        'logprobs',
        'enable_enhanced_civic_answers',
        'thinking_config',
        'media_resolution',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.stop_sequences,
            self.response_mime_type,
            self.response_schema,
            self.response_json_schema,
            self.response_modalities,
            self.candidate_count,
            self.max_output_tokens,
            self.temperature,
            self.top_p,
            self.top_k,
            self.seed,
            self.presence_penalty,
            self.frequency_penalty,
            self.response_logprobs,
            self.logprobs,
            self.enable_enhanced_civic_answers,
            self.thinking_config,
            self.media_resolution,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        stop_sequences: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        response_mime_type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        response_schema: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        response_json_schema: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        response_modalities: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        candidate_count: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        max_output_tokens: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        temperature: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        top_p: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        top_k: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        seed: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        presence_penalty: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        frequency_penalty: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        response_logprobs: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        logprobs: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        enable_enhanced_civic_answers: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        thinking_config: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        media_resolution: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'stop_sequences', stop_sequences)
        __dataclass__object_setattr(self, 'response_mime_type', response_mime_type)
        __dataclass__object_setattr(self, 'response_schema', response_schema)
        __dataclass__object_setattr(self, 'response_json_schema', response_json_schema)
        __dataclass__object_setattr(self, 'response_modalities', response_modalities)
        __dataclass__object_setattr(self, 'candidate_count', candidate_count)
        __dataclass__object_setattr(self, 'max_output_tokens', max_output_tokens)
        __dataclass__object_setattr(self, 'temperature', temperature)
        __dataclass__object_setattr(self, 'top_p', top_p)
        __dataclass__object_setattr(self, 'top_k', top_k)
        __dataclass__object_setattr(self, 'seed', seed)
        __dataclass__object_setattr(self, 'presence_penalty', presence_penalty)
        __dataclass__object_setattr(self, 'frequency_penalty', frequency_penalty)
        __dataclass__object_setattr(self, 'response_logprobs', response_logprobs)
        __dataclass__object_setattr(self, 'logprobs', logprobs)
        __dataclass__object_setattr(self, 'enable_enhanced_civic_answers', enable_enhanced_civic_answers)
        __dataclass__object_setattr(self, 'thinking_config', thinking_config)
        __dataclass__object_setattr(self, 'media_resolution', media_resolution)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"stop_sequences={self.stop_sequences!r}")
        parts.append(f"response_mime_type={self.response_mime_type!r}")
        parts.append(f"response_schema={self.response_schema!r}")
        parts.append(f"response_json_schema={self.response_json_schema!r}")
        parts.append(f"response_modalities={self.response_modalities!r}")
        parts.append(f"candidate_count={self.candidate_count!r}")
        parts.append(f"max_output_tokens={self.max_output_tokens!r}")
        parts.append(f"temperature={self.temperature!r}")
        parts.append(f"top_p={self.top_p!r}")
        parts.append(f"top_k={self.top_k!r}")
        parts.append(f"seed={self.seed!r}")
        parts.append(f"presence_penalty={self.presence_penalty!r}")
        parts.append(f"frequency_penalty={self.frequency_penalty!r}")
        parts.append(f"response_logprobs={self.response_logprobs!r}")
        parts.append(f"logprobs={self.logprobs!r}")
        parts.append(f"enable_enhanced_civic_answers={self.enable_enhanced_civic_answers!r}")
        parts.append(f"thinking_config={self.thinking_config!r}")
        parts.append(f"media_resolution={self.media_resolution!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('contents', 'tools', 'tool_config', 'safety_settings', 'system_instruction', 'generati"
    "on_config', 'cached_content')), EqPlan(fields=('contents', 'tools', 'tool_config', 'safety_settings', 'system_inst"
    "ruction', 'generation_config', 'cached_content')), FrozenPlan(fields=('contents', 'tools', 'tool_config', 'safety_"
    "settings', 'system_instruction', 'generation_config', 'cached_content'), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=('contents', 'tools', 'tool_config', 'safety_settings', 'system_instruction', 'generation_"
    "config', 'cached_content'), cache=False), InitPlan(fields=(InitPlan.Field(name='contents', annotation=OpRef(name='"
    "init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tools', "
    "annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='tool_config', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='safety_settings', annotation=OpRef(name='init.fields.3.annotation'), d"
    "efault=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType."
    "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='system_instruction', annotation=OpRef"
    "(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='g"
    "eneration_config', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'),"
    " default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check"
    "_type=None), InitPlan.Field(name='cached_content', annotation=OpRef(name='init.fields.6.annotation'), default=OpRe"
    "f(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('contents', 'tools"
    "', 'tool_config', 'safety_settings', 'system_instruction', 'generation_config', 'cached_content'), frozen=True, sl"
    "ots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='contents', "
    "kw_only=True, fn=None), ReprPlan.Field(name='tools', kw_only=True, fn=None), ReprPlan.Field(name='tool_config', kw"
    "_only=True, fn=None), ReprPlan.Field(name='safety_settings', kw_only=True, fn=None), ReprPlan.Field(name='system_i"
    "nstruction', kw_only=True, fn=None), ReprPlan.Field(name='generation_config', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='cached_content', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fGenerateContentRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            contents=self.contents,
            tools=self.tools,
            tool_config=self.tool_config,
            safety_settings=self.safety_settings,
            system_instruction=self.system_instruction,
            generation_config=self.generation_config,
            cached_content=self.cached_content,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.contents == other.contents and
            self.tools == other.tools and
            self.tool_config == other.tool_config and
            self.safety_settings == other.safety_settings and
            self.system_instruction == other.system_instruction and
            self.generation_config == other.generation_config and
            self.cached_content == other.cached_content
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'contents',
        'tools',
        'tool_config',
        'safety_settings',
        'system_instruction',
        'generation_config',
        'cached_content',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'contents',
        'tools',
        'tool_config',
        'safety_settings',
        'system_instruction',
        'generation_config',
        'cached_content',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.contents,
            self.tools,
            self.tool_config,
            self.safety_settings,
            self.system_instruction,
            self.generation_config,
            self.cached_content,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        contents: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        tools: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        tool_config: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        safety_settings: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        system_instruction: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        generation_config: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        cached_content: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'contents', contents)
        __dataclass__object_setattr(self, 'tools', tools)
        __dataclass__object_setattr(self, 'tool_config', tool_config)
        __dataclass__object_setattr(self, 'safety_settings', safety_settings)
        __dataclass__object_setattr(self, 'system_instruction', system_instruction)
        __dataclass__object_setattr(self, 'generation_config', generation_config)
        __dataclass__object_setattr(self, 'cached_content', cached_content)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"contents={self.contents!r}")
        parts.append(f"tools={self.tools!r}")
        parts.append(f"tool_config={self.tool_config!r}")
        parts.append(f"safety_settings={self.safety_settings!r}")
        parts.append(f"system_instruction={self.system_instruction!r}")
        parts.append(f"generation_config={self.generation_config!r}")
        parts.append(f"cached_content={self.cached_content!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('content', 'finish_reason', 'finish_message', 'token_count', 'avg_logprobs', 'index'))"
    ", EqPlan(fields=('content', 'finish_reason', 'finish_message', 'token_count', 'avg_logprobs', 'index')), FrozenPla"
    "n(fields=('content', 'finish_reason', 'finish_message', 'token_count', 'avg_logprobs', 'index'), allow_dynamic_dun"
    "der_attrs=False), HashPlan(action='add', fields=('content', 'finish_reason', 'finish_message', 'token_count', 'avg"
    "_logprobs', 'index'), cache=False), InitPlan(fields=(InitPlan.Field(name='content', annotation=OpRef(name='init.fi"
    "elds.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='finish_reason',"
    " annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=N"
    "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
    "lan.Field(name='finish_message', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.field"
    "s.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='token_count', annotation=OpRef(name='init.fields.3.annotation'), d"
    "efault=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType."
    "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='avg_logprobs', annotation=OpRef(name="
    "'init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='index',"
    " annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=N"
    "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self"
    "_param='self', std_params=(), kw_only_params=('content', 'finish_reason', 'finish_message', 'token_count', 'avg_lo"
    "gprobs', 'index'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields"
    "=(ReprPlan.Field(name='content', kw_only=True, fn=None), ReprPlan.Field(name='finish_reason', kw_only=True, fn=Non"
    "e), ReprPlan.Field(name='finish_message', kw_only=True, fn=None), ReprPlan.Field(name='token_count', kw_only=True,"
    " fn=None), ReprPlan.Field(name='avg_logprobs', kw_only=True, fn=None), ReprPlan.Field(name='index', kw_only=True, "
    "fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fGenerateContentResponse_2fCandidate(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            content=self.content,
            finish_reason=self.finish_reason,
            finish_message=self.finish_message,
            token_count=self.token_count,
            avg_logprobs=self.avg_logprobs,
            index=self.index,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.content == other.content and
            self.finish_reason == other.finish_reason and
            self.finish_message == other.finish_message and
            self.token_count == other.token_count and
            self.avg_logprobs == other.avg_logprobs and
            self.index == other.index
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'content',
        'finish_reason',
        'finish_message',
        'token_count',
        'avg_logprobs',
        'index',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'content',
        'finish_reason',
        'finish_message',
        'token_count',
        'avg_logprobs',
        'index',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.content,
            self.finish_reason,
            self.finish_message,
            self.token_count,
            self.avg_logprobs,
            self.index,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        content: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        finish_reason: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        finish_message: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        token_count: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        avg_logprobs: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        index: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'finish_reason', finish_reason)
        __dataclass__object_setattr(self, 'finish_message', finish_message)
        __dataclass__object_setattr(self, 'token_count', token_count)
        __dataclass__object_setattr(self, 'avg_logprobs', avg_logprobs)
        __dataclass__object_setattr(self, 'index', index)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"content={self.content!r}")
        parts.append(f"finish_reason={self.finish_reason!r}")
        parts.append(f"finish_message={self.finish_message!r}")
        parts.append(f"token_count={self.token_count!r}")
        parts.append(f"avg_logprobs={self.avg_logprobs!r}")
        parts.append(f"index={self.index!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('modality', 'token_count')), EqPlan(fields=('modality', 'token_count')), FrozenPlan(fi"
    "elds=('modality', 'token_count'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('modality', 't"
    "oken_count'), cache=False), InitPlan(fields=(InitPlan.Field(name='modality', annotation=OpRef(name='init.fields.0."
    "annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='token_count', annotati"
    "on=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='s"
    "elf', std_params=(), kw_only_params=('modality', 'token_count'), frozen=True, slots=False, post_init_params=None, "
    "init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='modality', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='token_count', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fGenerateContentResponse_2fUsageMetadata_2fModalityTokenCount(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            modality=self.modality,
            token_count=self.token_count,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.modality == other.modality and
            self.token_count == other.token_count
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'modality',
        'token_count',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'modality',
        'token_count',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.modality,
            self.token_count,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        modality: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        token_count: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'modality', modality)
        __dataclass__object_setattr(self, 'token_count', token_count)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"modality={self.modality!r}")
        parts.append(f"token_count={self.token_count!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('prompt_token_count', 'cached_content_token_count', 'candidates_token_count', 'total_t"
    "oken_count', 'thoughts_token_count', 'prompt_tokens_details', 'cache_tokens_details', 'candidates_tokens_details',"
    " 'tool_use_prompt_tokens_details')), EqPlan(fields=('prompt_token_count', 'cached_content_token_count', 'candidate"
    "s_token_count', 'total_token_count', 'thoughts_token_count', 'prompt_tokens_details', 'cache_tokens_details', 'can"
    "didates_tokens_details', 'tool_use_prompt_tokens_details')), FrozenPlan(fields=('prompt_token_count', 'cached_cont"
    "ent_token_count', 'candidates_token_count', 'total_token_count', 'thoughts_token_count', 'prompt_tokens_details', "
    "'cache_tokens_details', 'candidates_tokens_details', 'tool_use_prompt_tokens_details'), allow_dynamic_dunder_attrs"
    "=False), HashPlan(action='add', fields=('prompt_token_count', 'cached_content_token_count', 'candidates_token_coun"
    "t', 'total_token_count', 'thoughts_token_count', 'prompt_tokens_details', 'cache_tokens_details', 'candidates_toke"
    "ns_details', 'tool_use_prompt_tokens_details'), cache=False), InitPlan(fields=(InitPlan.Field(name='prompt_token_c"
    "ount', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='cached_content_token_count', annotation=OpRef(name='init.fields.1.annotation'), default=OpRe"
    "f(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='candidates_token_count', annotation=OpRef(name='"
    "init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='total_to"
    "ken_count', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='thoughts_token_count', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef"
    "(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None), InitPlan.Field(name='prompt_tokens_details', annotation=OpRef(name='in"
    "it.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cache_toke"
    "ns_details', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), defau"
    "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='candidates_tokens_details', annotation=OpRef(name='init.fields.7.annotation'), default"
    "=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tool_use_prompt_tokens_details', annotation"
    "=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=T"
    "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='sel"
    "f', std_params=(), kw_only_params=('prompt_token_count', 'cached_content_token_count', 'candidates_token_count', '"
    "total_token_count', 'thoughts_token_count', 'prompt_tokens_details', 'cache_tokens_details', 'candidates_tokens_de"
    "tails', 'tool_use_prompt_tokens_details'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_"
    "fns=()), ReprPlan(fields=(ReprPlan.Field(name='prompt_token_count', kw_only=True, fn=None), ReprPlan.Field(name='c"
    "ached_content_token_count', kw_only=True, fn=None), ReprPlan.Field(name='candidates_token_count', kw_only=True, fn"
    "=None), ReprPlan.Field(name='total_token_count', kw_only=True, fn=None), ReprPlan.Field(name='thoughts_token_count"
    "', kw_only=True, fn=None), ReprPlan.Field(name='prompt_tokens_details', kw_only=True, fn=None), ReprPlan.Field(nam"
    "e='cache_tokens_details', kw_only=True, fn=None), ReprPlan.Field(name='candidates_tokens_details', kw_only=True, f"
    "n=None), ReprPlan.Field(name='tool_use_prompt_tokens_details', kw_only=True, fn=None)), id=False, terse=False, def"
    "ault_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fGenerateContentResponse_2fUsageMetadata(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            prompt_token_count=self.prompt_token_count,
            cached_content_token_count=self.cached_content_token_count,
            candidates_token_count=self.candidates_token_count,
            total_token_count=self.total_token_count,
            thoughts_token_count=self.thoughts_token_count,
            prompt_tokens_details=self.prompt_tokens_details,
            cache_tokens_details=self.cache_tokens_details,
            candidates_tokens_details=self.candidates_tokens_details,
            tool_use_prompt_tokens_details=self.tool_use_prompt_tokens_details,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.prompt_token_count == other.prompt_token_count and
            self.cached_content_token_count == other.cached_content_token_count and
            self.candidates_token_count == other.candidates_token_count and
            self.total_token_count == other.total_token_count and
            self.thoughts_token_count == other.thoughts_token_count and
            self.prompt_tokens_details == other.prompt_tokens_details and
            self.cache_tokens_details == other.cache_tokens_details and
            self.candidates_tokens_details == other.candidates_tokens_details and
            self.tool_use_prompt_tokens_details == other.tool_use_prompt_tokens_details
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'prompt_token_count',
        'cached_content_token_count',
        'candidates_token_count',
        'total_token_count',
        'thoughts_token_count',
        'prompt_tokens_details',
        'cache_tokens_details',
        'candidates_tokens_details',
        'tool_use_prompt_tokens_details',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'prompt_token_count',
        'cached_content_token_count',
        'candidates_token_count',
        'total_token_count',
        'thoughts_token_count',
        'prompt_tokens_details',
        'cache_tokens_details',
        'candidates_tokens_details',
        'tool_use_prompt_tokens_details',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.prompt_token_count,
            self.cached_content_token_count,
            self.candidates_token_count,
            self.total_token_count,
            self.thoughts_token_count,
            self.prompt_tokens_details,
            self.cache_tokens_details,
            self.candidates_tokens_details,
            self.tool_use_prompt_tokens_details,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        prompt_token_count: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        cached_content_token_count: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        candidates_token_count: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        total_token_count: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        thoughts_token_count: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        prompt_tokens_details: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        cache_tokens_details: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        candidates_tokens_details: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        tool_use_prompt_tokens_details: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'prompt_token_count', prompt_token_count)
        __dataclass__object_setattr(self, 'cached_content_token_count', cached_content_token_count)
        __dataclass__object_setattr(self, 'candidates_token_count', candidates_token_count)
        __dataclass__object_setattr(self, 'total_token_count', total_token_count)
        __dataclass__object_setattr(self, 'thoughts_token_count', thoughts_token_count)
        __dataclass__object_setattr(self, 'prompt_tokens_details', prompt_tokens_details)
        __dataclass__object_setattr(self, 'cache_tokens_details', cache_tokens_details)
        __dataclass__object_setattr(self, 'candidates_tokens_details', candidates_tokens_details)
        __dataclass__object_setattr(self, 'tool_use_prompt_tokens_details', tool_use_prompt_tokens_details)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"prompt_token_count={self.prompt_token_count!r}")
        parts.append(f"cached_content_token_count={self.cached_content_token_count!r}")
        parts.append(f"candidates_token_count={self.candidates_token_count!r}")
        parts.append(f"total_token_count={self.total_token_count!r}")
        parts.append(f"thoughts_token_count={self.thoughts_token_count!r}")
        parts.append(f"prompt_tokens_details={self.prompt_tokens_details!r}")
        parts.append(f"cache_tokens_details={self.cache_tokens_details!r}")
        parts.append(f"candidates_tokens_details={self.candidates_tokens_details!r}")
        parts.append(f"tool_use_prompt_tokens_details={self.tool_use_prompt_tokens_details!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('candidates', 'usage_metadata', 'model_version', 'response_id')), EqPlan(fields=('cand"
    "idates', 'usage_metadata', 'model_version', 'response_id')), FrozenPlan(fields=('candidates', 'usage_metadata', 'm"
    "odel_version', 'response_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('candidates', 'us"
    "age_metadata', 'model_version', 'response_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='candidates', a"
    "nnotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
    "n.Field(name='usage_metadata', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields."
    "1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='model_version', annotation=OpRef(name='init.fields.2.annotation'), d"
    "efault=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType."
    "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='response_id', annotation=OpRef(name='"
    "init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_param"
    "s=(), kw_only_params=('candidates', 'usage_metadata', 'model_version', 'response_id'), frozen=True, slots=False, p"
    "ost_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='candidates', kw_only=Tr"
    "ue, fn=None), ReprPlan.Field(name='usage_metadata', kw_only=True, fn=None), ReprPlan.Field(name='model_version', k"
    "w_only=True, fn=None), ReprPlan.Field(name='response_id', kw_only=True, fn=None)), id=False, terse=False, default_"
    "fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgoogle_2fprotocol_2ftypes_2fGenerateContentResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            candidates=self.candidates,
            usage_metadata=self.usage_metadata,
            model_version=self.model_version,
            response_id=self.response_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.candidates == other.candidates and
            self.usage_metadata == other.usage_metadata and
            self.model_version == other.model_version and
            self.response_id == other.response_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'candidates',
        'usage_metadata',
        'model_version',
        'response_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'candidates',
        'usage_metadata',
        'model_version',
        'response_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.candidates,
            self.usage_metadata,
            self.model_version,
            self.response_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        candidates: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        usage_metadata: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        model_version: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        response_id: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'candidates', candidates)
        __dataclass__object_setattr(self, 'usage_metadata', usage_metadata)
        __dataclass__object_setattr(self, 'model_version', model_version)
        __dataclass__object_setattr(self, 'response_id', response_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"candidates={self.candidates!r}")
        parts.append(f"usage_metadata={self.usage_metadata!r}")
        parts.append(f"model_version={self.model_version!r}")
        parts.append(f"response_id={self.response_id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('kind', 'title', 'html_title', 'link', 'display_link', 'snippet', 'html_snippet', 'cac"
    "he_id', 'formatted_url', 'html_formatted_url', 'mime', 'file_format', 'x')), EqPlan(fields=('kind', 'title', 'html"
    "_title', 'link', 'display_link', 'snippet', 'html_snippet', 'cache_id', 'formatted_url', 'html_formatted_url', 'mi"
    "me', 'file_format', 'x')), FrozenPlan(fields=('kind', 'title', 'html_title', 'link', 'display_link', 'snippet', 'h"
    "tml_snippet', 'cache_id', 'formatted_url', 'html_formatted_url', 'mime', 'file_format', 'x'), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('kind', 'title', 'html_title', 'link', 'display_link', 'snippet', 'h"
    "tml_snippet', 'cache_id', 'formatted_url', 'html_formatted_url', 'mime', 'file_format', 'x'), cache=False), InitPl"
    "an(fields=(InitPlan.Field(name='kind', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init"
    ".fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='title', annotation=OpRef(name='init.fields.1.annotation'), d"
    "efault=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType."
    "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='html_title', annotation=OpRef(name='i"
    "nit.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override="
    "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='link', an"
    "notation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
    ".Field(name='display_link', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.d"
    "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
    "ne, check_type=None), InitPlan.Field(name='snippet', annotation=OpRef(name='init.fields.5.annotation'), default=Op"
    "Ref(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='html_snippet', annotation=OpRef(name='init.fie"
    "lds.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='cache_id', annot"
    "ation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, i"
    "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
    "eld(name='formatted_url', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fields.8.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
    ", check_type=None), InitPlan.Field(name='html_formatted_url', annotation=OpRef(name='init.fields.9.annotation'), d"
    "efault=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_type=FieldType."
    "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='mime', annotation=OpRef(name='init.fi"
    "elds.10.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, override=Fals"
    "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='file_format',"
    " annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_factory"
    "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
    "tPlan.Field(name='x', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields.12.defau"
    "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
    "check_type=None)), self_param='self', std_params=('kind', 'title', 'html_title', 'link', 'display_link', 'snippet'"
    ", 'html_snippet', 'cache_id', 'formatted_url', 'html_formatted_url', 'mime', 'file_format', 'x'), kw_only_params=("
    "), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field"
    "(name='kind', kw_only=False, fn=None), ReprPlan.Field(name='title', kw_only=False, fn=None), ReprPlan.Field(name='"
    "html_title', kw_only=False, fn=None), ReprPlan.Field(name='link', kw_only=False, fn=None), ReprPlan.Field(name='di"
    "splay_link', kw_only=False, fn=None), ReprPlan.Field(name='snippet', kw_only=False, fn=None), ReprPlan.Field(name="
    "'html_snippet', kw_only=False, fn=None), ReprPlan.Field(name='cache_id', kw_only=False, fn=None), ReprPlan.Field(n"
    "ame='formatted_url', kw_only=False, fn=None), ReprPlan.Field(name='html_formatted_url', kw_only=False, fn=None), R"
    "eprPlan.Field(name='mime', kw_only=False, fn=None), ReprPlan.Field(name='file_format', kw_only=False, fn=None)), i"
    "d=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fbackends_2fimpls_2fgoogle_2fsearch_2fCseSearchResult(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            kind=self.kind,
            title=self.title,
            html_title=self.html_title,
            link=self.link,
            display_link=self.display_link,
            snippet=self.snippet,
            html_snippet=self.html_snippet,
            cache_id=self.cache_id,
            formatted_url=self.formatted_url,
            html_formatted_url=self.html_formatted_url,
            mime=self.mime,
            file_format=self.file_format,
            x=self.x,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.kind == other.kind and
            self.title == other.title and
            self.html_title == other.html_title and
            self.link == other.link and
            self.display_link == other.display_link and
            self.snippet == other.snippet and
            self.html_snippet == other.html_snippet and
            self.cache_id == other.cache_id and
            self.formatted_url == other.formatted_url and
            self.html_formatted_url == other.html_formatted_url and
            self.mime == other.mime and
            self.file_format == other.file_format and
            self.x == other.x
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'kind',
        'title',
        'html_title',
        'link',
        'display_link',
        'snippet',
        'html_snippet',
        'cache_id',
        'formatted_url',
        'html_formatted_url',
        'mime',
        'file_format',
        'x',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'kind',
        'title',
        'html_title',
        'link',
        'display_link',
        'snippet',
        'html_snippet',
        'cache_id',
        'formatted_url',
        'html_formatted_url',
        'mime',
        'file_format',
        'x',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.kind,
            self.title,
            self.html_title,
            self.link,
            self.display_link,
            self.snippet,
            self.html_snippet,
            self.cache_id,
            self.formatted_url,
            self.html_formatted_url,
            self.mime,
            self.file_format,
            self.x,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        kind: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        title: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        html_title: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        link: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        display_link: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        snippet: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        html_snippet: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        cache_id: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        formatted_url: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        html_formatted_url: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        mime: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        file_format: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        x: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'kind', kind)
        __dataclass__object_setattr(self, 'title', title)
        __dataclass__object_setattr(self, 'html_title', html_title)
        __dataclass__object_setattr(self, 'link', link)
        __dataclass__object_setattr(self, 'display_link', display_link)
        __dataclass__object_setattr(self, 'snippet', snippet)
        __dataclass__object_setattr(self, 'html_snippet', html_snippet)
        __dataclass__object_setattr(self, 'cache_id', cache_id)
        __dataclass__object_setattr(self, 'formatted_url', formatted_url)
        __dataclass__object_setattr(self, 'html_formatted_url', html_formatted_url)
        __dataclass__object_setattr(self, 'mime', mime)
        __dataclass__object_setattr(self, 'file_format', file_format)
        __dataclass__object_setattr(self, 'x', x)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"kind={self.kind!r}")
        parts.append(f"title={self.title!r}")
        parts.append(f"html_title={self.html_title!r}")
        parts.append(f"link={self.link!r}")
        parts.append(f"display_link={self.display_link!r}")
        parts.append(f"snippet={self.snippet!r}")
        parts.append(f"html_snippet={self.html_snippet!r}")
        parts.append(f"cache_id={self.cache_id!r}")
        parts.append(f"formatted_url={self.formatted_url!r}")
        parts.append(f"html_formatted_url={self.html_formatted_url!r}")
        parts.append(f"mime={self.mime!r}")
        parts.append(f"file_format={self.file_format!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('search_time', 'total_results', 'x')), EqPlan(fields=('search_time', 'total_results', "
    "'x')), FrozenPlan(fields=('search_time', 'total_results', 'x'), allow_dynamic_dunder_attrs=False), HashPlan(action"
    "='add', fields=('search_time', 'total_results', 'x'), cache=False), InitPlan(fields=(InitPlan.Field(name='search_t"
    "ime', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
    "InitPlan.Field(name='total_results', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.f"
    "ields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='x', annotation=OpRef(name='init.fields.2.annotation'), default"
    "=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('search_time', 'total_results', "
    "'x'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan("
    "fields=(ReprPlan.Field(name='search_time', kw_only=False, fn=None), ReprPlan.Field(name='total_results', kw_only=F"
    "alse, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fbackends_2fimpls_2fgoogle_2fsearch_2fCseSearchInfo(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            search_time=self.search_time,
            total_results=self.total_results,
            x=self.x,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.search_time == other.search_time and
            self.total_results == other.total_results and
            self.x == other.x
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'search_time',
        'total_results',
        'x',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'search_time',
        'total_results',
        'x',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.search_time,
            self.total_results,
            self.x,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        search_time: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        total_results: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        x: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'search_time', search_time)
        __dataclass__object_setattr(self, 'total_results', total_results)
        __dataclass__object_setattr(self, 'x', x)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"search_time={self.search_time!r}")
        parts.append(f"total_results={self.total_results!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('kind', 'info', 'items', 'x')), EqPlan(fields=('kind', 'info', 'items', 'x')), FrozenP"
    "lan(fields=('kind', 'info', 'items', 'x'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('kind"
    "', 'info', 'items', 'x'), cache=False), InitPlan(fields=(InitPlan.Field(name='kind', annotation=OpRef(name='init.f"
    "ields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='info', annotat"
    "ion=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, ini"
    "t=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fiel"
    "d(name='items', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), de"
    "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='x', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fie"
    "lds.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None)), self_param='self', std_params=('kind', 'info', 'items', 'x'), kw_only_params=(), fro"
    "zen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name="
    "'kind', kw_only=False, fn=None), ReprPlan.Field(name='info', kw_only=False, fn=None), ReprPlan.Field(name='items',"
    " kw_only=False, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fbackends_2fimpls_2fgoogle_2fsearch_2fCseSearchResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            kind=self.kind,
            info=self.info,
            items=self.items,
            x=self.x,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.kind == other.kind and
            self.info == other.info and
            self.items == other.items and
            self.x == other.x
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'kind',
        'info',
        'items',
        'x',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'kind',
        'info',
        'items',
        'x',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.kind,
            self.info,
            self.items,
            self.x,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        kind: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        info: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        items: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        x: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'kind', kind)
        __dataclass__object_setattr(self, 'info', info)
        __dataclass__object_setattr(self, 'items', items)
        __dataclass__object_setattr(self, 'x', x)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"kind={self.kind!r}")
        parts.append(f"info={self.info!r}")
        parts.append(f"items={self.items!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=(), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=(), cache=False), InitPlan(fields=(), self_param='self', std_params=(), kw_only_params=(),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionRequest_2fMessage(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('content', 'name', 'role')), EqPlan(fields=('content', 'name', 'role')), FrozenPlan(fi"
    "elds=('content', 'name', 'role'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('content', 'na"
    "me', 'role'), cache=False), InitPlan(fields=(InitPlan.Field(name='content', annotation=OpRef(name='init.fields.0.a"
    "nnotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation"
    "'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='role', annotation=OpRef(name='in"
    "it.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params="
    "(), kw_only_params=('content', 'name', 'role'), frozen=True, slots=False, post_init_params=None, init_fns=(), vali"
    "date_fns=()), ReprPlan(fields=(ReprPlan.Field(name='content', kw_only=True, fn=None), ReprPlan.Field(name='name', "
    "kw_only=True, fn=None), ReprPlan.Field(name='role', kw_only=True, fn=None)), id=False, terse=False, default_fn=Non"
    "e)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionRequest_2fSystemMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            content=self.content,
            name=self.name,
            role=self.role,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.content == other.content and
            self.name == other.name and
            self.role == other.role
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'content',
        'name',
        'role',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'content',
        'name',
        'role',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.content,
            self.name,
            self.role,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        content: __dataclass__init__fields__0__annotation,
        name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        role: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'role', role)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"content={self.content!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"role={self.role!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('content', 'name', 'role')), EqPlan(fields=('content', 'name', 'role')), FrozenPlan(fi"
    "elds=('content', 'name', 'role'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('content', 'na"
    "me', 'role'), cache=False), InitPlan(fields=(InitPlan.Field(name='content', annotation=OpRef(name='init.fields.0.a"
    "nnotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation"
    "'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='role', annotation=OpRef(name='in"
    "it.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params="
    "(), kw_only_params=('content', 'name', 'role'), frozen=True, slots=False, post_init_params=None, init_fns=(), vali"
    "date_fns=()), ReprPlan(fields=(ReprPlan.Field(name='content', kw_only=True, fn=None), ReprPlan.Field(name='name', "
    "kw_only=True, fn=None), ReprPlan.Field(name='role', kw_only=True, fn=None)), id=False, terse=False, default_fn=Non"
    "e)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionRequest_2fUserMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            content=self.content,
            name=self.name,
            role=self.role,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.content == other.content and
            self.name == other.name and
            self.role == other.role
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'content',
        'name',
        'role',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'content',
        'name',
        'role',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.content,
            self.name,
            self.role,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        content: __dataclass__init__fields__0__annotation,
        name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        role: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'role', role)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"content={self.content!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"role={self.role!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('arguments', 'name')), EqPlan(fields=('arguments', 'name')), FrozenPlan(fields=('argum"
    "ents', 'name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('arguments', 'name'), cache=Fals"
    "e), InitPlan(fields=(InitPlan.Field(name='arguments', annotation=OpRef(name='init.fields.0.annotation'), default=N"
    "one, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation'), default=None, defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None)), self_param='self', std_params=(), kw_only_params=('arguments', 'name'), frozen=True, slots=False, post_in"
    "it_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='arguments', kw_only=True, fn="
    "None), ReprPlan.Field(name='name', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionRequest_2fAssistantMessage_2fToolCall_2fFunction(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            arguments=self.arguments,
            name=self.name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.arguments == other.arguments and
            self.name == other.name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'arguments',
        'name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'arguments',
        'name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.arguments,
            self.name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        arguments: __dataclass__init__fields__0__annotation,
        name: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'arguments', arguments)
        __dataclass__object_setattr(self, 'name', name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"arguments={self.arguments!r}")
        parts.append(f"name={self.name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('function', 'id', 'type')), EqPlan(fields=('function', 'id', 'type')), FrozenPlan(fiel"
    "ds=('function', 'id', 'type'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('function', 'id',"
    " 'type'), cache=False), InitPlan(fields=(InitPlan.Field(name='function', annotation=OpRef(name='init.fields.0.anno"
    "tation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
    "e, validate=None, check_type=None), InitPlan.Field(name='id', annotation=OpRef(name='init.fields.1.annotation'), d"
    "efault=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.2.annotation'), default=Op"
    "Ref(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
    " coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('function', 'id'"
    ", 'type'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPl"
    "an.Field(name='function', kw_only=True, fn=None), ReprPlan.Field(name='id', kw_only=True, fn=None), ReprPlan.Field"
    "(name='type', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionRequest_2fAssistantMessage_2fToolCall(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            function=self.function,
            id=self.id,
            type=self.type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.function == other.function and
            self.id == other.id and
            self.type == other.type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'function',
        'id',
        'type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'function',
        'id',
        'type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.function,
            self.id,
            self.type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        function: __dataclass__init__fields__0__annotation,
        id: __dataclass__init__fields__1__annotation,
        type: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'function', function)
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'type', type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"function={self.function!r}")
        parts.append(f"id={self.id!r}")
        parts.append(f"type={self.type!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('content', 'name', 'reasoning', 'role', 'tool_calls')), EqPlan(fields=('content', 'nam"
    "e', 'reasoning', 'role', 'tool_calls')), FrozenPlan(fields=('content', 'name', 'reasoning', 'role', 'tool_calls'),"
    " allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('content', 'name', 'reasoning', 'role', 'tool_c"
    "alls'), cache=False), InitPlan(fields=(InitPlan.Field(name='content', annotation=OpRef(name='init.fields.0.annotat"
    "ion'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name="
    "'init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='reasoni"
    "ng', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_facto"
    "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
    "nitPlan.Field(name='role', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None), InitPlan.Field(name='tool_calls', annotation=OpRef(name='init.fields.4.annotation'), default="
    "OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
    "E, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('content', 'na"
    "me', 'reasoning', 'role', 'tool_calls'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fn"
    "s=()), ReprPlan(fields=(ReprPlan.Field(name='content', kw_only=True, fn=None), ReprPlan.Field(name='name', kw_only"
    "=True, fn=None), ReprPlan.Field(name='reasoning', kw_only=True, fn=None), ReprPlan.Field(name='role', kw_only=True"
    ", fn=None), ReprPlan.Field(name='tool_calls', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionRequest_2fAssistantMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            content=self.content,
            name=self.name,
            reasoning=self.reasoning,
            role=self.role,
            tool_calls=self.tool_calls,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.content == other.content and
            self.name == other.name and
            self.reasoning == other.reasoning and
            self.role == other.role and
            self.tool_calls == other.tool_calls
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'content',
        'name',
        'reasoning',
        'role',
        'tool_calls',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'content',
        'name',
        'reasoning',
        'role',
        'tool_calls',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.content,
            self.name,
            self.reasoning,
            self.role,
            self.tool_calls,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        content: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        reasoning: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        role: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        tool_calls: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'reasoning', reasoning)
        __dataclass__object_setattr(self, 'role', role)
        __dataclass__object_setattr(self, 'tool_calls', tool_calls)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"content={self.content!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"reasoning={self.reasoning!r}")
        parts.append(f"role={self.role!r}")
        parts.append(f"tool_calls={self.tool_calls!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('content', 'role', 'tool_call_id')), EqPlan(fields=('content', 'role', 'tool_call_id')"
    "), FrozenPlan(fields=('content', 'role', 'tool_call_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add'"
    ", fields=('content', 'role', 'tool_call_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='content', annota"
    "tion=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='role', annotation=OpRe"
    "f(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "tool_call_id', annotation=OpRef(name='init.fields.2.annotation'), default=None, default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', st"
    "d_params=(), kw_only_params=('content', 'role', 'tool_call_id'), frozen=True, slots=False, post_init_params=None, "
    "init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='content', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='role', kw_only=True, fn=None), ReprPlan.Field(name='tool_call_id', kw_only=True, fn=None)), id=False, te"
    "rse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionRequest_2fToolMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            content=self.content,
            role=self.role,
            tool_call_id=self.tool_call_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.content == other.content and
            self.role == other.role and
            self.tool_call_id == other.tool_call_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'content',
        'role',
        'tool_call_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'content',
        'role',
        'tool_call_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.content,
            self.role,
            self.tool_call_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        content: __dataclass__init__fields__0__annotation,
        role: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        tool_call_id: __dataclass__init__fields__2__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'role', role)
        __dataclass__object_setattr(self, 'tool_call_id', tool_call_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"content={self.content!r}")
        parts.append(f"role={self.role!r}")
        parts.append(f"tool_call_id={self.tool_call_id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('description', 'name', 'parameters', 'strict')), EqPlan(fields=('description', 'name',"
    " 'parameters', 'strict')), FrozenPlan(fields=('description', 'name', 'parameters', 'strict'), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('description', 'name', 'parameters', 'strict'), cache=False), InitPl"
    "an(fields=(InitPlan.Field(name='description', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(nam"
    "e='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotatio"
    "n'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='parameters', annotation=OpRef(name='init.fields.2.annotation')"
    ", default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
    "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='strict', annotation=OpRef(name='in"
    "it.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params="
    "(), kw_only_params=('description', 'name', 'parameters', 'strict'), frozen=True, slots=False, post_init_params=Non"
    "e, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='description', kw_only=True, fn=None), Repr"
    "Plan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='parameters', kw_only=True, fn=None), ReprPlan"
    ".Field(name='strict', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionRequest_2fTool_2fFunction(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            description=self.description,
            name=self.name,
            parameters=self.parameters,
            strict=self.strict,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.description == other.description and
            self.name == other.name and
            self.parameters == other.parameters and
            self.strict == other.strict
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'description',
        'name',
        'parameters',
        'strict',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'description',
        'name',
        'parameters',
        'strict',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.description,
            self.name,
            self.parameters,
            self.strict,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        description: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        name: __dataclass__init__fields__1__annotation,
        parameters: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        strict: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'parameters', parameters)
        __dataclass__object_setattr(self, 'strict', strict)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"description={self.description!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"parameters={self.parameters!r}")
        parts.append(f"strict={self.strict!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('function', 'type')), EqPlan(fields=('function', 'type')), FrozenPlan(fields=('functio"
    "n', 'type'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('function', 'type'), cache=False), "
    "InitPlan(fields=(InitPlan.Field(name='function', annotation=OpRef(name='init.fields.0.annotation'), default=None, "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='ini"
    "t.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('function', 'type'), frozen=T"
    "rue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='func"
    "tion', kw_only=True, fn=None), ReprPlan.Field(name='type', kw_only=True, fn=None)), id=False, terse=False, default"
    "_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionRequest_2fTool(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            function=self.function,
            type=self.type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.function == other.function and
            self.type == other.type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'function',
        'type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'function',
        'type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.function,
            self.type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        function: __dataclass__init__fields__0__annotation,
        type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'function', function)
        __dataclass__object_setattr(self, 'type', type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"function={self.function!r}")
        parts.append(f"type={self.type!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('messages', 'model', 'citation_options', 'compound_custom', 'disable_tool_validation',"
    " 'documents', 'frequency_penalty', 'include_reasoning', 'logit_bias', 'logprobs', 'max_completion_tokens', 'n', 'p"
    "arallel_tool_calls', 'presence_penalty', 'reasoning_effort', 'reasoning_format', 'response_format', 'search_settin"
    "gs', 'seed', 'service_tier', 'stop', 'store', 'stream', 'stream_options', 'temperature', 'ool_choice', 'tools', 't"
    "op_logprobs', 'top_p', 'user')), EqPlan(fields=('messages', 'model', 'citation_options', 'compound_custom', 'disab"
    "le_tool_validation', 'documents', 'frequency_penalty', 'include_reasoning', 'logit_bias', 'logprobs', 'max_complet"
    "ion_tokens', 'n', 'parallel_tool_calls', 'presence_penalty', 'reasoning_effort', 'reasoning_format', 'response_for"
    "mat', 'search_settings', 'seed', 'service_tier', 'stop', 'store', 'stream', 'stream_options', 'temperature', 'ool_"
    "choice', 'tools', 'top_logprobs', 'top_p', 'user')), FrozenPlan(fields=('messages', 'model', 'citation_options', '"
    "compound_custom', 'disable_tool_validation', 'documents', 'frequency_penalty', 'include_reasoning', 'logit_bias', "
    "'logprobs', 'max_completion_tokens', 'n', 'parallel_tool_calls', 'presence_penalty', 'reasoning_effort', 'reasonin"
    "g_format', 'response_format', 'search_settings', 'seed', 'service_tier', 'stop', 'store', 'stream', 'stream_option"
    "s', 'temperature', 'ool_choice', 'tools', 'top_logprobs', 'top_p', 'user'), allow_dynamic_dunder_attrs=False), Has"
    "hPlan(action='add', fields=('messages', 'model', 'citation_options', 'compound_custom', 'disable_tool_validation',"
    " 'documents', 'frequency_penalty', 'include_reasoning', 'logit_bias', 'logprobs', 'max_completion_tokens', 'n', 'p"
    "arallel_tool_calls', 'presence_penalty', 'reasoning_effort', 'reasoning_format', 'response_format', 'search_settin"
    "gs', 'seed', 'service_tier', 'stop', 'store', 'stream', 'stream_options', 'temperature', 'ool_choice', 'tools', 't"
    "op_logprobs', 'top_p', 'user'), cache=False), InitPlan(fields=(InitPlan.Field(name='messages', annotation=OpRef(na"
    "me='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='model', annotation=OpRef(name='init"
    ".fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='citation_options', annotation=OpRef(name='i"
    "nit.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override="
    "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='compound_"
    "custom', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='disable_tool_validation', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef"
    "(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None), InitPlan.Field(name='documents', annotation=OpRef(name='init.fields.5."
    "annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='frequency_penalty', an"
    "notation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
    ".Field(name='include_reasoning', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.field"
    "s.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='logit_bias', annotation=OpRef(name='init.fields.8.annotation'), de"
    "fault=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
    "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='logprobs', annotation=OpRef(name='init"
    ".fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_completi"
    "on_tokens', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='n', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fiel"
    "ds.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None), InitPlan.Field(name='parallel_tool_calls', annotation=OpRef(name='init.fields.12.anno"
    "tation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='presence_penalty', annota"
    "tion=OpRef(name='init.fields.13.annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
    "ield(name='reasoning_effort', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields."
    "14.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None), InitPlan.Field(name='reasoning_format', annotation=OpRef(name='init.fields.15.annotation"
    "'), default=OpRef(name='init.fields.15.default'), default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='response_format', annotation=Op"
    "Ref(name='init.fields.16.annotation'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='search_settings', annotation=OpRef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.defau"
    "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
    "check_type=None), InitPlan.Field(name='seed', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(na"
    "me='init.fields.18.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='service_tier', annotation=OpRef(name='init.fields.1"
    "9.annotation'), default=OpRef(name='init.fields.19.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='stop', annotation=O"
    "pRef(name='init.fields.20.annotation'), default=OpRef(name='init.fields.20.default'), default_factory=None, init=T"
    "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
    "ame='store', annotation=OpRef(name='init.fields.21.annotation'), default=OpRef(name='init.fields.21.default'), def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='stream', annotation=OpRef(name='init.fields.22.annotation'), default=OpRef(name='ini"
    "t.fields.22.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None"
    ", validate=None, check_type=None), InitPlan.Field(name='stream_options', annotation=OpRef(name='init.fields.23.ann"
    "otation'), default=OpRef(name='init.fields.23.default'), default_factory=None, init=True, override=False, field_ty"
    "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='temperature', annotation"
    "=OpRef(name='init.fields.24.annotation'), default=OpRef(name='init.fields.24.default'), default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='ool_choice', annotation=OpRef(name='init.fields.25.annotation'), default=OpRef(name='init.fields.25.default"
    "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None), InitPlan.Field(name='tools', annotation=OpRef(name='init.fields.26.annotation'), default=OpRef(nam"
    "e='init.fields.26.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='top_logprobs', annotation=OpRef(name='init.fields.27"
    ".annotation'), default=OpRef(name='init.fields.27.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='top_p', annotation=O"
    "pRef(name='init.fields.28.annotation'), default=OpRef(name='init.fields.28.default'), default_factory=None, init=T"
    "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(n"
    "ame='user', annotation=OpRef(name='init.fields.29.annotation'), default=OpRef(name='init.fields.29.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None)), self_param='self', std_params=(), kw_only_params=('messages', 'model', 'citation_options', 'compound_cust"
    "om', 'disable_tool_validation', 'documents', 'frequency_penalty', 'include_reasoning', 'logit_bias', 'logprobs', '"
    "max_completion_tokens', 'n', 'parallel_tool_calls', 'presence_penalty', 'reasoning_effort', 'reasoning_format', 'r"
    "esponse_format', 'search_settings', 'seed', 'service_tier', 'stop', 'store', 'stream', 'stream_options', 'temperat"
    "ure', 'ool_choice', 'tools', 'top_logprobs', 'top_p', 'user'), frozen=True, slots=False, post_init_params=None, in"
    "it_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='messages', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='model', kw_only=True, fn=None), ReprPlan.Field(name='citation_options', kw_only=True, fn=None), ReprPlan."
    "Field(name='compound_custom', kw_only=True, fn=None), ReprPlan.Field(name='disable_tool_validation', kw_only=True,"
    " fn=None), ReprPlan.Field(name='documents', kw_only=True, fn=None), ReprPlan.Field(name='frequency_penalty', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='include_reasoning', kw_only=True, fn=None), ReprPlan.Field(name='logit_bia"
    "s', kw_only=True, fn=None), ReprPlan.Field(name='logprobs', kw_only=True, fn=None), ReprPlan.Field(name='max_compl"
    "etion_tokens', kw_only=True, fn=None), ReprPlan.Field(name='n', kw_only=True, fn=None), ReprPlan.Field(name='paral"
    "lel_tool_calls', kw_only=True, fn=None), ReprPlan.Field(name='presence_penalty', kw_only=True, fn=None), ReprPlan."
    "Field(name='reasoning_effort', kw_only=True, fn=None), ReprPlan.Field(name='reasoning_format', kw_only=True, fn=No"
    "ne), ReprPlan.Field(name='response_format', kw_only=True, fn=None), ReprPlan.Field(name='search_settings', kw_only"
    "=True, fn=None), ReprPlan.Field(name='seed', kw_only=True, fn=None), ReprPlan.Field(name='service_tier', kw_only=T"
    "rue, fn=None), ReprPlan.Field(name='stop', kw_only=True, fn=None), ReprPlan.Field(name='store', kw_only=True, fn=N"
    "one), ReprPlan.Field(name='stream', kw_only=True, fn=None), ReprPlan.Field(name='stream_options', kw_only=True, fn"
    "=None), ReprPlan.Field(name='temperature', kw_only=True, fn=None), ReprPlan.Field(name='ool_choice', kw_only=True,"
    " fn=None), ReprPlan.Field(name='tools', kw_only=True, fn=None), ReprPlan.Field(name='top_logprobs', kw_only=True, "
    "fn=None), ReprPlan.Field(name='top_p', kw_only=True, fn=None), ReprPlan.Field(name='user', kw_only=True, fn=None))"
    ", id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__21__annotation,
    __dataclass__init__fields__21__default,
    __dataclass__init__fields__22__annotation,
    __dataclass__init__fields__22__default,
    __dataclass__init__fields__23__annotation,
    __dataclass__init__fields__23__default,
    __dataclass__init__fields__24__annotation,
    __dataclass__init__fields__24__default,
    __dataclass__init__fields__25__annotation,
    __dataclass__init__fields__25__default,
    __dataclass__init__fields__26__annotation,
    __dataclass__init__fields__26__default,
    __dataclass__init__fields__27__annotation,
    __dataclass__init__fields__27__default,
    __dataclass__init__fields__28__annotation,
    __dataclass__init__fields__28__default,
    __dataclass__init__fields__29__annotation,
    __dataclass__init__fields__29__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            messages=self.messages,
            model=self.model,
            citation_options=self.citation_options,
            compound_custom=self.compound_custom,
            disable_tool_validation=self.disable_tool_validation,
            documents=self.documents,
            frequency_penalty=self.frequency_penalty,
            include_reasoning=self.include_reasoning,
            logit_bias=self.logit_bias,
            logprobs=self.logprobs,
            max_completion_tokens=self.max_completion_tokens,
            n=self.n,
            parallel_tool_calls=self.parallel_tool_calls,
            presence_penalty=self.presence_penalty,
            reasoning_effort=self.reasoning_effort,
            reasoning_format=self.reasoning_format,
            response_format=self.response_format,
            search_settings=self.search_settings,
            seed=self.seed,
            service_tier=self.service_tier,
            stop=self.stop,
            store=self.store,
            stream=self.stream,
            stream_options=self.stream_options,
            temperature=self.temperature,
            ool_choice=self.ool_choice,
            tools=self.tools,
            top_logprobs=self.top_logprobs,
            top_p=self.top_p,
            user=self.user,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.messages == other.messages and
            self.model == other.model and
            self.citation_options == other.citation_options and
            self.compound_custom == other.compound_custom and
            self.disable_tool_validation == other.disable_tool_validation and
            self.documents == other.documents and
            self.frequency_penalty == other.frequency_penalty and
            self.include_reasoning == other.include_reasoning and
            self.logit_bias == other.logit_bias and
            self.logprobs == other.logprobs and
            self.max_completion_tokens == other.max_completion_tokens and
            self.n == other.n and
            self.parallel_tool_calls == other.parallel_tool_calls and
            self.presence_penalty == other.presence_penalty and
            self.reasoning_effort == other.reasoning_effort and
            self.reasoning_format == other.reasoning_format and
            self.response_format == other.response_format and
            self.search_settings == other.search_settings and
            self.seed == other.seed and
            self.service_tier == other.service_tier and
            self.stop == other.stop and
            self.store == other.store and
            self.stream == other.stream and
            self.stream_options == other.stream_options and
            self.temperature == other.temperature and
            self.ool_choice == other.ool_choice and
            self.tools == other.tools and
            self.top_logprobs == other.top_logprobs and
            self.top_p == other.top_p and
            self.user == other.user
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'messages',
        'model',
        'citation_options',
        'compound_custom',
        'disable_tool_validation',
        'documents',
        'frequency_penalty',
        'include_reasoning',
        'logit_bias',
        'logprobs',
        'max_completion_tokens',
        'n',
        'parallel_tool_calls',
        'presence_penalty',
        'reasoning_effort',
        'reasoning_format',
        'response_format',
        'search_settings',
        'seed',
        'service_tier',
        'stop',
        'store',
        'stream',
        'stream_options',
        'temperature',
        'ool_choice',
        'tools',
        'top_logprobs',
        'top_p',
        'user',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'messages',
        'model',
        'citation_options',
        'compound_custom',
        'disable_tool_validation',
        'documents',
        'frequency_penalty',
        'include_reasoning',
        'logit_bias',
        'logprobs',
        'max_completion_tokens',
        'n',
        'parallel_tool_calls',
        'presence_penalty',
        'reasoning_effort',
        'reasoning_format',
        'response_format',
        'search_settings',
        'seed',
        'service_tier',
        'stop',
        'store',
        'stream',
        'stream_options',
        'temperature',
        'ool_choice',
        'tools',
        'top_logprobs',
        'top_p',
        'user',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.messages,
            self.model,
            self.citation_options,
            self.compound_custom,
            self.disable_tool_validation,
            self.documents,
            self.frequency_penalty,
            self.include_reasoning,
            self.logit_bias,
            self.logprobs,
            self.max_completion_tokens,
            self.n,
            self.parallel_tool_calls,
            self.presence_penalty,
            self.reasoning_effort,
            self.reasoning_format,
            self.response_format,
            self.search_settings,
            self.seed,
            self.service_tier,
            self.stop,
            self.store,
            self.stream,
            self.stream_options,
            self.temperature,
            self.ool_choice,
            self.tools,
            self.top_logprobs,
            self.top_p,
            self.user,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        messages: __dataclass__init__fields__0__annotation,
        model: __dataclass__init__fields__1__annotation,
        citation_options: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        compound_custom: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        disable_tool_validation: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        documents: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        frequency_penalty: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        include_reasoning: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        logit_bias: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        logprobs: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        max_completion_tokens: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        n: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        parallel_tool_calls: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        presence_penalty: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        reasoning_effort: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        reasoning_format: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        response_format: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        search_settings: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        seed: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        service_tier: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        stop: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        store: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
        stream: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
        stream_options: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
        temperature: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
        ool_choice: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
        tools: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
        top_logprobs: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
        top_p: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
        user: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'messages', messages)
        __dataclass__object_setattr(self, 'model', model)
        __dataclass__object_setattr(self, 'citation_options', citation_options)
        __dataclass__object_setattr(self, 'compound_custom', compound_custom)
        __dataclass__object_setattr(self, 'disable_tool_validation', disable_tool_validation)
        __dataclass__object_setattr(self, 'documents', documents)
        __dataclass__object_setattr(self, 'frequency_penalty', frequency_penalty)
        __dataclass__object_setattr(self, 'include_reasoning', include_reasoning)
        __dataclass__object_setattr(self, 'logit_bias', logit_bias)
        __dataclass__object_setattr(self, 'logprobs', logprobs)
        __dataclass__object_setattr(self, 'max_completion_tokens', max_completion_tokens)
        __dataclass__object_setattr(self, 'n', n)
        __dataclass__object_setattr(self, 'parallel_tool_calls', parallel_tool_calls)
        __dataclass__object_setattr(self, 'presence_penalty', presence_penalty)
        __dataclass__object_setattr(self, 'reasoning_effort', reasoning_effort)
        __dataclass__object_setattr(self, 'reasoning_format', reasoning_format)
        __dataclass__object_setattr(self, 'response_format', response_format)
        __dataclass__object_setattr(self, 'search_settings', search_settings)
        __dataclass__object_setattr(self, 'seed', seed)
        __dataclass__object_setattr(self, 'service_tier', service_tier)
        __dataclass__object_setattr(self, 'stop', stop)
        __dataclass__object_setattr(self, 'store', store)
        __dataclass__object_setattr(self, 'stream', stream)
        __dataclass__object_setattr(self, 'stream_options', stream_options)
        __dataclass__object_setattr(self, 'temperature', temperature)
        __dataclass__object_setattr(self, 'ool_choice', ool_choice)
        __dataclass__object_setattr(self, 'tools', tools)
        __dataclass__object_setattr(self, 'top_logprobs', top_logprobs)
        __dataclass__object_setattr(self, 'top_p', top_p)
        __dataclass__object_setattr(self, 'user', user)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"messages={self.messages!r}")
        parts.append(f"model={self.model!r}")
        parts.append(f"citation_options={self.citation_options!r}")
        parts.append(f"compound_custom={self.compound_custom!r}")
        parts.append(f"disable_tool_validation={self.disable_tool_validation!r}")
        parts.append(f"documents={self.documents!r}")
        parts.append(f"frequency_penalty={self.frequency_penalty!r}")
        parts.append(f"include_reasoning={self.include_reasoning!r}")
        parts.append(f"logit_bias={self.logit_bias!r}")
        parts.append(f"logprobs={self.logprobs!r}")
        parts.append(f"max_completion_tokens={self.max_completion_tokens!r}")
        parts.append(f"n={self.n!r}")
        parts.append(f"parallel_tool_calls={self.parallel_tool_calls!r}")
        parts.append(f"presence_penalty={self.presence_penalty!r}")
        parts.append(f"reasoning_effort={self.reasoning_effort!r}")
        parts.append(f"reasoning_format={self.reasoning_format!r}")
        parts.append(f"response_format={self.response_format!r}")
        parts.append(f"search_settings={self.search_settings!r}")
        parts.append(f"seed={self.seed!r}")
        parts.append(f"service_tier={self.service_tier!r}")
        parts.append(f"stop={self.stop!r}")
        parts.append(f"store={self.store!r}")
        parts.append(f"stream={self.stream!r}")
        parts.append(f"stream_options={self.stream_options!r}")
        parts.append(f"temperature={self.temperature!r}")
        parts.append(f"ool_choice={self.ool_choice!r}")
        parts.append(f"tools={self.tools!r}")
        parts.append(f"top_logprobs={self.top_logprobs!r}")
        parts.append(f"top_p={self.top_p!r}")
        parts.append(f"user={self.user!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('arguments', 'index', 'type', 'browser_results', 'code_results', 'output', 'search_res"
    "ults')), EqPlan(fields=('arguments', 'index', 'type', 'browser_results', 'code_results', 'output', 'search_results"
    "')), FrozenPlan(fields=('arguments', 'index', 'type', 'browser_results', 'code_results', 'output', 'search_results"
    "'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('arguments', 'index', 'type', 'browser_resul"
    "ts', 'code_results', 'output', 'search_results'), cache=False), InitPlan(fields=(InitPlan.Field(name='arguments', "
    "annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='index', annotati"
    "on=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_ty"
    "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='type', annotation=OpRef("
    "name='init.fields.2.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldT"
    "ype.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='browser_results', annotation=OpRe"
    "f(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "code_results', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='output', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init"
    ".fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='search_results', annotation=OpRef(name='init.fields.6.annota"
    "tion'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=F"
    "ieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params"
    "=('arguments', 'index', 'type', 'browser_results', 'code_results', 'output', 'search_results'), frozen=True, slots"
    "=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='arguments', kw"
    "_only=True, fn=None), ReprPlan.Field(name='index', kw_only=True, fn=None), ReprPlan.Field(name='type', kw_only=Tru"
    "e, fn=None), ReprPlan.Field(name='browser_results', kw_only=True, fn=None), ReprPlan.Field(name='code_results', kw"
    "_only=True, fn=None), ReprPlan.Field(name='output', kw_only=True, fn=None), ReprPlan.Field(name='search_results', "
    "kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fExecutedTool(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            arguments=self.arguments,
            index=self.index,
            type=self.type,
            browser_results=self.browser_results,
            code_results=self.code_results,
            output=self.output,
            search_results=self.search_results,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.arguments == other.arguments and
            self.index == other.index and
            self.type == other.type and
            self.browser_results == other.browser_results and
            self.code_results == other.code_results and
            self.output == other.output and
            self.search_results == other.search_results
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'arguments',
        'index',
        'type',
        'browser_results',
        'code_results',
        'output',
        'search_results',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'arguments',
        'index',
        'type',
        'browser_results',
        'code_results',
        'output',
        'search_results',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.arguments,
            self.index,
            self.type,
            self.browser_results,
            self.code_results,
            self.output,
            self.search_results,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        arguments: __dataclass__init__fields__0__annotation,
        index: __dataclass__init__fields__1__annotation,
        type: __dataclass__init__fields__2__annotation,
        browser_results: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        code_results: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        output: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        search_results: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'arguments', arguments)
        __dataclass__object_setattr(self, 'index', index)
        __dataclass__object_setattr(self, 'type', type)
        __dataclass__object_setattr(self, 'browser_results', browser_results)
        __dataclass__object_setattr(self, 'code_results', code_results)
        __dataclass__object_setattr(self, 'output', output)
        __dataclass__object_setattr(self, 'search_results', search_results)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"arguments={self.arguments!r}")
        parts.append(f"index={self.index!r}")
        parts.append(f"type={self.type!r}")
        parts.append(f"browser_results={self.browser_results!r}")
        parts.append(f"code_results={self.code_results!r}")
        parts.append(f"output={self.output!r}")
        parts.append(f"search_results={self.search_results!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('arguments', 'name')), EqPlan(fields=('arguments', 'name')), FrozenPlan(fields=('argum"
    "ents', 'name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('arguments', 'name'), cache=Fals"
    "e), InitPlan(fields=(InitPlan.Field(name='arguments', annotation=OpRef(name='init.fields.0.annotation'), default=N"
    "one, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation'), default=None, defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None)), self_param='self', std_params=(), kw_only_params=('arguments', 'name'), frozen=True, slots=False, post_in"
    "it_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='arguments', kw_only=True, fn="
    "None), ReprPlan.Field(name='name', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionResponse_2fChoice_2fMessage_2fToolCall_2fFunction(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            arguments=self.arguments,
            name=self.name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.arguments == other.arguments and
            self.name == other.name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'arguments',
        'name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'arguments',
        'name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.arguments,
            self.name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        arguments: __dataclass__init__fields__0__annotation,
        name: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'arguments', arguments)
        __dataclass__object_setattr(self, 'name', name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"arguments={self.arguments!r}")
        parts.append(f"name={self.name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('id', 'function', 'type')), EqPlan(fields=('id', 'function', 'type')), FrozenPlan(fiel"
    "ds=('id', 'function', 'type'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('id', 'function',"
    " 'type'), cache=False), InitPlan(fields=(InitPlan.Field(name='id', annotation=OpRef(name='init.fields.0.annotation"
    "'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='function', annotation=OpRef(name='init.fields.1.annotation'), d"
    "efault=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.2.annotation'), default=Op"
    "Ref(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
    " coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('id', 'function'"
    ", 'type'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPl"
    "an.Field(name='id', kw_only=True, fn=None), ReprPlan.Field(name='function', kw_only=True, fn=None), ReprPlan.Field"
    "(name='type', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionResponse_2fChoice_2fMessage_2fToolCall(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            id=self.id,
            function=self.function,
            type=self.type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.id == other.id and
            self.function == other.function and
            self.type == other.type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'id',
        'function',
        'type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'id',
        'function',
        'type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.id,
            self.function,
            self.type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        id: __dataclass__init__fields__0__annotation,
        function: __dataclass__init__fields__1__annotation,
        type: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'function', function)
        __dataclass__object_setattr(self, 'type', type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"id={self.id!r}")
        parts.append(f"function={self.function!r}")
        parts.append(f"type={self.type!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('annotations', 'content', 'executed_tools', 'reasoning', 'role', 'tool_calls')), EqPla"
    "n(fields=('annotations', 'content', 'executed_tools', 'reasoning', 'role', 'tool_calls')), FrozenPlan(fields=('ann"
    "otations', 'content', 'executed_tools', 'reasoning', 'role', 'tool_calls'), allow_dynamic_dunder_attrs=False), Has"
    "hPlan(action='add', fields=('annotations', 'content', 'executed_tools', 'reasoning', 'role', 'tool_calls'), cache="
    "False), InitPlan(fields=(InitPlan.Field(name='annotations', annotation=OpRef(name='init.fields.0.annotation'), def"
    "ault=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='content', annotation=OpRef(name='init.f"
    "ields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='executed_tools"
    "', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory"
    "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
    "tPlan.Field(name='reasoning', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3"
    ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None), InitPlan.Field(name='role', annotation=OpRef(name='init.fields.4.annotation'), default=OpR"
    "ef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None), InitPlan.Field(name='tool_calls', annotation=OpRef(name='init.fields"
    ".5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_on"
    "ly_params=('annotations', 'content', 'executed_tools', 'reasoning', 'role', 'tool_calls'), frozen=True, slots=Fals"
    "e, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='annotations', kw_on"
    "ly=True, fn=None), ReprPlan.Field(name='content', kw_only=True, fn=None), ReprPlan.Field(name='executed_tools', kw"
    "_only=True, fn=None), ReprPlan.Field(name='reasoning', kw_only=True, fn=None), ReprPlan.Field(name='role', kw_only"
    "=True, fn=None), ReprPlan.Field(name='tool_calls', kw_only=True, fn=None)), id=False, terse=False, default_fn=None"
    ")))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionResponse_2fChoice_2fMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            annotations=self.annotations,
            content=self.content,
            executed_tools=self.executed_tools,
            reasoning=self.reasoning,
            role=self.role,
            tool_calls=self.tool_calls,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.annotations == other.annotations and
            self.content == other.content and
            self.executed_tools == other.executed_tools and
            self.reasoning == other.reasoning and
            self.role == other.role and
            self.tool_calls == other.tool_calls
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'annotations',
        'content',
        'executed_tools',
        'reasoning',
        'role',
        'tool_calls',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'annotations',
        'content',
        'executed_tools',
        'reasoning',
        'role',
        'tool_calls',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.annotations,
            self.content,
            self.executed_tools,
            self.reasoning,
            self.role,
            self.tool_calls,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        annotations: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        content: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        executed_tools: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        reasoning: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        role: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        tool_calls: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'annotations', annotations)
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'executed_tools', executed_tools)
        __dataclass__object_setattr(self, 'reasoning', reasoning)
        __dataclass__object_setattr(self, 'role', role)
        __dataclass__object_setattr(self, 'tool_calls', tool_calls)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"annotations={self.annotations!r}")
        parts.append(f"content={self.content!r}")
        parts.append(f"executed_tools={self.executed_tools!r}")
        parts.append(f"reasoning={self.reasoning!r}")
        parts.append(f"role={self.role!r}")
        parts.append(f"tool_calls={self.tool_calls!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('finish_reason', 'index', 'logprobs', 'message')), EqPlan(fields=('finish_reason', 'in"
    "dex', 'logprobs', 'message')), FrozenPlan(fields=('finish_reason', 'index', 'logprobs', 'message'), allow_dynamic_"
    "dunder_attrs=False), HashPlan(action='add', fields=('finish_reason', 'index', 'logprobs', 'message'), cache=False)"
    ", InitPlan(fields=(InitPlan.Field(name='finish_reason', annotation=OpRef(name='init.fields.0.annotation'), default"
    "=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='index', annotation=OpRef(name='init.fields.1.annotation'), default=None, d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None), InitPlan.Field(name='logprobs', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='"
    "init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
    "ne, validate=None, check_type=None), InitPlan.Field(name='message', annotation=OpRef(name='init.fields.3.annotatio"
    "n'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('finish_reason', 'index', 'logpr"
    "obs', 'message'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields="
    "(ReprPlan.Field(name='finish_reason', kw_only=True, fn=None), ReprPlan.Field(name='index', kw_only=True, fn=None),"
    " ReprPlan.Field(name='logprobs', kw_only=True, fn=None), ReprPlan.Field(name='message', kw_only=True, fn=None)), i"
    "d=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionResponse_2fChoice(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            finish_reason=self.finish_reason,
            index=self.index,
            logprobs=self.logprobs,
            message=self.message,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.finish_reason == other.finish_reason and
            self.index == other.index and
            self.logprobs == other.logprobs and
            self.message == other.message
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'finish_reason',
        'index',
        'logprobs',
        'message',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'finish_reason',
        'index',
        'logprobs',
        'message',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.finish_reason,
            self.index,
            self.logprobs,
            self.message,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        finish_reason: __dataclass__init__fields__0__annotation,
        index: __dataclass__init__fields__1__annotation,
        logprobs: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        message: __dataclass__init__fields__3__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'finish_reason', finish_reason)
        __dataclass__object_setattr(self, 'index', index)
        __dataclass__object_setattr(self, 'logprobs', logprobs)
        __dataclass__object_setattr(self, 'message', message)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"finish_reason={self.finish_reason!r}")
        parts.append(f"index={self.index!r}")
        parts.append(f"logprobs={self.logprobs!r}")
        parts.append(f"message={self.message!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('choices', 'created', 'id', 'model', 'object', 'system_fingerprint', 'usage', 'usage_b"
    "reakdown', 'x_groq', 'service_tier')), EqPlan(fields=('choices', 'created', 'id', 'model', 'object', 'system_finge"
    "rprint', 'usage', 'usage_breakdown', 'x_groq', 'service_tier')), FrozenPlan(fields=('choices', 'created', 'id', 'm"
    "odel', 'object', 'system_fingerprint', 'usage', 'usage_breakdown', 'x_groq', 'service_tier'), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('choices', 'created', 'id', 'model', 'object', 'system_fingerprint',"
    " 'usage', 'usage_breakdown', 'x_groq', 'service_tier'), cache=False), InitPlan(fields=(InitPlan.Field(name='choice"
    "s', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='created', an"
    "notation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='id', annotation=Op"
    "Ref(name='init.fields.2.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='model', annotation=OpRef(name"
    "='init.fields.3.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType."
    "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='object', annotation=OpRef(name='init."
    "fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=Fals"
    "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='system_finger"
    "print', annotation=OpRef(name='init.fields.5.annotation'), default=None, default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='usage', "
    "annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='usage_breakdown', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.field"
    "s.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='x_groq', annotation=OpRef(name='init.fields.8.annotation'), defaul"
    "t=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
    "NCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='service_tier', annotation=OpRef(name='init"
    ".fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=()"
    ", kw_only_params=('choices', 'created', 'id', 'model', 'object', 'system_fingerprint', 'usage', 'usage_breakdown',"
    " 'x_groq', 'service_tier'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPl"
    "an(fields=(ReprPlan.Field(name='choices', kw_only=True, fn=None), ReprPlan.Field(name='created', kw_only=True, fn="
    "None), ReprPlan.Field(name='id', kw_only=True, fn=None), ReprPlan.Field(name='model', kw_only=True, fn=None), Repr"
    "Plan.Field(name='object', kw_only=True, fn=None), ReprPlan.Field(name='system_fingerprint', kw_only=True, fn=None)"
    ", ReprPlan.Field(name='usage', kw_only=True, fn=None), ReprPlan.Field(name='usage_breakdown', kw_only=True, fn=Non"
    "e), ReprPlan.Field(name='x_groq', kw_only=True, fn=None), ReprPlan.Field(name='service_tier', kw_only=True, fn=Non"
    "e)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            choices=self.choices,
            created=self.created,
            id=self.id,
            model=self.model,
            object=self.object,
            system_fingerprint=self.system_fingerprint,
            usage=self.usage,
            usage_breakdown=self.usage_breakdown,
            x_groq=self.x_groq,
            service_tier=self.service_tier,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.choices == other.choices and
            self.created == other.created and
            self.id == other.id and
            self.model == other.model and
            self.object == other.object and
            self.system_fingerprint == other.system_fingerprint and
            self.usage == other.usage and
            self.usage_breakdown == other.usage_breakdown and
            self.x_groq == other.x_groq and
            self.service_tier == other.service_tier
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'choices',
        'created',
        'id',
        'model',
        'object',
        'system_fingerprint',
        'usage',
        'usage_breakdown',
        'x_groq',
        'service_tier',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'choices',
        'created',
        'id',
        'model',
        'object',
        'system_fingerprint',
        'usage',
        'usage_breakdown',
        'x_groq',
        'service_tier',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.choices,
            self.created,
            self.id,
            self.model,
            self.object,
            self.system_fingerprint,
            self.usage,
            self.usage_breakdown,
            self.x_groq,
            self.service_tier,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        choices: __dataclass__init__fields__0__annotation,
        created: __dataclass__init__fields__1__annotation,
        id: __dataclass__init__fields__2__annotation,
        model: __dataclass__init__fields__3__annotation,
        object: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        system_fingerprint: __dataclass__init__fields__5__annotation,
        usage: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        usage_breakdown: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        x_groq: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        service_tier: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'choices', choices)
        __dataclass__object_setattr(self, 'created', created)
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'model', model)
        __dataclass__object_setattr(self, 'object', object)
        __dataclass__object_setattr(self, 'system_fingerprint', system_fingerprint)
        __dataclass__object_setattr(self, 'usage', usage)
        __dataclass__object_setattr(self, 'usage_breakdown', usage_breakdown)
        __dataclass__object_setattr(self, 'x_groq', x_groq)
        __dataclass__object_setattr(self, 'service_tier', service_tier)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"choices={self.choices!r}")
        parts.append(f"created={self.created!r}")
        parts.append(f"id={self.id!r}")
        parts.append(f"model={self.model!r}")
        parts.append(f"object={self.object!r}")
        parts.append(f"system_fingerprint={self.system_fingerprint!r}")
        parts.append(f"usage={self.usage!r}")
        parts.append(f"usage_breakdown={self.usage_breakdown!r}")
        parts.append(f"x_groq={self.x_groq!r}")
        parts.append(f"service_tier={self.service_tier!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('arguments', 'name')), EqPlan(fields=('arguments', 'name')), FrozenPlan(fields=('argum"
    "ents', 'name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('arguments', 'name'), cache=Fals"
    "e), InitPlan(fields=(InitPlan.Field(name='arguments', annotation=OpRef(name='init.fields.0.annotation'), default=O"
    "pRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
    ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.a"
    "nnotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_p"
    "arams=('arguments', 'name'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
    "lan(fields=(ReprPlan.Field(name='arguments', kw_only=True, fn=None), ReprPlan.Field(name='name', kw_only=True, fn="
    "None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionChunk_2fChoice_2fDelta_2fToolCall_2fFunction(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            arguments=self.arguments,
            name=self.name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.arguments == other.arguments and
            self.name == other.name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'arguments',
        'name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'arguments',
        'name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.arguments,
            self.name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        arguments: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'arguments', arguments)
        __dataclass__object_setattr(self, 'name', name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"arguments={self.arguments!r}")
        parts.append(f"name={self.name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('index', 'id', 'function', 'type')), EqPlan(fields=('index', 'id', 'function', 'type')"
    "), FrozenPlan(fields=('index', 'id', 'function', 'type'), allow_dynamic_dunder_attrs=False), HashPlan(action='add'"
    ", fields=('index', 'id', 'function', 'type'), cache=False), InitPlan(fields=(InitPlan.Field(name='index', annotati"
    "on=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_ty"
    "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='id', annotation=OpRef(na"
    "me='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='func"
    "tion', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='type', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None)), self_param='self', std_params=(), kw_only_params=('index', 'id', 'function', 'type'), froz"
    "en=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='"
    "index', kw_only=True, fn=None), ReprPlan.Field(name='id', kw_only=True, fn=None), ReprPlan.Field(name='function', "
    "kw_only=True, fn=None), ReprPlan.Field(name='type', kw_only=True, fn=None)), id=False, terse=False, default_fn=Non"
    "e)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionChunk_2fChoice_2fDelta_2fToolCall(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            index=self.index,
            id=self.id,
            function=self.function,
            type=self.type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.index == other.index and
            self.id == other.id and
            self.function == other.function and
            self.type == other.type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'index',
        'id',
        'function',
        'type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'index',
        'id',
        'function',
        'type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.index,
            self.id,
            self.function,
            self.type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        index: __dataclass__init__fields__0__annotation,
        id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        function: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        type: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'index', index)
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'function', function)
        __dataclass__object_setattr(self, 'type', type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"index={self.index!r}")
        parts.append(f"id={self.id!r}")
        parts.append(f"function={self.function!r}")
        parts.append(f"type={self.type!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('role', 'content', 'channel', 'reasoning', 'tool_calls', 'executed_tools')), EqPlan(fi"
    "elds=('role', 'content', 'channel', 'reasoning', 'tool_calls', 'executed_tools')), FrozenPlan(fields=('role', 'con"
    "tent', 'channel', 'reasoning', 'tool_calls', 'executed_tools'), allow_dynamic_dunder_attrs=False), HashPlan(action"
    "='add', fields=('role', 'content', 'channel', 'reasoning', 'tool_calls', 'executed_tools'), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='role', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.f"
    "ields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='content', annotation=OpRef(name='init.fields.1.annotation'), d"
    "efault=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType."
    "INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='channel', annotation=OpRef(name='init"
    ".fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='reasoning', "
    "annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='tool_calls', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.d"
    "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
    "ne, check_type=None), InitPlan.Field(name='executed_tools', annotation=OpRef(name='init.fields.5.annotation'), def"
    "ault=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('role', '"
    "content', 'channel', 'reasoning', 'tool_calls', 'executed_tools'), frozen=True, slots=False, post_init_params=None"
    ", init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='role', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='content', kw_only=True, fn=None), ReprPlan.Field(name='channel', kw_only=True, fn=None), ReprPlan.Field(n"
    "ame='reasoning', kw_only=True, fn=None), ReprPlan.Field(name='tool_calls', kw_only=True, fn=None), ReprPlan.Field("
    "name='executed_tools', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionChunk_2fChoice_2fDelta(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            role=self.role,
            content=self.content,
            channel=self.channel,
            reasoning=self.reasoning,
            tool_calls=self.tool_calls,
            executed_tools=self.executed_tools,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.role == other.role and
            self.content == other.content and
            self.channel == other.channel and
            self.reasoning == other.reasoning and
            self.tool_calls == other.tool_calls and
            self.executed_tools == other.executed_tools
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'role',
        'content',
        'channel',
        'reasoning',
        'tool_calls',
        'executed_tools',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'role',
        'content',
        'channel',
        'reasoning',
        'tool_calls',
        'executed_tools',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.role,
            self.content,
            self.channel,
            self.reasoning,
            self.tool_calls,
            self.executed_tools,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        role: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        content: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        channel: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        reasoning: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        tool_calls: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        executed_tools: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'role', role)
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'channel', channel)
        __dataclass__object_setattr(self, 'reasoning', reasoning)
        __dataclass__object_setattr(self, 'tool_calls', tool_calls)
        __dataclass__object_setattr(self, 'executed_tools', executed_tools)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"role={self.role!r}")
        parts.append(f"content={self.content!r}")
        parts.append(f"channel={self.channel!r}")
        parts.append(f"reasoning={self.reasoning!r}")
        parts.append(f"tool_calls={self.tool_calls!r}")
        parts.append(f"executed_tools={self.executed_tools!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('index', 'delta', 'logprobs', 'finish_reason')), EqPlan(fields=('index', 'delta', 'log"
    "probs', 'finish_reason')), FrozenPlan(fields=('index', 'delta', 'logprobs', 'finish_reason'), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('index', 'delta', 'logprobs', 'finish_reason'), cache=False), InitPl"
    "an(fields=(InitPlan.Field(name='index', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='delta', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=N"
    "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
    "lan.Field(name='logprobs', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.de"
    "fault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None), InitPlan.Field(name='finish_reason', annotation=OpRef(name='init.fields.3.annotation'), defau"
    "lt=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
    "ANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('index', 'd"
    "elta', 'logprobs', 'finish_reason'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()"
    "), ReprPlan(fields=(ReprPlan.Field(name='index', kw_only=True, fn=None), ReprPlan.Field(name='delta', kw_only=True"
    ", fn=None), ReprPlan.Field(name='logprobs', kw_only=True, fn=None), ReprPlan.Field(name='finish_reason', kw_only=T"
    "rue, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionChunk_2fChoice(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            index=self.index,
            delta=self.delta,
            logprobs=self.logprobs,
            finish_reason=self.finish_reason,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.index == other.index and
            self.delta == other.delta and
            self.logprobs == other.logprobs and
            self.finish_reason == other.finish_reason
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'index',
        'delta',
        'logprobs',
        'finish_reason',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'index',
        'delta',
        'logprobs',
        'finish_reason',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.index,
            self.delta,
            self.logprobs,
            self.finish_reason,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        index: __dataclass__init__fields__0__annotation,
        delta: __dataclass__init__fields__1__annotation,
        logprobs: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        finish_reason: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'index', index)
        __dataclass__object_setattr(self, 'delta', delta)
        __dataclass__object_setattr(self, 'logprobs', logprobs)
        __dataclass__object_setattr(self, 'finish_reason', finish_reason)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"index={self.index!r}")
        parts.append(f"delta={self.delta!r}")
        parts.append(f"logprobs={self.logprobs!r}")
        parts.append(f"finish_reason={self.finish_reason!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('id', 'object', 'created', 'model', 'system_fingerprint', 'choices', 'x_groq', 'servic"
    "e_tier', 'usage')), EqPlan(fields=('id', 'object', 'created', 'model', 'system_fingerprint', 'choices', 'x_groq', "
    "'service_tier', 'usage')), FrozenPlan(fields=('id', 'object', 'created', 'model', 'system_fingerprint', 'choices',"
    " 'x_groq', 'service_tier', 'usage'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('id', 'obje"
    "ct', 'created', 'model', 'system_fingerprint', 'choices', 'x_groq', 'service_tier', 'usage'), cache=False), InitPl"
    "an(fields=(InitPlan.Field(name='id', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
    "InitPlan.Field(name='object', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1"
    ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None), InitPlan.Field(name='created', annotation=OpRef(name='init.fields.2.annotation'), default="
    "None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
    "check_type=None), InitPlan.Field(name='model', annotation=OpRef(name='init.fields.3.annotation'), default=None, de"
    "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='system_fingerprint', annotation=OpRef(name='init.fields.4.annotation'), default=Non"
    "e, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
    "ck_type=None), InitPlan.Field(name='choices', annotation=OpRef(name='init.fields.5.annotation'), default=None, def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='x_groq', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init"
    ".fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='service_tier', annotation=OpRef(name='init.fields.7.annotati"
    "on'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='usage', annotation=OpRef(name="
    "'init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_para"
    "ms=(), kw_only_params=('id', 'object', 'created', 'model', 'system_fingerprint', 'choices', 'x_groq', 'service_tie"
    "r', 'usage'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Rep"
    "rPlan.Field(name='id', kw_only=True, fn=None), ReprPlan.Field(name='object', kw_only=True, fn=None), ReprPlan.Fiel"
    "d(name='created', kw_only=True, fn=None), ReprPlan.Field(name='model', kw_only=True, fn=None), ReprPlan.Field(name"
    "='system_fingerprint', kw_only=True, fn=None), ReprPlan.Field(name='choices', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='x_groq', kw_only=True, fn=None), ReprPlan.Field(name='service_tier', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='usage', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fgroq_2fprotocol_2fChatCompletionChunk(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            id=self.id,
            object=self.object,
            created=self.created,
            model=self.model,
            system_fingerprint=self.system_fingerprint,
            choices=self.choices,
            x_groq=self.x_groq,
            service_tier=self.service_tier,
            usage=self.usage,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.id == other.id and
            self.object == other.object and
            self.created == other.created and
            self.model == other.model and
            self.system_fingerprint == other.system_fingerprint and
            self.choices == other.choices and
            self.x_groq == other.x_groq and
            self.service_tier == other.service_tier and
            self.usage == other.usage
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'id',
        'object',
        'created',
        'model',
        'system_fingerprint',
        'choices',
        'x_groq',
        'service_tier',
        'usage',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'id',
        'object',
        'created',
        'model',
        'system_fingerprint',
        'choices',
        'x_groq',
        'service_tier',
        'usage',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.id,
            self.object,
            self.created,
            self.model,
            self.system_fingerprint,
            self.choices,
            self.x_groq,
            self.service_tier,
            self.usage,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        id: __dataclass__init__fields__0__annotation,
        object: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        created: __dataclass__init__fields__2__annotation,
        model: __dataclass__init__fields__3__annotation,
        system_fingerprint: __dataclass__init__fields__4__annotation,
        choices: __dataclass__init__fields__5__annotation,
        x_groq: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        service_tier: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        usage: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'object', object)
        __dataclass__object_setattr(self, 'created', created)
        __dataclass__object_setattr(self, 'model', model)
        __dataclass__object_setattr(self, 'system_fingerprint', system_fingerprint)
        __dataclass__object_setattr(self, 'choices', choices)
        __dataclass__object_setattr(self, 'x_groq', x_groq)
        __dataclass__object_setattr(self, 'service_tier', service_tier)
        __dataclass__object_setattr(self, 'usage', usage)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"id={self.id!r}")
        parts.append(f"object={self.object!r}")
        parts.append(f"created={self.created!r}")
        parts.append(f"model={self.model!r}")
        parts.append(f"system_fingerprint={self.system_fingerprint!r}")
        parts.append(f"choices={self.choices!r}")
        parts.append(f"x_groq={self.x_groq!r}")
        parts.append(f"service_tier={self.service_tier!r}")
        parts.append(f"usage={self.usage!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=OpRef(name='repr.fns.0.fn')),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fbackends_2fimpls_2fhuggingface_2fconfigs_2fHuggingfaceHubToken(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__repr__fns__0__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__fns__0__fn(self.v)) is not None:
            parts.append(f"{s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('numa', 'num_ctx', 'num_batch', 'num_gpu', 'main_gpu', 'low_vram', 'f16_kv', 'logits_a"
    "ll', 'vocab_only', 'use_mmap', 'use_mlock', 'embedding_only', 'num_thread', 'num_keep', 'seed', 'num_predict', 'to"
    "p_k', 'top_p', 'tfs_z', 'typical_p', 'repeat_last_n', 'temperature', 'repeat_penalty', 'presence_penalty', 'freque"
    "ncy_penalty', 'mirostat', 'mirostat_tau', 'mirostat_eta', 'penalize_newline', 'stop')), EqPlan(fields=('numa', 'nu"
    "m_ctx', 'num_batch', 'num_gpu', 'main_gpu', 'low_vram', 'f16_kv', 'logits_all', 'vocab_only', 'use_mmap', 'use_mlo"
    "ck', 'embedding_only', 'num_thread', 'num_keep', 'seed', 'num_predict', 'top_k', 'top_p', 'tfs_z', 'typical_p', 'r"
    "epeat_last_n', 'temperature', 'repeat_penalty', 'presence_penalty', 'frequency_penalty', 'mirostat', 'mirostat_tau"
    "', 'mirostat_eta', 'penalize_newline', 'stop')), FrozenPlan(fields=('numa', 'num_ctx', 'num_batch', 'num_gpu', 'ma"
    "in_gpu', 'low_vram', 'f16_kv', 'logits_all', 'vocab_only', 'use_mmap', 'use_mlock', 'embedding_only', 'num_thread'"
    ", 'num_keep', 'seed', 'num_predict', 'top_k', 'top_p', 'tfs_z', 'typical_p', 'repeat_last_n', 'temperature', 'repe"
    "at_penalty', 'presence_penalty', 'frequency_penalty', 'mirostat', 'mirostat_tau', 'mirostat_eta', 'penalize_newlin"
    "e', 'stop'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('numa', 'num_ctx', 'num_batch', 'nu"
    "m_gpu', 'main_gpu', 'low_vram', 'f16_kv', 'logits_all', 'vocab_only', 'use_mmap', 'use_mlock', 'embedding_only', '"
    "num_thread', 'num_keep', 'seed', 'num_predict', 'top_k', 'top_p', 'tfs_z', 'typical_p', 'repeat_last_n', 'temperat"
    "ure', 'repeat_penalty', 'presence_penalty', 'frequency_penalty', 'mirostat', 'mirostat_tau', 'mirostat_eta', 'pena"
    "lize_newline', 'stop'), cache=False), InitPlan(fields=(InitPlan.Field(name='numa', annotation=OpRef(name='init.fie"
    "lds.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='num_ctx', annota"
    "tion=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fie"
    "ld(name='num_batch', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'"
    "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
    "ck_type=None), InitPlan.Field(name='num_gpu', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(nam"
    "e='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='main_gpu', annotation=OpRef(name='init.fields.4.annot"
    "ation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type="
    "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='low_vram', annotation=OpRef"
    "(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='f"
    "16_kv', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='logits_all', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fi"
    "elds.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='vocab_only', annotation=OpRef(name='init.fields.8.annotation'),"
    " default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='use_mmap', annotation=OpRef(name='i"
    "nit.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override="
    "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='use_mlock"
    "', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_facto"
    "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
    "nitPlan.Field(name='embedding_only', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init."
    "fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='num_thread', annotation=OpRef(name='init.fields.12.annotatio"
    "n'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='num_keep', annotation=OpRef(na"
    "me='init.fields.13.annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, ov"
    "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='se"
    "ed', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='num_predict', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name='init.f"
    "ields.15.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, v"
    "alidate=None, check_type=None), InitPlan.Field(name='top_k', annotation=OpRef(name='init.fields.16.annotation'), d"
    "efault=OpRef(name='init.fields.16.default'), default_factory=None, init=True, override=False, field_type=FieldType"
    ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='top_p', annotation=OpRef(name='init."
    "fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=True, override=Fa"
    "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tfs_z', ann"
    "otation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.18.default'), default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
    "n.Field(name='typical_p', annotation=OpRef(name='init.fields.19.annotation'), default=OpRef(name='init.fields.19.d"
    "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
    "ne, check_type=None), InitPlan.Field(name='repeat_last_n', annotation=OpRef(name='init.fields.20.annotation'), def"
    "ault=OpRef(name='init.fields.20.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
    "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='temperature', annotation=OpRef(name='i"
    "nit.fields.21.annotation'), default=OpRef(name='init.fields.21.default'), default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='repeat_"
    "penalty', annotation=OpRef(name='init.fields.22.annotation'), default=OpRef(name='init.fields.22.default'), defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='presence_penalty', annotation=OpRef(name='init.fields.23.annotation'), default=OpRef(na"
    "me='init.fields.23.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='frequency_penalty', annotation=OpRef(name='init.fie"
    "lds.24.annotation'), default=OpRef(name='init.fields.24.default'), default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='mirostat', ann"
    "otation=OpRef(name='init.fields.25.annotation'), default=OpRef(name='init.fields.25.default'), default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
    "n.Field(name='mirostat_tau', annotation=OpRef(name='init.fields.26.annotation'), default=OpRef(name='init.fields.2"
    "6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='mirostat_eta', annotation=OpRef(name='init.fields.27.annotation'), d"
    "efault=OpRef(name='init.fields.27.default'), default_factory=None, init=True, override=False, field_type=FieldType"
    ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='penalize_newline', annotation=OpRef("
    "name='init.fields.28.annotation'), default=OpRef(name='init.fields.28.default'), default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "stop', annotation=OpRef(name='init.fields.29.annotation'), default=OpRef(name='init.fields.29.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    ")), self_param='self', std_params=(), kw_only_params=('numa', 'num_ctx', 'num_batch', 'num_gpu', 'main_gpu', 'low_"
    "vram', 'f16_kv', 'logits_all', 'vocab_only', 'use_mmap', 'use_mlock', 'embedding_only', 'num_thread', 'num_keep', "
    "'seed', 'num_predict', 'top_k', 'top_p', 'tfs_z', 'typical_p', 'repeat_last_n', 'temperature', 'repeat_penalty', '"
    "presence_penalty', 'frequency_penalty', 'mirostat', 'mirostat_tau', 'mirostat_eta', 'penalize_newline', 'stop'), f"
    "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
    "e='numa', kw_only=True, fn=None), ReprPlan.Field(name='num_ctx', kw_only=True, fn=None), ReprPlan.Field(name='num_"
    "batch', kw_only=True, fn=None), ReprPlan.Field(name='num_gpu', kw_only=True, fn=None), ReprPlan.Field(name='main_g"
    "pu', kw_only=True, fn=None), ReprPlan.Field(name='low_vram', kw_only=True, fn=None), ReprPlan.Field(name='f16_kv',"
    " kw_only=True, fn=None), ReprPlan.Field(name='logits_all', kw_only=True, fn=None), ReprPlan.Field(name='vocab_only"
    "', kw_only=True, fn=None), ReprPlan.Field(name='use_mmap', kw_only=True, fn=None), ReprPlan.Field(name='use_mlock'"
    ", kw_only=True, fn=None), ReprPlan.Field(name='embedding_only', kw_only=True, fn=None), ReprPlan.Field(name='num_t"
    "hread', kw_only=True, fn=None), ReprPlan.Field(name='num_keep', kw_only=True, fn=None), ReprPlan.Field(name='seed'"
    ", kw_only=True, fn=None), ReprPlan.Field(name='num_predict', kw_only=True, fn=None), ReprPlan.Field(name='top_k', "
    "kw_only=True, fn=None), ReprPlan.Field(name='top_p', kw_only=True, fn=None), ReprPlan.Field(name='tfs_z', kw_only="
    "True, fn=None), ReprPlan.Field(name='typical_p', kw_only=True, fn=None), ReprPlan.Field(name='repeat_last_n', kw_o"
    "nly=True, fn=None), ReprPlan.Field(name='temperature', kw_only=True, fn=None), ReprPlan.Field(name='repeat_penalty"
    "', kw_only=True, fn=None), ReprPlan.Field(name='presence_penalty', kw_only=True, fn=None), ReprPlan.Field(name='fr"
    "equency_penalty', kw_only=True, fn=None), ReprPlan.Field(name='mirostat', kw_only=True, fn=None), ReprPlan.Field(n"
    "ame='mirostat_tau', kw_only=True, fn=None), ReprPlan.Field(name='mirostat_eta', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='penalize_newline', kw_only=True, fn=None), ReprPlan.Field(name='stop', kw_only=True, fn=None)), id=Fals"
    "e, terse=False, default_fn=OpRef(name='repr.default_fn'))))"
)
def _process_dataclass__ommlds_2fbackends_2follama_2fprotocol_2fOptions(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__21__annotation,
    __dataclass__init__fields__21__default,
    __dataclass__init__fields__22__annotation,
    __dataclass__init__fields__22__default,
    __dataclass__init__fields__23__annotation,
    __dataclass__init__fields__23__default,
    __dataclass__init__fields__24__annotation,
    __dataclass__init__fields__24__default,
    __dataclass__init__fields__25__annotation,
    __dataclass__init__fields__25__default,
    __dataclass__init__fields__26__annotation,
    __dataclass__init__fields__26__default,
    __dataclass__init__fields__27__annotation,
    __dataclass__init__fields__27__default,
    __dataclass__init__fields__28__annotation,
    __dataclass__init__fields__28__default,
    __dataclass__init__fields__29__annotation,
    __dataclass__init__fields__29__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__repr__default_fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            numa=self.numa,
            num_ctx=self.num_ctx,
            num_batch=self.num_batch,
            num_gpu=self.num_gpu,
            main_gpu=self.main_gpu,
            low_vram=self.low_vram,
            f16_kv=self.f16_kv,
            logits_all=self.logits_all,
            vocab_only=self.vocab_only,
            use_mmap=self.use_mmap,
            use_mlock=self.use_mlock,
            embedding_only=self.embedding_only,
            num_thread=self.num_thread,
            num_keep=self.num_keep,
            seed=self.seed,
            num_predict=self.num_predict,
            top_k=self.top_k,
            top_p=self.top_p,
            tfs_z=self.tfs_z,
            typical_p=self.typical_p,
            repeat_last_n=self.repeat_last_n,
            temperature=self.temperature,
            repeat_penalty=self.repeat_penalty,
            presence_penalty=self.presence_penalty,
            frequency_penalty=self.frequency_penalty,
            mirostat=self.mirostat,
            mirostat_tau=self.mirostat_tau,
            mirostat_eta=self.mirostat_eta,
            penalize_newline=self.penalize_newline,
            stop=self.stop,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.numa == other.numa and
            self.num_ctx == other.num_ctx and
            self.num_batch == other.num_batch and
            self.num_gpu == other.num_gpu and
            self.main_gpu == other.main_gpu and
            self.low_vram == other.low_vram and
            self.f16_kv == other.f16_kv and
            self.logits_all == other.logits_all and
            self.vocab_only == other.vocab_only and
            self.use_mmap == other.use_mmap and
            self.use_mlock == other.use_mlock and
            self.embedding_only == other.embedding_only and
            self.num_thread == other.num_thread and
            self.num_keep == other.num_keep and
            self.seed == other.seed and
            self.num_predict == other.num_predict and
            self.top_k == other.top_k and
            self.top_p == other.top_p and
            self.tfs_z == other.tfs_z and
            self.typical_p == other.typical_p and
            self.repeat_last_n == other.repeat_last_n and
            self.temperature == other.temperature and
            self.repeat_penalty == other.repeat_penalty and
            self.presence_penalty == other.presence_penalty and
            self.frequency_penalty == other.frequency_penalty and
            self.mirostat == other.mirostat and
            self.mirostat_tau == other.mirostat_tau and
            self.mirostat_eta == other.mirostat_eta and
            self.penalize_newline == other.penalize_newline and
            self.stop == other.stop
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'numa',
        'num_ctx',
        'num_batch',
        'num_gpu',
        'main_gpu',
        'low_vram',
        'f16_kv',
        'logits_all',
        'vocab_only',
        'use_mmap',
        'use_mlock',
        'embedding_only',
        'num_thread',
        'num_keep',
        'seed',
        'num_predict',
        'top_k',
        'top_p',
        'tfs_z',
        'typical_p',
        'repeat_last_n',
        'temperature',
        'repeat_penalty',
        'presence_penalty',
        'frequency_penalty',
        'mirostat',
        'mirostat_tau',
        'mirostat_eta',
        'penalize_newline',
        'stop',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'numa',
        'num_ctx',
        'num_batch',
        'num_gpu',
        'main_gpu',
        'low_vram',
        'f16_kv',
        'logits_all',
        'vocab_only',
        'use_mmap',
        'use_mlock',
        'embedding_only',
        'num_thread',
        'num_keep',
        'seed',
        'num_predict',
        'top_k',
        'top_p',
        'tfs_z',
        'typical_p',
        'repeat_last_n',
        'temperature',
        'repeat_penalty',
        'presence_penalty',
        'frequency_penalty',
        'mirostat',
        'mirostat_tau',
        'mirostat_eta',
        'penalize_newline',
        'stop',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.numa,
            self.num_ctx,
            self.num_batch,
            self.num_gpu,
            self.main_gpu,
            self.low_vram,
            self.f16_kv,
            self.logits_all,
            self.vocab_only,
            self.use_mmap,
            self.use_mlock,
            self.embedding_only,
            self.num_thread,
            self.num_keep,
            self.seed,
            self.num_predict,
            self.top_k,
            self.top_p,
            self.tfs_z,
            self.typical_p,
            self.repeat_last_n,
            self.temperature,
            self.repeat_penalty,
            self.presence_penalty,
            self.frequency_penalty,
            self.mirostat,
            self.mirostat_tau,
            self.mirostat_eta,
            self.penalize_newline,
            self.stop,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        numa: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        num_ctx: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        num_batch: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        num_gpu: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        main_gpu: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        low_vram: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        f16_kv: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        logits_all: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        vocab_only: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        use_mmap: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        use_mlock: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        embedding_only: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        num_thread: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        num_keep: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        seed: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        num_predict: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        top_k: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        top_p: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        tfs_z: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        typical_p: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        repeat_last_n: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        temperature: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
        repeat_penalty: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
        presence_penalty: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
        frequency_penalty: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
        mirostat: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
        mirostat_tau: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
        mirostat_eta: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
        penalize_newline: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
        stop: __dataclass__init__fields__29__annotation = __dataclass__init__fields__29__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'numa', numa)
        __dataclass__object_setattr(self, 'num_ctx', num_ctx)
        __dataclass__object_setattr(self, 'num_batch', num_batch)
        __dataclass__object_setattr(self, 'num_gpu', num_gpu)
        __dataclass__object_setattr(self, 'main_gpu', main_gpu)
        __dataclass__object_setattr(self, 'low_vram', low_vram)
        __dataclass__object_setattr(self, 'f16_kv', f16_kv)
        __dataclass__object_setattr(self, 'logits_all', logits_all)
        __dataclass__object_setattr(self, 'vocab_only', vocab_only)
        __dataclass__object_setattr(self, 'use_mmap', use_mmap)
        __dataclass__object_setattr(self, 'use_mlock', use_mlock)
        __dataclass__object_setattr(self, 'embedding_only', embedding_only)
        __dataclass__object_setattr(self, 'num_thread', num_thread)
        __dataclass__object_setattr(self, 'num_keep', num_keep)
        __dataclass__object_setattr(self, 'seed', seed)
        __dataclass__object_setattr(self, 'num_predict', num_predict)
        __dataclass__object_setattr(self, 'top_k', top_k)
        __dataclass__object_setattr(self, 'top_p', top_p)
        __dataclass__object_setattr(self, 'tfs_z', tfs_z)
        __dataclass__object_setattr(self, 'typical_p', typical_p)
        __dataclass__object_setattr(self, 'repeat_last_n', repeat_last_n)
        __dataclass__object_setattr(self, 'temperature', temperature)
        __dataclass__object_setattr(self, 'repeat_penalty', repeat_penalty)
        __dataclass__object_setattr(self, 'presence_penalty', presence_penalty)
        __dataclass__object_setattr(self, 'frequency_penalty', frequency_penalty)
        __dataclass__object_setattr(self, 'mirostat', mirostat)
        __dataclass__object_setattr(self, 'mirostat_tau', mirostat_tau)
        __dataclass__object_setattr(self, 'mirostat_eta', mirostat_eta)
        __dataclass__object_setattr(self, 'penalize_newline', penalize_newline)
        __dataclass__object_setattr(self, 'stop', stop)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__default_fn(self.numa)) is not None:
            parts.append(f"numa={s}")
        if (s := __dataclass__repr__default_fn(self.num_ctx)) is not None:
            parts.append(f"num_ctx={s}")
        if (s := __dataclass__repr__default_fn(self.num_batch)) is not None:
            parts.append(f"num_batch={s}")
        if (s := __dataclass__repr__default_fn(self.num_gpu)) is not None:
            parts.append(f"num_gpu={s}")
        if (s := __dataclass__repr__default_fn(self.main_gpu)) is not None:
            parts.append(f"main_gpu={s}")
        if (s := __dataclass__repr__default_fn(self.low_vram)) is not None:
            parts.append(f"low_vram={s}")
        if (s := __dataclass__repr__default_fn(self.f16_kv)) is not None:
            parts.append(f"f16_kv={s}")
        if (s := __dataclass__repr__default_fn(self.logits_all)) is not None:
            parts.append(f"logits_all={s}")
        if (s := __dataclass__repr__default_fn(self.vocab_only)) is not None:
            parts.append(f"vocab_only={s}")
        if (s := __dataclass__repr__default_fn(self.use_mmap)) is not None:
            parts.append(f"use_mmap={s}")
        if (s := __dataclass__repr__default_fn(self.use_mlock)) is not None:
            parts.append(f"use_mlock={s}")
        if (s := __dataclass__repr__default_fn(self.embedding_only)) is not None:
            parts.append(f"embedding_only={s}")
        if (s := __dataclass__repr__default_fn(self.num_thread)) is not None:
            parts.append(f"num_thread={s}")
        if (s := __dataclass__repr__default_fn(self.num_keep)) is not None:
            parts.append(f"num_keep={s}")
        if (s := __dataclass__repr__default_fn(self.seed)) is not None:
            parts.append(f"seed={s}")
        if (s := __dataclass__repr__default_fn(self.num_predict)) is not None:
            parts.append(f"num_predict={s}")
        if (s := __dataclass__repr__default_fn(self.top_k)) is not None:
            parts.append(f"top_k={s}")
        if (s := __dataclass__repr__default_fn(self.top_p)) is not None:
            parts.append(f"top_p={s}")
        if (s := __dataclass__repr__default_fn(self.tfs_z)) is not None:
            parts.append(f"tfs_z={s}")
        if (s := __dataclass__repr__default_fn(self.typical_p)) is not None:
            parts.append(f"typical_p={s}")
        if (s := __dataclass__repr__default_fn(self.repeat_last_n)) is not None:
            parts.append(f"repeat_last_n={s}")
        if (s := __dataclass__repr__default_fn(self.temperature)) is not None:
            parts.append(f"temperature={s}")
        if (s := __dataclass__repr__default_fn(self.repeat_penalty)) is not None:
            parts.append(f"repeat_penalty={s}")
        if (s := __dataclass__repr__default_fn(self.presence_penalty)) is not None:
            parts.append(f"presence_penalty={s}")
        if (s := __dataclass__repr__default_fn(self.frequency_penalty)) is not None:
            parts.append(f"frequency_penalty={s}")
        if (s := __dataclass__repr__default_fn(self.mirostat)) is not None:
            parts.append(f"mirostat={s}")
        if (s := __dataclass__repr__default_fn(self.mirostat_tau)) is not None:
            parts.append(f"mirostat_tau={s}")
        if (s := __dataclass__repr__default_fn(self.mirostat_eta)) is not None:
            parts.append(f"mirostat_eta={s}")
        if (s := __dataclass__repr__default_fn(self.penalize_newline)) is not None:
            parts.append(f"penalize_newline={s}")
        if (s := __dataclass__repr__default_fn(self.stop)) is not None:
            parts.append(f"stop={s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('model',)), EqPlan(fields=('model',)), FrozenPlan(fields=('model',), allow_dynamic_dun"
    "der_attrs=False), HashPlan(action='add', fields=('model',), cache=False), InitPlan(fields=(InitPlan.Field(name='mo"
    "del', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params"
    "=(), kw_only_params=('model',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Re"
    "prPlan(fields=(ReprPlan.Field(name='model', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2follama_2fprotocol_2fBaseRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            model=self.model,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.model == other.model
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'model',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'model',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.model,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        model: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'model', model)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"model={self.model!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('model', 'stream')), EqPlan(fields=('model', 'stream')), FrozenPlan(fields=('model', '"
    "stream'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('model', 'stream'), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='model', annotation=OpRef(name='init.fields.0.annotation'), default=None, default"
    "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
    "ne), InitPlan.Field(name='stream', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fie"
    "lds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('model', 'stream'), frozen=True, s"
    "lots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='model', kw"
    "_only=True, fn=None), ReprPlan.Field(name='stream', kw_only=True, fn=None)), id=False, terse=False, default_fn=Non"
    "e)))"
)
def _process_dataclass__ommlds_2fbackends_2follama_2fprotocol_2fBaseStreamableRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            model=self.model,
            stream=self.stream,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.model == other.model and
            self.stream == other.stream
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'model',
        'stream',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'model',
        'stream',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.model,
            self.stream,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        model: __dataclass__init__fields__0__annotation,
        stream: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'model', model)
        __dataclass__object_setattr(self, 'stream', stream)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"model={self.model!r}")
        parts.append(f"stream={self.stream!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('model', 'stream', 'options', 'format', 'keep_alive')), EqPlan(fields=('model', 'strea"
    "m', 'options', 'format', 'keep_alive')), FrozenPlan(fields=('model', 'stream', 'options', 'format', 'keep_alive'),"
    " allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('model', 'stream', 'options', 'format', 'keep_a"
    "live'), cache=False), InitPlan(fields=(InitPlan.Field(name='model', annotation=OpRef(name='init.fields.0.annotatio"
    "n'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='stream', annotation=OpRef(name='init.fields.1.annotation'), de"
    "fault=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
    "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='options', annotation=OpRef(name='init."
    "fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=Fals"
    "e, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='format', anno"
    "tation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.F"
    "ield(name='keep_alive', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.defau"
    "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
    "check_type=None)), self_param='self', std_params=(), kw_only_params=('model', 'stream', 'options', 'format', 'keep"
    "_alive'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPla"
    "n.Field(name='model', kw_only=True, fn=None), ReprPlan.Field(name='stream', kw_only=True, fn=None), ReprPlan.Field"
    "(name='options', kw_only=True, fn=None), ReprPlan.Field(name='format', kw_only=True, fn=None), ReprPlan.Field(name"
    "='keep_alive', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2follama_2fprotocol_2fBaseGenerateRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            model=self.model,
            stream=self.stream,
            options=self.options,
            format=self.format,
            keep_alive=self.keep_alive,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.model == other.model and
            self.stream == other.stream and
            self.options == other.options and
            self.format == other.format and
            self.keep_alive == other.keep_alive
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'model',
        'stream',
        'options',
        'format',
        'keep_alive',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'model',
        'stream',
        'options',
        'format',
        'keep_alive',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.model,
            self.stream,
            self.options,
            self.format,
            self.keep_alive,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        model: __dataclass__init__fields__0__annotation,
        stream: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        options: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        format: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        keep_alive: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'model', model)
        __dataclass__object_setattr(self, 'stream', stream)
        __dataclass__object_setattr(self, 'options', options)
        __dataclass__object_setattr(self, 'format', format)
        __dataclass__object_setattr(self, 'keep_alive', keep_alive)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"model={self.model!r}")
        parts.append(f"stream={self.stream!r}")
        parts.append(f"options={self.options!r}")
        parts.append(f"format={self.format!r}")
        parts.append(f"keep_alive={self.keep_alive!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('model', 'stream', 'options', 'format', 'keep_alive', 'prompt', 'suffix', 'system', 't"
    "emplate', 'context', 'raw', 'images', 'think')), EqPlan(fields=('model', 'stream', 'options', 'format', 'keep_aliv"
    "e', 'prompt', 'suffix', 'system', 'template', 'context', 'raw', 'images', 'think')), FrozenPlan(fields=('model', '"
    "stream', 'options', 'format', 'keep_alive', 'prompt', 'suffix', 'system', 'template', 'context', 'raw', 'images', "
    "'think'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('model', 'stream', 'options', 'format'"
    ", 'keep_alive', 'prompt', 'suffix', 'system', 'template', 'context', 'raw', 'images', 'think'), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='model', annotation=OpRef(name='init.fields.0.annotation'), default=None, default"
    "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
    "ne), InitPlan.Field(name='stream', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fie"
    "lds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None), InitPlan.Field(name='options', annotation=OpRef(name='init.fields.2.annotation'), def"
    "ault=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='format', annotation=OpRef(name='init.fi"
    "elds.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='keep_alive', an"
    "notation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None"
    ", init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan"
    ".Field(name='prompt', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default"
    "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None), InitPlan.Field(name='suffix', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(nam"
    "e='init.fields.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='system', annotation=OpRef(name='init.fields.7.annotat"
    "ion'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='template', annotation=OpRef(n"
    "ame='init.fields.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='con"
    "text', annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='raw', annotation=OpRef(name='init.fields.10.annotation'), default=OpRef(name='init.fields.10"
    ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None), InitPlan.Field(name='images', annotation=OpRef(name='init.fields.11.annotation'), default="
    "OpRef(name='init.fields.11.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='think', annotation=OpRef(name='init.fields."
    "12.annotation'), default=OpRef(name='init.fields.12.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_o"
    "nly_params=('model', 'stream', 'options', 'format', 'keep_alive', 'prompt', 'suffix', 'system', 'template', 'conte"
    "xt', 'raw', 'images', 'think'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Re"
    "prPlan(fields=(ReprPlan.Field(name='model', kw_only=True, fn=None), ReprPlan.Field(name='stream', kw_only=True, fn"
    "=None), ReprPlan.Field(name='options', kw_only=True, fn=None), ReprPlan.Field(name='format', kw_only=True, fn=None"
    "), ReprPlan.Field(name='keep_alive', kw_only=True, fn=None), ReprPlan.Field(name='prompt', kw_only=True, fn=None),"
    " ReprPlan.Field(name='suffix', kw_only=True, fn=None), ReprPlan.Field(name='system', kw_only=True, fn=None), ReprP"
    "lan.Field(name='template', kw_only=True, fn=None), ReprPlan.Field(name='context', kw_only=True, fn=None), ReprPlan"
    ".Field(name='raw', kw_only=True, fn=None), ReprPlan.Field(name='images', kw_only=True, fn=None), ReprPlan.Field(na"
    "me='think', kw_only=True, fn=None)), id=False, terse=False, default_fn=OpRef(name='repr.default_fn'))))"
)
def _process_dataclass__ommlds_2fbackends_2follama_2fprotocol_2fGenerateRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__repr__default_fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            model=self.model,
            stream=self.stream,
            options=self.options,
            format=self.format,
            keep_alive=self.keep_alive,
            prompt=self.prompt,
            suffix=self.suffix,
            system=self.system,
            template=self.template,
            context=self.context,
            raw=self.raw,
            images=self.images,
            think=self.think,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.model == other.model and
            self.stream == other.stream and
            self.options == other.options and
            self.format == other.format and
            self.keep_alive == other.keep_alive and
            self.prompt == other.prompt and
            self.suffix == other.suffix and
            self.system == other.system and
            self.template == other.template and
            self.context == other.context and
            self.raw == other.raw and
            self.images == other.images and
            self.think == other.think
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'model',
        'stream',
        'options',
        'format',
        'keep_alive',
        'prompt',
        'suffix',
        'system',
        'template',
        'context',
        'raw',
        'images',
        'think',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'model',
        'stream',
        'options',
        'format',
        'keep_alive',
        'prompt',
        'suffix',
        'system',
        'template',
        'context',
        'raw',
        'images',
        'think',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.model,
            self.stream,
            self.options,
            self.format,
            self.keep_alive,
            self.prompt,
            self.suffix,
            self.system,
            self.template,
            self.context,
            self.raw,
            self.images,
            self.think,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        model: __dataclass__init__fields__0__annotation,
        stream: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        options: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        format: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        keep_alive: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        prompt: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        suffix: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        system: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        template: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        context: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        raw: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        images: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        think: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'model', model)
        __dataclass__object_setattr(self, 'stream', stream)
        __dataclass__object_setattr(self, 'options', options)
        __dataclass__object_setattr(self, 'format', format)
        __dataclass__object_setattr(self, 'keep_alive', keep_alive)
        __dataclass__object_setattr(self, 'prompt', prompt)
        __dataclass__object_setattr(self, 'suffix', suffix)
        __dataclass__object_setattr(self, 'system', system)
        __dataclass__object_setattr(self, 'template', template)
        __dataclass__object_setattr(self, 'context', context)
        __dataclass__object_setattr(self, 'raw', raw)
        __dataclass__object_setattr(self, 'images', images)
        __dataclass__object_setattr(self, 'think', think)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__default_fn(self.model)) is not None:
            parts.append(f"model={s}")
        if (s := __dataclass__repr__default_fn(self.stream)) is not None:
            parts.append(f"stream={s}")
        if (s := __dataclass__repr__default_fn(self.options)) is not None:
            parts.append(f"options={s}")
        if (s := __dataclass__repr__default_fn(self.format)) is not None:
            parts.append(f"format={s}")
        if (s := __dataclass__repr__default_fn(self.keep_alive)) is not None:
            parts.append(f"keep_alive={s}")
        if (s := __dataclass__repr__default_fn(self.prompt)) is not None:
            parts.append(f"prompt={s}")
        if (s := __dataclass__repr__default_fn(self.suffix)) is not None:
            parts.append(f"suffix={s}")
        if (s := __dataclass__repr__default_fn(self.system)) is not None:
            parts.append(f"system={s}")
        if (s := __dataclass__repr__default_fn(self.template)) is not None:
            parts.append(f"template={s}")
        if (s := __dataclass__repr__default_fn(self.context)) is not None:
            parts.append(f"context={s}")
        if (s := __dataclass__repr__default_fn(self.raw)) is not None:
            parts.append(f"raw={s}")
        if (s := __dataclass__repr__default_fn(self.images)) is not None:
            parts.append(f"images={s}")
        if (s := __dataclass__repr__default_fn(self.think)) is not None:
            parts.append(f"think={s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('model', 'created_at', 'done', 'done_reason', 'total_duration', 'load_duration', 'prom"
    "pt_eval_count', 'prompt_eval_duration', 'eval_count', 'eval_duration')), EqPlan(fields=('model', 'created_at', 'do"
    "ne', 'done_reason', 'total_duration', 'load_duration', 'prompt_eval_count', 'prompt_eval_duration', 'eval_count', "
    "'eval_duration')), FrozenPlan(fields=('model', 'created_at', 'done', 'done_reason', 'total_duration', 'load_durati"
    "on', 'prompt_eval_count', 'prompt_eval_duration', 'eval_count', 'eval_duration'), allow_dynamic_dunder_attrs=False"
    "), HashPlan(action='add', fields=('model', 'created_at', 'done', 'done_reason', 'total_duration', 'load_duration',"
    " 'prompt_eval_count', 'prompt_eval_duration', 'eval_count', 'eval_duration'), cache=False), InitPlan(fields=(InitP"
    "lan.Field(name='model', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.defau"
    "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
    "check_type=None), InitPlan.Field(name='created_at', annotation=OpRef(name='init.fields.1.annotation'), default=OpR"
    "ef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None), InitPlan.Field(name='done', annotation=OpRef(name='init.fields.2.ann"
    "otation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='done_reason', annotation="
    "OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=Tr"
    "ue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(na"
    "me='total_duration', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'"
    "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
    "ck_type=None), InitPlan.Field(name='load_duration', annotation=OpRef(name='init.fields.5.annotation'), default=OpR"
    "ef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, "
    "coerce=None, validate=None, check_type=None), InitPlan.Field(name='prompt_eval_count', annotation=OpRef(name='init"
    ".fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=Fal"
    "se, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='prompt_eval_"
    "duration', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default"
    "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
    "ne), InitPlan.Field(name='eval_count', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init"
    ".fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, "
    "validate=None, check_type=None), InitPlan.Field(name='eval_duration', annotation=OpRef(name='init.fields.9.annotat"
    "ion'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params="
    "('model', 'created_at', 'done', 'done_reason', 'total_duration', 'load_duration', 'prompt_eval_count', 'prompt_eva"
    "l_duration', 'eval_count', 'eval_duration'), frozen=True, slots=False, post_init_params=None, init_fns=(), validat"
    "e_fns=()), ReprPlan(fields=(ReprPlan.Field(name='model', kw_only=True, fn=None), ReprPlan.Field(name='created_at',"
    " kw_only=True, fn=None), ReprPlan.Field(name='done', kw_only=True, fn=None), ReprPlan.Field(name='done_reason', kw"
    "_only=True, fn=None), ReprPlan.Field(name='total_duration', kw_only=True, fn=None), ReprPlan.Field(name='load_dura"
    "tion', kw_only=True, fn=None), ReprPlan.Field(name='prompt_eval_count', kw_only=True, fn=None), ReprPlan.Field(nam"
    "e='prompt_eval_duration', kw_only=True, fn=None), ReprPlan.Field(name='eval_count', kw_only=True, fn=None), ReprPl"
    "an.Field(name='eval_duration', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2follama_2fprotocol_2fBaseGenerateResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            model=self.model,
            created_at=self.created_at,
            done=self.done,
            done_reason=self.done_reason,
            total_duration=self.total_duration,
            load_duration=self.load_duration,
            prompt_eval_count=self.prompt_eval_count,
            prompt_eval_duration=self.prompt_eval_duration,
            eval_count=self.eval_count,
            eval_duration=self.eval_duration,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.model == other.model and
            self.created_at == other.created_at and
            self.done == other.done and
            self.done_reason == other.done_reason and
            self.total_duration == other.total_duration and
            self.load_duration == other.load_duration and
            self.prompt_eval_count == other.prompt_eval_count and
            self.prompt_eval_duration == other.prompt_eval_duration and
            self.eval_count == other.eval_count and
            self.eval_duration == other.eval_duration
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'model',
        'created_at',
        'done',
        'done_reason',
        'total_duration',
        'load_duration',
        'prompt_eval_count',
        'prompt_eval_duration',
        'eval_count',
        'eval_duration',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'model',
        'created_at',
        'done',
        'done_reason',
        'total_duration',
        'load_duration',
        'prompt_eval_count',
        'prompt_eval_duration',
        'eval_count',
        'eval_duration',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.model,
            self.created_at,
            self.done,
            self.done_reason,
            self.total_duration,
            self.load_duration,
            self.prompt_eval_count,
            self.prompt_eval_duration,
            self.eval_count,
            self.eval_duration,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        model: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        created_at: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        done: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        done_reason: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        total_duration: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        load_duration: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        prompt_eval_count: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        prompt_eval_duration: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        eval_count: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        eval_duration: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'model', model)
        __dataclass__object_setattr(self, 'created_at', created_at)
        __dataclass__object_setattr(self, 'done', done)
        __dataclass__object_setattr(self, 'done_reason', done_reason)
        __dataclass__object_setattr(self, 'total_duration', total_duration)
        __dataclass__object_setattr(self, 'load_duration', load_duration)
        __dataclass__object_setattr(self, 'prompt_eval_count', prompt_eval_count)
        __dataclass__object_setattr(self, 'prompt_eval_duration', prompt_eval_duration)
        __dataclass__object_setattr(self, 'eval_count', eval_count)
        __dataclass__object_setattr(self, 'eval_duration', eval_duration)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"model={self.model!r}")
        parts.append(f"created_at={self.created_at!r}")
        parts.append(f"done={self.done!r}")
        parts.append(f"done_reason={self.done_reason!r}")
        parts.append(f"total_duration={self.total_duration!r}")
        parts.append(f"load_duration={self.load_duration!r}")
        parts.append(f"prompt_eval_count={self.prompt_eval_count!r}")
        parts.append(f"prompt_eval_duration={self.prompt_eval_duration!r}")
        parts.append(f"eval_count={self.eval_count!r}")
        parts.append(f"eval_duration={self.eval_duration!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('model', 'created_at', 'done', 'done_reason', 'total_duration', 'load_duration', 'prom"
    "pt_eval_count', 'prompt_eval_duration', 'eval_count', 'eval_duration', 'response', 'thinking', 'context')), EqPlan"
    "(fields=('model', 'created_at', 'done', 'done_reason', 'total_duration', 'load_duration', 'prompt_eval_count', 'pr"
    "ompt_eval_duration', 'eval_count', 'eval_duration', 'response', 'thinking', 'context')), FrozenPlan(fields=('model"
    "', 'created_at', 'done', 'done_reason', 'total_duration', 'load_duration', 'prompt_eval_count', 'prompt_eval_durat"
    "ion', 'eval_count', 'eval_duration', 'response', 'thinking', 'context'), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=('model', 'created_at', 'done', 'done_reason', 'total_duration', 'load_duration', 'prompt_"
    "eval_count', 'prompt_eval_duration', 'eval_count', 'eval_duration', 'response', 'thinking', 'context'), cache=Fals"
    "e), InitPlan(fields=(InitPlan.Field(name='model', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef"
    "(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None), InitPlan.Field(name='created_at', annotation=OpRef(name='init.fields.1"
    ".annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field"
    "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='done', annotation=OpR"
    "ef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True,"
    " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
    "'done_reason', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='total_duration', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(na"
    "me='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='load_duration', annotation=OpRef(name='init.fields.5"
    ".annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field"
    "_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='prompt_eval_count', a"
    "nnotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
    "n.Field(name='prompt_eval_duration', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.f"
    "ields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='eval_count', annotation=OpRef(name='init.fields.8.annotation')"
    ", default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
    "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='eval_duration', annotation=OpRef(n"
    "ame='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='res"
    "ponse', annotation=OpRef(name='init.fields.10.annotation'), default=None, default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='thinkin"
    "g', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.default'), default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
    "InitPlan.Field(name='context', annotation=OpRef(name='init.fields.12.annotation'), default=OpRef(name='init.fields"
    ".12.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('model', 'created_at', 'done', 'done"
    "_reason', 'total_duration', 'load_duration', 'prompt_eval_count', 'prompt_eval_duration', 'eval_count', 'eval_dura"
    "tion', 'response', 'thinking', 'context'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_"
    "fns=()), ReprPlan(fields=(ReprPlan.Field(name='model', kw_only=True, fn=None), ReprPlan.Field(name='created_at', k"
    "w_only=True, fn=None), ReprPlan.Field(name='done', kw_only=True, fn=None), ReprPlan.Field(name='done_reason', kw_o"
    "nly=True, fn=None), ReprPlan.Field(name='total_duration', kw_only=True, fn=None), ReprPlan.Field(name='load_durati"
    "on', kw_only=True, fn=None), ReprPlan.Field(name='prompt_eval_count', kw_only=True, fn=None), ReprPlan.Field(name="
    "'prompt_eval_duration', kw_only=True, fn=None), ReprPlan.Field(name='eval_count', kw_only=True, fn=None), ReprPlan"
    ".Field(name='eval_duration', kw_only=True, fn=None), ReprPlan.Field(name='response', kw_only=True, fn=None), ReprP"
    "lan.Field(name='thinking', kw_only=True, fn=None), ReprPlan.Field(name='context', kw_only=True, fn=None)), id=Fals"
    "e, terse=False, default_fn=OpRef(name='repr.default_fn'))))"
)
def _process_dataclass__ommlds_2fbackends_2follama_2fprotocol_2fGenerateResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__repr__default_fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            model=self.model,
            created_at=self.created_at,
            done=self.done,
            done_reason=self.done_reason,
            total_duration=self.total_duration,
            load_duration=self.load_duration,
            prompt_eval_count=self.prompt_eval_count,
            prompt_eval_duration=self.prompt_eval_duration,
            eval_count=self.eval_count,
            eval_duration=self.eval_duration,
            response=self.response,
            thinking=self.thinking,
            context=self.context,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.model == other.model and
            self.created_at == other.created_at and
            self.done == other.done and
            self.done_reason == other.done_reason and
            self.total_duration == other.total_duration and
            self.load_duration == other.load_duration and
            self.prompt_eval_count == other.prompt_eval_count and
            self.prompt_eval_duration == other.prompt_eval_duration and
            self.eval_count == other.eval_count and
            self.eval_duration == other.eval_duration and
            self.response == other.response and
            self.thinking == other.thinking and
            self.context == other.context
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'model',
        'created_at',
        'done',
        'done_reason',
        'total_duration',
        'load_duration',
        'prompt_eval_count',
        'prompt_eval_duration',
        'eval_count',
        'eval_duration',
        'response',
        'thinking',
        'context',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'model',
        'created_at',
        'done',
        'done_reason',
        'total_duration',
        'load_duration',
        'prompt_eval_count',
        'prompt_eval_duration',
        'eval_count',
        'eval_duration',
        'response',
        'thinking',
        'context',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.model,
            self.created_at,
            self.done,
            self.done_reason,
            self.total_duration,
            self.load_duration,
            self.prompt_eval_count,
            self.prompt_eval_duration,
            self.eval_count,
            self.eval_duration,
            self.response,
            self.thinking,
            self.context,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        model: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        created_at: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        done: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        done_reason: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        total_duration: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        load_duration: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        prompt_eval_count: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        prompt_eval_duration: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        eval_count: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        eval_duration: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        response: __dataclass__init__fields__10__annotation,
        thinking: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        context: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'model', model)
        __dataclass__object_setattr(self, 'created_at', created_at)
        __dataclass__object_setattr(self, 'done', done)
        __dataclass__object_setattr(self, 'done_reason', done_reason)
        __dataclass__object_setattr(self, 'total_duration', total_duration)
        __dataclass__object_setattr(self, 'load_duration', load_duration)
        __dataclass__object_setattr(self, 'prompt_eval_count', prompt_eval_count)
        __dataclass__object_setattr(self, 'prompt_eval_duration', prompt_eval_duration)
        __dataclass__object_setattr(self, 'eval_count', eval_count)
        __dataclass__object_setattr(self, 'eval_duration', eval_duration)
        __dataclass__object_setattr(self, 'response', response)
        __dataclass__object_setattr(self, 'thinking', thinking)
        __dataclass__object_setattr(self, 'context', context)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__default_fn(self.model)) is not None:
            parts.append(f"model={s}")
        if (s := __dataclass__repr__default_fn(self.created_at)) is not None:
            parts.append(f"created_at={s}")
        if (s := __dataclass__repr__default_fn(self.done)) is not None:
            parts.append(f"done={s}")
        if (s := __dataclass__repr__default_fn(self.done_reason)) is not None:
            parts.append(f"done_reason={s}")
        if (s := __dataclass__repr__default_fn(self.total_duration)) is not None:
            parts.append(f"total_duration={s}")
        if (s := __dataclass__repr__default_fn(self.load_duration)) is not None:
            parts.append(f"load_duration={s}")
        if (s := __dataclass__repr__default_fn(self.prompt_eval_count)) is not None:
            parts.append(f"prompt_eval_count={s}")
        if (s := __dataclass__repr__default_fn(self.prompt_eval_duration)) is not None:
            parts.append(f"prompt_eval_duration={s}")
        if (s := __dataclass__repr__default_fn(self.eval_count)) is not None:
            parts.append(f"eval_count={s}")
        if (s := __dataclass__repr__default_fn(self.eval_duration)) is not None:
            parts.append(f"eval_duration={s}")
        if (s := __dataclass__repr__default_fn(self.response)) is not None:
            parts.append(f"response={s}")
        if (s := __dataclass__repr__default_fn(self.thinking)) is not None:
            parts.append(f"thinking={s}")
        if (s := __dataclass__repr__default_fn(self.context)) is not None:
            parts.append(f"context={s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'arguments')), EqPlan(fields=('name', 'arguments')), FrozenPlan(fields=('name'"
    ", 'arguments'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'arguments'), cache=Fals"
    "e), InitPlan(fields=(InitPlan.Field(name='name', annotation=OpRef(name='init.fields.0.annotation'), default=None, "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None), InitPlan.Field(name='arguments', annotation=OpRef(name='init.fields.1.annotation'), default=None, defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None)), self_param='self', std_params=(), kw_only_params=('name', 'arguments'), frozen=True, slots=False, post_in"
    "it_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_only=True, fn=None)"
    ", ReprPlan.Field(name='arguments', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2follama_2fprotocol_2fMessage_2fToolCall_2fFunction(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            arguments=self.arguments,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.arguments == other.arguments
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'name',
        'arguments',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
        'arguments',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.arguments,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        name: __dataclass__init__fields__0__annotation,
        arguments: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'arguments', arguments)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"arguments={self.arguments!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('function',)), EqPlan(fields=('function',)), FrozenPlan(fields=('function',), allow_dy"
    "namic_dunder_attrs=False), HashPlan(action='add', fields=('function',), cache=False), InitPlan(fields=(InitPlan.Fi"
    "eld(name='function', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=T"
    "rue, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='se"
    "lf', std_params=(), kw_only_params=('function',), frozen=True, slots=False, post_init_params=None, init_fns=(), va"
    "lidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='function', kw_only=True, fn=None),), id=False, terse=False, "
    "default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2follama_2fprotocol_2fMessage_2fToolCall(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            function=self.function,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.function == other.function
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'function',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'function',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.function,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        function: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'function', function)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"function={self.function!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('role', 'content', 'thinking', 'images', 'tool_name', 'tool_calls')), EqPlan(fields=('"
    "role', 'content', 'thinking', 'images', 'tool_name', 'tool_calls')), FrozenPlan(fields=('role', 'content', 'thinki"
    "ng', 'images', 'tool_name', 'tool_calls'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('role"
    "', 'content', 'thinking', 'images', 'tool_name', 'tool_calls'), cache=False), InitPlan(fields=(InitPlan.Field(name"
    "='role', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='content"
    "', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory"
    "=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Ini"
    "tPlan.Field(name='thinking', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='images', annotation=OpRef(name='init.fields.3.annotation'), default=Op"
    "Ref(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='tool_name', annotation=OpRef(name='init.fields"
    ".4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tool_calls', annota"
    "tion=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param="
    "'self', std_params=(), kw_only_params=('role', 'content', 'thinking', 'images', 'tool_name', 'tool_calls'), frozen"
    "=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='ro"
    "le', kw_only=True, fn=None), ReprPlan.Field(name='content', kw_only=True, fn=None), ReprPlan.Field(name='thinking'"
    ", kw_only=True, fn=None), ReprPlan.Field(name='images', kw_only=True, fn=None), ReprPlan.Field(name='tool_name', k"
    "w_only=True, fn=None), ReprPlan.Field(name='tool_calls', kw_only=True, fn=None)), id=False, terse=False, default_f"
    "n=OpRef(name='repr.default_fn'))))"
)
def _process_dataclass__ommlds_2fbackends_2follama_2fprotocol_2fMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__repr__default_fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            role=self.role,
            content=self.content,
            thinking=self.thinking,
            images=self.images,
            tool_name=self.tool_name,
            tool_calls=self.tool_calls,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.role == other.role and
            self.content == other.content and
            self.thinking == other.thinking and
            self.images == other.images and
            self.tool_name == other.tool_name and
            self.tool_calls == other.tool_calls
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'role',
        'content',
        'thinking',
        'images',
        'tool_name',
        'tool_calls',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'role',
        'content',
        'thinking',
        'images',
        'tool_name',
        'tool_calls',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.role,
            self.content,
            self.thinking,
            self.images,
            self.tool_name,
            self.tool_calls,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        role: __dataclass__init__fields__0__annotation,
        content: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        thinking: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        images: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        tool_name: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        tool_calls: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'role', role)
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'thinking', thinking)
        __dataclass__object_setattr(self, 'images', images)
        __dataclass__object_setattr(self, 'tool_name', tool_name)
        __dataclass__object_setattr(self, 'tool_calls', tool_calls)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__default_fn(self.role)) is not None:
            parts.append(f"role={s}")
        if (s := __dataclass__repr__default_fn(self.content)) is not None:
            parts.append(f"content={s}")
        if (s := __dataclass__repr__default_fn(self.thinking)) is not None:
            parts.append(f"thinking={s}")
        if (s := __dataclass__repr__default_fn(self.images)) is not None:
            parts.append(f"images={s}")
        if (s := __dataclass__repr__default_fn(self.tool_name)) is not None:
            parts.append(f"tool_name={s}")
        if (s := __dataclass__repr__default_fn(self.tool_calls)) is not None:
            parts.append(f"tool_calls={s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'description', 'parameters')), EqPlan(fields=('name', 'description', 'paramete"
    "rs')), FrozenPlan(fields=('name', 'description', 'parameters'), allow_dynamic_dunder_attrs=False), HashPlan(action"
    "='add', fields=('name', 'description', 'parameters'), cache=False), InitPlan(fields=(InitPlan.Field(name='name', a"
    "nnotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
    "n.Field(name='description', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.d"
    "efault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
    "ne, check_type=None), InitPlan.Field(name='parameters', annotation=OpRef(name='init.fields.2.annotation'), default"
    "=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('name', 'desc"
    "ription', 'parameters'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan("
    "fields=(ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='description', kw_only=True, fn=No"
    "ne), ReprPlan.Field(name='parameters', kw_only=True, fn=None)), id=False, terse=False, default_fn=OpRef(name='repr"
    ".default_fn'))))"
)
def _process_dataclass__ommlds_2fbackends_2follama_2fprotocol_2fTool_2fFunction(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__repr__default_fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            description=self.description,
            parameters=self.parameters,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.description == other.description and
            self.parameters == other.parameters
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'name',
        'description',
        'parameters',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
        'description',
        'parameters',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.description,
            self.parameters,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        name: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        description: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        parameters: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'parameters', parameters)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__default_fn(self.name)) is not None:
            parts.append(f"name={s}")
        if (s := __dataclass__repr__default_fn(self.description)) is not None:
            parts.append(f"description={s}")
        if (s := __dataclass__repr__default_fn(self.parameters)) is not None:
            parts.append(f"parameters={s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('type', 'function')), EqPlan(fields=('type', 'function')), FrozenPlan(fields=('type', "
    "'function'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('type', 'function'), cache=False), "
    "InitPlan(fields=(InitPlan.Field(name='type', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name"
    "='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='function', annotation=OpRef(name='init.fields.1.annota"
    "tion'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=F"
    "ieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params"
    "=('type', 'function'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fi"
    "elds=(ReprPlan.Field(name='type', kw_only=True, fn=None), ReprPlan.Field(name='function', kw_only=True, fn=None)),"
    " id=False, terse=False, default_fn=OpRef(name='repr.default_fn'))))"
)
def _process_dataclass__ommlds_2fbackends_2follama_2fprotocol_2fTool(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__repr__default_fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            type=self.type,
            function=self.function,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.type == other.type and
            self.function == other.function
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'type',
        'function',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'type',
        'function',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.type,
            self.function,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        type: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        function: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'type', type)
        __dataclass__object_setattr(self, 'function', function)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__default_fn(self.type)) is not None:
            parts.append(f"type={s}")
        if (s := __dataclass__repr__default_fn(self.function)) is not None:
            parts.append(f"function={s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('model', 'stream', 'options', 'format', 'keep_alive', 'messages', 'tools', 'think')), "
    "EqPlan(fields=('model', 'stream', 'options', 'format', 'keep_alive', 'messages', 'tools', 'think')), FrozenPlan(fi"
    "elds=('model', 'stream', 'options', 'format', 'keep_alive', 'messages', 'tools', 'think'), allow_dynamic_dunder_at"
    "trs=False), HashPlan(action='add', fields=('model', 'stream', 'options', 'format', 'keep_alive', 'messages', 'tool"
    "s', 'think'), cache=False), InitPlan(fields=(InitPlan.Field(name='model', annotation=OpRef(name='init.fields.0.ann"
    "otation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
    "ne, validate=None, check_type=None), InitPlan.Field(name='stream', annotation=OpRef(name='init.fields.1.annotation"
    "'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=Field"
    "Type.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='options', annotation=OpRef(name="
    "'init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, overrid"
    "e=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='format'"
    ", annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='keep_alive', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4"
    ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None), InitPlan.Field(name='messages', annotation=OpRef(name='init.fields.5.annotation'), default"
    "=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tools', annotation=OpRef(name='init.fields."
    "6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='think', annotation=O"
    "pRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_factory=None, init=Tru"
    "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self'"
    ", std_params=(), kw_only_params=('model', 'stream', 'options', 'format', 'keep_alive', 'messages', 'tools', 'think"
    "'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Fiel"
    "d(name='model', kw_only=True, fn=None), ReprPlan.Field(name='stream', kw_only=True, fn=None), ReprPlan.Field(name="
    "'options', kw_only=True, fn=None), ReprPlan.Field(name='format', kw_only=True, fn=None), ReprPlan.Field(name='keep"
    "_alive', kw_only=True, fn=None), ReprPlan.Field(name='messages', kw_only=True, fn=None), ReprPlan.Field(name='tool"
    "s', kw_only=True, fn=None), ReprPlan.Field(name='think', kw_only=True, fn=None)), id=False, terse=False, default_f"
    "n=OpRef(name='repr.default_fn'))))"
)
def _process_dataclass__ommlds_2fbackends_2follama_2fprotocol_2fChatRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__repr__default_fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            model=self.model,
            stream=self.stream,
            options=self.options,
            format=self.format,
            keep_alive=self.keep_alive,
            messages=self.messages,
            tools=self.tools,
            think=self.think,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.model == other.model and
            self.stream == other.stream and
            self.options == other.options and
            self.format == other.format and
            self.keep_alive == other.keep_alive and
            self.messages == other.messages and
            self.tools == other.tools and
            self.think == other.think
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'model',
        'stream',
        'options',
        'format',
        'keep_alive',
        'messages',
        'tools',
        'think',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'model',
        'stream',
        'options',
        'format',
        'keep_alive',
        'messages',
        'tools',
        'think',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.model,
            self.stream,
            self.options,
            self.format,
            self.keep_alive,
            self.messages,
            self.tools,
            self.think,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        model: __dataclass__init__fields__0__annotation,
        stream: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        options: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        format: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        keep_alive: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        messages: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        tools: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        think: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'model', model)
        __dataclass__object_setattr(self, 'stream', stream)
        __dataclass__object_setattr(self, 'options', options)
        __dataclass__object_setattr(self, 'format', format)
        __dataclass__object_setattr(self, 'keep_alive', keep_alive)
        __dataclass__object_setattr(self, 'messages', messages)
        __dataclass__object_setattr(self, 'tools', tools)
        __dataclass__object_setattr(self, 'think', think)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__default_fn(self.model)) is not None:
            parts.append(f"model={s}")
        if (s := __dataclass__repr__default_fn(self.stream)) is not None:
            parts.append(f"stream={s}")
        if (s := __dataclass__repr__default_fn(self.options)) is not None:
            parts.append(f"options={s}")
        if (s := __dataclass__repr__default_fn(self.format)) is not None:
            parts.append(f"format={s}")
        if (s := __dataclass__repr__default_fn(self.keep_alive)) is not None:
            parts.append(f"keep_alive={s}")
        if (s := __dataclass__repr__default_fn(self.messages)) is not None:
            parts.append(f"messages={s}")
        if (s := __dataclass__repr__default_fn(self.tools)) is not None:
            parts.append(f"tools={s}")
        if (s := __dataclass__repr__default_fn(self.think)) is not None:
            parts.append(f"think={s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('model', 'created_at', 'done', 'done_reason', 'total_duration', 'load_duration', 'prom"
    "pt_eval_count', 'prompt_eval_duration', 'eval_count', 'eval_duration', 'message')), EqPlan(fields=('model', 'creat"
    "ed_at', 'done', 'done_reason', 'total_duration', 'load_duration', 'prompt_eval_count', 'prompt_eval_duration', 'ev"
    "al_count', 'eval_duration', 'message')), FrozenPlan(fields=('model', 'created_at', 'done', 'done_reason', 'total_d"
    "uration', 'load_duration', 'prompt_eval_count', 'prompt_eval_duration', 'eval_count', 'eval_duration', 'message'),"
    " allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('model', 'created_at', 'done', 'done_reason', '"
    "total_duration', 'load_duration', 'prompt_eval_count', 'prompt_eval_duration', 'eval_count', 'eval_duration', 'mes"
    "sage'), cache=False), InitPlan(fields=(InitPlan.Field(name='model', annotation=OpRef(name='init.fields.0.annotatio"
    "n'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='created_at', annotation=OpRef(n"
    "ame='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='don"
    "e', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factor"
    "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), In"
    "itPlan.Field(name='done_reason', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.field"
    "s.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='total_duration', annotation=OpRef(name='init.fields.4.annotation')"
    ", default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
    "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='load_duration', annotation=OpRef(n"
    "ame='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='pro"
    "mpt_eval_count', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None), InitPlan.Field(name='prompt_eval_duration', annotation=OpRef(name='init.fields.7.annotation'), default="
    "OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
    "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='eval_count', annotation=OpRef(name='init.fie"
    "lds.8.annotation'), default=OpRef(name='init.fields.8.default'), default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='eval_duration', "
    "annotation=OpRef(name='init.fields.9.annotation'), default=OpRef(name='init.fields.9.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='message', annotation=OpRef(name='init.fields.10.annotation'), default=None, default_factory=None, i"
    "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param"
    "='self', std_params=(), kw_only_params=('model', 'created_at', 'done', 'done_reason', 'total_duration', 'load_dura"
    "tion', 'prompt_eval_count', 'prompt_eval_duration', 'eval_count', 'eval_duration', 'message'), frozen=True, slots="
    "False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='model', kw_only"
    "=True, fn=None), ReprPlan.Field(name='created_at', kw_only=True, fn=None), ReprPlan.Field(name='done', kw_only=Tru"
    "e, fn=None), ReprPlan.Field(name='done_reason', kw_only=True, fn=None), ReprPlan.Field(name='total_duration', kw_o"
    "nly=True, fn=None), ReprPlan.Field(name='load_duration', kw_only=True, fn=None), ReprPlan.Field(name='prompt_eval_"
    "count', kw_only=True, fn=None), ReprPlan.Field(name='prompt_eval_duration', kw_only=True, fn=None), ReprPlan.Field"
    "(name='eval_count', kw_only=True, fn=None), ReprPlan.Field(name='eval_duration', kw_only=True, fn=None), ReprPlan."
    "Field(name='message', kw_only=True, fn=None)), id=False, terse=False, default_fn=OpRef(name='repr.default_fn'))))"
)
def _process_dataclass__ommlds_2fbackends_2follama_2fprotocol_2fChatResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__repr__default_fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            model=self.model,
            created_at=self.created_at,
            done=self.done,
            done_reason=self.done_reason,
            total_duration=self.total_duration,
            load_duration=self.load_duration,
            prompt_eval_count=self.prompt_eval_count,
            prompt_eval_duration=self.prompt_eval_duration,
            eval_count=self.eval_count,
            eval_duration=self.eval_duration,
            message=self.message,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.model == other.model and
            self.created_at == other.created_at and
            self.done == other.done and
            self.done_reason == other.done_reason and
            self.total_duration == other.total_duration and
            self.load_duration == other.load_duration and
            self.prompt_eval_count == other.prompt_eval_count and
            self.prompt_eval_duration == other.prompt_eval_duration and
            self.eval_count == other.eval_count and
            self.eval_duration == other.eval_duration and
            self.message == other.message
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'model',
        'created_at',
        'done',
        'done_reason',
        'total_duration',
        'load_duration',
        'prompt_eval_count',
        'prompt_eval_duration',
        'eval_count',
        'eval_duration',
        'message',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'model',
        'created_at',
        'done',
        'done_reason',
        'total_duration',
        'load_duration',
        'prompt_eval_count',
        'prompt_eval_duration',
        'eval_count',
        'eval_duration',
        'message',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.model,
            self.created_at,
            self.done,
            self.done_reason,
            self.total_duration,
            self.load_duration,
            self.prompt_eval_count,
            self.prompt_eval_duration,
            self.eval_count,
            self.eval_duration,
            self.message,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        model: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        created_at: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        done: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        done_reason: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        total_duration: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        load_duration: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        prompt_eval_count: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        prompt_eval_duration: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        eval_count: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        eval_duration: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        message: __dataclass__init__fields__10__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'model', model)
        __dataclass__object_setattr(self, 'created_at', created_at)
        __dataclass__object_setattr(self, 'done', done)
        __dataclass__object_setattr(self, 'done_reason', done_reason)
        __dataclass__object_setattr(self, 'total_duration', total_duration)
        __dataclass__object_setattr(self, 'load_duration', load_duration)
        __dataclass__object_setattr(self, 'prompt_eval_count', prompt_eval_count)
        __dataclass__object_setattr(self, 'prompt_eval_duration', prompt_eval_duration)
        __dataclass__object_setattr(self, 'eval_count', eval_count)
        __dataclass__object_setattr(self, 'eval_duration', eval_duration)
        __dataclass__object_setattr(self, 'message', message)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__default_fn(self.model)) is not None:
            parts.append(f"model={s}")
        if (s := __dataclass__repr__default_fn(self.created_at)) is not None:
            parts.append(f"created_at={s}")
        if (s := __dataclass__repr__default_fn(self.done)) is not None:
            parts.append(f"done={s}")
        if (s := __dataclass__repr__default_fn(self.done_reason)) is not None:
            parts.append(f"done_reason={s}")
        if (s := __dataclass__repr__default_fn(self.total_duration)) is not None:
            parts.append(f"total_duration={s}")
        if (s := __dataclass__repr__default_fn(self.load_duration)) is not None:
            parts.append(f"load_duration={s}")
        if (s := __dataclass__repr__default_fn(self.prompt_eval_count)) is not None:
            parts.append(f"prompt_eval_count={s}")
        if (s := __dataclass__repr__default_fn(self.prompt_eval_duration)) is not None:
            parts.append(f"prompt_eval_duration={s}")
        if (s := __dataclass__repr__default_fn(self.eval_count)) is not None:
            parts.append(f"eval_count={s}")
        if (s := __dataclass__repr__default_fn(self.eval_duration)) is not None:
            parts.append(f"eval_duration={s}")
        if (s := __dataclass__repr__default_fn(self.message)) is not None:
            parts.append(f"message={s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('accepted_prediction_tokens', 'audio_tokens', 'reasoning_tokens', 'rejected_prediction"
    "_tokens')), EqPlan(fields=('accepted_prediction_tokens', 'audio_tokens', 'reasoning_tokens', 'rejected_prediction_"
    "tokens')), FrozenPlan(fields=('accepted_prediction_tokens', 'audio_tokens', 'reasoning_tokens', 'rejected_predicti"
    "on_tokens'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('accepted_prediction_tokens', 'audi"
    "o_tokens', 'reasoning_tokens', 'rejected_prediction_tokens'), cache=False), InitPlan(fields=(InitPlan.Field(name='"
    "accepted_prediction_tokens', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='audio_tokens', annotation=OpRef(name='init.fields.1.annotation'), defa"
    "ult=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
    "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='reasoning_tokens', annotation=OpRef(name"
    "='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, overri"
    "de=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='reject"
    "ed_prediction_tokens', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.defaul"
    "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None)), self_param='self', std_params=(), kw_only_params=('accepted_prediction_tokens', 'audio_tokens', "
    "'reasoning_tokens', 'rejected_prediction_tokens'), frozen=True, slots=False, post_init_params=None, init_fns=(), v"
    "alidate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='accepted_prediction_tokens', kw_only=True, fn=None), ReprPl"
    "an.Field(name='audio_tokens', kw_only=True, fn=None), ReprPlan.Field(name='reasoning_tokens', kw_only=True, fn=Non"
    "e), ReprPlan.Field(name='rejected_prediction_tokens', kw_only=True, fn=None)), id=False, terse=False, default_fn=N"
    "one)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fcompletionusage_2fCompletionUsage_2fCompletionTokensDetails(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            accepted_prediction_tokens=self.accepted_prediction_tokens,
            audio_tokens=self.audio_tokens,
            reasoning_tokens=self.reasoning_tokens,
            rejected_prediction_tokens=self.rejected_prediction_tokens,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.accepted_prediction_tokens == other.accepted_prediction_tokens and
            self.audio_tokens == other.audio_tokens and
            self.reasoning_tokens == other.reasoning_tokens and
            self.rejected_prediction_tokens == other.rejected_prediction_tokens
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'accepted_prediction_tokens',
        'audio_tokens',
        'reasoning_tokens',
        'rejected_prediction_tokens',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'accepted_prediction_tokens',
        'audio_tokens',
        'reasoning_tokens',
        'rejected_prediction_tokens',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.accepted_prediction_tokens,
            self.audio_tokens,
            self.reasoning_tokens,
            self.rejected_prediction_tokens,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        accepted_prediction_tokens: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        audio_tokens: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        reasoning_tokens: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        rejected_prediction_tokens: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'accepted_prediction_tokens', accepted_prediction_tokens)
        __dataclass__object_setattr(self, 'audio_tokens', audio_tokens)
        __dataclass__object_setattr(self, 'reasoning_tokens', reasoning_tokens)
        __dataclass__object_setattr(self, 'rejected_prediction_tokens', rejected_prediction_tokens)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"accepted_prediction_tokens={self.accepted_prediction_tokens!r}")
        parts.append(f"audio_tokens={self.audio_tokens!r}")
        parts.append(f"reasoning_tokens={self.reasoning_tokens!r}")
        parts.append(f"rejected_prediction_tokens={self.rejected_prediction_tokens!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('audio_tokens', 'cached_tokens')), EqPlan(fields=('audio_tokens', 'cached_tokens')), F"
    "rozenPlan(fields=('audio_tokens', 'cached_tokens'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fiel"
    "ds=('audio_tokens', 'cached_tokens'), cache=False), InitPlan(fields=(InitPlan.Field(name='audio_tokens', annotatio"
    "n=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='cached_tokens', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default"
    "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None)), self_param='self', std_params=(), kw_only_params=('audio_tokens', 'cached_tokens'), frozen=True, "
    "slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='audio_tok"
    "ens', kw_only=True, fn=None), ReprPlan.Field(name='cached_tokens', kw_only=True, fn=None)), id=False, terse=False,"
    " default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fcompletionusage_2fCompletionUsage_2fPromptTokensDetails(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            audio_tokens=self.audio_tokens,
            cached_tokens=self.cached_tokens,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.audio_tokens == other.audio_tokens and
            self.cached_tokens == other.cached_tokens
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'audio_tokens',
        'cached_tokens',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'audio_tokens',
        'cached_tokens',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.audio_tokens,
            self.cached_tokens,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        audio_tokens: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        cached_tokens: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'audio_tokens', audio_tokens)
        __dataclass__object_setattr(self, 'cached_tokens', cached_tokens)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"audio_tokens={self.audio_tokens!r}")
        parts.append(f"cached_tokens={self.cached_tokens!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('completion_tokens', 'prompt_tokens', 'total_tokens', 'completion_tokens_details', 'pr"
    "ompt_tokens_details')), EqPlan(fields=('completion_tokens', 'prompt_tokens', 'total_tokens', 'completion_tokens_de"
    "tails', 'prompt_tokens_details')), FrozenPlan(fields=('completion_tokens', 'prompt_tokens', 'total_tokens', 'compl"
    "etion_tokens_details', 'prompt_tokens_details'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields="
    "('completion_tokens', 'prompt_tokens', 'total_tokens', 'completion_tokens_details', 'prompt_tokens_details'), cach"
    "e=False), InitPlan(fields=(InitPlan.Field(name='completion_tokens', annotation=OpRef(name='init.fields.0.annotatio"
    "n'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='prompt_tokens', annotation=OpRef(name='init.fields.1.annotatio"
    "n'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='total_tokens', annotation=OpRef(name='init.fields.2.annotation"
    "'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='completion_tokens_details', annotation=OpRef(name='init.fields."
    "3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='prompt_tokens_detail"
    "s', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factor"
    "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), s"
    "elf_param='self', std_params=(), kw_only_params=('completion_tokens', 'prompt_tokens', 'total_tokens', 'completion"
    "_tokens_details', 'prompt_tokens_details'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate"
    "_fns=()), ReprPlan(fields=(ReprPlan.Field(name='completion_tokens', kw_only=True, fn=None), ReprPlan.Field(name='p"
    "rompt_tokens', kw_only=True, fn=None), ReprPlan.Field(name='total_tokens', kw_only=True, fn=None), ReprPlan.Field("
    "name='completion_tokens_details', kw_only=True, fn=None), ReprPlan.Field(name='prompt_tokens_details', kw_only=Tru"
    "e, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fcompletionusage_2fCompletionUsage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            completion_tokens=self.completion_tokens,
            prompt_tokens=self.prompt_tokens,
            total_tokens=self.total_tokens,
            completion_tokens_details=self.completion_tokens_details,
            prompt_tokens_details=self.prompt_tokens_details,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.completion_tokens == other.completion_tokens and
            self.prompt_tokens == other.prompt_tokens and
            self.total_tokens == other.total_tokens and
            self.completion_tokens_details == other.completion_tokens_details and
            self.prompt_tokens_details == other.prompt_tokens_details
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'completion_tokens',
        'prompt_tokens',
        'total_tokens',
        'completion_tokens_details',
        'prompt_tokens_details',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'completion_tokens',
        'prompt_tokens',
        'total_tokens',
        'completion_tokens_details',
        'prompt_tokens_details',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.completion_tokens,
            self.prompt_tokens,
            self.total_tokens,
            self.completion_tokens_details,
            self.prompt_tokens_details,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        completion_tokens: __dataclass__init__fields__0__annotation,
        prompt_tokens: __dataclass__init__fields__1__annotation,
        total_tokens: __dataclass__init__fields__2__annotation,
        completion_tokens_details: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        prompt_tokens_details: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'completion_tokens', completion_tokens)
        __dataclass__object_setattr(self, 'prompt_tokens', prompt_tokens)
        __dataclass__object_setattr(self, 'total_tokens', total_tokens)
        __dataclass__object_setattr(self, 'completion_tokens_details', completion_tokens_details)
        __dataclass__object_setattr(self, 'prompt_tokens_details', prompt_tokens_details)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"completion_tokens={self.completion_tokens!r}")
        parts.append(f"prompt_tokens={self.prompt_tokens!r}")
        parts.append(f"total_tokens={self.total_tokens!r}")
        parts.append(f"completion_tokens_details={self.completion_tokens_details!r}")
        parts.append(f"prompt_tokens_details={self.prompt_tokens_details!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('token', 'bytes', 'logprob')), EqPlan(fields=('token', 'bytes', 'logprob')), FrozenPla"
    "n(fields=('token', 'bytes', 'logprob'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('token',"
    " 'bytes', 'logprob'), cache=False), InitPlan(fields=(InitPlan.Field(name='token', annotation=OpRef(name='init.fiel"
    "ds.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None), InitPlan.Field(name='bytes', annotation=OpRef(name='init.fields.1.ann"
    "otation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='logprob', annotation=OpRe"
    "f(name='init.fields.2.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('"
    "token', 'bytes', 'logprob'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
    "lan(fields=(ReprPlan.Field(name='token', kw_only=True, fn=None), ReprPlan.Field(name='bytes', kw_only=True, fn=Non"
    "e), ReprPlan.Field(name='logprob', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2ftokenlogprob_2fChatCompletionTokenLogprob_2fTopLogprob(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            token=self.token,
            bytes=self.bytes,
            logprob=self.logprob,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.token == other.token and
            self.bytes == other.bytes and
            self.logprob == other.logprob
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'token',
        'bytes',
        'logprob',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'token',
        'bytes',
        'logprob',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.token,
            self.bytes,
            self.logprob,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        token: __dataclass__init__fields__0__annotation,
        bytes: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        logprob: __dataclass__init__fields__2__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'token', token)
        __dataclass__object_setattr(self, 'bytes', bytes)
        __dataclass__object_setattr(self, 'logprob', logprob)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"token={self.token!r}")
        parts.append(f"bytes={self.bytes!r}")
        parts.append(f"logprob={self.logprob!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('token', 'bytes', 'logprob', 'top_logprobs')), EqPlan(fields=('token', 'bytes', 'logpr"
    "ob', 'top_logprobs')), FrozenPlan(fields=('token', 'bytes', 'logprob', 'top_logprobs'), allow_dynamic_dunder_attrs"
    "=False), HashPlan(action='add', fields=('token', 'bytes', 'logprob', 'top_logprobs'), cache=False), InitPlan(field"
    "s=(InitPlan.Field(name='token', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=N"
    "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
    "lan.Field(name='bytes', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defau"
    "lt'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, "
    "check_type=None), InitPlan.Field(name='logprob', annotation=OpRef(name='init.fields.2.annotation'), default=None, "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None), InitPlan.Field(name='top_logprobs', annotation=OpRef(name='init.fields.3.annotation'), default=None, d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None)), self_param='self', std_params=(), kw_only_params=('token', 'bytes', 'logprob', 'top_logprobs'), frozen"
    "=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='to"
    "ken', kw_only=True, fn=None), ReprPlan.Field(name='bytes', kw_only=True, fn=None), ReprPlan.Field(name='logprob', "
    "kw_only=True, fn=None), ReprPlan.Field(name='top_logprobs', kw_only=True, fn=None)), id=False, terse=False, defaul"
    "t_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2ftokenlogprob_2fChatCompletionTokenLogprob(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__3__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            token=self.token,
            bytes=self.bytes,
            logprob=self.logprob,
            top_logprobs=self.top_logprobs,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.token == other.token and
            self.bytes == other.bytes and
            self.logprob == other.logprob and
            self.top_logprobs == other.top_logprobs
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'token',
        'bytes',
        'logprob',
        'top_logprobs',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'token',
        'bytes',
        'logprob',
        'top_logprobs',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.token,
            self.bytes,
            self.logprob,
            self.top_logprobs,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        token: __dataclass__init__fields__0__annotation,
        bytes: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        logprob: __dataclass__init__fields__2__annotation,
        top_logprobs: __dataclass__init__fields__3__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'token', token)
        __dataclass__object_setattr(self, 'bytes', bytes)
        __dataclass__object_setattr(self, 'logprob', logprob)
        __dataclass__object_setattr(self, 'top_logprobs', top_logprobs)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"token={self.token!r}")
        parts.append(f"bytes={self.bytes!r}")
        parts.append(f"logprob={self.logprob!r}")
        parts.append(f"top_logprobs={self.top_logprobs!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('arguments', 'name')), EqPlan(fields=('arguments', 'name')), FrozenPlan(fields=('argum"
    "ents', 'name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('arguments', 'name'), cache=Fals"
    "e), InitPlan(fields=(InitPlan.Field(name='arguments', annotation=OpRef(name='init.fields.0.annotation'), default=O"
    "pRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
    ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.a"
    "nnotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_t"
    "ype=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_p"
    "arams=('arguments', 'name'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
    "lan(fields=(ReprPlan.Field(name='arguments', kw_only=True, fn=None), ReprPlan.Field(name='name', kw_only=True, fn="
    "None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fchunk_2fChatCompletionChunkChoiceDelta_2fToolCall_2fFunction(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            arguments=self.arguments,
            name=self.name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.arguments == other.arguments and
            self.name == other.name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'arguments',
        'name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'arguments',
        'name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.arguments,
            self.name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        arguments: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'arguments', arguments)
        __dataclass__object_setattr(self, 'name', name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"arguments={self.arguments!r}")
        parts.append(f"name={self.name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('index', 'id', 'function', 'type')), EqPlan(fields=('index', 'id', 'function', 'type')"
    "), FrozenPlan(fields=('index', 'id', 'function', 'type'), allow_dynamic_dunder_attrs=False), HashPlan(action='add'"
    ", fields=('index', 'id', 'function', 'type'), cache=False), InitPlan(fields=(InitPlan.Field(name='index', annotati"
    "on=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_ty"
    "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='id', annotation=OpRef(na"
    "me='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='func"
    "tion', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_fac"
    "tory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),"
    " InitPlan.Field(name='type', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3."
    "default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None)), self_param='self', std_params=(), kw_only_params=('index', 'id', 'function', 'type'), froz"
    "en=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='"
    "index', kw_only=True, fn=None), ReprPlan.Field(name='id', kw_only=True, fn=None), ReprPlan.Field(name='function', "
    "kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fchunk_2fChatCompletionChunkChoiceDelta_2fToolCall(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            index=self.index,
            id=self.id,
            function=self.function,
            type=self.type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.index == other.index and
            self.id == other.id and
            self.function == other.function and
            self.type == other.type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'index',
        'id',
        'function',
        'type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'index',
        'id',
        'function',
        'type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.index,
            self.id,
            self.function,
            self.type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        index: __dataclass__init__fields__0__annotation,
        id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        function: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        type: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'index', index)
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'function', function)
        __dataclass__object_setattr(self, 'type', type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"index={self.index!r}")
        parts.append(f"id={self.id!r}")
        parts.append(f"function={self.function!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('content', 'refusal', 'role', 'tool_calls')), EqPlan(fields=('content', 'refusal', 'ro"
    "le', 'tool_calls')), FrozenPlan(fields=('content', 'refusal', 'role', 'tool_calls'), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('content', 'refusal', 'role', 'tool_calls'), cache=False), InitPlan(fields=(I"
    "nitPlan.Field(name='content', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0"
    ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None), InitPlan.Field(name='refusal', annotation=OpRef(name='init.fields.1.annotation'), default="
    "OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
    "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='role', annotation=OpRef(name='init.fields.2."
    "annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tool_calls', annotatio"
    "n=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='se"
    "lf', std_params=(), kw_only_params=('content', 'refusal', 'role', 'tool_calls'), frozen=True, slots=False, post_in"
    "it_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='content', kw_only=True, fn=No"
    "ne), ReprPlan.Field(name='refusal', kw_only=True, fn=None), ReprPlan.Field(name='role', kw_only=True, fn=None), Re"
    "prPlan.Field(name='tool_calls', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fchunk_2fChatCompletionChunkChoiceDelta(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            content=self.content,
            refusal=self.refusal,
            role=self.role,
            tool_calls=self.tool_calls,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.content == other.content and
            self.refusal == other.refusal and
            self.role == other.role and
            self.tool_calls == other.tool_calls
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'content',
        'refusal',
        'role',
        'tool_calls',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'content',
        'refusal',
        'role',
        'tool_calls',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.content,
            self.refusal,
            self.role,
            self.tool_calls,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        content: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        refusal: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        role: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        tool_calls: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'refusal', refusal)
        __dataclass__object_setattr(self, 'role', role)
        __dataclass__object_setattr(self, 'tool_calls', tool_calls)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"content={self.content!r}")
        parts.append(f"refusal={self.refusal!r}")
        parts.append(f"role={self.role!r}")
        parts.append(f"tool_calls={self.tool_calls!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('content', 'refusal')), EqPlan(fields=('content', 'refusal')), FrozenPlan(fields=('con"
    "tent', 'refusal'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('content', 'refusal'), cache="
    "False), InitPlan(fields=(InitPlan.Field(name='content', annotation=OpRef(name='init.fields.0.annotation'), default"
    "=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='refusal', annotation=OpRef(name='init.field"
    "s.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_o"
    "nly_params=('content', 'refusal'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
    " ReprPlan(fields=(ReprPlan.Field(name='content', kw_only=True, fn=None), ReprPlan.Field(name='refusal', kw_only=Tr"
    "ue, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fchunk_2fChatCompletionChunkChoice_2fLogprobs(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            content=self.content,
            refusal=self.refusal,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.content == other.content and
            self.refusal == other.refusal
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'content',
        'refusal',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'content',
        'refusal',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.content,
            self.refusal,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        content: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        refusal: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'refusal', refusal)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"content={self.content!r}")
        parts.append(f"refusal={self.refusal!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('delta', 'finish_reason', 'index', 'logprobs')), EqPlan(fields=('delta', 'finish_reaso"
    "n', 'index', 'logprobs')), FrozenPlan(fields=('delta', 'finish_reason', 'index', 'logprobs'), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('delta', 'finish_reason', 'index', 'logprobs'), cache=False), InitPl"
    "an(fields=(InitPlan.Field(name='delta', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='finish_reason', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='ini"
    "t.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None), InitPlan.Field(name='index', annotation=OpRef(name='init.fields.2.annotation'), "
    "default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None), InitPlan.Field(name='logprobs', annotation=OpRef(name='init.fields.3.annotation'), defau"
    "lt=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INST"
    "ANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('delta', 'f"
    "inish_reason', 'index', 'logprobs'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()"
    "), ReprPlan(fields=(ReprPlan.Field(name='delta', kw_only=True, fn=None), ReprPlan.Field(name='finish_reason', kw_o"
    "nly=True, fn=None), ReprPlan.Field(name='index', kw_only=True, fn=None), ReprPlan.Field(name='logprobs', kw_only=T"
    "rue, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fchunk_2fChatCompletionChunkChoice(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            delta=self.delta,
            finish_reason=self.finish_reason,
            index=self.index,
            logprobs=self.logprobs,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.delta == other.delta and
            self.finish_reason == other.finish_reason and
            self.index == other.index and
            self.logprobs == other.logprobs
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'delta',
        'finish_reason',
        'index',
        'logprobs',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'delta',
        'finish_reason',
        'index',
        'logprobs',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.delta,
            self.finish_reason,
            self.index,
            self.logprobs,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        delta: __dataclass__init__fields__0__annotation,
        finish_reason: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        index: __dataclass__init__fields__2__annotation,
        logprobs: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'delta', delta)
        __dataclass__object_setattr(self, 'finish_reason', finish_reason)
        __dataclass__object_setattr(self, 'index', index)
        __dataclass__object_setattr(self, 'logprobs', logprobs)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"delta={self.delta!r}")
        parts.append(f"finish_reason={self.finish_reason!r}")
        parts.append(f"index={self.index!r}")
        parts.append(f"logprobs={self.logprobs!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('id', 'choices', 'created', 'model', 'object', 'service_tier', 'system_fingerprint', '"
    "usage', 'obfuscation')), EqPlan(fields=('id', 'choices', 'created', 'model', 'object', 'service_tier', 'system_fin"
    "gerprint', 'usage', 'obfuscation')), FrozenPlan(fields=('id', 'choices', 'created', 'model', 'object', 'service_ti"
    "er', 'system_fingerprint', 'usage', 'obfuscation'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fiel"
    "ds=('id', 'choices', 'created', 'model', 'object', 'service_tier', 'system_fingerprint', 'usage', 'obfuscation'), "
    "cache=False), InitPlan(fields=(InitPlan.Field(name='id', annotation=OpRef(name='init.fields.0.annotation'), defaul"
    "t=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
    ", check_type=None), InitPlan.Field(name='choices', annotation=OpRef(name='init.fields.1.annotation'), default=None"
    ", default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, chec"
    "k_type=None), InitPlan.Field(name='created', annotation=OpRef(name='init.fields.2.annotation'), default=None, defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='model', annotation=OpRef(name='init.fields.3.annotation'), default=None, default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
    "InitPlan.Field(name='object', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4"
    ".default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate="
    "None, check_type=None), InitPlan.Field(name='service_tier', annotation=OpRef(name='init.fields.5.annotation'), def"
    "ault=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='system_fingerprint', annotation=OpRef(n"
    "ame='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, init=True, ove"
    "rride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='usa"
    "ge', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.default'), default_facto"
    "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
    "nitPlan.Field(name='obfuscation', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef(name='init.fiel"
    "ds.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('id', 'choices', 'created', 'model'"
    ", 'object', 'service_tier', 'system_fingerprint', 'usage', 'obfuscation'), frozen=True, slots=False, post_init_par"
    "ams=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='id', kw_only=True, fn=None), ReprPl"
    "an.Field(name='choices', kw_only=True, fn=None), ReprPlan.Field(name='created', kw_only=True, fn=None), ReprPlan.F"
    "ield(name='model', kw_only=True, fn=None), ReprPlan.Field(name='service_tier', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='system_fingerprint', kw_only=True, fn=None), ReprPlan.Field(name='usage', kw_only=True, fn=None), ReprPl"
    "an.Field(name='obfuscation', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fchunk_2fChatCompletionChunk(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            id=self.id,
            choices=self.choices,
            created=self.created,
            model=self.model,
            object=self.object,
            service_tier=self.service_tier,
            system_fingerprint=self.system_fingerprint,
            usage=self.usage,
            obfuscation=self.obfuscation,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.id == other.id and
            self.choices == other.choices and
            self.created == other.created and
            self.model == other.model and
            self.object == other.object and
            self.service_tier == other.service_tier and
            self.system_fingerprint == other.system_fingerprint and
            self.usage == other.usage and
            self.obfuscation == other.obfuscation
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'id',
        'choices',
        'created',
        'model',
        'object',
        'service_tier',
        'system_fingerprint',
        'usage',
        'obfuscation',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'id',
        'choices',
        'created',
        'model',
        'object',
        'service_tier',
        'system_fingerprint',
        'usage',
        'obfuscation',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.id,
            self.choices,
            self.created,
            self.model,
            self.object,
            self.service_tier,
            self.system_fingerprint,
            self.usage,
            self.obfuscation,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        id: __dataclass__init__fields__0__annotation,
        choices: __dataclass__init__fields__1__annotation,
        created: __dataclass__init__fields__2__annotation,
        model: __dataclass__init__fields__3__annotation,
        object: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        service_tier: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        system_fingerprint: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        usage: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        obfuscation: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'choices', choices)
        __dataclass__object_setattr(self, 'created', created)
        __dataclass__object_setattr(self, 'model', model)
        __dataclass__object_setattr(self, 'object', object)
        __dataclass__object_setattr(self, 'service_tier', service_tier)
        __dataclass__object_setattr(self, 'system_fingerprint', system_fingerprint)
        __dataclass__object_setattr(self, 'usage', usage)
        __dataclass__object_setattr(self, 'obfuscation', obfuscation)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"id={self.id!r}")
        parts.append(f"choices={self.choices!r}")
        parts.append(f"created={self.created!r}")
        parts.append(f"model={self.model!r}")
        parts.append(f"service_tier={self.service_tier!r}")
        parts.append(f"system_fingerprint={self.system_fingerprint!r}")
        parts.append(f"usage={self.usage!r}")
        parts.append(f"obfuscation={self.obfuscation!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('text',)), EqPlan(fields=('text',)), FrozenPlan(fields=('text',), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('text',), cache=False), InitPlan(fields=(InitPlan.Field(name='text',"
    " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('te"
    "xt',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan"
    "(fields=(ReprPlan.Field(name='text', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fcontentpart_2fTextChatCompletionContentPart(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            text=self.text,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.text == other.text
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'text',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'text',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.text,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        text: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'text', text)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"text={self.text!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('url', 'detail')), EqPlan(fields=('url', 'detail')), FrozenPlan(fields=('url', 'detail"
    "'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('url', 'detail'), cache=False), InitPlan(fie"
    "lds=(InitPlan.Field(name='url', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=N"
    "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
    "lan.Field(name='detail', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param="
    "'self', std_params=('url', 'detail'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns"
    "=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='url', kw_only=False, fn=None), ReprPlan.Field(name='d"
    "etail', kw_only=False, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fcontentpart_2fImageUrlChatCompletionContentPart_2fImageUrl(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            url=self.url,
            detail=self.detail,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.url == other.url and
            self.detail == other.detail
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'url',
        'detail',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'url',
        'detail',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.url,
            self.detail,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        url: __dataclass__init__fields__0__annotation,
        detail: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'url', url)
        __dataclass__object_setattr(self, 'detail', detail)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"url={self.url!r}")
        parts.append(f"detail={self.detail!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('image_url',)), EqPlan(fields=('image_url',)), FrozenPlan(fields=('image_url',), allow"
    "_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('image_url',), cache=False), InitPlan(fields=(InitPla"
    "n.Field(name='image_url', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, i"
    "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_para"
    "m='self', std_params=('image_url',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns="
    "(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='image_url', kw_only=False, fn=None),), id=False, terse"
    "=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fcontentpart_2fImageUrlChatCompletionContentPart(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            image_url=self.image_url,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.image_url == other.image_url
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'image_url',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'image_url',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.image_url,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        image_url: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'image_url', image_url)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"image_url={self.image_url!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('file_data', 'file_id', 'filename')), EqPlan(fields=('file_data', 'file_id', 'filename"
    "')), FrozenPlan(fields=('file_data', 'file_id', 'filename'), allow_dynamic_dunder_attrs=False), HashPlan(action='a"
    "dd', fields=('file_data', 'file_id', 'filename'), cache=False), InitPlan(fields=(InitPlan.Field(name='file_data', "
    "annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='file_id', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='filename', annotation=OpRef(name='init.fields.2.annotation'), default=OpRe"
    "f(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, c"
    "oerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('file_data', 'file"
    "_id', 'filename'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields"
    "=(ReprPlan.Field(name='file_data', kw_only=True, fn=None), ReprPlan.Field(name='file_id', kw_only=True, fn=None), "
    "ReprPlan.Field(name='filename', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fcontentpart_2fFileChatCompletionContentPart_2fFile(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            file_data=self.file_data,
            file_id=self.file_id,
            filename=self.filename,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.file_data == other.file_data and
            self.file_id == other.file_id and
            self.filename == other.filename
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'file_data',
        'file_id',
        'filename',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'file_data',
        'file_id',
        'filename',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.file_data,
            self.file_id,
            self.filename,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        file_data: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        file_id: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        filename: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'file_data', file_data)
        __dataclass__object_setattr(self, 'file_id', file_id)
        __dataclass__object_setattr(self, 'filename', filename)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"file_data={self.file_data!r}")
        parts.append(f"file_id={self.file_id!r}")
        parts.append(f"filename={self.filename!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('file',)), EqPlan(fields=('file',)), FrozenPlan(fields=('file',), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('file',), cache=False), InitPlan(fields=(InitPlan.Field(name='file',"
    " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('fi"
    "le',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan"
    "(fields=(ReprPlan.Field(name='file', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fcontentpart_2fFileChatCompletionContentPart(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            file=self.file,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.file == other.file
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'file',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'file',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.file,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        file: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'file', file)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"file={self.file!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('data', 'format')), EqPlan(fields=('data', 'format')), FrozenPlan(fields=('data', 'for"
    "mat'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('data', 'format'), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='data', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), "
    "InitPlan.Field(name='format', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_p"
    "aram='self', std_params=('data', 'format'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, in"
    "it_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='data', kw_only=False, fn=None), ReprPlan.Field("
    "name='format', kw_only=False, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fcontentpart_2fInputAudioChatCompletionContentPart_2fInputAudio(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            data=self.data,
            format=self.format,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.data == other.data and
            self.format == other.format
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'data',
        'format',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'data',
        'format',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.data,
            self.format,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        data: __dataclass__init__fields__0__annotation,
        format: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'data', data)
        __dataclass__object_setattr(self, 'format', format)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"data={self.data!r}")
        parts.append(f"format={self.format!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('input_audio',)), EqPlan(fields=('input_audio',)), FrozenPlan(fields=('input_audio',),"
    " allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('input_audio',), cache=False), InitPlan(fields="
    "(InitPlan.Field(name='input_audio', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_facto"
    "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),),"
    " self_param='self', std_params=('input_audio',), kw_only_params=(), frozen=True, slots=False, post_init_params=Non"
    "e, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='input_audio', kw_only=False, fn=None),), i"
    "d=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fcontentpart_2fInputAudioChatCompletionContentPart(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            input_audio=self.input_audio,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.input_audio == other.input_audio
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'input_audio',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'input_audio',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.input_audio,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        input_audio: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'input_audio', input_audio)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"input_audio={self.input_audio!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('refusal',)), EqPlan(fields=('refusal',)), FrozenPlan(fields=('refusal',), allow_dynam"
    "ic_dunder_attrs=False), HashPlan(action='add', fields=('refusal',), cache=False), InitPlan(fields=(InitPlan.Field("
    "name='refusal', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', "
    "std_params=('refusal',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate"
    "_fns=()), ReprPlan(fields=(ReprPlan.Field(name='refusal', kw_only=False, fn=None),), id=False, terse=False, defaul"
    "t_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fcontentpart_2fRefusalChatCompletionContentPart(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            refusal=self.refusal,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.refusal == other.refusal
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'refusal',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'refusal',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.refusal,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        refusal: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'refusal', refusal)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"refusal={self.refusal!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('content', 'name')), EqPlan(fields=('content', 'name')), FrozenPlan(fields=('content',"
    " 'name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('content', 'name'), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='content', annotation=OpRef(name='init.fields.0.annotation'), default=None, defau"
    "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fie"
    "lds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('content', 'name'), frozen=True, s"
    "lots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='content', "
    "kw_only=True, fn=None), ReprPlan.Field(name='name', kw_only=True, fn=None)), id=False, terse=False, default_fn=Non"
    "e)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fmessage_2fDeveloperChatCompletionMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            content=self.content,
            name=self.name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.content == other.content and
            self.name == other.name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'content',
        'name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'content',
        'name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.content,
            self.name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        content: __dataclass__init__fields__0__annotation,
        name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'name', name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"content={self.content!r}")
        parts.append(f"name={self.name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('content', 'name')), EqPlan(fields=('content', 'name')), FrozenPlan(fields=('content',"
    " 'name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('content', 'name'), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='content', annotation=OpRef(name='init.fields.0.annotation'), default=None, defau"
    "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fie"
    "lds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('content', 'name'), frozen=True, s"
    "lots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='content', "
    "kw_only=True, fn=None), ReprPlan.Field(name='name', kw_only=True, fn=None)), id=False, terse=False, default_fn=Non"
    "e)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fmessage_2fSystemChatCompletionMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            content=self.content,
            name=self.name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.content == other.content and
            self.name == other.name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'content',
        'name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'content',
        'name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.content,
            self.name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        content: __dataclass__init__fields__0__annotation,
        name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'name', name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"content={self.content!r}")
        parts.append(f"name={self.name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('content', 'name')), EqPlan(fields=('content', 'name')), FrozenPlan(fields=('content',"
    " 'name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('content', 'name'), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='content', annotation=OpRef(name='init.fields.0.annotation'), default=None, defau"
    "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fie"
    "lds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('content', 'name'), frozen=True, s"
    "lots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='content', "
    "kw_only=True, fn=None), ReprPlan.Field(name='name', kw_only=True, fn=None)), id=False, terse=False, default_fn=Non"
    "e)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fmessage_2fUserChatCompletionMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            content=self.content,
            name=self.name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.content == other.content and
            self.name == other.name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'content',
        'name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'content',
        'name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.content,
            self.name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        content: __dataclass__init__fields__0__annotation,
        name: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'name', name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"content={self.content!r}")
        parts.append(f"name={self.name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('id',)), EqPlan(fields=('id',)), FrozenPlan(fields=('id',), allow_dynamic_dunder_attrs"
    "=False), HashPlan(action='add', fields=('id',), cache=False), InitPlan(fields=(InitPlan.Field(name='id', annotatio"
    "n=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_pa"
    "rams=('id',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Rep"
    "rPlan.Field(name='id', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fmessage_2fAssistantChatCompletionMessage_2fAudio(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            id=self.id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.id == other.id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        id: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'id', id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"id={self.id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('arguments', 'name')), EqPlan(fields=('arguments', 'name')), FrozenPlan(fields=('argum"
    "ents', 'name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('arguments', 'name'), cache=Fals"
    "e), InitPlan(fields=(InitPlan.Field(name='arguments', annotation=OpRef(name='init.fields.0.annotation'), default=N"
    "one, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation'), default=None, defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None)), self_param='self', std_params=(), kw_only_params=('arguments', 'name'), frozen=True, slots=False, post_in"
    "it_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='arguments', kw_only=True, fn="
    "None), ReprPlan.Field(name='name', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fmessage_2fAssistantChatCompletionMessage_2fToolCall_2fFunction(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            arguments=self.arguments,
            name=self.name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.arguments == other.arguments and
            self.name == other.name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'arguments',
        'name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'arguments',
        'name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.arguments,
            self.name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        arguments: __dataclass__init__fields__0__annotation,
        name: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'arguments', arguments)
        __dataclass__object_setattr(self, 'name', name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"arguments={self.arguments!r}")
        parts.append(f"name={self.name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('id', 'function', 'type')), EqPlan(fields=('id', 'function', 'type')), FrozenPlan(fiel"
    "ds=('id', 'function', 'type'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('id', 'function',"
    " 'type'), cache=False), InitPlan(fields=(InitPlan.Field(name='id', annotation=OpRef(name='init.fields.0.annotation"
    "'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='function', annotation=OpRef(name='init.fields.1.annotation'), d"
    "efault=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.2.annotation'), default=Op"
    "Ref(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
    " coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('id', 'function'"
    ", 'type'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPl"
    "an.Field(name='id', kw_only=True, fn=None), ReprPlan.Field(name='function', kw_only=True, fn=None)), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fmessage_2fAssistantChatCompletionMessage_2fToolCall(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            id=self.id,
            function=self.function,
            type=self.type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.id == other.id and
            self.function == other.function and
            self.type == other.type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'id',
        'function',
        'type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'id',
        'function',
        'type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.id,
            self.function,
            self.type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        id: __dataclass__init__fields__0__annotation,
        function: __dataclass__init__fields__1__annotation,
        type: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'function', function)
        __dataclass__object_setattr(self, 'type', type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"id={self.id!r}")
        parts.append(f"function={self.function!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('audio', 'content', 'name', 'refusal', 'tool_calls')), EqPlan(fields=('audio', 'conten"
    "t', 'name', 'refusal', 'tool_calls')), FrozenPlan(fields=('audio', 'content', 'name', 'refusal', 'tool_calls'), al"
    "low_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('audio', 'content', 'name', 'refusal', 'tool_calls"
    "'), cache=False), InitPlan(fields=(InitPlan.Field(name='audio', annotation=OpRef(name='init.fields.0.annotation'),"
    " default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='content', annotation=OpRef(name='in"
    "it.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='name', ann"
    "otation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None,"
    " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
    "Field(name='refusal', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default"
    "'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None), InitPlan.Field(name='tool_calls', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef"
    "(name='init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('audio', 'content',"
    " 'name', 'refusal', 'tool_calls'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
    " ReprPlan(fields=(ReprPlan.Field(name='audio', kw_only=True, fn=None), ReprPlan.Field(name='content', kw_only=True"
    ", fn=None), ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='refusal', kw_only=True, fn=No"
    "ne), ReprPlan.Field(name='tool_calls', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fmessage_2fAssistantChatCompletionMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            audio=self.audio,
            content=self.content,
            name=self.name,
            refusal=self.refusal,
            tool_calls=self.tool_calls,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.audio == other.audio and
            self.content == other.content and
            self.name == other.name and
            self.refusal == other.refusal and
            self.tool_calls == other.tool_calls
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'audio',
        'content',
        'name',
        'refusal',
        'tool_calls',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'audio',
        'content',
        'name',
        'refusal',
        'tool_calls',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.audio,
            self.content,
            self.name,
            self.refusal,
            self.tool_calls,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        audio: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        content: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        name: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        refusal: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        tool_calls: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'audio', audio)
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'refusal', refusal)
        __dataclass__object_setattr(self, 'tool_calls', tool_calls)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"audio={self.audio!r}")
        parts.append(f"content={self.content!r}")
        parts.append(f"name={self.name!r}")
        parts.append(f"refusal={self.refusal!r}")
        parts.append(f"tool_calls={self.tool_calls!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('content', 'tool_call_id')), EqPlan(fields=('content', 'tool_call_id')), FrozenPlan(fi"
    "elds=('content', 'tool_call_id'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('content', 'to"
    "ol_call_id'), cache=False), InitPlan(fields=(InitPlan.Field(name='content', annotation=OpRef(name='init.fields.0.a"
    "nnotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='tool_call_id', annotation=OpRef(name='init.fields.1.an"
    "notation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
    "one, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('content', 'tool_call_id'"
    "), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field"
    "(name='content', kw_only=True, fn=None), ReprPlan.Field(name='tool_call_id', kw_only=True, fn=None)), id=False, te"
    "rse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fmessage_2fToolChatCompletionMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            content=self.content,
            tool_call_id=self.tool_call_id,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.content == other.content and
            self.tool_call_id == other.tool_call_id
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'content',
        'tool_call_id',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'content',
        'tool_call_id',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.content,
            self.tool_call_id,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        content: __dataclass__init__fields__0__annotation,
        tool_call_id: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'tool_call_id', tool_call_id)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"content={self.content!r}")
        parts.append(f"tool_call_id={self.tool_call_id!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('content', 'name')), EqPlan(fields=('content', 'name')), FrozenPlan(fields=('content',"
    " 'name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('content', 'name'), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='content', annotation=OpRef(name='init.fields.0.annotation'), default=None, defau"
    "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factor"
    "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), s"
    "elf_param='self', std_params=(), kw_only_params=('content', 'name'), frozen=True, slots=False, post_init_params=No"
    "ne, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='content', kw_only=True, fn=None), ReprPla"
    "n.Field(name='name', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fmessage_2fFunctionChatCompletionMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            content=self.content,
            name=self.name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.content == other.content and
            self.name == other.name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'content',
        'name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'content',
        'name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.content,
            self.name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        content: __dataclass__init__fields__0__annotation,
        name: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'name', name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"content={self.content!r}")
        parts.append(f"name={self.name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=(), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=(), cache=False), InitPlan(fields=(), self_param='self', std_params=(), kw_only_params=(),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fresponseformat_2fTextChatCompletionResponseFormat(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'description', 'schema', 'strict')), EqPlan(fields=('name', 'description', 'sc"
    "hema', 'strict')), FrozenPlan(fields=('name', 'description', 'schema', 'strict'), allow_dynamic_dunder_attrs=False"
    "), HashPlan(action='add', fields=('name', 'description', 'schema', 'strict'), cache=False), InitPlan(fields=(InitP"
    "lan.Field(name='name', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init"
    "=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field"
    "(name='description', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'"
    "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
    "ck_type=None), InitPlan.Field(name='schema', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name"
    "='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='strict', annotation=OpRef(name='init.fields.3.annotati"
    "on'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=("
    "'name', 'description', 'schema', 'strict'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate"
    "_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Field(name='description', "
    "kw_only=True, fn=None), ReprPlan.Field(name='schema', kw_only=True, fn=None), ReprPlan.Field(name='strict', kw_onl"
    "y=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fresponseformat_2fJsonSchemaChatCompletionResponseFormat_2fJsonSchema(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            description=self.description,
            schema=self.schema,
            strict=self.strict,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.description == other.description and
            self.schema == other.schema and
            self.strict == other.strict
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'name',
        'description',
        'schema',
        'strict',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
        'description',
        'schema',
        'strict',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.description,
            self.schema,
            self.strict,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        name: __dataclass__init__fields__0__annotation,
        description: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        schema: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        strict: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'schema', schema)
        __dataclass__object_setattr(self, 'strict', strict)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"description={self.description!r}")
        parts.append(f"schema={self.schema!r}")
        parts.append(f"strict={self.strict!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('json_schema',)), EqPlan(fields=('json_schema',)), FrozenPlan(fields=('json_schema',),"
    " allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('json_schema',), cache=False), InitPlan(fields="
    "(InitPlan.Field(name='json_schema', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_facto"
    "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),),"
    " self_param='self', std_params=(), kw_only_params=('json_schema',), frozen=True, slots=False, post_init_params=Non"
    "e, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='json_schema', kw_only=True, fn=None),), id"
    "=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fresponseformat_2fJsonSchemaChatCompletionResponseFormat(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            json_schema=self.json_schema,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.json_schema == other.json_schema
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'json_schema',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'json_schema',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.json_schema,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        json_schema: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'json_schema', json_schema)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"json_schema={self.json_schema!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=(), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=(), cache=False), InitPlan(fields=(), self_param='self', std_params=(), kw_only_params=(),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fresponseformat_2fJsonObjectChatCompletionResponseFormat(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('city', 'country', 'region', 'timezone')), EqPlan(fields=('city', 'country', 'region',"
    " 'timezone')), FrozenPlan(fields=('city', 'country', 'region', 'timezone'), allow_dynamic_dunder_attrs=False), Has"
    "hPlan(action='add', fields=('city', 'country', 'region', 'timezone'), cache=False), InitPlan(fields=(InitPlan.Fiel"
    "d(name='city', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), def"
    "ault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_typ"
    "e=None), InitPlan.Field(name='country', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='ini"
    "t.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None), InitPlan.Field(name='region', annotation=OpRef(name='init.fields.2.annotation'),"
    " default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldTyp"
    "e.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='timezone', annotation=OpRef(name='i"
    "nit.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override="
    "False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params"
    "=(), kw_only_params=('city', 'country', 'region', 'timezone'), frozen=True, slots=False, post_init_params=None, in"
    "it_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='city', kw_only=True, fn=None), ReprPlan.Field(n"
    "ame='country', kw_only=True, fn=None), ReprPlan.Field(name='region', kw_only=True, fn=None), ReprPlan.Field(name='"
    "timezone', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2frequest_2fChatCompletionRequestWebSearchOptions_2fUserLocation_2fApproximate(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            city=self.city,
            country=self.country,
            region=self.region,
            timezone=self.timezone,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.city == other.city and
            self.country == other.country and
            self.region == other.region and
            self.timezone == other.timezone
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'city',
        'country',
        'region',
        'timezone',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'city',
        'country',
        'region',
        'timezone',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.city,
            self.country,
            self.region,
            self.timezone,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        city: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        country: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        region: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        timezone: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'city', city)
        __dataclass__object_setattr(self, 'country', country)
        __dataclass__object_setattr(self, 'region', region)
        __dataclass__object_setattr(self, 'timezone', timezone)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"city={self.city!r}")
        parts.append(f"country={self.country!r}")
        parts.append(f"region={self.region!r}")
        parts.append(f"timezone={self.timezone!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('approximate', 'type')), EqPlan(fields=('approximate', 'type')), FrozenPlan(fields=('a"
    "pproximate', 'type'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('approximate', 'type'), ca"
    "che=False), InitPlan(fields=(InitPlan.Field(name='approximate', annotation=OpRef(name='init.fields.0.annotation'),"
    " default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valida"
    "te=None, check_type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.1.annotation'), default="
    "OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
    "E, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('approximate',"
    " 'type'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPla"
    "n.Field(name='approximate', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2frequest_2fChatCompletionRequestWebSearchOptions_2fUserLocation(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            approximate=self.approximate,
            type=self.type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.approximate == other.approximate and
            self.type == other.type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'approximate',
        'type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'approximate',
        'type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.approximate,
            self.type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        approximate: __dataclass__init__fields__0__annotation,
        type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'approximate', approximate)
        __dataclass__object_setattr(self, 'type', type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"approximate={self.approximate!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('search_context_size', 'user_location')), EqPlan(fields=('search_context_size', 'user_"
    "location')), FrozenPlan(fields=('search_context_size', 'user_location'), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=('search_context_size', 'user_location'), cache=False), InitPlan(fields=(InitPlan.Field(na"
    "me='search_context_size', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.def"
    "ault'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None"
    ", check_type=None), InitPlan.Field(name='user_location', annotation=OpRef(name='init.fields.1.annotation'), defaul"
    "t=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTA"
    "NCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('search_cont"
    "ext_size', 'user_location'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprP"
    "lan(fields=(ReprPlan.Field(name='search_context_size', kw_only=True, fn=None), ReprPlan.Field(name='user_location'"
    ", kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2frequest_2fChatCompletionRequestWebSearchOptions(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            search_context_size=self.search_context_size,
            user_location=self.user_location,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.search_context_size == other.search_context_size and
            self.user_location == other.user_location
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'search_context_size',
        'user_location',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'search_context_size',
        'user_location',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.search_context_size,
            self.user_location,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        search_context_size: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        user_location: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'search_context_size', search_context_size)
        __dataclass__object_setattr(self, 'user_location', user_location)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"search_context_size={self.search_context_size!r}")
        parts.append(f"user_location={self.user_location!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('content', 'type')), EqPlan(fields=('content', 'type')), FrozenPlan(fields=('content',"
    " 'type'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('content', 'type'), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='content', annotation=OpRef(name='init.fields.0.annotation'), default=None, defau"
    "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fie"
    "lds.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('content', 'type'), frozen=True, s"
    "lots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='content', "
    "kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2frequest_2fChatCompletionRequestPrediction(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            content=self.content,
            type=self.type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.content == other.content and
            self.type == other.type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'content',
        'type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'content',
        'type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.content,
            self.type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        content: __dataclass__init__fields__0__annotation,
        type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'type', type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"content={self.content!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'description', 'parameters', 'strict')), EqPlan(fields=('name', 'description',"
    " 'parameters', 'strict')), FrozenPlan(fields=('name', 'description', 'parameters', 'strict'), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('name', 'description', 'parameters', 'strict'), cache=False), InitPl"
    "an(fields=(InitPlan.Field(name='name', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_fa"
    "ctory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)"
    ", InitPlan.Field(name='description', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.f"
    "ields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='parameters', annotation=OpRef(name='init.fields.2.annotation')"
    ", default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldTy"
    "pe.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='strict', annotation=OpRef(name='in"
    "it.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params="
    "(), kw_only_params=('name', 'description', 'parameters', 'strict'), frozen=True, slots=False, post_init_params=Non"
    "e, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_only=True, fn=None), ReprPlan.Fi"
    "eld(name='description', kw_only=True, fn=None), ReprPlan.Field(name='parameters', kw_only=True, fn=None), ReprPlan"
    ".Field(name='strict', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2frequest_2fChatCompletionRequestTool_2fFunction(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            description=self.description,
            parameters=self.parameters,
            strict=self.strict,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.description == other.description and
            self.parameters == other.parameters and
            self.strict == other.strict
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'name',
        'description',
        'parameters',
        'strict',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
        'description',
        'parameters',
        'strict',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.description,
            self.parameters,
            self.strict,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        name: __dataclass__init__fields__0__annotation,
        description: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        parameters: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        strict: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'description', description)
        __dataclass__object_setattr(self, 'parameters', parameters)
        __dataclass__object_setattr(self, 'strict', strict)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"description={self.description!r}")
        parts.append(f"parameters={self.parameters!r}")
        parts.append(f"strict={self.strict!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('function', 'type')), EqPlan(fields=('function', 'type')), FrozenPlan(fields=('functio"
    "n', 'type'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('function', 'type'), cache=False), "
    "InitPlan(fields=(InitPlan.Field(name='function', annotation=OpRef(name='init.fields.0.annotation'), default=None, "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='ini"
    "t.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None)), self_param='self', std_params=('function',), kw_only_params=('type',), frozen=T"
    "rue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='func"
    "tion', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2frequest_2fChatCompletionRequestTool(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            function=self.function,
            type=self.type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.function == other.function and
            self.type == other.type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'function',
        'type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'function',
        'type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.function,
            self.type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        function: __dataclass__init__fields__0__annotation,
        *,
        type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'function', function)
        __dataclass__object_setattr(self, 'type', type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"function={self.function!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name',)), EqPlan(fields=('name',)), FrozenPlan(fields=('name',), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('name',), cache=False), InitPlan(fields=(InitPlan.Field(name='name',"
    " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('na"
    "me',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan"
    "(fields=(ReprPlan.Field(name='name', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2frequest_2fChatCompletionRequestNamedToolChoice_2fFunction(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        name: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('function', 'type')), EqPlan(fields=('function', 'type')), FrozenPlan(fields=('functio"
    "n', 'type'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('function', 'type'), cache=False), "
    "InitPlan(fields=(InitPlan.Field(name='function', annotation=OpRef(name='init.fields.0.annotation'), default=None, "
    "default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_"
    "type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='ini"
    "t.fields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None,"
    " validate=None, check_type=None)), self_param='self', std_params=('function',), kw_only_params=('type',), frozen=T"
    "rue, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='func"
    "tion', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2frequest_2fChatCompletionRequestNamedToolChoice(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            function=self.function,
            type=self.type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.function == other.function and
            self.type == other.type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'function',
        'type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'function',
        'type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.function,
            self.type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        function: __dataclass__init__fields__0__annotation,
        *,
        type: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'function', function)
        __dataclass__object_setattr(self, 'type', type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"function={self.function!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('format', 'voice')), EqPlan(fields=('format', 'voice')), FrozenPlan(fields=('format', "
    "'voice'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('format', 'voice'), cache=False), Init"
    "Plan(fields=(InitPlan.Field(name='format', annotation=OpRef(name='init.fields.0.annotation'), default=None, defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='voice', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factor"
    "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), s"
    "elf_param='self', std_params=(), kw_only_params=('format', 'voice'), frozen=True, slots=False, post_init_params=No"
    "ne, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='format', kw_only=True, fn=None), ReprPlan"
    ".Field(name='voice', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2frequest_2fChatCompletionRequestAudio(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            format=self.format,
            voice=self.voice,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.format == other.format and
            self.voice == other.voice
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'format',
        'voice',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'format',
        'voice',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.format,
            self.voice,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        format: __dataclass__init__fields__0__annotation,
        voice: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'format', format)
        __dataclass__object_setattr(self, 'voice', voice)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"format={self.format!r}")
        parts.append(f"voice={self.voice!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('include_usage',)), EqPlan(fields=('include_usage',)), FrozenPlan(fields=('include_usa"
    "ge',), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('include_usage',), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='include_usage', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(nam"
    "e='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None),), self_param='self', std_params=(), kw_only_params=('include_usage',), fro"
    "zen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name="
    "'include_usage', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2frequest_2fChatCompletionRequest_2fStreamOptions(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            include_usage=self.include_usage,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.include_usage == other.include_usage
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'include_usage',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'include_usage',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.include_usage,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        include_usage: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'include_usage', include_usage)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"include_usage={self.include_usage!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('messages', 'model', 'audio', 'frequency_penalty', 'logit_bias', 'logprobs', 'max_comp"
    "letion_tokens', 'max_tokens', 'metadata', 'modalities', 'n', 'parallel_tool_calls', 'prediction', 'presence_penalt"
    "y', 'reasoning_effort', 'response_format', 'seed', 'service_tier', 'stop', 'store', 'stream', 'stream_options', 't"
    "emperature', 'tool_choice', 'tools', 'top_logprobs', 'top_p', 'user', 'web_search_options')), EqPlan(fields=('mess"
    "ages', 'model', 'audio', 'frequency_penalty', 'logit_bias', 'logprobs', 'max_completion_tokens', 'max_tokens', 'me"
    "tadata', 'modalities', 'n', 'parallel_tool_calls', 'prediction', 'presence_penalty', 'reasoning_effort', 'response"
    "_format', 'seed', 'service_tier', 'stop', 'store', 'stream', 'stream_options', 'temperature', 'tool_choice', 'tool"
    "s', 'top_logprobs', 'top_p', 'user', 'web_search_options')), FrozenPlan(fields=('messages', 'model', 'audio', 'fre"
    "quency_penalty', 'logit_bias', 'logprobs', 'max_completion_tokens', 'max_tokens', 'metadata', 'modalities', 'n', '"
    "parallel_tool_calls', 'prediction', 'presence_penalty', 'reasoning_effort', 'response_format', 'seed', 'service_ti"
    "er', 'stop', 'store', 'stream', 'stream_options', 'temperature', 'tool_choice', 'tools', 'top_logprobs', 'top_p', "
    "'user', 'web_search_options'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('messages', 'mode"
    "l', 'audio', 'frequency_penalty', 'logit_bias', 'logprobs', 'max_completion_tokens', 'max_tokens', 'metadata', 'mo"
    "dalities', 'n', 'parallel_tool_calls', 'prediction', 'presence_penalty', 'reasoning_effort', 'response_format', 's"
    "eed', 'service_tier', 'stop', 'store', 'stream', 'stream_options', 'temperature', 'tool_choice', 'tools', 'top_log"
    "probs', 'top_p', 'user', 'web_search_options'), cache=False), InitPlan(fields=(InitPlan.Field(name='messages', ann"
    "otation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='model', annotation="
    "OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type="
    "FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='audio', annotation=OpRef(na"
    "me='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='freq"
    "uency_penalty', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), de"
    "fault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_ty"
    "pe=None), InitPlan.Field(name='logit_bias', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name="
    "'init.fields.4.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
    "one, validate=None, check_type=None), InitPlan.Field(name='logprobs', annotation=OpRef(name='init.fields.5.annotat"
    "ion'), default=OpRef(name='init.fields.5.default'), default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='max_completion_tokens', annot"
    "ation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fields.6.default'), default_factory=None, i"
    "nit=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Fi"
    "eld(name='max_tokens', annotation=OpRef(name='init.fields.7.annotation'), default=OpRef(name='init.fields.7.defaul"
    "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='metadata', annotation=OpRef(name='init.fields.8.annotation'), default=OpRef("
    "name='init.fields.8.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coe"
    "rce=None, validate=None, check_type=None), InitPlan.Field(name='modalities', annotation=OpRef(name='init.fields.9."
    "annotation'), default=OpRef(name='init.fields.9.default'), default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='n', annotation=OpRef(n"
    "ame='init.fields.10.annotation'), default=OpRef(name='init.fields.10.default'), default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='p"
    "arallel_tool_calls', annotation=OpRef(name='init.fields.11.annotation'), default=OpRef(name='init.fields.11.defaul"
    "t'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='prediction', annotation=OpRef(name='init.fields.12.annotation'), default=OpR"
    "ef(name='init.fields.12.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
    " coerce=None, validate=None, check_type=None), InitPlan.Field(name='presence_penalty', annotation=OpRef(name='init"
    ".fields.13.annotation'), default=OpRef(name='init.fields.13.default'), default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='reasoning_"
    "effort', annotation=OpRef(name='init.fields.14.annotation'), default=OpRef(name='init.fields.14.default'), default"
    "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
    "ne), InitPlan.Field(name='response_format', annotation=OpRef(name='init.fields.15.annotation'), default=OpRef(name"
    "='init.fields.15.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='seed', annotation=OpRef(name='init.fields.16.annotati"
    "on'), default=OpRef(name='init.fields.16.default'), default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='service_tier', annotation=OpR"
    "ef(name='init.fields.17.annotation'), default=OpRef(name='init.fields.17.default'), default_factory=None, init=Tru"
    "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
    "e='stop', annotation=OpRef(name='init.fields.18.annotation'), default=OpRef(name='init.fields.18.default'), defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='store', annotation=OpRef(name='init.fields.19.annotation'), default=OpRef(name='init.fi"
    "elds.19.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='stream', annotation=OpRef(name='init.fields.20.annotation'), d"
    "efault=OpRef(name='init.fields.20.default'), default_factory=None, init=True, override=False, field_type=FieldType"
    ".INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='stream_options', annotation=OpRef(na"
    "me='init.fields.21.annotation'), default=OpRef(name='init.fields.21.default'), default_factory=None, init=True, ov"
    "erride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='te"
    "mperature', annotation=OpRef(name='init.fields.22.annotation'), default=OpRef(name='init.fields.22.default'), defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None), InitPlan.Field(name='tool_choice', annotation=OpRef(name='init.fields.23.annotation'), default=OpRef(name="
    "'init.fields.23.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce="
    "None, validate=None, check_type=None), InitPlan.Field(name='tools', annotation=OpRef(name='init.fields.24.annotati"
    "on'), default=OpRef(name='init.fields.24.default'), default_factory=None, init=True, override=False, field_type=Fi"
    "eldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='top_logprobs', annotation=OpR"
    "ef(name='init.fields.25.annotation'), default=OpRef(name='init.fields.25.default'), default_factory=None, init=Tru"
    "e, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(nam"
    "e='top_p', annotation=OpRef(name='init.fields.26.annotation'), default=OpRef(name='init.fields.26.default'), defau"
    "lt_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type="
    "None), InitPlan.Field(name='user', annotation=OpRef(name='init.fields.27.annotation'), default=OpRef(name='init.fi"
    "elds.27.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='web_search_options', annotation=OpRef(name='init.fields.28.ann"
    "otation'), default=OpRef(name='init.fields.28.default'), default_factory=None, init=True, override=False, field_ty"
    "pe=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_pa"
    "rams=('messages', 'model', 'audio', 'frequency_penalty', 'logit_bias', 'logprobs', 'max_completion_tokens', 'max_t"
    "okens', 'metadata', 'modalities', 'n', 'parallel_tool_calls', 'prediction', 'presence_penalty', 'reasoning_effort'"
    ", 'response_format', 'seed', 'service_tier', 'stop', 'store', 'stream', 'stream_options', 'temperature', 'tool_cho"
    "ice', 'tools', 'top_logprobs', 'top_p', 'user', 'web_search_options'), frozen=True, slots=False, post_init_params="
    "None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='messages', kw_only=True, fn=None), Repr"
    "Plan.Field(name='model', kw_only=True, fn=None), ReprPlan.Field(name='audio', kw_only=True, fn=None), ReprPlan.Fie"
    "ld(name='frequency_penalty', kw_only=True, fn=None), ReprPlan.Field(name='logit_bias', kw_only=True, fn=None), Rep"
    "rPlan.Field(name='logprobs', kw_only=True, fn=None), ReprPlan.Field(name='max_completion_tokens', kw_only=True, fn"
    "=None), ReprPlan.Field(name='max_tokens', kw_only=True, fn=None), ReprPlan.Field(name='metadata', kw_only=True, fn"
    "=None), ReprPlan.Field(name='modalities', kw_only=True, fn=None), ReprPlan.Field(name='n', kw_only=True, fn=None),"
    " ReprPlan.Field(name='parallel_tool_calls', kw_only=True, fn=None), ReprPlan.Field(name='prediction', kw_only=True"
    ", fn=None), ReprPlan.Field(name='presence_penalty', kw_only=True, fn=None), ReprPlan.Field(name='reasoning_effort'"
    ", kw_only=True, fn=None), ReprPlan.Field(name='response_format', kw_only=True, fn=None), ReprPlan.Field(name='seed"
    "', kw_only=True, fn=None), ReprPlan.Field(name='service_tier', kw_only=True, fn=None), ReprPlan.Field(name='stop',"
    " kw_only=True, fn=None), ReprPlan.Field(name='store', kw_only=True, fn=None), ReprPlan.Field(name='stream', kw_onl"
    "y=True, fn=None), ReprPlan.Field(name='stream_options', kw_only=True, fn=None), ReprPlan.Field(name='temperature',"
    " kw_only=True, fn=None), ReprPlan.Field(name='tool_choice', kw_only=True, fn=None), ReprPlan.Field(name='tools', k"
    "w_only=True, fn=None), ReprPlan.Field(name='top_logprobs', kw_only=True, fn=None), ReprPlan.Field(name='top_p', kw"
    "_only=True, fn=None), ReprPlan.Field(name='user', kw_only=True, fn=None), ReprPlan.Field(name='web_search_options'"
    ", kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2frequest_2fChatCompletionRequest(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__10__annotation,
    __dataclass__init__fields__10__default,
    __dataclass__init__fields__11__annotation,
    __dataclass__init__fields__11__default,
    __dataclass__init__fields__12__annotation,
    __dataclass__init__fields__12__default,
    __dataclass__init__fields__13__annotation,
    __dataclass__init__fields__13__default,
    __dataclass__init__fields__14__annotation,
    __dataclass__init__fields__14__default,
    __dataclass__init__fields__15__annotation,
    __dataclass__init__fields__15__default,
    __dataclass__init__fields__16__annotation,
    __dataclass__init__fields__16__default,
    __dataclass__init__fields__17__annotation,
    __dataclass__init__fields__17__default,
    __dataclass__init__fields__18__annotation,
    __dataclass__init__fields__18__default,
    __dataclass__init__fields__19__annotation,
    __dataclass__init__fields__19__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__20__annotation,
    __dataclass__init__fields__20__default,
    __dataclass__init__fields__21__annotation,
    __dataclass__init__fields__21__default,
    __dataclass__init__fields__22__annotation,
    __dataclass__init__fields__22__default,
    __dataclass__init__fields__23__annotation,
    __dataclass__init__fields__23__default,
    __dataclass__init__fields__24__annotation,
    __dataclass__init__fields__24__default,
    __dataclass__init__fields__25__annotation,
    __dataclass__init__fields__25__default,
    __dataclass__init__fields__26__annotation,
    __dataclass__init__fields__26__default,
    __dataclass__init__fields__27__annotation,
    __dataclass__init__fields__27__default,
    __dataclass__init__fields__28__annotation,
    __dataclass__init__fields__28__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__init__fields__8__annotation,
    __dataclass__init__fields__8__default,
    __dataclass__init__fields__9__annotation,
    __dataclass__init__fields__9__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            messages=self.messages,
            model=self.model,
            audio=self.audio,
            frequency_penalty=self.frequency_penalty,
            logit_bias=self.logit_bias,
            logprobs=self.logprobs,
            max_completion_tokens=self.max_completion_tokens,
            max_tokens=self.max_tokens,
            metadata=self.metadata,
            modalities=self.modalities,
            n=self.n,
            parallel_tool_calls=self.parallel_tool_calls,
            prediction=self.prediction,
            presence_penalty=self.presence_penalty,
            reasoning_effort=self.reasoning_effort,
            response_format=self.response_format,
            seed=self.seed,
            service_tier=self.service_tier,
            stop=self.stop,
            store=self.store,
            stream=self.stream,
            stream_options=self.stream_options,
            temperature=self.temperature,
            tool_choice=self.tool_choice,
            tools=self.tools,
            top_logprobs=self.top_logprobs,
            top_p=self.top_p,
            user=self.user,
            web_search_options=self.web_search_options,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.messages == other.messages and
            self.model == other.model and
            self.audio == other.audio and
            self.frequency_penalty == other.frequency_penalty and
            self.logit_bias == other.logit_bias and
            self.logprobs == other.logprobs and
            self.max_completion_tokens == other.max_completion_tokens and
            self.max_tokens == other.max_tokens and
            self.metadata == other.metadata and
            self.modalities == other.modalities and
            self.n == other.n and
            self.parallel_tool_calls == other.parallel_tool_calls and
            self.prediction == other.prediction and
            self.presence_penalty == other.presence_penalty and
            self.reasoning_effort == other.reasoning_effort and
            self.response_format == other.response_format and
            self.seed == other.seed and
            self.service_tier == other.service_tier and
            self.stop == other.stop and
            self.store == other.store and
            self.stream == other.stream and
            self.stream_options == other.stream_options and
            self.temperature == other.temperature and
            self.tool_choice == other.tool_choice and
            self.tools == other.tools and
            self.top_logprobs == other.top_logprobs and
            self.top_p == other.top_p and
            self.user == other.user and
            self.web_search_options == other.web_search_options
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'messages',
        'model',
        'audio',
        'frequency_penalty',
        'logit_bias',
        'logprobs',
        'max_completion_tokens',
        'max_tokens',
        'metadata',
        'modalities',
        'n',
        'parallel_tool_calls',
        'prediction',
        'presence_penalty',
        'reasoning_effort',
        'response_format',
        'seed',
        'service_tier',
        'stop',
        'store',
        'stream',
        'stream_options',
        'temperature',
        'tool_choice',
        'tools',
        'top_logprobs',
        'top_p',
        'user',
        'web_search_options',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'messages',
        'model',
        'audio',
        'frequency_penalty',
        'logit_bias',
        'logprobs',
        'max_completion_tokens',
        'max_tokens',
        'metadata',
        'modalities',
        'n',
        'parallel_tool_calls',
        'prediction',
        'presence_penalty',
        'reasoning_effort',
        'response_format',
        'seed',
        'service_tier',
        'stop',
        'store',
        'stream',
        'stream_options',
        'temperature',
        'tool_choice',
        'tools',
        'top_logprobs',
        'top_p',
        'user',
        'web_search_options',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.messages,
            self.model,
            self.audio,
            self.frequency_penalty,
            self.logit_bias,
            self.logprobs,
            self.max_completion_tokens,
            self.max_tokens,
            self.metadata,
            self.modalities,
            self.n,
            self.parallel_tool_calls,
            self.prediction,
            self.presence_penalty,
            self.reasoning_effort,
            self.response_format,
            self.seed,
            self.service_tier,
            self.stop,
            self.store,
            self.stream,
            self.stream_options,
            self.temperature,
            self.tool_choice,
            self.tools,
            self.top_logprobs,
            self.top_p,
            self.user,
            self.web_search_options,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        messages: __dataclass__init__fields__0__annotation,
        model: __dataclass__init__fields__1__annotation,
        audio: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        frequency_penalty: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        logit_bias: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        logprobs: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        max_completion_tokens: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        max_tokens: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
        metadata: __dataclass__init__fields__8__annotation = __dataclass__init__fields__8__default,
        modalities: __dataclass__init__fields__9__annotation = __dataclass__init__fields__9__default,
        n: __dataclass__init__fields__10__annotation = __dataclass__init__fields__10__default,
        parallel_tool_calls: __dataclass__init__fields__11__annotation = __dataclass__init__fields__11__default,
        prediction: __dataclass__init__fields__12__annotation = __dataclass__init__fields__12__default,
        presence_penalty: __dataclass__init__fields__13__annotation = __dataclass__init__fields__13__default,
        reasoning_effort: __dataclass__init__fields__14__annotation = __dataclass__init__fields__14__default,
        response_format: __dataclass__init__fields__15__annotation = __dataclass__init__fields__15__default,
        seed: __dataclass__init__fields__16__annotation = __dataclass__init__fields__16__default,
        service_tier: __dataclass__init__fields__17__annotation = __dataclass__init__fields__17__default,
        stop: __dataclass__init__fields__18__annotation = __dataclass__init__fields__18__default,
        store: __dataclass__init__fields__19__annotation = __dataclass__init__fields__19__default,
        stream: __dataclass__init__fields__20__annotation = __dataclass__init__fields__20__default,
        stream_options: __dataclass__init__fields__21__annotation = __dataclass__init__fields__21__default,
        temperature: __dataclass__init__fields__22__annotation = __dataclass__init__fields__22__default,
        tool_choice: __dataclass__init__fields__23__annotation = __dataclass__init__fields__23__default,
        tools: __dataclass__init__fields__24__annotation = __dataclass__init__fields__24__default,
        top_logprobs: __dataclass__init__fields__25__annotation = __dataclass__init__fields__25__default,
        top_p: __dataclass__init__fields__26__annotation = __dataclass__init__fields__26__default,
        user: __dataclass__init__fields__27__annotation = __dataclass__init__fields__27__default,
        web_search_options: __dataclass__init__fields__28__annotation = __dataclass__init__fields__28__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'messages', messages)
        __dataclass__object_setattr(self, 'model', model)
        __dataclass__object_setattr(self, 'audio', audio)
        __dataclass__object_setattr(self, 'frequency_penalty', frequency_penalty)
        __dataclass__object_setattr(self, 'logit_bias', logit_bias)
        __dataclass__object_setattr(self, 'logprobs', logprobs)
        __dataclass__object_setattr(self, 'max_completion_tokens', max_completion_tokens)
        __dataclass__object_setattr(self, 'max_tokens', max_tokens)
        __dataclass__object_setattr(self, 'metadata', metadata)
        __dataclass__object_setattr(self, 'modalities', modalities)
        __dataclass__object_setattr(self, 'n', n)
        __dataclass__object_setattr(self, 'parallel_tool_calls', parallel_tool_calls)
        __dataclass__object_setattr(self, 'prediction', prediction)
        __dataclass__object_setattr(self, 'presence_penalty', presence_penalty)
        __dataclass__object_setattr(self, 'reasoning_effort', reasoning_effort)
        __dataclass__object_setattr(self, 'response_format', response_format)
        __dataclass__object_setattr(self, 'seed', seed)
        __dataclass__object_setattr(self, 'service_tier', service_tier)
        __dataclass__object_setattr(self, 'stop', stop)
        __dataclass__object_setattr(self, 'store', store)
        __dataclass__object_setattr(self, 'stream', stream)
        __dataclass__object_setattr(self, 'stream_options', stream_options)
        __dataclass__object_setattr(self, 'temperature', temperature)
        __dataclass__object_setattr(self, 'tool_choice', tool_choice)
        __dataclass__object_setattr(self, 'tools', tools)
        __dataclass__object_setattr(self, 'top_logprobs', top_logprobs)
        __dataclass__object_setattr(self, 'top_p', top_p)
        __dataclass__object_setattr(self, 'user', user)
        __dataclass__object_setattr(self, 'web_search_options', web_search_options)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"messages={self.messages!r}")
        parts.append(f"model={self.model!r}")
        parts.append(f"audio={self.audio!r}")
        parts.append(f"frequency_penalty={self.frequency_penalty!r}")
        parts.append(f"logit_bias={self.logit_bias!r}")
        parts.append(f"logprobs={self.logprobs!r}")
        parts.append(f"max_completion_tokens={self.max_completion_tokens!r}")
        parts.append(f"max_tokens={self.max_tokens!r}")
        parts.append(f"metadata={self.metadata!r}")
        parts.append(f"modalities={self.modalities!r}")
        parts.append(f"n={self.n!r}")
        parts.append(f"parallel_tool_calls={self.parallel_tool_calls!r}")
        parts.append(f"prediction={self.prediction!r}")
        parts.append(f"presence_penalty={self.presence_penalty!r}")
        parts.append(f"reasoning_effort={self.reasoning_effort!r}")
        parts.append(f"response_format={self.response_format!r}")
        parts.append(f"seed={self.seed!r}")
        parts.append(f"service_tier={self.service_tier!r}")
        parts.append(f"stop={self.stop!r}")
        parts.append(f"store={self.store!r}")
        parts.append(f"stream={self.stream!r}")
        parts.append(f"stream_options={self.stream_options!r}")
        parts.append(f"temperature={self.temperature!r}")
        parts.append(f"tool_choice={self.tool_choice!r}")
        parts.append(f"tools={self.tools!r}")
        parts.append(f"top_logprobs={self.top_logprobs!r}")
        parts.append(f"top_p={self.top_p!r}")
        parts.append(f"user={self.user!r}")
        parts.append(f"web_search_options={self.web_search_options!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('end_index', 'start_index', 'title', 'url')), EqPlan(fields=('end_index', 'start_index"
    "', 'title', 'url')), FrozenPlan(fields=('end_index', 'start_index', 'title', 'url'), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('end_index', 'start_index', 'title', 'url'), cache=False), InitPlan(fields=(I"
    "nitPlan.Field(name='end_index', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=N"
    "one, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitP"
    "lan.Field(name='start_index', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=Non"
    "e, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPla"
    "n.Field(name='title', annotation=OpRef(name='init.fields.2.annotation'), default=None, default_factory=None, init="
    "True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field("
    "name='url', annotation=OpRef(name='init.fields.3.annotation'), default=None, default_factory=None, init=True, over"
    "ride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_p"
    "arams=(), kw_only_params=('end_index', 'start_index', 'title', 'url'), frozen=True, slots=False, post_init_params="
    "None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='end_index', kw_only=True, fn=None), Rep"
    "rPlan.Field(name='start_index', kw_only=True, fn=None), ReprPlan.Field(name='title', kw_only=True, fn=None), ReprP"
    "lan.Field(name='url', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fresponse_2fChatCompletionResponseMessage_2fAnnotation_2fUrlCitation(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__3__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            end_index=self.end_index,
            start_index=self.start_index,
            title=self.title,
            url=self.url,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.end_index == other.end_index and
            self.start_index == other.start_index and
            self.title == other.title and
            self.url == other.url
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'end_index',
        'start_index',
        'title',
        'url',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'end_index',
        'start_index',
        'title',
        'url',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.end_index,
            self.start_index,
            self.title,
            self.url,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        end_index: __dataclass__init__fields__0__annotation,
        start_index: __dataclass__init__fields__1__annotation,
        title: __dataclass__init__fields__2__annotation,
        url: __dataclass__init__fields__3__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'end_index', end_index)
        __dataclass__object_setattr(self, 'start_index', start_index)
        __dataclass__object_setattr(self, 'title', title)
        __dataclass__object_setattr(self, 'url', url)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"end_index={self.end_index!r}")
        parts.append(f"start_index={self.start_index!r}")
        parts.append(f"title={self.title!r}")
        parts.append(f"url={self.url!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('type', 'url_citation')), EqPlan(fields=('type', 'url_citation')), FrozenPlan(fields=("
    "'type', 'url_citation'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('type', 'url_citation')"
    ", cache=False), InitPlan(fields=(InitPlan.Field(name='type', annotation=OpRef(name='init.fields.0.annotation'), de"
    "fault=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.I"
    "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='url_citation', annotation=OpRef(name='"
    "init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('type', '"
    "url_citation'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(R"
    "eprPlan.Field(name='url_citation', kw_only=True, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fresponse_2fChatCompletionResponseMessage_2fAnnotation(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            type=self.type,
            url_citation=self.url_citation,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.type == other.type and
            self.url_citation == other.url_citation
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'type',
        'url_citation',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'type',
        'url_citation',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.type,
            self.url_citation,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        type: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        url_citation: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'type', type)
        __dataclass__object_setattr(self, 'url_citation', url_citation)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"url_citation={self.url_citation!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('id', 'data', 'expires_at', 'transcript')), EqPlan(fields=('id', 'data', 'expires_at',"
    " 'transcript')), FrozenPlan(fields=('id', 'data', 'expires_at', 'transcript'), allow_dynamic_dunder_attrs=False), "
    "HashPlan(action='add', fields=('id', 'data', 'expires_at', 'transcript'), cache=False), InitPlan(fields=(InitPlan."
    "Field(name='id', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True,"
    " override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name="
    "'data', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override"
    "=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='expires_"
    "at', annotation=OpRef(name='init.fields.2.annotation'), default=None, default_factory=None, init=True, override=Fa"
    "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='transcript'"
    ", annotation=OpRef(name='init.fields.3.annotation'), default=None, default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), "
    "kw_only_params=('id', 'data', 'expires_at', 'transcript'), frozen=True, slots=False, post_init_params=None, init_f"
    "ns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='id', kw_only=True, fn=None), ReprPlan.Field(name='d"
    "ata', kw_only=True, fn=None), ReprPlan.Field(name='expires_at', kw_only=True, fn=None), ReprPlan.Field(name='trans"
    "cript', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fresponse_2fChatCompletionResponseMessage_2fAudio(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__3__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            id=self.id,
            data=self.data,
            expires_at=self.expires_at,
            transcript=self.transcript,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.id == other.id and
            self.data == other.data and
            self.expires_at == other.expires_at and
            self.transcript == other.transcript
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'id',
        'data',
        'expires_at',
        'transcript',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'id',
        'data',
        'expires_at',
        'transcript',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.id,
            self.data,
            self.expires_at,
            self.transcript,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        id: __dataclass__init__fields__0__annotation,
        data: __dataclass__init__fields__1__annotation,
        expires_at: __dataclass__init__fields__2__annotation,
        transcript: __dataclass__init__fields__3__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'data', data)
        __dataclass__object_setattr(self, 'expires_at', expires_at)
        __dataclass__object_setattr(self, 'transcript', transcript)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"id={self.id!r}")
        parts.append(f"data={self.data!r}")
        parts.append(f"expires_at={self.expires_at!r}")
        parts.append(f"transcript={self.transcript!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('arguments', 'name')), EqPlan(fields=('arguments', 'name')), FrozenPlan(fields=('argum"
    "ents', 'name'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('arguments', 'name'), cache=Fals"
    "e), InitPlan(fields=(InitPlan.Field(name='arguments', annotation=OpRef(name='init.fields.0.annotation'), default=N"
    "one, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, c"
    "heck_type=None), InitPlan.Field(name='name', annotation=OpRef(name='init.fields.1.annotation'), default=None, defa"
    "ult_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type"
    "=None)), self_param='self', std_params=(), kw_only_params=('arguments', 'name'), frozen=True, slots=False, post_in"
    "it_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='arguments', kw_only=True, fn="
    "None), ReprPlan.Field(name='name', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fresponse_2fChatCompletionResponseMessage_2fToolCall_2fFunction(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            arguments=self.arguments,
            name=self.name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.arguments == other.arguments and
            self.name == other.name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'arguments',
        'name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'arguments',
        'name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.arguments,
            self.name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        arguments: __dataclass__init__fields__0__annotation,
        name: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'arguments', arguments)
        __dataclass__object_setattr(self, 'name', name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"arguments={self.arguments!r}")
        parts.append(f"name={self.name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('id', 'function', 'type')), EqPlan(fields=('id', 'function', 'type')), FrozenPlan(fiel"
    "ds=('id', 'function', 'type'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('id', 'function',"
    " 'type'), cache=False), InitPlan(fields=(InitPlan.Field(name='id', annotation=OpRef(name='init.fields.0.annotation"
    "'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='function', annotation=OpRef(name='init.fields.1.annotation'), d"
    "efault=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None), InitPlan.Field(name='type', annotation=OpRef(name='init.fields.2.annotation'), default=Op"
    "Ref(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE,"
    " coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('id', 'function'"
    ", 'type'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPl"
    "an.Field(name='id', kw_only=True, fn=None), ReprPlan.Field(name='function', kw_only=True, fn=None)), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fresponse_2fChatCompletionResponseMessage_2fToolCall(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            id=self.id,
            function=self.function,
            type=self.type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.id == other.id and
            self.function == other.function and
            self.type == other.type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'id',
        'function',
        'type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'id',
        'function',
        'type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.id,
            self.function,
            self.type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        id: __dataclass__init__fields__0__annotation,
        function: __dataclass__init__fields__1__annotation,
        type: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'function', function)
        __dataclass__object_setattr(self, 'type', type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"id={self.id!r}")
        parts.append(f"function={self.function!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('content', 'refusal', 'role', 'annotations', 'audio', 'tool_calls')), EqPlan(fields=('"
    "content', 'refusal', 'role', 'annotations', 'audio', 'tool_calls')), FrozenPlan(fields=('content', 'refusal', 'rol"
    "e', 'annotations', 'audio', 'tool_calls'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('cont"
    "ent', 'refusal', 'role', 'annotations', 'audio', 'tool_calls'), cache=False), InitPlan(fields=(InitPlan.Field(name"
    "='content', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one), InitPlan.Field(name='refusal', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.f"
    "ields.1.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None), InitPlan.Field(name='role', annotation=OpRef(name='init.fields.2.annotation'), defa"
    "ult=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
    "TANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='annotations', annotation=OpRef(name='ini"
    "t.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, override=Fa"
    "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='audio', ann"
    "otation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None,"
    " init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan."
    "Field(name='tool_calls', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.defa"
    "ult'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None)), self_param='self', std_params=(), kw_only_params=('content', 'refusal', 'role', 'annotations',"
    " 'audio', 'tool_calls'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan("
    "fields=(ReprPlan.Field(name='content', kw_only=True, fn=None), ReprPlan.Field(name='refusal', kw_only=True, fn=Non"
    "e), ReprPlan.Field(name='annotations', kw_only=True, fn=None), ReprPlan.Field(name='audio', kw_only=True, fn=None)"
    ", ReprPlan.Field(name='tool_calls', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fresponse_2fChatCompletionResponseMessage(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            content=self.content,
            refusal=self.refusal,
            role=self.role,
            annotations=self.annotations,
            audio=self.audio,
            tool_calls=self.tool_calls,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.content == other.content and
            self.refusal == other.refusal and
            self.role == other.role and
            self.annotations == other.annotations and
            self.audio == other.audio and
            self.tool_calls == other.tool_calls
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'content',
        'refusal',
        'role',
        'annotations',
        'audio',
        'tool_calls',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'content',
        'refusal',
        'role',
        'annotations',
        'audio',
        'tool_calls',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.content,
            self.refusal,
            self.role,
            self.annotations,
            self.audio,
            self.tool_calls,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        content: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        refusal: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        role: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        annotations: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        audio: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        tool_calls: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'refusal', refusal)
        __dataclass__object_setattr(self, 'role', role)
        __dataclass__object_setattr(self, 'annotations', annotations)
        __dataclass__object_setattr(self, 'audio', audio)
        __dataclass__object_setattr(self, 'tool_calls', tool_calls)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"content={self.content!r}")
        parts.append(f"refusal={self.refusal!r}")
        parts.append(f"annotations={self.annotations!r}")
        parts.append(f"audio={self.audio!r}")
        parts.append(f"tool_calls={self.tool_calls!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('content', 'refusal')), EqPlan(fields=('content', 'refusal')), FrozenPlan(fields=('con"
    "tent', 'refusal'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('content', 'refusal'), cache="
    "False), InitPlan(fields=(InitPlan.Field(name='content', annotation=OpRef(name='init.fields.0.annotation'), default"
    "=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='refusal', annotation=OpRef(name='init.field"
    "s.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, override=False, fi"
    "eld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_o"
    "nly_params=('content', 'refusal'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()),"
    " ReprPlan(fields=(ReprPlan.Field(name='content', kw_only=True, fn=None), ReprPlan.Field(name='refusal', kw_only=Tr"
    "ue, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fresponse_2fChatCompletionResponseChoice_2fLogprobs(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            content=self.content,
            refusal=self.refusal,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.content == other.content and
            self.refusal == other.refusal
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'content',
        'refusal',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'content',
        'refusal',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.content,
            self.refusal,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        content: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        refusal: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'content', content)
        __dataclass__object_setattr(self, 'refusal', refusal)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"content={self.content!r}")
        parts.append(f"refusal={self.refusal!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('finish_reason', 'index', 'logprobs', 'message')), EqPlan(fields=('finish_reason', 'in"
    "dex', 'logprobs', 'message')), FrozenPlan(fields=('finish_reason', 'index', 'logprobs', 'message'), allow_dynamic_"
    "dunder_attrs=False), HashPlan(action='add', fields=('finish_reason', 'index', 'logprobs', 'message'), cache=False)"
    ", InitPlan(fields=(InitPlan.Field(name='finish_reason', annotation=OpRef(name='init.fields.0.annotation'), default"
    "=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None,"
    " check_type=None), InitPlan.Field(name='index', annotation=OpRef(name='init.fields.1.annotation'), default=None, d"
    "efault_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_t"
    "ype=None), InitPlan.Field(name='logprobs', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='"
    "init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=No"
    "ne, validate=None, check_type=None), InitPlan.Field(name='message', annotation=OpRef(name='init.fields.3.annotatio"
    "n'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, va"
    "lidate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('finish_reason', 'index', 'logpr"
    "obs', 'message'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields="
    "(ReprPlan.Field(name='finish_reason', kw_only=True, fn=None), ReprPlan.Field(name='index', kw_only=True, fn=None),"
    " ReprPlan.Field(name='logprobs', kw_only=True, fn=None), ReprPlan.Field(name='message', kw_only=True, fn=None)), i"
    "d=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fresponse_2fChatCompletionResponseChoice(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            finish_reason=self.finish_reason,
            index=self.index,
            logprobs=self.logprobs,
            message=self.message,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.finish_reason == other.finish_reason and
            self.index == other.index and
            self.logprobs == other.logprobs and
            self.message == other.message
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'finish_reason',
        'index',
        'logprobs',
        'message',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'finish_reason',
        'index',
        'logprobs',
        'message',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.finish_reason,
            self.index,
            self.logprobs,
            self.message,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        finish_reason: __dataclass__init__fields__0__annotation,
        index: __dataclass__init__fields__1__annotation,
        logprobs: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        message: __dataclass__init__fields__3__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'finish_reason', finish_reason)
        __dataclass__object_setattr(self, 'index', index)
        __dataclass__object_setattr(self, 'logprobs', logprobs)
        __dataclass__object_setattr(self, 'message', message)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"finish_reason={self.finish_reason!r}")
        parts.append(f"index={self.index!r}")
        parts.append(f"logprobs={self.logprobs!r}")
        parts.append(f"message={self.message!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('id', 'choices', 'created', 'model', 'object', 'service_tier', 'system_fingerprint', '"
    "usage')), EqPlan(fields=('id', 'choices', 'created', 'model', 'object', 'service_tier', 'system_fingerprint', 'usa"
    "ge')), FrozenPlan(fields=('id', 'choices', 'created', 'model', 'object', 'service_tier', 'system_fingerprint', 'us"
    "age'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('id', 'choices', 'created', 'model', 'obj"
    "ect', 'service_tier', 'system_fingerprint', 'usage'), cache=False), InitPlan(fields=(InitPlan.Field(name='id', ann"
    "otation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='choices', annotatio"
    "n=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='created', annotation=OpRe"
    "f(name='init.fields.2.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fiel"
    "dType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='model', annotation=OpRef(name='"
    "init.fields.3.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='object', annotation=OpRef(name='init.fi"
    "elds.4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='service_tier', "
    "annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=No"
    "ne, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPl"
    "an.Field(name='system_fingerprint', annotation=OpRef(name='init.fields.6.annotation'), default=OpRef(name='init.fi"
    "elds.6.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='usage', annotation=OpRef(name='init.fields.7.annotation'), defa"
    "ult=OpRef(name='init.fields.7.default'), default_factory=None, init=True, override=False, field_type=FieldType.INS"
    "TANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=(), kw_only_params=('id', 'cho"
    "ices', 'created', 'model', 'object', 'service_tier', 'system_fingerprint', 'usage'), frozen=True, slots=False, pos"
    "t_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='id', kw_only=True, fn=Non"
    "e), ReprPlan.Field(name='choices', kw_only=True, fn=None), ReprPlan.Field(name='created', kw_only=True, fn=None), "
    "ReprPlan.Field(name='model', kw_only=True, fn=None), ReprPlan.Field(name='service_tier', kw_only=True, fn=None), R"
    "eprPlan.Field(name='system_fingerprint', kw_only=True, fn=None), ReprPlan.Field(name='usage', kw_only=True, fn=Non"
    "e)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fbackends_2fopenai_2fprotocol_2fchatcompletion_2fresponse_2fChatCompletionResponse(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__init__fields__6__annotation,
    __dataclass__init__fields__6__default,
    __dataclass__init__fields__7__annotation,
    __dataclass__init__fields__7__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            id=self.id,
            choices=self.choices,
            created=self.created,
            model=self.model,
            object=self.object,
            service_tier=self.service_tier,
            system_fingerprint=self.system_fingerprint,
            usage=self.usage,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.id == other.id and
            self.choices == other.choices and
            self.created == other.created and
            self.model == other.model and
            self.object == other.object and
            self.service_tier == other.service_tier and
            self.system_fingerprint == other.system_fingerprint and
            self.usage == other.usage
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'id',
        'choices',
        'created',
        'model',
        'object',
        'service_tier',
        'system_fingerprint',
        'usage',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'id',
        'choices',
        'created',
        'model',
        'object',
        'service_tier',
        'system_fingerprint',
        'usage',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.id,
            self.choices,
            self.created,
            self.model,
            self.object,
            self.service_tier,
            self.system_fingerprint,
            self.usage,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        id: __dataclass__init__fields__0__annotation,
        choices: __dataclass__init__fields__1__annotation,
        created: __dataclass__init__fields__2__annotation,
        model: __dataclass__init__fields__3__annotation,
        object: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        service_tier: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
        system_fingerprint: __dataclass__init__fields__6__annotation = __dataclass__init__fields__6__default,
        usage: __dataclass__init__fields__7__annotation = __dataclass__init__fields__7__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'choices', choices)
        __dataclass__object_setattr(self, 'created', created)
        __dataclass__object_setattr(self, 'model', model)
        __dataclass__object_setattr(self, 'object', object)
        __dataclass__object_setattr(self, 'service_tier', service_tier)
        __dataclass__object_setattr(self, 'system_fingerprint', system_fingerprint)
        __dataclass__object_setattr(self, 'usage', usage)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"id={self.id!r}")
        parts.append(f"choices={self.choices!r}")
        parts.append(f"created={self.created!r}")
        parts.append(f"model={self.model!r}")
        parts.append(f"service_tier={self.service_tier!r}")
        parts.append(f"system_fingerprint={self.system_fingerprint!r}")
        parts.append(f"usage={self.usage!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('_metadata', 'v')), EqPlan(fields=('_metadata', 'v')), FrozenPlan(fields=('_metadata',"
    " 'v'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('_metadata', 'v'), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='_metadata', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='i"
    "nit.fields.0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=OpR"
    "ef(name='init.fields.0.coerce'), validate=None, check_type=None), InitPlan.Field(name='v', annotation=OpRef(name='"
    "init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('v',), kw_only_params=('_met"
    "adata',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPla"
    "n.Field(name='_metadata', kw_only=True, fn=OpRef(name='repr.fns.0.fn')), ReprPlan.Field(name='v', kw_only=False, f"
    "n=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fcontent_2fjson_2fJsonContent(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__coerce,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__repr__fns__0__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            _metadata=self._metadata,
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self._metadata == other._metadata and
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        '_metadata',
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        '_metadata',
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self._metadata,
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__1__annotation,
        *,
        _metadata: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        _metadata = __dataclass__init__fields__0__coerce(_metadata)
        __dataclass__object_setattr(self, '_metadata', _metadata)
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        if (s := __dataclass__repr__fns__0__fn(self._metadata)) is not None:
            parts.append(f"_metadata={s}")
        parts.append(f"v={self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftokens_2ftypes_2fTokenStr(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fbackends_2fimpls_2ftransformers_2ftransformers_2fTransformersPipelineKwargs(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=(), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=(), cache=False), InitPlan(fields=(), self_param='self', std_params=(), kw_only_params=(),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fformats_2fTextResponseFormat(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('schema',)), EqPlan(fields=('schema',)), FrozenPlan(fields=('schema',), allow_dynamic_"
    "dunder_attrs=False), HashPlan(action='add', fields=('schema',), cache=False), InitPlan(fields=(InitPlan.Field(name"
    "='schema', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), default"
    "_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=No"
    "ne),), self_param='self', std_params=('schema',), kw_only_params=(), frozen=True, slots=False, post_init_params=No"
    "ne, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='schema', kw_only=False, fn=None),), id=Fa"
    "lse, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fformats_2fJsonResponseFormat(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            schema=self.schema,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.schema == other.schema
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'schema',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'schema',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.schema,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        schema: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'schema', schema)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"schema={self.schema!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('fn',)), EqPlan(fields=('fn',)), FrozenPlan(fields=('fn',), allow_dynamic_dunder_attrs"
    "=False), HashPlan(action='add', fields=('fn',), cache=False), InitPlan(fields=(InitPlan.Field(name='fn', annotatio"
    "n=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('fn',), kw_on"
    "ly_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Rep"
    "rPlan.Field(name='fn', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fcontent_2ftransforms_2fstrings_2fStringFnContentTransform(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            fn=self.fn,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.fn == other.fn
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'fn',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'fn',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.fn,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        fn: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'fn', fn)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"fn={self.fn!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftemplating_2fMessageTemplate(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('key',)), EqPlan(fields=('key',)), FrozenPlan(fields=('key',), allow_dynamic_dunder_at"
    "trs=False), HashPlan(action='add', fields=('key',), cache=False), InitPlan(fields=(InitPlan.Field(name='key', anno"
    "tation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('key',),"
    " kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(field"
    "s=(ReprPlan.Field(name='key', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftemplating_2fMessagePlaceholder(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            key=self.key,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.key == other.key
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'key',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'key',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.key,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        key: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'key', key)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"key={self.key!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('m',)), EqPlan(fields=('m',)), FrozenPlan(fields=('m',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('m',), cache=False), InitPlan(fields=(InitPlan.Field(name='m', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('m',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='m', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftemplating_2fChatTemplater_2f_00MessageStep(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            m=self.m,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.m == other.m
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'm',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'm',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.m,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        m: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'm', m)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"m={self.m!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('m', 'd')), EqPlan(fields=('m', 'd')), FrozenPlan(fields=('m', 'd'), allow_dynamic_dun"
    "der_attrs=False), HashPlan(action='add', fields=('m', 'd'), cache=False), InitPlan(fields=(InitPlan.Field(name='m'"
    ", annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False"
    ", field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='d', annotation"
    "=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type"
    "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('m', 'd'), kw_o"
    "nly_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Re"
    "prPlan.Field(name='m', kw_only=False, fn=None), ReprPlan.Field(name='d', kw_only=False, fn=None)), id=False, terse"
    "=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftemplating_2fChatTemplater_2f_00TemplateStep(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            m=self.m,
            d=self.d,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.m == other.m and
            self.d == other.d
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'm',
        'd',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'm',
        'd',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.m,
            self.d,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        m: __dataclass__init__fields__0__annotation,
        d: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'm', m)
        __dataclass__object_setattr(self, 'd', d)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"m={self.m!r}")
        parts.append(f"d={self.d!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('p',)), EqPlan(fields=('p',)), FrozenPlan(fields=('p',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('p',), cache=False), InitPlan(fields=(InitPlan.Field(name='p', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('p',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='p', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftemplating_2fChatTemplater_2f_00PlaceholderStep(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            p=self.p,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.p == other.p
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'p',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'p',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.p,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        p: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'p', p)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"p={self.p!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('service',)), EqPlan(fields=('service',)), FrozenPlan(fields=('service',), allow_dynam"
    "ic_dunder_attrs=False), HashPlan(action='add', fields=('service',), cache=False), InitPlan(fields=(InitPlan.Field("
    "name='service', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', "
    "std_params=('service',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate"
    "_fns=()), ReprPlan(fields=(ReprPlan.Field(name='service', kw_only=False, fn=None),), id=False, terse=False, defaul"
    "t_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fchoices_2fadapters_2fChatChoicesServiceChatService(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            service=self.service,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.service == other.service
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'service',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'service',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.service,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        service: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'service', service)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"service={self.service!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('service',)), EqPlan(fields=('service',)), FrozenPlan(fields=('service',), allow_dynam"
    "ic_dunder_attrs=False), HashPlan(action='add', fields=('service',), cache=False), InitPlan(fields=(InitPlan.Field("
    "name='service', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', "
    "std_params=('service',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate"
    "_fns=()), ReprPlan(fields=(ReprPlan.Field(name='service', kw_only=False, fn=None),), id=False, terse=False, defaul"
    "t_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2fchoices_2fstream_2fadapters_2fChatChoicesStreamServiceChatChoicesService(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            service=self.service,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.service == other.service
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'service',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'service',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.service,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        service: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'service', service)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"service={self.service!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=(), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=(), cache=False), InitPlan(fields=(), self_param='self', std_params=(), kw_only_params=(),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ffns_2fToolFn_2fImpl(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('s', 'a')), EqPlan(fields=('s', 'a')), FrozenPlan(fields=('s', 'a'), allow_dynamic_dun"
    "der_attrs=False), HashPlan(action='add', fields=('s', 'a'), cache=False), InitPlan(fields=(InitPlan.Field(name='s'"
    ", annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='a', annotation=OpRef(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'"
    "), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, che"
    "ck_type=None)), self_param='self', std_params=(), kw_only_params=('s', 'a'), frozen=True, slots=False, post_init_p"
    "arams=(), init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='s', kw_only=True, fn=None), ReprPla"
    "n.Field(name='a', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ffns_2fToolFn_2fFnImpl(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            s=self.s,
            a=self.a,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.s == other.s and
            self.a == other.a
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        's',
        'a',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        's',
        'a',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.s,
            self.a,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        *,
        s: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        a: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 's', s)
        __dataclass__object_setattr(self, 'a', a)
        self.__post_init__()

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"s={self.s!r}")
        parts.append(f"a={self.a!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('m',)), EqPlan(fields=('m',)), FrozenPlan(fields=('m',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('m',), cache=False), InitPlan(fields=(InitPlan.Field(name='m', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('m',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='m', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ffns_2fToolFn_2fMaysyncImpl(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            m=self.m,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.m == other.m
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'm',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'm',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.m,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        m: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'm', m)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"m={self.m!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=(), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=(), cache=False), InitPlan(fields=(), self_param='self', std_params=(), kw_only_params=(),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ffns_2fToolFn_2fInput(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('cls',)), EqPlan(fields=('cls',)), FrozenPlan(fields=('cls',), allow_dynamic_dunder_at"
    "trs=False), HashPlan(action='add', fields=('cls',), cache=False), InitPlan(fields=(InitPlan.Field(name='cls', anno"
    "tation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('cls',),"
    " kw_only_params=(), frozen=True, slots=False, post_init_params=(), init_fns=(), validate_fns=()), ReprPlan(fields="
    "(ReprPlan.Field(name='cls', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ffns_2fToolFn_2fDataclassInput(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            cls=self.cls,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.cls == other.cls
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'cls',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'cls',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.cls,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        cls: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'cls', cls)
        self.__post_init__()

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"cls={self.cls!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('rtys',)), EqPlan(fields=('rtys',)), FrozenPlan(fields=('rtys',), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('rtys',), cache=False), InitPlan(fields=(InitPlan.Field(name='rtys',"
    " annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False,"
    " field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('rt"
    "ys',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan"
    "(fields=(ReprPlan.Field(name='rtys', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ffns_2fToolFn_2fMarshalInput(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            rtys=self.rtys,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.rtys == other.rtys
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'rtys',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'rtys',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.rtys,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        rtys: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'rtys', rtys)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"rtys={self.rtys!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=(), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=(), cache=False), InitPlan(fields=(), self_param='self', std_params=(), kw_only_params=(),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ffns_2fToolFn_2fRawKwargsInput(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=(), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=(), cache=False), InitPlan(fields=(), self_param='self', std_params=(), kw_only_params=(),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ffns_2fToolFn_2fOutput(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('cls',)), EqPlan(fields=('cls',)), FrozenPlan(fields=('cls',), allow_dynamic_dunder_at"
    "trs=False), HashPlan(action='add', fields=('cls',), cache=False), InitPlan(fields=(InitPlan.Field(name='cls', anno"
    "tation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('cls',),"
    " kw_only_params=(), frozen=True, slots=False, post_init_params=(), init_fns=(), validate_fns=()), ReprPlan(fields="
    "(ReprPlan.Field(name='cls', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ffns_2fToolFn_2fDataclassOutput(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            cls=self.cls,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.cls == other.cls
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'cls',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'cls',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.cls,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        cls: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'cls', cls)
        self.__post_init__()

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"cls={self.cls!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('rty',)), EqPlan(fields=('rty',)), FrozenPlan(fields=('rty',), allow_dynamic_dunder_at"
    "trs=False), HashPlan(action='add', fields=('rty',), cache=False), InitPlan(fields=(InitPlan.Field(name='rty', anno"
    "tation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('rty',),"
    " kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(field"
    "s=(ReprPlan.Field(name='rty', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ffns_2fToolFn_2fMarshalOutput(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            rty=self.rty,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.rty == other.rty
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'rty',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'rty',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.rty,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        rty: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'rty', rty)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"rty={self.rty!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=()), EqPlan(fields=()), FrozenPlan(fields=(), allow_dynamic_dunder_attrs=False), HashPl"
    "an(action='add', fields=(), cache=False), InitPlan(fields=(), self_param='self', std_params=(), kw_only_params=(),"
    " frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(), id=False, ter"
    "se=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ffns_2fToolFn_2fRawStringOutput(
    *,
    __dataclass__cls,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls()  # noqa

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return True

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash(())

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
    ) -> __dataclass__None:
        pass

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('impl', 'input', 'output')), EqPlan(fields=('impl', 'input', 'output')), FrozenPlan(fi"
    "elds=('impl', 'input', 'output'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('impl', 'input"
    "', 'output'), cache=False), InitPlan(fields=(InitPlan.Field(name='impl', annotation=OpRef(name='init.fields.0.anno"
    "tation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=Non"
    "e, validate=None, check_type=None), InitPlan.Field(name='input', annotation=OpRef(name='init.fields.1.annotation')"
    ", default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, valid"
    "ate=None, check_type=None), InitPlan.Field(name='output', annotation=OpRef(name='init.fields.2.annotation'), defau"
    "lt=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=Non"
    "e, check_type=None)), self_param='self', std_params=('impl', 'input', 'output'), kw_only_params=(), frozen=True, s"
    "lots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='impl', kw_"
    "only=False, fn=None), ReprPlan.Field(name='input', kw_only=False, fn=None), ReprPlan.Field(name='output', kw_only="
    "False, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2ffns_2fToolFn(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            impl=self.impl,
            input=self.input,
            output=self.output,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.impl == other.impl and
            self.input == other.input and
            self.output == other.output
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'impl',
        'input',
        'output',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'impl',
        'input',
        'output',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.impl,
            self.input,
            self.output,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        impl: __dataclass__init__fields__0__annotation,
        input: __dataclass__init__fields__1__annotation,
        output: __dataclass__init__fields__2__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'impl', impl)
        __dataclass__object_setattr(self, 'input', input)
        __dataclass__object_setattr(self, 'output', output)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"impl={self.impl!r}")
        parts.append(f"input={self.input!r}")
        parts.append(f"output={self.output!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('tool_fn',)), EqPlan(fields=('tool_fn',)), FrozenPlan(fields=('tool_fn',), allow_dynam"
    "ic_dunder_attrs=False), HashPlan(action='add', fields=('tool_fn',), cache=False), InitPlan(fields=(InitPlan.Field("
    "name='tool_fn', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', "
    "std_params=('tool_fn',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate"
    "_fns=()), ReprPlan(fields=(ReprPlan.Field(name='tool_fn', kw_only=False, fn=None),), id=False, terse=False, defaul"
    "t_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2fexecution_2fexecutors_2fToolFnToolExecutor(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            tool_fn=self.tool_fn,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.tool_fn == other.tool_fn
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'tool_fn',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'tool_fn',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.tool_fn,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        tool_fn: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'tool_fn', tool_fn)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"tool_fn={self.tool_fn!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('tool_executors_by_name',)), EqPlan(fields=('tool_executors_by_name',)), FrozenPlan(fi"
    "elds=('tool_executors_by_name',), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('tool_executor"
    "s_by_name',), cache=False), InitPlan(fields=(InitPlan.Field(name='tool_executors_by_name', annotation=OpRef(name='"
    "init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.IN"
    "STANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('tool_executors_by_name',),"
    " kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(field"
    "s=(ReprPlan.Field(name='tool_executors_by_name', kw_only=False, fn=None),), id=False, terse=False, default_fn=None"
    ")))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2fexecution_2fexecutors_2fNameSwitchedToolExecutor(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            tool_executors_by_name=self.tool_executors_by_name,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.tool_executors_by_name == other.tool_executors_by_name
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'tool_executors_by_name',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'tool_executors_by_name',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.tool_executors_by_name,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        tool_executors_by_name: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'tool_executors_by_name', tool_executors_by_name)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"tool_executors_by_name={self.tool_executors_by_name!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('mts',)), EqPlan(fields=('mts',)), FrozenPlan(fields=('mts',), allow_dynamic_dunder_at"
    "trs=False), HashPlan(action='add', fields=('mts',), cache=False), InitPlan(fields=(InitPlan.Field(name='mts', anno"
    "tation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('mts',),"
    " kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(field"
    "s=(ReprPlan.Field(name='mts', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftransforms_2fbase_2fCompositeMessageTransform(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            mts=self.mts,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.mts == other.mts
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'mts',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'mts',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.mts,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        mts: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'mts', mts)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"mts={self.mts!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('fn',)), EqPlan(fields=('fn',)), FrozenPlan(fields=('fn',), allow_dynamic_dunder_attrs"
    "=False), HashPlan(action='add', fields=('fn',), cache=False), InitPlan(fields=(InitPlan.Field(name='fn', annotatio"
    "n=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('fn',), kw_on"
    "ly_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Rep"
    "rPlan.Field(name='fn', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftransforms_2fbase_2fFnMessageTransform(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            fn=self.fn,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.fn == other.fn
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'fn',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'fn',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.fn,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        fn: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'fn', fn)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"fn={self.fn!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ty', 'mt')), EqPlan(fields=('ty', 'mt')), FrozenPlan(fields=('ty', 'mt'), allow_dynam"
    "ic_dunder_attrs=False), HashPlan(action='add', fields=('ty', 'mt'), cache=False), InitPlan(fields=(InitPlan.Field("
    "name='ty', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='mt', "
    "annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=False, "
    "field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('ty',"
    " 'mt'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPla"
    "n(fields=(ReprPlan.Field(name='ty', kw_only=False, fn=None), ReprPlan.Field(name='mt', kw_only=False, fn=None)), i"
    "d=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftransforms_2fbase_2fTypeFilteredMessageTransform(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ty=self.ty,
            mt=self.mt,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ty == other.ty and
            self.mt == other.mt
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'ty',
        'mt',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'ty',
        'mt',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ty,
            self.mt,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        ty: __dataclass__init__fields__0__annotation,
        mt: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ty', ty)
        __dataclass__object_setattr(self, 'mt', mt)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ty={self.ty!r}")
        parts.append(f"mt={self.mt!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('cts',)), EqPlan(fields=('cts',)), FrozenPlan(fields=('cts',), allow_dynamic_dunder_at"
    "trs=False), HashPlan(action='add', fields=('cts',), cache=False), InitPlan(fields=(InitPlan.Field(name='cts', anno"
    "tation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('cts',),"
    " kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(field"
    "s=(ReprPlan.Field(name='cts', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftransforms_2fbase_2fCompositeChatTransform(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            cts=self.cts,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.cts == other.cts
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'cts',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'cts',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.cts,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        cts: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'cts', cts)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"cts={self.cts!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('fn',)), EqPlan(fields=('fn',)), FrozenPlan(fields=('fn',), allow_dynamic_dunder_attrs"
    "=False), HashPlan(action='add', fields=('fn',), cache=False), InitPlan(fields=(InitPlan.Field(name='fn', annotatio"
    "n=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('fn',), kw_on"
    "ly_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Rep"
    "rPlan.Field(name='fn', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftransforms_2fbase_2fFnChatTransform(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            fn=self.fn,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.fn == other.fn
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'fn',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'fn',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.fn,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        fn: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'fn', fn)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"fn={self.fn!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('mt',)), EqPlan(fields=('mt',)), FrozenPlan(fields=('mt',), allow_dynamic_dunder_attrs"
    "=False), HashPlan(action='add', fields=('mt',), cache=False), InitPlan(fields=(InitPlan.Field(name='mt', annotatio"
    "n=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('mt',), kw_on"
    "ly_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Rep"
    "rPlan.Field(name='mt', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftransforms_2fbase_2fMessageTransformChatTransform(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            mt=self.mt,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.mt == other.mt
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'mt',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'mt',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.mt,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        mt: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'mt', mt)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"mt={self.mt!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('mt',)), EqPlan(fields=('mt',)), FrozenPlan(fields=('mt',), allow_dynamic_dunder_attrs"
    "=False), HashPlan(action='add', fields=('mt',), cache=False), InitPlan(fields=(InitPlan.Field(name='mt', annotatio"
    "n=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_typ"
    "e=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('mt',), kw_on"
    "ly_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(Rep"
    "rPlan.Field(name='mt', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftransforms_2fbase_2fLastMessageTransformChatTransform(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            mt=self.mt,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.mt == other.mt
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'mt',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'mt',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.mt,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        mt: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'mt', mt)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"mt={self.mt!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('id_factory',)), EqPlan(fields=('id_factory',)), FrozenPlan(fields=('id_factory',), al"
    "low_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('id_factory',), cache=False), InitPlan(fields=(Ini"
    "tPlan.Field(name='id_factory', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields."
    "0.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate"
    "=None, check_type=None),), self_param='self', std_params=('id_factory',), kw_only_params=(), frozen=True, slots=Fa"
    "lse, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='id_factory', kw_o"
    "nly=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftools_2fids_2fToolUseIdAddingMessageTransform(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            id_factory=self.id_factory,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.id_factory == other.id_factory
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'id_factory',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'id_factory',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.id_factory,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        id_factory: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'id_factory', id_factory)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"id_factory={self.id_factory!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'args', 'raw_text', 'raw_body', 'id', 'reasoning')), EqPlan(fields=('name', 'a"
    "rgs', 'raw_text', 'raw_body', 'id', 'reasoning')), FrozenPlan(fields=('name', 'args', 'raw_text', 'raw_body', 'id'"
    ", 'reasoning'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'args', 'raw_text', 'raw"
    "_body', 'id', 'reasoning'), cache=False), InitPlan(fields=(InitPlan.Field(name='name', annotation=OpRef(name='init"
    ".fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTAN"
    "CE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='args', annotation=OpRef(name='init.fields.1"
    ".annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerc"
    "e=None, validate=None, check_type=None), InitPlan.Field(name='raw_text', annotation=OpRef(name='init.fields.2.anno"
    "tation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type"
    "=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='raw_body', annotation=OpRe"
    "f(name='init.fields.3.annotation'), default=OpRef(name='init.fields.3.default'), default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "id', annotation=OpRef(name='init.fields.4.annotation'), default=OpRef(name='init.fields.4.default'), default_facto"
    "ry=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), I"
    "nitPlan.Field(name='reasoning', annotation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields"
    ".5.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=None, check_type=None)), self_param='self', std_params=('name', 'args'), kw_only_params=('raw_text', 'raw_body',"
    " 'id', 'reasoning'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fiel"
    "ds=(ReprPlan.Field(name='name', kw_only=False, fn=None), ReprPlan.Field(name='args', kw_only=False, fn=None), Repr"
    "Plan.Field(name='raw_text', kw_only=True, fn=None), ReprPlan.Field(name='raw_body', kw_only=True, fn=None), ReprPl"
    "an.Field(name='id', kw_only=True, fn=None), ReprPlan.Field(name='reasoning', kw_only=True, fn=None)), id=False, te"
    "rse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftext_2ftoolparsing_2fbase_2fParsedToolExec(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            args=self.args,
            raw_text=self.raw_text,
            raw_body=self.raw_body,
            id=self.id,
            reasoning=self.reasoning,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.args == other.args and
            self.raw_text == other.raw_text and
            self.raw_body == other.raw_body and
            self.id == other.id and
            self.reasoning == other.reasoning
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'name',
        'args',
        'raw_text',
        'raw_body',
        'id',
        'reasoning',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
        'args',
        'raw_text',
        'raw_body',
        'id',
        'reasoning',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.args,
            self.raw_text,
            self.raw_body,
            self.id,
            self.reasoning,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        name: __dataclass__init__fields__0__annotation,
        args: __dataclass__init__fields__1__annotation,
        *,
        raw_text: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        raw_body: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        id: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        reasoning: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'args', args)
        __dataclass__object_setattr(self, 'raw_text', raw_text)
        __dataclass__object_setattr(self, 'raw_body', raw_body)
        __dataclass__object_setattr(self, 'id', id)
        __dataclass__object_setattr(self, 'reasoning', reasoning)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"args={self.args!r}")
        parts.append(f"raw_text={self.raw_text!r}")
        parts.append(f"raw_body={self.raw_body!r}")
        parts.append(f"id={self.id!r}")
        parts.append(f"reasoning={self.reasoning!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('parser',)), EqPlan(fields=('parser',)), FrozenPlan(fields=('parser',), allow_dynamic_"
    "dunder_attrs=False), HashPlan(action='add', fields=('parser',), cache=False), InitPlan(fields=(InitPlan.Field(name"
    "='parser', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_p"
    "arams=('parser',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=("
    ")), ReprPlan(fields=(ReprPlan.Field(name='parser', kw_only=False, fn=None),), id=False, terse=False, default_fn=No"
    "ne)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftools_2fparsing_2fToolExecParsingMessageTransform(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            parser=self.parser,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.parser == other.parser
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'parser',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'parser',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.parser,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        parser: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'parser', parser)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"parser={self.parser!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('uuid_factory',)), EqPlan(fields=('uuid_factory',)), FrozenPlan(fields=('uuid_factory'"
    ",), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('uuid_factory',), cache=False), InitPlan(fie"
    "lds=(InitPlan.Field(name='uuid_factory', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_"
    "factory=OpRef(name='init.fields.0.default_factory'), init=True, override=False, field_type=FieldType.INSTANCE, coe"
    "rce=None, validate=None, check_type=None),), self_param='self', std_params=('uuid_factory',), kw_only_params=(), f"
    "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
    "e='uuid_factory', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftransforms_2fmetadata_2fUuidAddingMessageTransform(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default_factory,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            uuid_factory=self.uuid_factory,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.uuid_factory == other.uuid_factory
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'uuid_factory',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'uuid_factory',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.uuid_factory,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        uuid_factory: __dataclass__init__fields__0__annotation = __dataclass__HAS_DEFAULT_FACTORY,
    ) -> __dataclass__None:
        if uuid_factory is __dataclass__HAS_DEFAULT_FACTORY:
            uuid_factory = __dataclass__init__fields__0__default_factory()
        __dataclass__object_setattr(self, 'uuid_factory', uuid_factory)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"uuid_factory={self.uuid_factory!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('clock',)), EqPlan(fields=('clock',)), FrozenPlan(fields=('clock',), allow_dynamic_dun"
    "der_attrs=False), HashPlan(action='add', fields=('clock',), cache=False), InitPlan(fields=(InitPlan.Field(name='cl"
    "ock', annotation=OpRef(name='init.fields.0.annotation'), default=OpRef(name='init.fields.0.default'), default_fact"
    "ory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),)"
    ", self_param='self', std_params=('clock',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, in"
    "it_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='clock', kw_only=False, fn=None),), id=False, te"
    "rse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftransforms_2fmetadata_2fCreatedAtAddingMessageTransform(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            clock=self.clock,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.clock == other.clock
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'clock',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'clock',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.clock,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        clock: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'clock', clock)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"clock={self.clock!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('v',)), EqPlan(fields=('v',)), FrozenPlan(fields=('v',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('v',), cache=False), InitPlan(fields=(InitPlan.Field(name='v', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('v',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='v', kw_only=False, fn=None),), id=False, terse=True, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftransforms_2fmetadata_2fTransformedMessageOrigin(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            v=self.v,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.v == other.v
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'v',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'v',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.v,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        v: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'v', v)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"{self.v!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('child',)), EqPlan(fields=('child',)), FrozenPlan(fields=('child',), allow_dynamic_dun"
    "der_attrs=False), HashPlan(action='add', fields=('child',), cache=False), InitPlan(fields=(InitPlan.Field(name='ch"
    "ild', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params"
    "=('child',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), Re"
    "prPlan(fields=(ReprPlan.Field(name='child', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftransforms_2fmetadata_2fOriginAddingMessageTransform(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            child=self.child,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.child == other.child
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'child',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'child',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.child,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        child: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'child', child)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"child={self.child!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ct', 'svc')), EqPlan(fields=('ct', 'svc')), FrozenPlan(fields=('ct', 'svc'), allow_dy"
    "namic_dunder_attrs=False), HashPlan(action='add', fields=('ct', 'svc'), cache=False), InitPlan(fields=(InitPlan.Fi"
    "eld(name='ct', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='s"
    "vc', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=Fa"
    "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=("
    "'ct', 'svc'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), R"
    "eprPlan(fields=(ReprPlan.Field(name='ct', kw_only=False, fn=None), ReprPlan.Field(name='svc', kw_only=False, fn=No"
    "ne)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftransforms_2fservices_2fRequestChatTransformingChatService(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ct=self.ct,
            svc=self.svc,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ct == other.ct and
            self.svc == other.svc
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'ct',
        'svc',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'ct',
        'svc',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ct,
            self.svc,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        ct: __dataclass__init__fields__0__annotation,
        svc: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ct', ct)
        __dataclass__object_setattr(self, 'svc', svc)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ct={self.ct!r}")
        parts.append(f"svc={self.svc!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('ct', 'svc')), EqPlan(fields=('ct', 'svc')), FrozenPlan(fields=('ct', 'svc'), allow_dy"
    "namic_dunder_attrs=False), HashPlan(action='add', fields=('ct', 'svc'), cache=False), InitPlan(fields=(InitPlan.Fi"
    "eld(name='ct', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, o"
    "verride=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='s"
    "vc', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, init=True, override=Fa"
    "lse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=("
    "'ct', 'svc'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), R"
    "eprPlan(fields=(ReprPlan.Field(name='ct', kw_only=False, fn=None), ReprPlan.Field(name='svc', kw_only=False, fn=No"
    "ne)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fchat_2ftransforms_2fservices_2fResponseChatTransformingChatService(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            ct=self.ct,
            svc=self.svc,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.ct == other.ct and
            self.svc == other.svc
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'ct',
        'svc',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'ct',
        'svc',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.ct,
            self.svc,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        ct: __dataclass__init__fields__0__annotation,
        svc: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'ct', ct)
        __dataclass__object_setattr(self, 'svc', svc)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"ct={self.ct!r}")
        parts.append(f"svc={self.svc!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'cls', 'primitive')), EqPlan(fields=('name', 'cls', 'primitive')), FrozenPlan("
    "fields=('name', 'cls', 'primitive'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'cl"
    "s', 'primitive'), cache=False), InitPlan(fields=(InitPlan.Field(name='name', annotation=OpRef(name='init.fields.0."
    "annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce"
    "=None, validate=None, check_type=None), InitPlan.Field(name='cls', annotation=OpRef(name='init.fields.1.annotation"
    "'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, val"
    "idate=None, check_type=None), InitPlan.Field(name='primitive', annotation=OpRef(name='init.fields.2.annotation'), "
    "default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, field_type=FieldType"
    ".INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('name', 'cls'), kw_only_p"
    "arams=('primitive',), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fie"
    "lds=(ReprPlan.Field(name='name', kw_only=False, fn=None), ReprPlan.Field(name='cls', kw_only=False, fn=None), Repr"
    "Plan.Field(name='primitive', kw_only=True, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fdocs_2fdtypes_2fDtype(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            cls=self.cls,
            primitive=self.primitive,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.cls == other.cls and
            self.primitive == other.primitive
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'name',
        'cls',
        'primitive',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
        'cls',
        'primitive',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.cls,
            self.primitive,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        name: __dataclass__init__fields__0__annotation,
        cls: __dataclass__init__fields__1__annotation,
        *,
        primitive: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'cls', cls)
        __dataclass__object_setattr(self, 'primitive', primitive)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"cls={self.cls!r}")
        parts.append(f"primitive={self.primitive!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('n',)), EqPlan(fields=('n',)), FrozenPlan(fields=('n',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('n',), cache=False), InitPlan(fields=(InitPlan.Field(name='n', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=OpRef(name='init.fields.0.check_type')),), self_param='sel"
    "f', std_params=('n',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_f"
    "ns=()), ReprPlan(fields=(ReprPlan.Field(name='n', kw_only=False, fn=None),), id=False, terse=False, default_fn=Non"
    "e)))"
)
def _process_dataclass__ommlds_2fminichain_2fdocs_2fdocs_2fFieldRef(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__check_type,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            n=self.n,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.n == other.n
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'n',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'n',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.n,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        n: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        if not __dataclass__isinstance(n, __dataclass__init__fields__0__check_type): 
            raise __dataclass__FieldTypeValidationError(
                obj=self,
                type=__dataclass__init__fields__0__check_type,
                field='n',
                value=n,
            )
        __dataclass__object_setattr(self, 'n', n)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"n={self.n!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'dtype')), EqPlan(fields=('name', 'dtype')), FrozenPlan(fields=('name', 'dtype"
    "'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('name', 'dtype'), cache=False), InitPlan(fie"
    "lds=(InitPlan.Field(name='name', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory="
    "None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), Init"
    "Plan.Field(name='dtype', annotation=OpRef(name='init.fields.1.annotation'), default=None, default_factory=None, in"
    "it=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param="
    "'self', std_params=('name', 'dtype'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns"
    "=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='name', kw_only=False, fn=None), ReprPlan.Field(name='"
    "dtype', kw_only=False, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fdocs_2fdocs_2fDocField(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            dtype=self.dtype,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.dtype == other.dtype
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'name',
        'dtype',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
        'dtype',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.dtype,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        name: __dataclass__init__fields__0__annotation,
        dtype: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'dtype', dtype)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"dtype={self.dtype!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('fields',)), EqPlan(fields=('fields',)), FrozenPlan(fields=('fields',), allow_dynamic_"
    "dunder_attrs=False), HashPlan(action='add', fields=('fields',), cache=False), InitPlan(fields=(InitPlan.Field(name"
    "='fields', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=OpRef(name='init.fields.0.validate'), check_type=N"
    "one),), self_param='self', std_params=('fields',), kw_only_params=(), frozen=True, slots=False, post_init_params=N"
    "one, init_fns=(OpRef(name='init.init_fns.0'),), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='fields', k"
    "w_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fdocs_2fdocs_2fDocSchema(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__validate,
    __dataclass__init__init_fns__0,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            fields=self.fields,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.fields == other.fields
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'fields',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'fields',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.fields,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        fields: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        if not __dataclass__init__fields__0__validate(fields): 
            raise __dataclass__FieldFnValidationError(
                obj=self,
                fn=__dataclass__init__fields__0__validate,
                field='fields',
                value=fields,
            )
        __dataclass__object_setattr(self, 'fields', fields)
        __dataclass__init__init_fns__0(self)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"fields={self.fields!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('values',)), EqPlan(fields=('values',)), FrozenPlan(fields=('values',), allow_dynamic_"
    "dunder_attrs=False), HashPlan(action='add', fields=('values',), cache=False), InitPlan(fields=(InitPlan.Field(name"
    "='values', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, overr"
    "ide=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_p"
    "arams=('values',), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=("
    ")), ReprPlan(fields=(ReprPlan.Field(name='values', kw_only=False, fn=None),), id=False, terse=False, default_fn=No"
    "ne)))"
)
def _process_dataclass__ommlds_2fminichain_2fdocs_2fdocs_2fDoc(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            values=self.values,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.values == other.values
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'values',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'values',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.values,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        values: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'values', values)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"values={self.values!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('op', 'children')), EqPlan(fields=('op', 'children')), FrozenPlan(fields=('op', 'child"
    "ren'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('op', 'children'), cache=False), InitPlan"
    "(fields=(InitPlan.Field(name='op', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factor"
    "y=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=OpRef(nam"
    "e='init.fields.0.check_type')), InitPlan.Field(name='children', annotation=OpRef(name='init.fields.1.annotation'),"
    " default=None, default_factory=None, init=True, override=True, field_type=FieldType.INSTANCE, coerce=None, validat"
    "e=OpRef(name='init.fields.1.validate'), check_type=None)), self_param='self', std_params=('op', 'children'), kw_on"
    "ly_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), OverridePlan(fields="
    "(OverridePlan.Field(name='children', annotation=OpRef(name='override.fields.1.annotation')),), frozen=True), ReprP"
    "lan(fields=(ReprPlan.Field(name='op', kw_only=False, fn=None), ReprPlan.Field(name='children', kw_only=False, fn=N"
    "one)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fdocs_2ffilters_2fMultiFilter(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__check_type,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__validate,
    __dataclass__override__fields__1__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            op=self.op,
            children=self.children,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.op == other.op and
            self.children == other.children
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'op',
        'children',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'op',
        'children',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.op,
            self.children,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        op: __dataclass__init__fields__0__annotation,
        children: __dataclass__init__fields__1__annotation,
    ) -> __dataclass__None:
        if not __dataclass__isinstance(op, __dataclass__init__fields__0__check_type): 
            raise __dataclass__FieldTypeValidationError(
                obj=self,
                type=__dataclass__init__fields__0__check_type,
                field='op',
                value=op,
            )
        if not __dataclass__init__fields__1__validate(children): 
            raise __dataclass__FieldFnValidationError(
                obj=self,
                fn=__dataclass__init__fields__1__validate,
                field='children',
                value=children,
            )
        __dataclass__object_setattr(self, 'op', op)
        __dataclass__self_dict = self.__dict__
        __dataclass__self_dict['children'] = children

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    def __dataclass__property__children():
        @__dataclass__property
        def children(__dataclass__self) -> __dataclass__override__fields__1__annotation:
            return __dataclass__self.__dict__['children']

        return children

    setattr(__dataclass__cls, 'children', __dataclass__property__children())

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"op={self.op!r}")
        parts.append(f"children={self.children!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('child',)), EqPlan(fields=('child',)), FrozenPlan(fields=('child',), allow_dynamic_dun"
    "der_attrs=False), HashPlan(action='add', fields=('child',), cache=False), InitPlan(fields=(InitPlan.Field(name='ch"
    "ild', annotation=OpRef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=F"
    "alse, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=OpRef(name='init.fields.0.check_type')"
    "),), self_param='self', std_params=('child',), kw_only_params=(), frozen=True, slots=False, post_init_params=None,"
    " init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='child', kw_only=False, fn=None),), id=False,"
    " terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fdocs_2ffilters_2fNot(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__check_type,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            child=self.child,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.child == other.child
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'child',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'child',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.child,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        child: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        if not __dataclass__isinstance(child, __dataclass__init__fields__0__check_type): 
            raise __dataclass__FieldTypeValidationError(
                obj=self,
                type=__dataclass__init__fields__0__check_type,
                field='child',
                value=child,
            )
        __dataclass__object_setattr(self, 'child', child)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"child={self.child!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('op', 'field', 'value')), EqPlan(fields=('op', 'field', 'value')), FrozenPlan(fields=("
    "'op', 'field', 'value'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('op', 'field', 'value')"
    ", cache=False), InitPlan(fields=(InitPlan.Field(name='op', annotation=OpRef(name='init.fields.0.annotation'), defa"
    "ult=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=No"
    "ne, check_type=OpRef(name='init.fields.0.check_type')), InitPlan.Field(name='field', annotation=OpRef(name='init.f"
    "ields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
    ", coerce=None, validate=None, check_type=OpRef(name='init.fields.1.check_type')), InitPlan.Field(name='value', ann"
    "otation=OpRef(name='init.fields.2.annotation'), default=None, default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('op', 'f"
    "ield', 'value'), kw_only_params=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=())"
    ", ReprPlan(fields=(ReprPlan.Field(name='op', kw_only=False, fn=None), ReprPlan.Field(name='field', kw_only=False, "
    "fn=None), ReprPlan.Field(name='value', kw_only=False, fn=None)), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fdocs_2ffilters_2fCmp(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__check_type,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__check_type,
    __dataclass__init__fields__2__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            op=self.op,
            field=self.field,
            value=self.value,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.op == other.op and
            self.field == other.field and
            self.value == other.value
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'op',
        'field',
        'value',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'op',
        'field',
        'value',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.op,
            self.field,
            self.value,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        op: __dataclass__init__fields__0__annotation,
        field: __dataclass__init__fields__1__annotation,
        value: __dataclass__init__fields__2__annotation,
    ) -> __dataclass__None:
        if not __dataclass__isinstance(op, __dataclass__init__fields__0__check_type): 
            raise __dataclass__FieldTypeValidationError(
                obj=self,
                type=__dataclass__init__fields__0__check_type,
                field='op',
                value=op,
            )
        if not __dataclass__isinstance(field, __dataclass__init__fields__1__check_type): 
            raise __dataclass__FieldTypeValidationError(
                obj=self,
                type=__dataclass__init__fields__1__check_type,
                field='field',
                value=field,
            )
        __dataclass__object_setattr(self, 'op', op)
        __dataclass__object_setattr(self, 'field', field)
        __dataclass__object_setattr(self, 'value', value)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"op={self.op!r}")
        parts.append(f"field={self.field!r}")
        parts.append(f"value={self.value!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('spec', 'target', 'name_override')), FrozenPlan(fields=('spec', 'target', 'name_overri"
    "de'), allow_dynamic_dunder_attrs=False), InitPlan(fields=(InitPlan.Field(name='spec', annotation=OpRef(name='init."
    "fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANC"
    "E, coerce=None, validate=None, check_type=None), InitPlan.Field(name='target', annotation=OpRef(name='init.fields."
    "1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coer"
    "ce=None, validate=None, check_type=None), InitPlan.Field(name='name_override', annotation=OpRef(name='init.fields."
    "2.annotation'), default=OpRef(name='init.fields.2.default'), default_factory=None, init=True, override=False, fiel"
    "d_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_param='self', std_params=('spec', '"
    "target'), kw_only_params=('name_override',), frozen=True, slots=False, post_init_params=(), init_fns=(), validate_"
    "fns=()), ReprPlan(fields=(ReprPlan.Field(name='spec', kw_only=False, fn=None), ReprPlan.Field(name='target', kw_on"
    "ly=False, fn=None), ReprPlan.Field(name='name_override', kw_only=True, fn=OpRef(name='repr.fns.2.fn'))), id=False,"
    " terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2fexecution_2fcatalog_2fToolCatalogEntry(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__repr__fns__2__fn,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            spec=self.spec,
            target=self.target,
            name_override=self.name_override,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    __dataclass___setattr_frozen_fields = {
        'spec',
        'target',
        'name_override',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'spec',
        'target',
        'name_override',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __init__(
        self,
        spec: __dataclass__init__fields__0__annotation,
        target: __dataclass__init__fields__1__annotation,
        *,
        name_override: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'spec', spec)
        __dataclass__object_setattr(self, 'target', target)
        __dataclass__object_setattr(self, 'name_override', name_override)
        self.__post_init__()

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"spec={self.spec!r}")
        parts.append(f"target={self.target!r}")
        if (s := __dataclass__repr__fns__2__fn(self.name_override)) is not None:
            parts.append(f"name_override={s}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'desc', 'params', 'allow_additional_params', 'returns_desc', 'returns_type')),"
    " EqPlan(fields=('name', 'desc', 'params', 'allow_additional_params', 'returns_desc', 'returns_type')), FrozenPlan("
    "fields=('name', 'desc', 'params', 'allow_additional_params', 'returns_desc', 'returns_type'), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('name', 'desc', 'params', 'allow_additional_params', 'returns_desc',"
    " 'returns_type'), cache=False), InitPlan(fields=(InitPlan.Field(name='name', annotation=OpRef(name='init.fields.0."
    "annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='desc', annotation=OpRe"
    "f(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "params', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='allow_additional_params', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef"
    "(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None), InitPlan.Field(name='returns_desc', annotation=OpRef(name='init.fields"
    ".4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='returns_type', anno"
    "tation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_para"
    "m='self', std_params=('name',), kw_only_params=('desc', 'params', 'allow_additional_params', 'returns_desc', 'retu"
    "rns_type'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprP"
    "lan.Field(name='name', kw_only=False, fn=None), ReprPlan.Field(name='desc', kw_only=True, fn=None), ReprPlan.Field"
    "(name='params', kw_only=True, fn=None), ReprPlan.Field(name='allow_additional_params', kw_only=True, fn=None), Rep"
    "rPlan.Field(name='returns_desc', kw_only=True, fn=None), ReprPlan.Field(name='returns_type', kw_only=True, fn=None"
    ")), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2freflect_2f_00ToolSpecAttach(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            desc=self.desc,
            params=self.params,
            allow_additional_params=self.allow_additional_params,
            returns_desc=self.returns_desc,
            returns_type=self.returns_type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.desc == other.desc and
            self.params == other.params and
            self.allow_additional_params == other.allow_additional_params and
            self.returns_desc == other.returns_desc and
            self.returns_type == other.returns_type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'name',
        'desc',
        'params',
        'allow_additional_params',
        'returns_desc',
        'returns_type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
        'desc',
        'params',
        'allow_additional_params',
        'returns_desc',
        'returns_type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.desc,
            self.params,
            self.allow_additional_params,
            self.returns_desc,
            self.returns_type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        name: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        *,
        desc: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        params: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        allow_additional_params: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        returns_desc: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        returns_type: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'desc', desc)
        __dataclass__object_setattr(self, 'params', params)
        __dataclass__object_setattr(self, 'allow_additional_params', allow_additional_params)
        __dataclass__object_setattr(self, 'returns_desc', returns_desc)
        __dataclass__object_setattr(self, 'returns_type', returns_type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"desc={self.desc!r}")
        parts.append(f"params={self.params!r}")
        parts.append(f"allow_additional_params={self.allow_additional_params!r}")
        parts.append(f"returns_desc={self.returns_desc!r}")
        parts.append(f"returns_type={self.returns_type!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('name', 'desc', 'params', 'allow_additional_params', 'returns_desc', 'returns_type')),"
    " EqPlan(fields=('name', 'desc', 'params', 'allow_additional_params', 'returns_desc', 'returns_type')), FrozenPlan("
    "fields=('name', 'desc', 'params', 'allow_additional_params', 'returns_desc', 'returns_type'), allow_dynamic_dunder"
    "_attrs=False), HashPlan(action='add', fields=('name', 'desc', 'params', 'allow_additional_params', 'returns_desc',"
    " 'returns_type'), cache=False), InitPlan(fields=(InitPlan.Field(name='name', annotation=OpRef(name='init.fields.0."
    "annotation'), default=OpRef(name='init.fields.0.default'), default_factory=None, init=True, override=False, field_"
    "type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='desc', annotation=OpRe"
    "f(name='init.fields.1.annotation'), default=OpRef(name='init.fields.1.default'), default_factory=None, init=True, "
    "override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='"
    "params', annotation=OpRef(name='init.fields.2.annotation'), default=OpRef(name='init.fields.2.default'), default_f"
    "actory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None"
    "), InitPlan.Field(name='allow_additional_params', annotation=OpRef(name='init.fields.3.annotation'), default=OpRef"
    "(name='init.fields.3.default'), default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, co"
    "erce=None, validate=None, check_type=None), InitPlan.Field(name='returns_desc', annotation=OpRef(name='init.fields"
    ".4.annotation'), default=OpRef(name='init.fields.4.default'), default_factory=None, init=True, override=False, fie"
    "ld_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='returns_type', anno"
    "tation=OpRef(name='init.fields.5.annotation'), default=OpRef(name='init.fields.5.default'), default_factory=None, "
    "init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=None)), self_para"
    "m='self', std_params=('name',), kw_only_params=('desc', 'params', 'allow_additional_params', 'returns_desc', 'retu"
    "rns_type'), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprP"
    "lan.Field(name='name', kw_only=False, fn=None), ReprPlan.Field(name='desc', kw_only=True, fn=None), ReprPlan.Field"
    "(name='params', kw_only=True, fn=None), ReprPlan.Field(name='allow_additional_params', kw_only=True, fn=None), Rep"
    "rPlan.Field(name='returns_desc', kw_only=True, fn=None), ReprPlan.Field(name='returns_type', kw_only=True, fn=None"
    ")), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2ftools_2freflect_2f_00ToolSpecOverride(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__0__default,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__1__default,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__2__default,
    __dataclass__init__fields__3__annotation,
    __dataclass__init__fields__3__default,
    __dataclass__init__fields__4__annotation,
    __dataclass__init__fields__4__default,
    __dataclass__init__fields__5__annotation,
    __dataclass__init__fields__5__default,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            name=self.name,
            desc=self.desc,
            params=self.params,
            allow_additional_params=self.allow_additional_params,
            returns_desc=self.returns_desc,
            returns_type=self.returns_type,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.name == other.name and
            self.desc == other.desc and
            self.params == other.params and
            self.allow_additional_params == other.allow_additional_params and
            self.returns_desc == other.returns_desc and
            self.returns_type == other.returns_type
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'name',
        'desc',
        'params',
        'allow_additional_params',
        'returns_desc',
        'returns_type',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'name',
        'desc',
        'params',
        'allow_additional_params',
        'returns_desc',
        'returns_type',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.name,
            self.desc,
            self.params,
            self.allow_additional_params,
            self.returns_desc,
            self.returns_type,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        name: __dataclass__init__fields__0__annotation = __dataclass__init__fields__0__default,
        *,
        desc: __dataclass__init__fields__1__annotation = __dataclass__init__fields__1__default,
        params: __dataclass__init__fields__2__annotation = __dataclass__init__fields__2__default,
        allow_additional_params: __dataclass__init__fields__3__annotation = __dataclass__init__fields__3__default,
        returns_desc: __dataclass__init__fields__4__annotation = __dataclass__init__fields__4__default,
        returns_type: __dataclass__init__fields__5__annotation = __dataclass__init__fields__5__default,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'name', name)
        __dataclass__object_setattr(self, 'desc', desc)
        __dataclass__object_setattr(self, 'params', params)
        __dataclass__object_setattr(self, 'allow_additional_params', allow_additional_params)
        __dataclass__object_setattr(self, 'returns_desc', returns_desc)
        __dataclass__object_setattr(self, 'returns_type', returns_type)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"name={self.name!r}")
        parts.append(f"desc={self.desc!r}")
        parts.append(f"params={self.params!r}")
        parts.append(f"allow_additional_params={self.allow_additional_params!r}")
        parts.append(f"returns_desc={self.returns_desc!r}")
        parts.append(f"returns_type={self.returns_type!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('l',)), EqPlan(fields=('l',)), FrozenPlan(fields=('l',), allow_dynamic_dunder_attrs=Fa"
    "lse), HashPlan(action='add', fields=('l',), cache=False), InitPlan(fields=(InitPlan.Field(name='l', annotation=OpR"
    "ef(name='init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=Fie"
    "ldType.INSTANCE, coerce=None, validate=None, check_type=None),), self_param='self', std_params=('l',), kw_only_par"
    "ams=(), frozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan."
    "Field(name='l', kw_only=False, fn=None),), id=False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fllms_2ftokens_2fTokens(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            l=self.l,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.l == other.l
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'l',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'l',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.l,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        l: __dataclass__init__fields__0__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'l', l)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"l={self.l!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('rty', 'tv_fld', 'v_m')), EqPlan(fields=('rty', 'tv_fld', 'v_m')), FrozenPlan(fields=("
    "'rty', 'tv_fld', 'v_m'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields=('rty', 'tv_fld', 'v_m')"
    ", cache=False), InitPlan(fields=(InitPlan.Field(name='rty', annotation=OpRef(name='init.fields.0.annotation'), def"
    "ault=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=N"
    "one, check_type=None), InitPlan.Field(name='tv_fld', annotation=OpRef(name='init.fields.1.annotation'), default=No"
    "ne, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, ch"
    "eck_type=None), InitPlan.Field(name='v_m', annotation=OpRef(name='init.fields.2.annotation'), default=None, defaul"
    "t_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, validate=None, check_type=N"
    "one)), self_param='self', std_params=('rty', 'tv_fld', 'v_m'), kw_only_params=(), frozen=True, slots=False, post_i"
    "nit_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(name='rty', kw_only=False, fn=None"
    "), ReprPlan.Field(name='tv_fld', kw_only=False, fn=None), ReprPlan.Field(name='v_m', kw_only=False, fn=None)), id="
    "False, terse=False, default_fn=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fservices_2f_00marshal_2f_00RequestResponseMarshaler(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            rty=self.rty,
            tv_fld=self.tv_fld,
            v_m=self.v_m,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.rty == other.rty and
            self.tv_fld == other.tv_fld and
            self.v_m == other.v_m
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'rty',
        'tv_fld',
        'v_m',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'rty',
        'tv_fld',
        'v_m',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.rty,
            self.tv_fld,
            self.v_m,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        rty: __dataclass__init__fields__0__annotation,
        tv_fld: __dataclass__init__fields__1__annotation,
        v_m: __dataclass__init__fields__2__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'rty', rty)
        __dataclass__object_setattr(self, 'tv_fld', tv_fld)
        __dataclass__object_setattr(self, 'v_m', v_m)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"rty={self.rty!r}")
        parts.append(f"tv_fld={self.tv_fld!r}")
        parts.append(f"v_m={self.v_m!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)


@_register(
    "Plans(tup=(CopyPlan(fields=('rty', 'tv_fld', 'v_u', 'tv_u')), EqPlan(fields=('rty', 'tv_fld', 'v_u', 'tv_u')), Fro"
    "zenPlan(fields=('rty', 'tv_fld', 'v_u', 'tv_u'), allow_dynamic_dunder_attrs=False), HashPlan(action='add', fields="
    "('rty', 'tv_fld', 'v_u', 'tv_u'), cache=False), InitPlan(fields=(InitPlan.Field(name='rty', annotation=OpRef(name="
    "'init.fields.0.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.I"
    "NSTANCE, coerce=None, validate=None, check_type=None), InitPlan.Field(name='tv_fld', annotation=OpRef(name='init.f"
    "ields.1.annotation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE"
    ", coerce=None, validate=None, check_type=None), InitPlan.Field(name='v_u', annotation=OpRef(name='init.fields.2.an"
    "notation'), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=N"
    "one, validate=None, check_type=None), InitPlan.Field(name='tv_u', annotation=OpRef(name='init.fields.3.annotation'"
    "), default=None, default_factory=None, init=True, override=False, field_type=FieldType.INSTANCE, coerce=None, vali"
    "date=None, check_type=None)), self_param='self', std_params=('rty', 'tv_fld', 'v_u', 'tv_u'), kw_only_params=(), f"
    "rozen=True, slots=False, post_init_params=None, init_fns=(), validate_fns=()), ReprPlan(fields=(ReprPlan.Field(nam"
    "e='rty', kw_only=False, fn=None), ReprPlan.Field(name='tv_fld', kw_only=False, fn=None), ReprPlan.Field(name='v_u'"
    ", kw_only=False, fn=None), ReprPlan.Field(name='tv_u', kw_only=False, fn=None)), id=False, terse=False, default_fn"
    "=None)))"
)
def _process_dataclass__ommlds_2fminichain_2fservices_2f_00marshal_2f_00RequestResponseUnmarshaler(
    *,
    __dataclass__cls,
    __dataclass__init__fields__0__annotation,
    __dataclass__init__fields__1__annotation,
    __dataclass__init__fields__2__annotation,
    __dataclass__init__fields__3__annotation,
    __dataclass__isinstance=isinstance,  # noqa
    __dataclass__None=None,  # noqa
    __dataclass__property=property,  # noqa
    __dataclass__TypeError=TypeError,  # noqa
    __dataclass__object_setattr=object.__setattr__,  # noqa
    __dataclass__FrozenInstanceError=dataclasses.FrozenInstanceError,  # noqa
    __dataclass__HAS_DEFAULT_FACTORY=dataclasses._HAS_DEFAULT_FACTORY,  # noqa
    __dataclass__MISSING=dataclasses.MISSING,  # noqa
    __dataclass___recursive_repr=reprlib.recursive_repr,  # noqa
    __dataclass__FunctionType=types.FunctionType,  # noqa
    __dataclass__FieldFnValidationError,  # noqa
    __dataclass__FieldTypeValidationError,  # noqa
    __dataclass__FnValidationError,  # noqa
):
    def __copy__(self):
        if self.__class__ is not __dataclass__cls:
            raise TypeError(self)
        return __dataclass__cls(  # noqa
            rty=self.rty,
            tv_fld=self.tv_fld,
            v_u=self.v_u,
            tv_u=self.tv_u,
        )

    __copy__.__qualname__ = f"{__dataclass__cls.__qualname__}.__copy__"
    if '__copy__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __copy__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__copy__', __copy__)

    def __eq__(self, other):
        if self is other:
            return True
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (
            self.rty == other.rty and
            self.tv_fld == other.tv_fld and
            self.v_u == other.v_u and
            self.tv_u == other.tv_u
        )

    __eq__.__qualname__ = f"{__dataclass__cls.__qualname__}.__eq__"
    if '__eq__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __eq__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__eq__', __eq__)

    __dataclass___setattr_frozen_fields = {
        'rty',
        'tv_fld',
        'v_u',
        'tv_u',
    }

    def __setattr__(self, name, value):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___setattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot assign to field {name!r}")
        super(__dataclass__cls, self).__setattr__(name, value)

    __setattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__setattr__"
    if '__setattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __setattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__setattr__', __setattr__)

    __dataclass___delattr_frozen_fields = {
        'rty',
        'tv_fld',
        'v_u',
        'tv_u',
    }

    def __delattr__(self, name):
        if (
            type(self) is __dataclass__cls
             or name in __dataclass___delattr_frozen_fields
        ):
            raise __dataclass__FrozenInstanceError(f"cannot delete field {name!r}")
        super(__dataclass__cls, self).__delattr__(name)

    __delattr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__delattr__"
    if '__delattr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __delattr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__delattr__', __delattr__)

    def __hash__(self):
        return hash((
            self.rty,
            self.tv_fld,
            self.v_u,
            self.tv_u,
        ))

    __hash__.__qualname__ = f"{__dataclass__cls.__qualname__}.__hash__"
    setattr(__dataclass__cls, '__hash__', __hash__)

    def __init__(
        self,
        rty: __dataclass__init__fields__0__annotation,
        tv_fld: __dataclass__init__fields__1__annotation,
        v_u: __dataclass__init__fields__2__annotation,
        tv_u: __dataclass__init__fields__3__annotation,
    ) -> __dataclass__None:
        __dataclass__object_setattr(self, 'rty', rty)
        __dataclass__object_setattr(self, 'tv_fld', tv_fld)
        __dataclass__object_setattr(self, 'v_u', v_u)
        __dataclass__object_setattr(self, 'tv_u', tv_u)

    __init__.__qualname__ = f"{__dataclass__cls.__qualname__}.__init__"
    if '__init__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __init__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__init__', __init__)

    @__dataclass___recursive_repr()
    def __repr__(self):
        parts = []
        parts.append(f"rty={self.rty!r}")
        parts.append(f"tv_fld={self.tv_fld!r}")
        parts.append(f"v_u={self.v_u!r}")
        parts.append(f"tv_u={self.tv_u!r}")
        return (
            f"{self.__class__.__qualname__}("
            f"{', '.join(parts)}"
            f")"
        )

    __repr__.__qualname__ = f"{__dataclass__cls.__qualname__}.__repr__"
    if '__repr__' in __dataclass__cls.__dict__:
        raise __dataclass__TypeError(f"Cannot overwrite attribute __repr__ in class {__dataclass__cls.__name__}")
    setattr(__dataclass__cls, '__repr__', __repr__)
